[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e Does that mean that\n```\nssz.get_hash_tree_root(apple) == ssz.get_hash_tree_root(ssz.get_hash_tree_root(apple))\n```",
        "created_at": "2020-11-22T02:32:57.495000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "no, that would be the hash_tree_root of the hash_tree_root of apple which is essentially the hash of a hash",
        "created_at": "2020-11-22T02:34:00.025000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That is my intuition as well, but it *seems* like what Piper has above implies that the tree root of a thing is the same as the thing itself when it comes to calculating a tree root.",
        "created_at": "2020-11-22T02:34:52.121000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Only when it's inside an object",
        "created_at": "2020-11-22T02:35:10.432000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah.",
        "created_at": "2020-11-22T02:35:29.511000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "essentially, you can replace any object with it's hash-tree-root when it's in a container and the container will have the same htr",
        "created_at": "2020-11-22T02:35:56.285000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "TypedTransactions are `Type || ssz(...)`.  Is it possible to do `ssz.hash_tree_root(Type || ssz(...))` and if so is that going to break our ability to do the fancy recursive proofs if that ends up in a block?",
        "created_at": "2020-11-22T02:36:44.670000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The proof boundary will be at whatever point things are no longer part of a valid ssz schema",
        "created_at": "2020-11-22T02:37:46.308000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nblock.transaction_root = ssz.tree_root([Type_0 || TransactionTreeRoot_0, Type_1 || TransactionTreeRoot_1, ..., || Type_N || TransactionTreeRoot_N)\n```",
        "created_at": "2020-11-22T02:38:43.795000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I *think* what you are saying is that the \"single byte type prefix\" thing we have proposed in 2718 won't help us achieve the desired goal of being able to do recursive proofs.  ðŸ˜–",
        "created_at": "2020-11-22T02:39:59.781000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And we really need transactions to be SSZ enveloped if we want those fancy proof features.",
        "created_at": "2020-11-22T02:40:21.430000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Define that as List[Container[uint8, bytes32], max_length=...]",
        "created_at": "2020-11-22T02:40:34.373000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Which I think serializes the same",
        "created_at": "2020-11-22T02:40:46.954000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't think that works for legacy transactions, where the payload is RLP encoded?",
        "created_at": "2020-11-22T02:41:19.522000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(I'm on mobile, slow typy)",
        "created_at": "2020-11-22T02:41:39.170000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think it still works",
        "created_at": "2020-11-22T02:41:44.625000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Currently, 2718 asserts that the first byte of a transaction is a type, and the rest of the bytes of the transaction are the payload.  2718 doesn't define how those remaining bytes are encoded.",
        "created_at": "2020-11-22T02:42:00.246000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If we assume that all future transactions are SSZ encoded payloads, but legacy transactions are RLP encoded payloads, what does that mean for us?",
        "created_at": "2020-11-22T02:42:25.485000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For some transactions, the hash will be opaque since they are rlp. For others where the hash is an ssz hash, you can make a proof that reaches down into the transaction.",
        "created_at": "2020-11-22T02:42:39.031000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Does SSZ support union types?",
        "created_at": "2020-11-22T02:43:02.976000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, but I don't think that is needed",
        "created_at": "2020-11-22T02:43:18.565000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And does it support infinite recursion (self referential)?",
        "created_at": "2020-11-22T02:43:30.519000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No clear way to define anything self referential work the scheme",
        "created_at": "2020-11-22T02:43:55.452000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```ts\n// recursive\nBlock = Container[Block, ...]\n// union\nTransactionList = List[Container[uint8, Union[Transaction, Vector[uint8,0xffffff]]]\n```",
        "created_at": "2020-11-22T02:44:25.257000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "unions  are currently defiend in the ssz spec but not used anywhere in eth2 specs or otherwise",
        "created_at": "2020-11-22T02:44:30.052000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "They were added for something but it was decided they werent really needed for that use case and made things messy",
        "created_at": "2020-11-22T02:45:00.273000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "can't remember the use case at the time...",
        "created_at": "2020-11-22T02:45:04.560000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For the block scenario, we would need to define the container as\n```ts\nBlock = Container[TreeRoot, ...]\n``` where TreeRoot is the `hash_tree_root` of some `Block`?",
        "created_at": "2020-11-22T02:46:39.184000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is there a special type for TreeRoots to let the system know that it can be drilled into?  Or is it just a `uint256`/`bytes32`?",
        "created_at": "2020-11-22T02:47:19.954000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "uint256/bytes32",
        "created_at": "2020-11-22T02:48:10.046000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think we need to change 2718.  ðŸ˜¢",
        "created_at": "2020-11-22T02:48:59.790000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nContainer[uint8, ...]\n```is not the same as\n```\nuint8 || ...\n```and the two will hash differently.",
        "created_at": "2020-11-22T02:49:41.290000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I recognize that I need to write up how this can work but I don't think I can manage explaining it from my phone",
        "created_at": "2020-11-22T02:50:01.331000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If... Is a fixed size value this two are the same.",
        "created_at": "2020-11-22T02:50:32.508000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I *think* we will need to define 2718 transactions as `TypeByte || 0x05000000 || TransactionPayload`",
        "created_at": "2020-11-22T02:50:47.334000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "`...` isn't fixed size, unfortunately.",
        "created_at": "2020-11-22T02:51:10.058000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Well, unless you only include the hash_tree_root... ðŸ¤”",
        "created_at": "2020-11-22T02:51:32.911000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It is if you use bytes32 and just use the ssz tree hash on the churns",
        "created_at": "2020-11-22T02:51:50.386000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This is where things are weird to me.  If you simplify some complex datastructure down to just its tree root, the entire container shape changes.",
        "created_at": "2020-11-22T02:51:55.332000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The underlying thing can be opaque",
        "created_at": "2020-11-22T02:52:07.487000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I suppose I can just trust the lot of you that you know what you are doing and what you say is true.  ðŸ™‚",
        "created_at": "2020-11-22T02:52:20.376000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But If the underlying thing is valid ssz, you can \"monkey patch\" the actual thing into the place of the hash",
        "created_at": "2020-11-22T02:52:48.644000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Trust but verify. I'll write this up when I'm at my computer",
        "created_at": "2020-11-22T02:53:22.042000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nTransaction = Container[Type=uint8, PayloadHash=bytes32]\n```where the `PayloadHash` may be an `ssz.tree_hash_root` for some types, and it may be `keccak256(rlp` for others.",
        "created_at": "2020-11-22T02:53:55.967000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes",
        "created_at": "2020-11-22T02:54:07.709000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Bleh, but that leads to a whole lot more complication in devp2p I think.",
        "created_at": "2020-11-22T02:54:18.474000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Since a transaction list will now just be a list of hashes which you then need to fetch.",
        "created_at": "2020-11-22T02:54:36.291000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Unless that payload isn't a list of \"things you hash\" and instead is something else.",
        "created_at": "2020-11-22T02:54:54.634000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But then we have multiple ways of wrapping up and listing transactions, which is unfortunate.",
        "created_at": "2020-11-22T02:55:07.821000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, I need to think about that",
        "created_at": "2020-11-22T02:55:29.564000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It might work fine... But it might be ugly... Intuition isn't clear for me on that part",
        "created_at": "2020-11-22T02:56:00.662000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nTransactionHash = ssz.hash_tree_root(Container[Type=uint8, PayloadHash=bytes32])\nTransactionList = rlp([Type_0 || Payload_0, Type_1, Payload_1, ..., Type_N, Payload_N])\n```",
        "created_at": "2020-11-22T02:57:04.300000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So when you get a transaction over devp2p you'll have to unpack it and then repack it in order to get the transaction hash.",
        "created_at": "2020-11-22T02:57:34.005000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The same is true pretty much anywhere you are shuffling around transactions, they hash quite differently from how they serialize.",
        "created_at": "2020-11-22T02:58:13.801000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nTransactionForHashing = Container[Type=uint8, PayloadHash=bytes32]\nTransactionForSerializing = uint8 || Container[Payload]\n```",
        "created_at": "2020-11-22T02:59:09.887000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And payload varies by type?",
        "created_at": "2020-11-22T03:00:12.107000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah.",
        "created_at": "2020-11-22T03:00:15.822000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nPayload = Union[TransactionType0Payload, TransactionType1Payload, ..., TransactionTypeNPayload]\n```",
        "created_at": "2020-11-22T03:00:46.781000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And they might be mixed?",
        "created_at": "2020-11-22T03:01:11.211000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In the sense that one serialized array will have different typed items, yes.",
        "created_at": "2020-11-22T03:01:36.620000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Item at index 0 may be a type 0 transaction while item at index 1 may be a type 5 transaction.",
        "created_at": "2020-11-22T03:01:58.622000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think it might still work.",
        "created_at": "2020-11-22T03:02:00.119000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I suspect that long term we may be better off by defining 2718 to be `Type || 0x05000000 || Payload`, which is just SSZ.",
        "created_at": "2020-11-22T03:02:38.605000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But it'll require some programmatic decoding. One pass to figure out the types, another pass to decide the payloads once the types are known",
        "created_at": "2020-11-22T03:02:48.074000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Schema for hashing and encoding stay the same.",
        "created_at": "2020-11-22T03:03:16.629000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Proofs should be able to cross into the transaction objects themselves",
        "created_at": "2020-11-22T03:03:44.873000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Multipass sounds like it is going to be an implementation nightmare.",
        "created_at": "2020-11-22T03:04:02.492000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Essentially a custom deserializer just to deal with transaction lists.",
        "created_at": "2020-11-22T03:04:14.318000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's the same ssz or not unless the encoding is self describing and then you'd still have to validate it matched the expected schema",
        "created_at": "2020-11-22T03:04:55.179000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What if the transaction list is the hash_tree_root of ssz objects =\n{\n  type: uint,\n  tx_hash: bytes 32,\n}\n?",
        "created_at": "2020-11-22T03:06:02.680000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That's what I'm wanting /suggesting",
        "created_at": "2020-11-22T03:06:20.642000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "See https://discordapp.com/channels/595666850260713488/718596092828057631/779902458389856287 and the following comments.",
        "created_at": "2020-11-22T03:06:32.764000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Why not SSZ for all types?",
        "created_at": "2020-11-22T03:07:04.468000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not a huge fan of having serialization for hashing be different from serialization for transport.",
        "created_at": "2020-11-22T03:07:10.434000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Because you can transparently swap that schema for one that replaces the hash with an ssz schema of the underlying transaction and the two schemas will hash the same",
        "created_at": "2020-11-22T03:07:29.633000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It feels like serialization for transport should be the same as serialization for hashing.",
        "created_at": "2020-11-22T03:07:39.412000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm saying that they can be",
        "created_at": "2020-11-22T03:07:49.680000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What transactions would still be RLP?",
        "created_at": "2020-11-22T03:08:12.044000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I am really struggling to wrap my head around this.  I believe you, but I don't fully grok it yet.",
        "created_at": "2020-11-22T03:08:13.818000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You are essentially saying that the tree root for `Container[bytes32] == Container[\u003csomething complicated\u003e]`, which kind of breaks what it means to hash a thing in my head.",
        "created_at": "2020-11-22T03:09:14.837000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think the problem is that I keep thinking of the tree root as a hash, but it is not (at least, not in the traditional sense).",
        "created_at": "2020-11-22T03:09:36.843000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So those are the same in terms of hashing",
        "created_at": "2020-11-22T03:09:39.773000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So if you are verifying something against a hash, you can sort of interchange those two depending on the context.",
        "created_at": "2020-11-22T03:10:19.028000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If you are serializing for transmission over the wire , you use the rich one",
        "created_at": "2020-11-22T03:10:53.195000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In the block header you use the terse one that only has roots",
        "created_at": "2020-11-22T03:11:16.797000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And you get  the same hash in both contexts",
        "created_at": "2020-11-22T03:11:30.396000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "End goal:\n```\nBlock = Container[\n  Parent = Block,\n  TransactionRoot = List[\n    Union[\n      Container[Type = 0, Payload = Vector[uint8, 0xffffff],\n      Container[Type = 1, Payload = Vector[uint8, 0xffffff],\n      Container[Type = 2, Payload = Container[...]],\n      Container[Type = 3, Payload = Container[...]],\n    ],\n    0xffffff,\n  ],\n  ...\n]\n```",
        "created_at": "2020-11-22T03:12:17.876000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Adjusted to account for legacy transactions (which are currently up in the air).",
        "created_at": "2020-11-22T03:13:13.865000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e union: union type containing one of the given subtypes\n\u003e     notation Union[type_0, type_1, ...], e.g. union[null, uint64]",
        "created_at": "2020-11-22T03:17:51.556000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "one issue with unions is that i don't believe most ssz implementations support them",
        "created_at": "2020-11-22T03:19:04.059000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!203220829473996800\u003e Do you know if the various SSZ libraries have implemented Unions?  I understand they aren't used for ETH2 at the moment, but they are defined in the spec.  We would *like* to use them for Berlin potentially, but needing to implement that across all libraries is likely unrealistic for Berlin timeline.",
        "created_at": "2020-11-22T03:27:58.366000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Lighthouse has rust SSZ, which supports unions. I think they have some Optional type definitions in their caching, which is basically a union of null and something.",
        "created_at": "2020-11-22T03:30:55.419000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Don't think the others have it",
        "created_at": "2020-11-22T03:31:45.092000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That said, it's literally just 4 bytes that determine the type of the next decoded thing. It's easy to implement if actually required",
        "created_at": "2020-11-22T03:32:31.690000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Afk now, but happy to look later why you need them, what you're trying to achieve. XY problem and all that. Don't ask for fixing the solution, ask to fix the problem ;)",
        "created_at": "2020-11-22T03:34:32.862000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!203220829473996800\u003e Typed transaction encoding is the use case: https://discordapp.com/channels/595666850260713488/718596092828057631/779907080130789376",
        "created_at": "2020-11-22T03:35:38.987000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In a number of places (such as a block) we have a list of transactions, and the transactions in that list are each one of a number of different types.  Each type of transaction has a different shape.",
        "created_at": "2020-11-22T03:36:49.788000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Unions seem like the perfect solution to the problem.",
        "created_at": "2020-11-22T03:36:58.218000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sounds reasonable to me. And are size constraints ok, will it repeat a lot? I always thought 4 bytes for a union selector were a bit much, but it does offer flexibility and is consistent with offset size in SSZ",
        "created_at": "2020-11-22T03:38:35.139000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "4 bytes seems exceedingly excessive.",
        "created_at": "2020-11-22T03:40:11.078000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We need 1 byte.",
        "created_at": "2020-11-22T03:40:15.347000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We currently have maybe 4-10 typed transactions in discussion, and 2718 defines the `TransactionType` as a `uint8`.",
        "created_at": "2020-11-22T03:40:55.069000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not opposed to changing the SSZ spec if it's a type that has never actually been used anywhere else in the spec",
        "created_at": "2020-11-22T03:42:54.919000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003chttps://github.com/prysmaticlabs/go-ssz/issues/3\u003e suggests that the Go library supports Unions.  Maybe \u003c@!118185622543269890\u003e can comment (assuming you are 0xKiwi)?",
        "created_at": "2020-11-22T03:43:00.912000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't recommend go-ssz",
        "created_at": "2020-11-22T03:43:14.777000+00:00",
        "attachments": []
    },
    {
        "author": "kiwi.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes thats me",
        "created_at": "2020-11-22T03:43:22.442000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Use fastssz",
        "created_at": "2020-11-22T03:43:25.856000+00:00",
        "attachments": []
    },
    {
        "author": "kiwi.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "go-ssz is pretty much deprecated",
        "created_at": "2020-11-22T03:43:27.585000+00:00",
        "attachments": []
    },
    {
        "author": "kiwi.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And yeah fastssz is the way to go",
        "created_at": "2020-11-22T03:43:48.007000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "fastssz isn't linked on \u003chttps://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#implementations\u003e, where can I find it?",
        "created_at": "2020-11-22T03:43:49.033000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or ztyp, my opinionated implementation ðŸ˜…",
        "created_at": "2020-11-22T03:44:02.365000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If someone drops some links on me I can submit a PR to the specs repo to add them.  ðŸ™‚",
        "created_at": "2020-11-22T03:44:25.406000+00:00",
        "attachments": []
    },
    {
        "author": "kiwi.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Thanks! ðŸ˜ƒ",
        "created_at": "2020-11-22T03:45:07.598000+00:00",
        "attachments": []
    },
    {
        "author": "kiwi.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Here ya go: https://github.com/ferranbt/fastssz",
        "created_at": "2020-11-22T03:45:20.349000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://github.com/protolambda/eth2.0-ssz\nWe're not changing the spec for listing every implementation all the time. The list in this doc may be more complete",
        "created_at": "2020-11-22T03:45:26.636000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "^ that repo was an old attempt at extending the ssz spec with more info. But the old minimal doc is more direct, and kind of frozen into the spec at this point",
        "created_at": "2020-11-22T03:46:57.032000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Would it be worth removing the implementations section of the spec and just linking to that list instead?",
        "created_at": "2020-11-22T03:47:48.577000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I hate seeing unmaintained lists of things...",
        "created_at": "2020-11-22T03:47:58.674000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Maybe, Putting the list in an issue or doc on its own might be best. It's just a quick reference for users, not spec",
        "created_at": "2020-11-22T03:48:37.778000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'll submit a PR to redirect the Implementations section to that link.  I feel like that is iteratively better than the current out-of-date list.",
        "created_at": "2020-11-22T03:49:10.096000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And leave it up to others to decide whether there is a better long term strategy.",
        "created_at": "2020-11-22T03:49:24.706000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Linking to a copy of the updated table, placed in a specs issue that can be maintained live, is best I think.",
        "created_at": "2020-11-22T03:50:20.928000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'll do that now",
        "created_at": "2020-11-22T03:50:39.166000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I agree that specs aren't the right place to maintain lists of implementations.",
        "created_at": "2020-11-22T03:50:47.202000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In the EIPs repository I have been really striving to kill that pattern.",
        "created_at": "2020-11-22T03:50:56.275000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "K.  I won't touch anything then.  ðŸ™‚",
        "created_at": "2020-11-22T03:51:07.998000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You can review the PR/issue, credits to you for idea. But will try to keep updating that list in the issue, so I'll create it",
        "created_at": "2020-11-22T03:52:09.786000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Back on topic though: Union with 1 byte selector? And then implement it everywhere?",
        "created_at": "2020-11-22T03:52:59.675000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes please",
        "created_at": "2020-11-22T03:53:38.209000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I care more about implement everywhere ASAP than 1 byte selector.",
        "created_at": "2020-11-22T03:53:45.250000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I do feel like if you have a union of more than 256 items you need a new data structure.",
        "created_at": "2020-11-22T03:54:03.420000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But that is a pretty weak position and I'm very willing to concede on that one.",
        "created_at": "2020-11-22T03:54:17.586000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What about a separate list for each tx? Is the order defined elsewhere already? And you already pay 4 bytes per offset if you use dynamic size transactions",
        "created_at": "2020-11-22T03:55:17.260000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My primary goal right now is to facilitate getting typed transactions into Berlin, because I don't want to see EIP-2930 (access lists) get implemented without them.  Secondary (high priority still) goal is to have 2718 be future-compatible with recursive SSZ blocks.",
        "created_at": "2020-11-22T03:55:23.339000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I *think* that secondary requirement requires Unions.",
        "created_at": "2020-11-22T03:55:30.503000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "technically, doesn't the tx type id the same as the union specifier?",
        "created_at": "2020-11-22T03:56:25.277000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A separate list for each type of transaction is technically possible, but it would require much more substantial client changes that I worry won't be palatable for Berlin inclusion.",
        "created_at": "2020-11-22T03:56:26.453000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "once we have the union specifier, we should drop the tx type id?",
        "created_at": "2020-11-22T03:56:38.618000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Specifically, transaction indexing is done by looking at list index right now.",
        "created_at": "2020-11-22T03:56:40.135000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!543900561460822016\u003e I believe they serve the same purpose, yes.  Is the union index the first item in the container?",
        "created_at": "2020-11-22T03:57:15.648000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes it is",
        "created_at": "2020-11-22T03:58:03.171000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah nice.  That means the type byte still technically is the first byte (due to little endian encoding of a 4-byte value).",
        "created_at": "2020-11-22T03:58:22.276000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Though, unwrapped legacy transactions will break things pretty horribly.  ðŸ˜¢",
        "created_at": "2020-11-22T03:58:55.648000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Unless we treat them as opaque vectors rather than containers.",
        "created_at": "2020-11-22T03:59:05.280000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i think we should just wrap all transactions if we're going to go with ssz",
        "created_at": "2020-11-22T03:59:29.351000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Based on discussions over the past few days, I think we want to eventually have recursive SSZ for transaction root and receipt root.  The Merge will take care of SSZifying the rest of the block.",
        "created_at": "2020-11-22T04:01:09.312000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And we ideally want as many transactions/receipts in a block to be SSZ as possible.",
        "created_at": "2020-11-22T04:01:37.750000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "why would we have non-ssz txs?",
        "created_at": "2020-11-22T04:01:57.711000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e ssz implementations list: https://github.com/ethereum/eth2.0-specs/issues/2138\nIf you like you can make the PR to specs repo, replacing the original list with a link. I'll review the PR",
        "created_at": "2020-11-22T04:03:43.769000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Legacy.",
        "created_at": "2020-11-22T04:04:58.837000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!203220829473996800\u003e Feature Request: Sort the list by Language.  ðŸ™‚",
        "created_at": "2020-11-22T04:05:27.651000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "why not encode them in ssz and maintain the legacy signing hash format?",
        "created_at": "2020-11-22T04:05:37.280000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e It's sorted by status, then by language",
        "created_at": "2020-11-22T04:06:03.531000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah.",
        "created_at": "2020-11-22T04:06:10.380000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The hashes for the transactions will change, which causes problems.",
        "created_at": "2020-11-22T04:06:35.724000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'll remove the spec entry from implementations though. It made more sense when it lived outside of the spec repo",
        "created_at": "2020-11-22T04:07:11.082000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Since I have you here, can we get a `#typed-transactions` channel in ETH1X-RESEARCH?  I have basically taken over this channel with discussion about it, which isn't really appropriate.",
        "created_at": "2020-11-22T04:12:55.130000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "sure",
        "created_at": "2020-11-22T04:13:05.479000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We can delete it after Berlin (if all goes well).  ðŸ™‚",
        "created_at": "2020-11-22T04:13:25.813000+00:00",
        "attachments": []
    }
]