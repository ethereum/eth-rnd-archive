[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Are you around at the moment \u003c@!364458974906548225\u003e?  Have some questions about SSZ merkleized blocks.",
        "created_at": "2020-11-21T05:17:38.031000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For simplicity, imagine a block is just:\n```\n[ Parent, StateRoot, TransactionRoot, ReceiptRoot, Nonce ]\n```\nWould `BlockUid` (not calling it `BlockHash`, because I think that isn't quite right in an SSZ merkleization world) `SszRoot(Ssz([Parent, StateRoot, TransactionRoot, ReceiptRoot, Nonce]))`?  Or is the `Ssz(...)` step there implicit?  I'm assuming that `Parent` there would be a `BlockId`, and the various Roots in there would also be `SszRoot`s?",
        "created_at": "2020-11-21T05:27:41.441000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I guess what I'm asking is, which of these signatures is correct?\n```\nfunction SszRoot(SszSchema schema, Struct datastructure) returns (bytes32);\nfunction SszRoot(Bytes sszBytes) returns (bytes32);\n```",
        "created_at": "2020-11-21T05:29:45.294000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, can we get a new channel in `ETH1X-RESEARCH` for `#block-merklization` \u003c@\u0026595685821026271242\u003e?",
        "created_at": "2020-11-21T05:30:09.854000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i would say the `ssz(..)` step is not needed, since \"`SszRoot`\" acts on SSZ objects, not ssz serialized byte",
        "created_at": "2020-11-21T06:41:09.602000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "IMO the correct signature should closely follow the signature in the eth2 specs repo:\n```python\ndef hash_tree_root(object: SSZSerializable) -\u003e Bytes32\n```",
        "created_at": "2020-11-21T06:42:33.370000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e I'm assuming that Parent there would be a BlockId, and the various Roots in there would also be SszRoots?\nthe actual ssz object would be a normal object representing the list of txs, receipts, etc -- ssz implies that object will be recursively merklized",
        "created_at": "2020-11-21T06:45:25.373000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I believe that for SSZ to provide what it promises, it needs to support roots directly, without the full object.",
        "created_at": "2020-11-21T06:49:13.535000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Otherwise getting the merkle root of a block requires having a datastructure that represents all blocks.",
        "created_at": "2020-11-21T06:49:32.165000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That is, `hash_tree_root([parentId, ...])` must be an acceptable call because `hash_tree_root([parentBlock, ...])` is recursive to the point of blowing out memory by a very large margin.",
        "created_at": "2020-11-21T06:50:36.864000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In theory, you can do something like have `parentBlock` be some kind of virtual block that is has its UID memoized, and doesn't actually pull the whole block into memory.  Do existing implementations support this concept if so?",
        "created_at": "2020-11-21T06:51:28.112000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "would have to see how the ssz libs are implemented, but you can refer to any element via a generalized index in a proof",
        "created_at": "2020-11-21T06:53:24.374000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i'm looking at the beacon spec again and i think i'm conflating some things together, it looks like you can have your block be `[Parent, StateRoot, ... , etc]` like you said",
        "created_at": "2020-11-21T06:55:38.681000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I actually think what I said was wrong.",
        "created_at": "2020-11-21T06:56:10.539000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Either you have:\n```\n[ Parent, State, TransactionList, ReceiptList, Nonce ]\n``` or you have\n```\n[ ParentRoot, StateRoot, TransactionListRoot, ReceiptListRoot, Nonce ]\n```",
        "created_at": "2020-11-21T06:56:47.893000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It doesn't make sense I think to have a mix like `[ Parent, StateRoot, ... ]`",
        "created_at": "2020-11-21T06:57:05.352000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ahh, gotcha - i think your second one is what the ssz repr should be",
        "created_at": "2020-11-21T06:57:28.701000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If `[Parent, State, ....]` is reality, then it means implementations **MUST** have a concept of virtual nodes since without you would need like 300GB of memory and a *lot* of SSZ stuff.",
        "created_at": "2020-11-21T06:57:59.266000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e did this quick experiment:\n\n```python\nimport ssz\nfrom ssz import sedes\n\n\nTransactionList = sedes.List(sedes.bytes32, max_length=256)\n\nParent = sedes.Container(field_sedes=(sedes.uint256, sedes.bytes32))\nFullBlock = sedes.Container(field_sedes=(Parent, TransactionList))\n\nHashBlock = sedes.Container(field_sedes=(sedes.bytes32, TransactionList))\n\n\ndef test_equality():\n    transaction_list = (b'\\x01' * 32, b'\\x02' * 32)\n    parent = (1234567890, b'\\x03' * 32)\n\n    parent_root = ssz.get_hash_tree_root(parent, sedes=Parent)\n    full_block = (parent, transaction_list)\n    hash_block = (parent_root, transaction_list)\n\n    full_block_root = ssz.get_hash_tree_root(full_block, sedes=FullBlock)\n    hash_block_root = ssz.get_hash_tree_root(hash_block, sedes=HashBlock)\n\n    assert full_block_root == hash_block_root\n```\n\nit passes",
        "created_at": "2020-11-21T20:08:05.189000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "so these produce equivalent hash_tree_roots:\n\n```\nFull = [Parent, StateRoot, ...]\nPartial = [ParentRoot, StateRoot, ...]\n\nSSZHash(Full) == SSZHash(Partial)\n```",
        "created_at": "2020-11-21T20:09:30.375000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You can simply replace objects with their hash-tree-roots and the resulting root is the same.",
        "created_at": "2020-11-21T20:09:55.357000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The ability to simply replace objects is pretty badass since it means that you can do something like any of the following and they are all equivalent in terms of ssz hash.\n\n```\nfull_objects = [txn_1, txn_2, txn_3]\nmixed = [txn_1, ssz_hash(txn_2), txn_3]\nall_hashes [ssz_hash(txn_1), ssz_hash(txn_2), ssz_hash(txn_3)]\n```\n\nAll three of the above will hash to the same value.",
        "created_at": "2020-11-21T20:16:15.383000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A proof can either be an actual merkle proof, or you can do something like this where you simply replace all the un-necessary parts of the data with their SSZ hashes.",
        "created_at": "2020-11-21T20:17:54.385000+00:00",
        "attachments": null
    }
]