[
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "1Ô∏è‚É£ \u003c@\u0026688090867927482525\u003e  2Ô∏è‚É£ \u003c@\u0026595684226221735986\u003e  3Ô∏è‚É£\u003c@\u0026652918665943056397\u003e 4Ô∏è‚É£\u003c@\u0026595683059651706974\u003e 5Ô∏è‚É£\u003c@\u0026688101493978562687\u003e Assuming we were to go with SSZ in 2718 for transaction and receipt encoding:  Would you plan to use an existing implementation or roll your own: Existing Implementations can be found here: https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#implementations",
        "created_at": "2020-11-16T16:22:26.009000+00:00",
        "attachments": null
    },
    {
        "author": "tkstanczak",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "we have our own SSZ implementation already",
        "created_at": "2020-11-16T16:23:48.983000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e for the topic of taking advantage of ssz hashing.  We would want to reference objects using the `hash_tree_root(value)` function defined in the spec here: https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#merkleization",
        "created_at": "2020-11-16T16:29:11.239000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "and ideally things like `Header.transactions_root` would be something like:\n\n```\nTypedTransaction = Container[type: uint8, payload: List[uint8, max_length=...]]\nHeader.transactions_root = hash_tree_root(List[TypedTransaction, max_length=...])\n```",
        "created_at": "2020-11-16T16:31:24.637000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That's a very simplistic version, we could very likely figure something a little more sophisticated out that preserved the structure but that sort of goes orthogonal to the idea of treating transactions as opaque payloads.",
        "created_at": "2020-11-16T16:32:57.275000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "now's maybe a good time to split off Rust SSZ implementation into a separate library as sentry would need that",
        "created_at": "2020-11-16T16:33:22.559000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "cc \u003c@\u0026595683849225240704\u003e",
        "created_at": "2020-11-16T16:33:27.464000+00:00",
        "attachments": null
    },
    {
        "author": "adria0",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e, if we can use it without upgrading parity libraries (we plan to upgrade them after Berlin) and it does not take so much time to review the  code the ovbious choice should be using an existing SSZ library.",
        "created_at": "2020-11-16T16:52:30.086000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!531145505355464708\u003e it would be nice if someone on your team could some time to do at least preliminary review of that codebase to have a more concrete indication of whether you'd be ok using the existing SSZ lib.",
        "created_at": "2020-11-16T16:58:21.295000+00:00",
        "attachments": null
    },
    {
        "author": "adria0",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e \u003c@!531145505355464708\u003e it would be nice if someone on your team could some time to do at least preliminary review of that codebase to have a more concrete indication of whether you'd be ok using the existing SSZ lib.\n\u003c@!364458974906548225\u003e cc/ \u003c@!429719902363058177\u003e",
        "created_at": "2020-11-16T16:58:48.100000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "sorry, I think I may have misread your statement to mean that you were unsure if an existing library would be suitable but maybe that wasn't your intent.  Either way, if it looks like the existing SSZ lib isn't something you are comfortable with, let us know.",
        "created_at": "2020-11-16T17:00:25.164000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Felix indicated in the breakout room channel that they'd be using the existing go implemetnation of ssz",
        "created_at": "2020-11-16T17:01:44.132000+00:00",
        "attachments": null
    },
    {
        "author": "adria0",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Reading 2972, is not the  _clients likely have access to an SSZ decoder_ reason, a little weak? Everything is RLP encoded except recipts for this reason?",
        "created_at": "2020-11-16T17:06:33.402000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!531145505355464708\u003e I believe that statement just means that there exists an SSZ implementation in every language that has a functional Ethereum client because ETH2 uses SSZ exclusively, and we have ETH2 clients in all major languages I believe.",
        "created_at": "2020-11-16T17:36:25.521000+00:00",
        "attachments": null
    },
    {
        "author": "adria0",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm just trying to understand what are the defacto (not teorical) advantages of using  `SSZ`  instead `RLP` at this moment. And why not to encode blocks in `SSZ` also?",
        "created_at": "2020-11-16T17:39:31.047000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Long term, the goal would be to encode every aspect of the block with SSZ so that we can maximally reap the benefits of SSZ encoding.",
        "created_at": "2020-11-16T17:40:51.344000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The idea here is to introduce SSZ as we add *new* things, and figure out how to swap out *old* things later.",
        "created_at": "2020-11-16T17:41:10.028000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e is better able to explain the benefits of SSZ for proof stuff.",
        "created_at": "2020-11-16T17:41:25.304000+00:00",
        "attachments": null
    },
    {
        "author": "adria0",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "mmmm... like merkle proofs for light client/regenesis?",
        "created_at": "2020-11-16T17:42:27.385000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The growing need for an SSZ explainer .... grows.",
        "created_at": "2020-11-16T17:42:34.336000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!531145505355464708\u003e so SSZ is both serialization (with a nice schema based system) and a hashing scheme for producing 32-byte hashes that represent a merkle root of the data.",
        "created_at": "2020-11-16T17:43:36.200000+00:00",
        "attachments": null
    },
    {
        "author": "adria0",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I super-quickly readed it and yes, makes sense, it's just _when_ to introduce it",
        "created_at": "2020-11-16T17:44:34.486000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For the serialization, there are a few benefits.  It's concise, in some cases RLP beats SSZ, but in general they are comprable.  There are some structures (particularly deeply nested ones) that SSZ produces more concise serialized formats.",
        "created_at": "2020-11-16T17:44:52.267000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Another benefit at the serialization scheme is that you can \"index\" into objects without having to fully decode them.  The serialization scheme gives you something like worst case Log(N) complexity for accessing a specific part of a serialized payload without having to decode the full payload.",
        "created_at": "2020-11-16T17:45:51.288000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "These are small wins over RLP",
        "created_at": "2020-11-16T17:45:59.666000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The \"big\" win is related to the merkle root based hashing.  SSZ defines a function `hash_tree_root(ssz_obj)` that gives a 32-byte root unique to that object.  SSZ uses the term \"partial\" to refer to an object that only contains some of the actual data, with the rest of it only represented as a minimal merkle proof.  So a full `Receipt` might be 10k of data, but maybe you only want a single log.  You could provide that \"log\" in an \"SSZ Partial\", which would be a merkle proof of just the part of the receipt that contains the log.  Compare that to the state-of-the-world today where we use `keccak(rlp(obj))` and you cannot provide such a proof. \n\nAnother place this comes into play is in transfering data over the wire in networking situations.  In a UDP based network, we can transmit things in about 1kb chunks.  If all we have is the hash produced by `keccak(rlp(obj))` then you cannot split that object up into pieces and transmit it in a manner that makes each piece provable.  This results in a griefing vector.  If something takes 10 packets and I cannot prove each packet is correct, then I have to get all 10 packets before I know I have the right data.  If objects are instead referenced by their `hash_tree_root`, then each of those packets can be a merkle proof.  The proofs can then be individually verified, and merged iteratively to rebuild the full object.",
        "created_at": "2020-11-16T17:51:07.578000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e in terms of the UDP packets, where are you bumping into these 1kb chunks as issues? In terms of the `keccak(rlp(obj))` which is the root unit in the current trie format?",
        "created_at": "2020-11-16T17:52:43.894000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The only part of the ethereum 1.x protocol that reliably fits into a UDP packet is the header.  Everything else has the potential to exceed the 1kb size boundary.  (block bodies, individual transactions and receipts)",
        "created_at": "2020-11-16T17:53:47.904000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The beautiful endgame as Micah hinted at above is conversion of the header to an SSZ object, converstion of the `Header.transactions_root` and other `XXX_root` fields to use something like the `hash_tree_root` of an SSZ object, and conversion of the transaction and receipts to be SSZ objects, at which point we have a very powerful unified data structure that supports the full gambit of slicing off any arbitrary part in a \"provable\" manner.",
        "created_at": "2020-11-16T17:56:14.908000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Fun history lesson.  There was a lot of excitement early on about using Swarm as a data warehouse for ethereum data.  Because the hashes that we use aren't compatible with the hashes swarm used, my conclusion after a decent bit of experimentation was that it wasn't feasible unless we changed to use the native hash used by the swarm network.  The same goes for using IPFS.  Because we don't use the same type of hash, leveraging that network for data storage can't be done because there's no way to translate the hash we have in the protocol to the has the storage network uses.\n\nThe SSZ hash is a much more versitile hashing scheme that is much better suited for both the cryptographic protocol needs and networking transmission needs.",
        "created_at": "2020-11-16T18:01:17.568000+00:00",
        "attachments": null
    },
    {
        "author": "adria0",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Got the point, make-them-all-contentaddressable-ASAP, like IPLD",
        "created_at": "2020-11-16T18:06:59.997000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e Looks like Prysmaitic implementation mentions Apache 2.0 in the README.md, but MIT in LICENCE file. C++ implementation does not mention the license at all in the repo. Quick scan of the Go implementation, and I see that the objective of the library is to provide marshalling and un-marshalling of the Go structs.  This is probably useful for the application and use SSZ casually, as one of the serialisation methods. If, however, we are talking about data that have to match on the binary level, then I would write custom serialiser anyway. It is worth the effort to get it exactly right, given that there are not a hundred types to maintain",
        "created_at": "2020-11-16T20:02:29.738000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "please note that this does not qualify as \"roll our own implementation\", because I probably would not write another marshalling library",
        "created_at": "2020-11-16T20:03:06.751000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@456226577798135808\u003e we are archiving our prysmaticlabs/go-ssz implementation. The one we use in production is https://github.com/ferranbt/fastssz",
        "created_at": "2020-11-16T23:27:02.973000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Via code generation for structs",
        "created_at": "2020-11-16T23:27:06.893000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "not sure if that was what you were referring to",
        "created_at": "2020-11-16T23:28:03.224000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes, that would be the way to do it",
        "created_at": "2020-11-16T23:36:33.977000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but in this case, \u003c@!364458974906548225\u003e 's original question kind of changes. If you use code generator like this, you don't really need to use the library üôÇ",
        "created_at": "2020-11-16T23:37:12.456000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "you would do it for the convenience if something changes",
        "created_at": "2020-11-16T23:37:41.531000+00:00",
        "attachments": null
    }
]