[
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@688748669268132001\u003e How are you doing the swaps?",
        "created_at": "2021-04-09T09:53:58.901000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Each round can be computed independently (or in groups, e.g. rounds 0-10, 10-20, etc.), and then you can merge them afterwards. If you use some webworker approach, that may be may improve things. Weird that swapping numbers in an array is so slow in JS",
        "created_at": "2021-04-09T09:57:36.437000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "https://github.com/ChainSafe/lodestar/blob/ec065635ca7da7f3788da018bd68c4900f0427d2/packages/beacon-state-transition/src/util/shuffle.ts#L126\n```ts\nconst tmp = input[j];\ninput[j] = input[i];\ninput[i] = tmp;\n```",
        "created_at": "2021-04-09T10:04:01.061000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You are sure that is the bottleneck?",
        "created_at": "2021-04-09T10:04:43.598000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "How big are the numbers in the array?  8 bits?",
        "created_at": "2021-04-09T10:05:18.767000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Stupid, but true, suggestion: can you try `var` instead of `const`? The transpiler may be adding more checks because it is const. And/or the VM may have more trouble with `const` than `var`",
        "created_at": "2021-04-09T10:05:22.883000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For the tmp var",
        "created_at": "2021-04-09T10:05:35.572000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If it is TypeScript, transpiler isn't doing anything there.  Can't speak to the VM being dumb though.",
        "created_at": "2021-04-09T10:06:04.730000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Would surprise me if it is doing something that silly.  As much as I deplore JavaScript, the VMs for it are pretty well optimized.",
        "created_at": "2021-04-09T10:06:38.011000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Just did profiling and those three lines are a significant hot path",
        "created_at": "2021-04-09T10:07:25.560000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Did a quick bench and doing swaps with regular arrays in javascript is x185 times slower than with Uint32Array",
        "created_at": "2021-04-09T10:07:43.581000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's a great suggestion I'll try",
        "created_at": "2021-04-09T10:07:57.873000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Was going to suggest switching to a typed array.  ðŸ™‚",
        "created_at": "2021-04-09T10:07:59.343000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And if you move the `tmp` outside of the loop, and use `var`? Super curious",
        "created_at": "2021-04-09T10:08:05.219000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Side note: Use `===` not `==`.",
        "created_at": "2021-04-09T10:08:42.946000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "(largely unrelated to performance, but `==` may be more expensive since it is more permissive)",
        "created_at": "2021-04-09T10:09:04.021000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ðŸ¤” I suppose we are talking about a really tight loop.  Just realized the other code in that function don't actually get hit every time other than some simple checks and math.  So we are essentially comparing pure math against arrays, in which case \"swapping items in an array is very expensive\" is relative to \"adding two numbers\".",
        "created_at": "2021-04-09T10:10:54.508000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "There is no noticeable difference from using var vs const, nor declaring the tmp var in the outer function scope",
        "created_at": "2021-04-09T10:22:01.144000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "`Uint32Array` it will be then ðŸ˜…",
        "created_at": "2021-04-09T10:22:53.777000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This is a profile of the hottest part of the function body, some parts the times are off by one line, it's a bit of guessing too. Function run for exactly 60 sec",
        "created_at": "2021-04-09T10:23:34.669000+00:00",
        "attachments": [
            {
                "type": "image/png",
                "origin_name": "Screenshot_from_2021-04-09_11-37-37.png",
                "content": "2820a69ac196ba756f4de36dc3dcb3235e6275e58f3e3b251d1ddfae8e7f9403"
            }
        ]
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I wonder about the bit comparisons like Micah now, e.g. the `bitV == 1` on line 125 seems critical. It could be `bitV === 1`",
        "created_at": "2021-04-09T10:27:55.974000+00:00",
        "attachments": null
    },
    {
        "author": "underbasic",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "it shouldn't matter but what if you hoist the varibles that you are hitting into the function? like let internalJ = j; and at the end j = internalJ ?",
        "created_at": "2021-04-09T10:28:36.373000+00:00",
        "attachments": null
    },
    {
        "author": "underbasic",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "and yeah the ===",
        "created_at": "2021-04-09T10:28:44.770000+00:00",
        "attachments": null
    },
    {
        "author": "underbasic",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "and using internalJ (or some better name) inside your function?",
        "created_at": "2021-04-09T10:29:25.478000+00:00",
        "attachments": null
    },
    {
        "author": "underbasic",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "and passing source and input as params",
        "created_at": "2021-04-09T10:30:59.729000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "the j is the same(var, value changes) throughout the whole code, it's meant to be shared. The function definitions are only to reduce duplicate code, but the logic is still a big thing",
        "created_at": "2021-04-09T10:31:27.391000+00:00",
        "attachments": null
    },
    {
        "author": "underbasic",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah but sometimes the compilers do funny things when you capture external vars into a function",
        "created_at": "2021-04-09T10:32:00.191000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If you're curious, here's the original Go implementation of the list-wise shuffle optimization; https://github.com/protolambda/eth2-shuffle/blob/master/shuffle.go",
        "created_at": "2021-04-09T10:32:31.582000+00:00",
        "attachments": null
    },
    {
        "author": "underbasic",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I am not saying logically its wrong, just that when you have a function that is being called via a closure it (at least used to I haven't looked deeply at more recent JS VM's and they have become amazing) can cause performance issues",
        "created_at": "2021-04-09T10:35:37.707000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "interesting. Duplicating that bit of code may be worth it then.",
        "created_at": "2021-04-09T10:36:38.195000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ah, those numbers aren't as bad as I thought.  That actually looks pretty reasonable to me.",
        "created_at": "2021-04-09T10:36:44.668000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The core of the problem here is that you are doing so many iterations of `step`, but the time spent looks pretty evenly distributed across the function.",
        "created_at": "2021-04-09T10:37:02.192000+00:00",
        "attachments": null
    },
    {
        "author": "underbasic",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "closures vs pure functions can have a decent perf impact",
        "created_at": "2021-04-09T10:37:07.845000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The swaps are costing similar amounts to the math operations, which suggests there isn't a ton of room for performance improvements.",
        "created_at": "2021-04-09T10:37:28.592000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You may be able to squeeze out a little more from Uint8Array, but probably not much.",
        "created_at": "2021-04-09T10:37:52.497000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You sure you hit compile?  Those off line numbers imply that your source maps are out of date or something.",
        "created_at": "2021-04-09T10:38:25.533000+00:00",
        "attachments": null
    },
    {
        "author": "underbasic",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "anyway, the closures thing might be a red herring, only an experiment will really be able to say",
        "created_at": "2021-04-09T10:39:40.271000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I did an error on the benchmark, swapping in regular arrays in javascript have same performance as Uint32Array",
        "created_at": "2021-04-09T11:18:30.733000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "By inline-ing the clousers reduces the cpu time not spent hashing by 50%. Thanks for the suggestion! Would be cool to have macros in JS",
        "created_at": "2021-04-09T11:34:37.838000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Same performance for equals == and strict equals ===",
        "created_at": "2021-04-09T12:25:02.790000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "After the `bitV = input \u0026 1`, the if can be `if (bitV)` instead of `if (bitV == 1) {`, that might be faster. \u003c@!688748669268132001\u003e",
        "created_at": "2021-04-09T12:27:35.403000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It runs that `if` almost a million times on Prater (`210000/2*90=9.45M`), so every little bit of performance helps there.",
        "created_at": "2021-04-09T12:30:31.755000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh good point! Tho perf is the same too. Will look into parallelizing, it's a great suggestion thanks",
        "created_at": "2021-04-09T12:39:31.961000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The parallelizing thing works like:\n- create a list of `0...N` for each worker\n- assign a `round` start and end to each worker. E.g.  worker 2 does rounds `20...30` of the total 90 rounds.\n- every worker runs the list shuffle for their range of rounds, effectively computing a mapping: the result tells you were each original index was.\n- a final merge step: apply the \"mapping\" of each worker to the input, in the order of the rounds\n\u003c@!688748669268132001\u003e",
        "created_at": "2021-04-09T12:44:02.478000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If you already run the hash function in WASM, then running this worker in WASM may be a good idea. It avoids a lot of repeated hash calls to WASM, and should parallelize more easily.",
        "created_at": "2021-04-09T12:46:19.315000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You mean running the entire swap or not routine in WASM?",
        "created_at": "2021-04-09T12:47:33.675000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yes",
        "created_at": "2021-04-09T12:48:44.348000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And you can either try to run WASM workers in parallel, or run the non-parallel algorithm in WASM.",
        "created_at": "2021-04-09T12:49:36.885000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Do you know how much extra memory does your algo require?",
        "created_at": "2021-04-09T12:52:16.854000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The biggest bottleneck in our shuffle function now is hashing, so I was looking into going the other way, running sha256 in a faster native binding for our nodeJS based node",
        "created_at": "2021-04-09T12:52:44.110000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The parallel one? Each worker basically requires as much memory as the original algo: N uint32 values.",
        "created_at": "2021-04-09T12:52:59.646000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Plus some small constant, to cover memory of the hash function and temporary variables.",
        "created_at": "2021-04-09T12:53:51.873000+00:00",
        "attachments": null
    }
]