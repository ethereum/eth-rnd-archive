[
    {
        "author": "arnetheduck",
        "category": "Testing",
        "parent": "",
        "content": "we're playing around with the startup, and an alternative idea (compared to https://github.com/ethereum/eth2.0-pm/issues/60#issuecomment-521593844) we're looking at is deterministic key generation from eth1 -\u003e eth2: use a seed phrase to generate a hierarchy of eth1 keys with the index in the derivation path, then map the bits of the eth1 key to the bits of an eth2 key - this makes the process deterministic and provides a convenient mapping of keys from eth1 to eth2 so the whole process is controlled - thoughts? https://github.com/status-im/thundercloud/blob/master/start.js#L153",
        "created_at": "2019-08-15T11:07:27.302000+00:00",
        "attachments": []
    },
    {
        "author": "carlbeek",
        "category": "Testing",
        "parent": "",
        "content": "Interesting idea. My concern is that every client then needs to write (or find an implementation in their language for) Eth1 HD wallets while still needing to define the mapping from eth1 -\u003e eth2 keys.  (Said mapping is basically all there is to  https://github.com/ethereum/eth2.0-pm/issues/60#issuecomment-521593844 .) Also, because there will very likely be a new HD wallet standard in Eth2  (see https://github.com/ethereum/eth2.0-specs/pull/1361 ) it seems like the wrong place to be putting effort into. I am open to suggestions though.",
        "created_at": "2019-08-15T11:21:33.793000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Testing",
        "parent": "",
        "content": "not necessarily, it's a one-off tool that generates all keys and can serialize them to file or whatever, that everyone can use",
        "created_at": "2019-08-15T13:04:06.678000+00:00",
        "attachments": []
    },
    {
        "author": "carlbeek",
        "category": "Testing",
        "parent": "",
        "content": "Ah, I see. Yeah that would work. üëç \n\nI still prefer https://github.com/ethereum/eth2.0-pm/issues/60#issuecomment-521593844 on the grounds of simplicity though.\n\nWhat are the benefits of using the BIP39,32,44 method \u003c@449019668296892420\u003e ?",
        "created_at": "2019-08-15T13:21:25.819000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "You should consider that subgroup used in eth1 (secp256k1) and subgroups built from BLS curves have different orders. It means that key created for eth1 could be an invalid key for eth2. You may apply a modulo operation to eth1 key in order to get valid eth2 key (as eth1 order is higher than for eth2) but it makes derived key modulo biased.",
        "created_at": "2019-08-15T13:25:24.763000+00:00",
        "attachments": []
    },
    {
        "author": "carlbeek",
        "category": "Testing",
        "parent": "",
        "content": "Yup absolutely. mod is the simplest map I can think of between the two groups. Modulo bias shouldn't be a problem for testing purposes here.\n\nMy proposal is basically:\n```\nprivkey = int(hash(index)) % curve_order\n```\n\nNot safe but fast and simple.",
        "created_at": "2019-08-15T13:28:41.912000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Testing",
        "parent": "",
        "content": "ah, nice. bipXX, not really critical except you can create different \"namespaces\" with the mnemonics that are easy to pass to one another. I guess an alternative is using the same method for eth1 \u0026 eht2 keys as in the ticket, and selecting the ones that are valid for both chains.",
        "created_at": "2019-08-15T13:58:48.694000+00:00",
        "attachments": []
    }
]