[
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "What breaks if the light client is \"wrong\"?",
        "created_at": "2021-12-17T01:31:38.246000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "In principle the client could just fall back to syncing back-to-front, right?",
        "created_at": "2021-12-17T01:32:00.909000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "------------------------------",
        "created_at": "2021-12-17T01:32:15.418000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "https://kintsugi.themerge.dev/",
        "created_at": "2021-12-17T01:32:24.725000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Wow this site looks amazing",
        "created_at": "2021-12-17T01:32:25.418000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Really appreciate the \"add to metamask\" button",
        "created_at": "2021-12-17T01:32:29.035000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Drives home the \"this is a network you can actually use\" bit",
        "created_at": "2021-12-17T01:32:32.202000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "woot woot I have 50 post-merge testnet eth",
        "created_at": "2021-12-17T01:32:36.794000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "I missed the call due to a personal engagement yesterday, it's a shame I missed out on opt sync discussion. I tried to listen to the call but it seems that perhaps the recording didn't work: https://www.youtube.com/watch?v=SKPQSR9CD24",
        "created_at": "2021-12-17T01:33:38.913000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I also missed it. Only saw the mention of light client in Benâ€™s notes. The recording didnâ€™t work.",
        "created_at": "2021-12-17T01:38:44.894000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I would imagine that the EL would sync the wrong world state and would then either be unable to validate payloads from other forks (or prior to the world state it has) or would have to start the sync process again. \n\nThe aim of light client sync would be to avoid the beacon node ever importing a block without the EL confirming it is valid which simplifies the beacon node logic a lot. \nSo Iâ€™m not sure there would be a fallback sync method. I think weâ€™d need the light client to work.",
        "created_at": "2021-12-17T01:42:56.736000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Why can't we just do some simple fallback like \"keep asking for the child of the current head\"?",
        "created_at": "2021-12-17T08:47:13.331000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I'm not sure what you mean.",
        "created_at": "2021-12-17T09:07:11.030000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Like, try to get as many blocks as you can by asking for children of the blocks you know, so you can then run the consensus on the block tree",
        "created_at": "2021-12-17T09:07:42.574000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "hmm, the main challenge with sync is getting the world state on the EL side.  For that you'd need to be on the right chain, not just any chain I think because the world state you download is a pretty finalized point (completely finalized in some clients but theoretically it may be possible to discard it and download a different one).",
        "created_at": "2021-12-17T09:10:00.420000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "right",
        "created_at": "2021-12-17T09:10:15.602000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Basically every time you see a consensus block, feed the embedded exec block into the exec client",
        "created_at": "2021-12-17T09:11:36.456000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "And then when you have the full consensus block tree, you'll also have the full exec block tree",
        "created_at": "2021-12-17T09:12:33.488000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Yeah that's true, but you couldn't validate any of those blocks because the EL isn't sync'd so you'd be back to optimistic sync.  Or you wind up storing every block you find somewhere and then essentially full sync the EL.",
        "created_at": "2021-12-17T09:13:07.934000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Right, that's what I mean, full sync the EL, at least from the state of the exec block that you WS-synced from",
        "created_at": "2021-12-17T09:13:43.110000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Ah but the WS-sync won't get you the EL world state and you generally can't get the EL world state for anything older than about 128 blocks (based on my reading of the snap sync protocol).  Certainly the older the state you're looking for the harder it is to find on the network.",
        "created_at": "2021-12-17T09:14:37.329000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "aha I see",
        "created_at": "2021-12-17T09:14:51.142000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "So you could completely full sync the EL from the PoW genesis but otherwise I think you need to start from very close to the canonical head.",
        "created_at": "2021-12-17T09:14:59.637000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Surely that's the problem that should be fixed then?",
        "created_at": "2021-12-17T09:14:59.724000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I mean that's essentially what portal network and stateless ethereum are working towards solving from my understanding. We don't currently have them as dependencies for the merge though.",
        "created_at": "2021-12-17T09:16:12.640000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "aha I see.....",
        "created_at": "2021-12-17T09:16:30.074000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Making it easier to sync EL world state is very definitely a worthy goal and would make life an awful lot easier for syncing merge clients.",
        "created_at": "2021-12-17T09:16:51.520000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "If the beacon chain is fully synced, then you can grab the EL state of the exec block in a recent beacon block, right?",
        "created_at": "2021-12-17T09:18:28.057000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "So you can do beacon first, EL second syncing",
        "created_at": "2021-12-17T09:18:36.284000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "If you optimistically sync the beacon chain (ie import blocks without validating the execution payload), then you can keep the EL updated with `forkChoiceUpdated` messages, each of which supply the head and finalized execution payload hash and the EL can get the world state hash from that.  It needs a constant stream of those updates to let it download the world state because it can't download the whole world state before its peers prune that state, so it keeps updating the block/payload that it's trying to download the world state for to something more recent.\n\nThe trouble is that optimistically syncing the beacon chain is quite complex for the beacon node and has a potential liveness issue.  Let me see if I can find Paul Hauner's write up of that.",
        "created_at": "2021-12-17T09:43:31.459000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "https://hackmd.io/S5ZEVhsNTqqfJirTAkBPlg",
        "created_at": "2021-12-17T09:44:01.114000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Reading that now",
        "created_at": "2021-12-17T10:09:25.375000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "That seems like it's an edge case specific to the transition period, right?",
        "created_at": "2021-12-17T10:09:35.935000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Right, this attack vector doesn't exist after transition block is justified. We assume that justification would be enough to prove that the transition block is fully available",
        "created_at": "2021-12-17T10:12:20.476000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "One of the options for online nodes to pass through this period is to avoid falling back to optimistic sync when EL returns `SYNCING` until transition block is justified.\n\nIt would mean that if terminal PoW block is not yet propagated across entire network some validators won't accept the transition block that is built upon. And it can result in a missed slot eventually, but at some point all terminal blocks will be propagated and chain will make its progress",
        "created_at": "2021-12-17T10:16:18.562000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "If a synced node sees a beacon block pointing to a terminal PoW block they don't know about, of course they should treat that as an unresolved dependency, like a missing parent",
        "created_at": "2021-12-17T10:17:19.235000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "I guess as long as already-synced nodes can carry us through the transition, newly-syncing nodes needing to wait until a post-merge beacon block is justified is ok if that's what we have to accept, right?",
        "created_at": "2021-12-17T10:18:16.110000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "If node is syncing it can keep syncing optimistically through the transition as online nodes will do their job by sorting out unavailable terminal block if such a block appears and syncing nodes will eventually converge at a viable fork",
        "created_at": "2021-12-17T10:20:45.694000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Right, but if transition block or any of its descendants is missing dependencies synced nodes should keep progressing with their validator duties to prevent liveness failure",
        "created_at": "2021-12-17T10:22:57.603000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "hmm I don't think that's true",
        "created_at": "2021-12-17T10:30:31.537000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Or rather, they should vote as though they never saw any of the beacon blocks that depend on a missing transition block",
        "created_at": "2021-12-17T10:30:57.152000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yes, they should not apply this block to their fork choice and keep progressing as if this block didn't exist",
        "created_at": "2021-12-17T10:31:44.375000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "ok great",
        "created_at": "2021-12-17T10:31:54.388000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "And then if the transition block shows up later, they can add those blocks to the beacon block tree at that point",
        "created_at": "2021-12-17T10:32:18.843000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "EL may finish `SYNCING` but it won't let CL know that the block has been processed and, thus, can be accepted until the child of `SYNCING` block is sent to EL and EL responds with `VALID`.\n\nThere could be the following case. Transition block turns EL into `SYNCING`, CL doesn't accept the block and votes or proposes on top of the pre-transition block. If CL is honest and it observes another terminal block it will pick it up and propose another transition block, but if there is only one terminal block that is not yet propagated to the entire network there will be another pre-transition block, like `[pre-transition block, missing slot (because EL is SYNCING), pre-transition block, accepted transition block (terminal block has reached everyone in the network)]`. \n\nSo, it should eventually converge after a few tries if a terminal block is available, and on the other hand if it's unavailable it won't take any effect except for missing slot.",
        "created_at": "2021-12-17T10:42:09.307000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "In terms of timing, beacon blocks are proposed 0s into a slot and accepted into the fork choice for attesting 4s into a slot, right?",
        "created_at": "2021-12-17T10:43:28.750000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "So for that to be possible, network latency + transition block processing time would need to exceed 4s",
        "created_at": "2021-12-17T10:43:42.354000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "If an honest node proposes a beacon block that points to a terminal block, they would do that 0s into a slot, and only if the terminal block was already broadcasted in the p2p network, and so in normal circumstances, by the time it's 4s into that slot and other beacon nodes need to do anything, the other beacon nodes will have seen and processed the terminal block",
        "created_at": "2021-12-17T10:45:01.462000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "(Data point: currently around 3% of blocks are processed after the 4s mark.)",
        "created_at": "2021-12-17T10:51:04.063000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "For this to happen a terminal block should be disseminated slower than the transition block.\n\nImagine the following:\nNode `A` received a terminal block at `T`, it proposed a transition beacon block at `T + d1`\nNode `B` received a transition block at `T + d2` and the terminal block at `T + d3`\n\nObviously, `d1 \u003c d2`, but in a very rare case `d3` could be `\u003e d2` as we use two different gossip networks to propagate beacon and PoW blocks.",
        "created_at": "2021-12-17T10:52:19.838000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "If this happens, and d3 \u003e d2, then node B should act as though it received the transition block at T + d3, right?",
        "created_at": "2021-12-17T10:55:20.581000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Ideally, yes. But in the current Engine API design there is no way to respond twice to the same `executePayload` method call, so, if `d3 \u003e d2` Node `B` will receive `SYNCING` from its EL. And then when EL pulls all dependencies and verifies the payload it may only signify that the syncing job is done by responding `VALID` to a subsequent `executePayload` call",
        "created_at": "2021-12-17T11:03:39.523000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "hmm how difficult is that to fix?",
        "created_at": "2021-12-17T11:04:11.128000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Theoretically, CL may call `executePayload` for a transition block in perpetuity until it receives `VALID` or `INVALID`, or when sees that another transition block gets justified and this one may be dropped. But I am not sure that we want this complexity to handle this pretty rare edge case. By doing it this way we would only make the things right when `d3 \u003e d2` for the transition block",
        "created_at": "2021-12-17T11:07:44.922000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Otherwise, if this edge case hits we will get one missed slot, the next slot will unlikely to be affected, it would require `d3 \u003e SECONDS_PER_SLOT` which is unrealistic",
        "created_at": "2021-12-17T11:11:30.445000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "right, makes sense",
        "created_at": "2021-12-17T12:18:15.942000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "\u003e The trouble is that optimistically syncing the beacon chain is quite complex for the beacon node and has a potential liveness issue\n\nAre there known complexities with optimistically syncing the beacon chain other than the transition-time-specific issue in that doc?",
        "created_at": "2021-12-17T12:18:51.144000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Another complexity which is more implementation-specific than the design-specific like the transition edge case is reverting blocks which payload or ancestor's payload is `INVALID` during optimistic sync. Suppose, `SYNCING` for a payload of beacon block `A` turns out to be `INVALID` after some time, it means that `A` and all its ancestors should be removed from the fork choice state. Also, `store.latest_messages` should be reverted to the state as if `A` and all its ancestors didn't exist. The latter thing seems complicated in terms of implementation. cc'ing \u003c@!361447803194441738\u003e \u003c@!340345049063882753\u003e for more input on this one",
        "created_at": "2021-12-17T12:44:44.488000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Other than that, I think we're really close to figure out all subtleties of the optimistic sync and hopefully will publish the spec soon",
        "created_at": "2021-12-17T12:49:54.272000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "When the testing is done and the merge is ready how much time should the network have to update their nodes before it activates?",
        "created_at": "2021-12-17T17:25:50.542000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "maybe 30 days ðŸ™‚",
        "created_at": "2021-12-17T17:28:26.456000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "The merge will happen in two steps, which addresses this concern. First, there will be a merge fork, similar to phase 0 or altair. Clients will already have to be ready for the merge fork, and by the time they are, they should be ready for the actual merge transition regardless of whether it's one day, thirty days, or 100 days.\n\nThe merge fork is mostly Altair-with-the-possibility-to-start-running fork choice for Ethereum as a whole and gossip blocks which the the ELs can use. The simple answer, though, is clients should be ready the moment the merge fork begins.",
        "created_at": "2021-12-17T18:27:31.360000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "We probably want The Merge to happen pretty close (e.g. few weeks at most) from when those releases go out because of how much the difficulty can change in a few weeks.",
        "created_at": "2021-12-17T21:08:13.616000+00:00",
        "attachments": null
    }
]