[
    {
        "author": "mardiansyah9511",
        "category": "general",
        "parent": "",
        "content": "Hi",
        "created_at": "2021-12-20T17:33:13.969000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "Do you all know if engine_executePayloadV1 can be called on a historical block?",
        "created_at": "2021-12-20T18:09:09.776000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "The answer *should* be yes, but I'm not sure the actual functionality. If the block is already executed and in the block tree, should jsut say SUCCESS",
        "created_at": "2021-12-20T18:43:22.461000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "this is important in the event that EL is synced but CL begins a fresh sync or for some reason starts in the past",
        "created_at": "2021-12-20T18:43:41.490000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "in such an event, CL would be sending in streams of past payloads is it syncs and EL will already know them and just say VALID, VALID, VALID, etc. without having to recompute",
        "created_at": "2021-12-20T18:44:05.142000+00:00",
        "attachments": null
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "from what i have seen in the kintsugi logs, geth says some akin to `already executed ignoring ....` with the correct status response.",
        "created_at": "2021-12-20T18:44:53.497000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "I'd like to be able to give the execution client a new payload on a past block and get whether or not it *would* have been valid (along with how much value it created for the feeRecipient: https://github.com/ethereum/execution-apis/pull/150)",
        "created_at": "2021-12-20T18:58:13.824000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Can you not do this with the existing eth APIs?",
        "created_at": "2021-12-20T19:00:34.633000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I'm also not 100% sure what you mean by historic block in this case?",
        "created_at": "2021-12-20T19:00:45.034000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "as in \"re-running\" a block that was already inserted into EL?",
        "created_at": "2021-12-20T19:00:55.668000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "or running *new* payloads built on top of (historic) blocks in the block tree",
        "created_at": "2021-12-20T19:01:21.067000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "essentially, can't I just insert N different payloads, then run a balance query on those branches (is this possible?), and select the one with the highest balance?",
        "created_at": "2021-12-20T19:03:24.874000+00:00",
        "attachments": null
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "i think this should be possible by changing transactions field of `ExecutionPayload` provided in execute payload api, doing multiple calls and evaluating the result",
        "created_at": "2021-12-20T19:18:32.007000+00:00",
        "attachments": null
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "I think EL would need to be patched with the code to ignore the `stateRoot` checks which they might be doing post execution of the transactions if one wants to swap the transactions",
        "created_at": "2021-12-20T19:28:16.648000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "It would be about finding out if payloads which did not become canonical were valid",
        "created_at": "2021-12-20T19:29:03.646000+00:00",
        "attachments": null
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "so you would have full payload variant with the full  matching corresponding data of `ExecutionPayload`",
        "created_at": "2021-12-20T19:31:37.984000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "correct",
        "created_at": "2021-12-20T19:31:49.453000+00:00",
        "attachments": null
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "in my opinion, it should work out, you can easily test this out against kintsugi target builds of geth, nethermind etc",
        "created_at": "2021-12-20T19:33:35.190000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "cool",
        "created_at": "2021-12-20T19:34:13.771000+00:00",
        "attachments": null
    },
    {
        "author": "marioevz",
        "category": "general",
        "parent": "",
        "content": "I'm writing a test case where forkchoiceUpdated is used to re-org to a pre-TTD block (after the chain had already transitioned to PoS), I am not sure what the outcome should be but it seems to me like it should produce an error, what should I expect in this case?",
        "created_at": "2021-12-20T22:06:15.964000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "yeah, you should be able to add minor \"fork\" blocks to the block tree within reasonable depth. certainly on the order of many epochs and should be much more depending on implementation",
        "created_at": "2021-12-20T22:33:08.194000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "this is like adding a newly found uncle in pow at some depth that isn't likely to ever be in the canonical chain",
        "created_at": "2021-12-20T22:33:48.530000+00:00",
        "attachments": null
    },
    {
        "author": "marioevz",
        "category": "general",
        "parent": "",
        "content": "thanks!",
        "created_at": "2021-12-20T22:40:43.885000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "sorry, was responding to \u003c@!385978868131168259\u003e",
        "created_at": "2021-12-20T22:42:22.516000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "for your case, as long as a post-merge PoS block has not been finalized, then yuo can and should be able to re-org to a different pre-TTD block",
        "created_at": "2021-12-20T22:42:50.321000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "say there is viable TTD block A and B, then we can have a PoS chain build on A for a while and then see another PoS chain build on B that has a higher fork choice weight and causes a re-org",
        "created_at": "2021-12-20T22:43:36.004000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "once any post-merge PoS chain is finalied though, you'd never re-org any PoW blocks in the tree ever again",
        "created_at": "2021-12-20T22:43:55.467000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "make sense?",
        "created_at": "2021-12-20T22:43:56.675000+00:00",
        "attachments": null
    },
    {
        "author": "marioevz",
        "category": "general",
        "parent": "",
        "content": "In this specific case, should be an error right?",
        "created_at": "2021-12-20T22:44:39.034000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "This is an edge case worth discussing. A signal of \"finalized\" means that that block and ancestors will never revert. If CL reneges on this promise, it would be natural for EL to not re-org and to provide an error. It is natural because EL is supposed to be able to use \"finalized\" as chance to prune and maybe move things to a cold DB\n\nThat said, this is not specified in the engine API and if EL was not doing anything with the finalizd info (it is a MAY), it*might* result in EL either re-orging (if it still had that alternative branch) or *SYNCING* if it had pruned the branch",
        "created_at": "2021-12-20T22:48:51.497000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "cc \u003c@!425572898787426305\u003e for discussion\n\noptions:\n1. EL just blindly follows and attempts to do the re-org even if it had previously noted as \"finalized\" and did pruning/cold storage\n2. EL returns error\n\n\n(2) is much cleaner imo. EL should be able to make strong commitments on \"finalized\"\n\nbut if we write it as a \"MUST return an error\", then EL MUST track the finality message and refuse the revert with an error\nIt could be a \"MAY return an error\" but then it's not really respecting the semantics of \"finalized\" fully.\n\nWe've currently left the use of \"finalized\" by EL in the engine API as they can do whatever they want (or not) with the info, but this case might require a bit more concrete discussion on the finalized matter",
        "created_at": "2021-12-20T22:53:32.094000+00:00",
        "attachments": null
    }
]