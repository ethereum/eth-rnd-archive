[
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Data availability sampling in sharding depends on finite field math",
        "created_at": "2021-08-13T00:40:16.649000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's where the uint256 gets used",
        "created_at": "2021-08-13T00:40:20.952000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I mean, technically our protocol depends on uint384 already, it's just hidden and encapsulated in the elliptic curve classes",
        "created_at": "2021-08-13T00:40:37.154000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "My concern is less about whether or not we need uint256 - it's only being used in a relatively small piece of logic that's very unlikely to be performance critical.\n\nBut it does feel like hoisting these validations up from the execution layer is basically just scope creep.  We put off a lot of stuff to minimise the number of changes required to make the happen and now we're adding in a change that feels very optional.",
        "created_at": "2021-08-13T00:43:23.566000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003cvbuterin\u003e uint256 stuff is for sharding.... surely we don't need to worry about optimizing that until post merge?",
        "created_at": "2021-08-13T01:10:34.167000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Discussion from last nights call was about also using uint256 for the baseFee and hoisting validation of the base fee changes into the consensus layer instead of doing them in the execution layer as is currently done. I think it should be less a question of whether uint256 needs to be avoided or not and more about whether we need to or should hoist the base fee verification at the point anyway.",
        "created_at": "2021-08-13T01:16:25.163000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If we tend to keep less responsibilities for the execution layer, namely, reduce its responsibility to the execution environment then it implies hoisting this kind of validations into the consensus layer. But this is definitely not for the Merge and not for the hard fork next to it. After the merge the execution layer would still handle the block format check, which is to check whether deprecated fields are set to the right constants.\n\nSo, I think we should try to do as much checks as we can on the consensus layer but keep their number sane without requirement of introducing `uint256` arithmetics just for the purpose of bringing up one more check.",
        "created_at": "2021-08-13T07:20:25.940000+00:00",
        "attachments": null
    }
]