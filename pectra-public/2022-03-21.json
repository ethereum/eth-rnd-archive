[
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Good point on all this side branch data. Not being able to handle this even though you EL has sufficient validations to do so seems a loss",
        "created_at": "2022-03-21T00:17:55.219000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I didn't get what would we not handling, we would reorg to a sidechain, call fcu and if the EL already had validated the chain we'd have a valid head.",
        "created_at": "2022-03-21T02:22:21.545000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's assuming the VC has the same view of the chain at the same time.  It's entirely possible that the VC will submit something that refers to a non-canonical block. That could be because the VC is using multiple beacon nodes in some form and they disagree or it could just be timing related - the block was canonical when the VC created the attestations or whatever but there was then a reorg before the final signed item was submitted and it's no longer canonical.",
        "created_at": "2022-03-21T02:44:20.669000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's what I don't understand here: this fails the only rule of the proposal: a validator will not act on a block that hasn't returned VALID from FCU. \nIf the node immediately calls fcu when updating head and locks, it will not serve duties to a validator for an optimistic block.",
        "created_at": "2022-03-21T04:57:57.613000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You‚Äôre assuming the vc is only using a single bn. That‚Äôs not a safe assumption. You‚Äôre also assuming the validator has got its timings right and will submit the attestation before the beacon node could reorg which is also not guaranteed. \nBasically you‚Äôre one rule doesn‚Äôt hold. The bn can‚Äôt control what the validator does, only what it does.",
        "created_at": "2022-03-21T05:06:29.864000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "FWIW, I still expect a BN to serve duties to a VC for an optimistic head. However, I don‚Äôt expect it to serve an attestation or sync message that references an optimistic head.",
        "created_at": "2022-03-21T05:08:22.157000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This is not the case, I'm assuming that the VC is using as many nodes as it wants as long as they follow the same rule",
        "created_at": "2022-03-21T09:15:42.533000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Do you assume they all have the same view of the network?",
        "created_at": "2022-03-21T09:16:43.289000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah by duty I mean that, that it shouldn't serve an attestation, sync message or a block proposal based on an optimistic block. If all beacon nodes serving the given validator follow this rule (which your implementation also assumes in a different way) it does not matter if the nodes have a different view of the chain",
        "created_at": "2022-03-21T09:18:42.131000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "AIUI, if you store the optimistic status on each block, then there‚Äôs a chance that an attestation to a non-canonical block from a VC will still make it to the network. If an implementation only tracks optimistic status for the head, it‚Äôs impossible for an attestation for a non-canonical block to safely make it to the network.",
        "created_at": "2022-03-21T09:21:40.176000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I *think* this is the point Adrian was making.",
        "created_at": "2022-03-21T09:21:53.667000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't see how that's the case: my validator currently sends an attestation to whatever it's head is at that time, if that block is not canonical later that's not a problem.  Inclusion shouldn't be a problem either the including node doesn't care if attestations are for optimistic or valid blocks",
        "created_at": "2022-03-21T09:27:25.367000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The only thing that matters is that my validator is guaranteed that it's attesting to a valid block according to the node that serves it",
        "created_at": "2022-03-21T09:28:08.485000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh yeah, sorry my description was lacking.\n\nThe problem exists if the VC performs a GET request for an attestation to a non-canonical block.",
        "created_at": "2022-03-21T09:29:21.674000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If you track all opt status on all blocks, there‚Äôs a chance you can return an attestation. If you only track it for the head, you can‚Äôt safely return an attestation.",
        "created_at": "2022-03-21T09:30:13.085000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh actually, I think I‚Äôm still wrong.",
        "created_at": "2022-03-21T09:30:44.082000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think you‚Äôre right, I concede.",
        "created_at": "2022-03-21T09:31:00.817000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Perhaps I misunderstood Adrian‚Äôs point, I‚Äôll step away from this. Sorry!",
        "created_at": "2022-03-21T09:32:00.740000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Fwiw, here is the prysm implementation of the optimization that we would lose if following this proposal",
        "created_at": "2022-03-21T09:32:32.787000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003chttps://github.com/prysmaticlabs/prysm/pull/10398\u003e it was a simple change indeed",
        "created_at": "2022-03-21T09:33:06.179000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But I also may step away for a different reason: I haven't seen an argument against that one rule (at least that I understand) except that optimization, but it seems to me that this proposal may move the complexity from tracking optimistic status of nodes to tracking when we stop initial optimistic sync which may not be entirely trivial, but no team will have time nor man power to dedicate to this right now",
        "created_at": "2022-03-21T09:36:35.318000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Regardless, we certainly explored some design space!",
        "created_at": "2022-03-21T09:40:33.729000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "üë®üèª‚ÄçüöÄ",
        "created_at": "2022-03-21T09:40:53.413000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I am very sorry to be late to this discussion. My concern is that during the transition a node that doesn't remember a validity status of a payload might not be able to re-org from one terminal block to another until `SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY` runs out. \n\nIt would depend on CL implementation but if `VALID` status in the response to `newPayload(aSideForkPayload)` would be processed as `ACCEPTED` *and* the root of the beacon block would be appended to `optimistic_roots` then `forkchoiceUpdated(headBlockHash: anOptimisticBlockFromASideFork)` must not happen until `SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY` runs out -- this is per Optimistic Sync spec.\n\nAnd if we get to this situation with a 50% of nodes able to re-org and another 50% unable to then we will get a liveness failure during the merge transition.\n\ncc \u003c@!755590043632140352\u003e \u003c@!361447803194441738\u003e \u003c@!291925846556540928\u003e \u003c@!340345049063882753\u003e",
        "created_at": "2022-03-21T13:40:26.864000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This proposal is for after the merge where the check for `SAFE_SLOTS_TO_IMPORT_OPTIMISTICALLY` is obsolete. At the fork we want to carefully track optimistic status of all blocks to guard from known attacks, but after that I claim tracking only head is good enough",
        "created_at": "2022-03-21T13:45:27.297000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I see. Then my concern is unrelated. Do I correctly understand that you're proposing the following:\n1) a node will add roots of all side chain blocks to `optimistic_roots`\n2) a node will remove beacon block roots of a chain that is designated by `forkchoiceUpdated` from this list?",
        "created_at": "2022-03-21T13:51:37.101000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I propose something more radical: node will add blocks to it's canonical chain only if they are VALID, node will add nodes to any sidechain if the result of newPayload is ACCEPTED/SYNCING/VALID, node **will not** keep a list of optimistic_roots, but will not switch head unless FCU returns with VALID",
        "created_at": "2022-03-21T13:54:06.736000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I see now. This proposal looks fine from the protocol perspective. There are related validator performance and user experience implications that you have already discussed previously. But I can't find any edge case (except for transition one) when this approach may get broken and affect the network.",
        "created_at": "2022-03-21T14:04:07.924000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Will blocks be stored both in CL and EL clients? Is there any mechanism or ideas for de-duplication?",
        "created_at": "2022-03-21T14:05:59.956000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "A proposal: https://github.com/ethereum/execution-apis/pull/146\nA related discussion: https://github.com/ethereum/execution-apis/issues/137\nA recent discussion on the topic: https://discord.com/channels/595666850260713488/892088344438255616/954362244861423666",
        "created_at": "2022-03-21T14:13:00.172000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Thanks this is very valuable. Since this is about code complexity and can be added later at any time, perhaps I'll add a high level bare PR to the spec repo about this to have a formal discussion",
        "created_at": "2022-03-21T14:27:51.727000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Sure, but you're planning to have `optimistic_roots` for transition. If you figure it out for the merge then it may just stay there post-Merge.",
        "created_at": "2022-03-21T14:31:27.792000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You should keep optimistic sync completely as it is now for initial sync (that is when you are processing batches of blocks instead of single blocks as they come) and specially across the fork. This is in part why I'm a little skeptical of this cause this may not be trivial to implement and may lead to other bugs. But in principle I'm happy to avoid worrying about optimistic status of each node in fork choice during regular operations and restrict possible bugs to those nodes that are syncing",
        "created_at": "2022-03-21T14:39:03.461000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hm, I don't see why would `optimistic_roots` be important for initial sync. You would still send `fcU` from time to time and when it's responded with `VALID` an optimistic mode is turned off and initial sync is continued in a lock-step mode or gracefully finishes.",
        "created_at": "2022-03-21T14:45:12.499000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If we're syncing from a post-merge state then I think you're right that even in this case we don't really care about the optimistic status of each block.",
        "created_at": "2022-03-21T14:48:13.263000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yes, so, if validator performance and UX aren't the concerns then it could be entirely removed post-Merge. It could be a statement in the spec that `optimistic_roots` may not exist post-Merge with explanation of the corresponding implications. Though, I would not add this statement right now to avoid confusion and incorrect implementations pre-Merge.",
        "created_at": "2022-03-21T14:59:01.822000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ah this is not what we discussed yesterday. it is unsafe to serve these side-blocks as NOT optimistic in the API becuase you don't know. so the way this miht be abl to work is that you serve non-canonical blocks AS optimistic because you do't have a flag for them one way or another\n\nor I guess, by not tracking optimistic roots, you are conceding that all non-canonical branches are optimistic and would thus serve thm in the API as such",
        "created_at": "2022-03-21T18:07:23.209000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yes, the API situation would be to return all non canonical blocks as optimistic. It can be a bit better without adding complexity: you know that any canonical block that was at any point in your canonical chain is VALID, so you can track this without any complexity added since you just mark them valid and there is no need to update nor prune nor anything. That leaves only non-canonical blocks that were never part of the canonical chain",
        "created_at": "2022-03-21T18:28:28.615000+00:00",
        "attachments": null
    }
]