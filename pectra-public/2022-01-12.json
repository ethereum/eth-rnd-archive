[
    {
        "author": "johnydony",
        "category": "general",
        "parent": "",
        "content": "Kintsugi testnet is working on stable? \nI think still lots of forks in there.",
        "created_at": "2022-01-12T03:04:36.771000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Just restarted my teku-geth node and this is what teku does on startup. It passes us 15 conflicting heads. We will try to sync all of them and regenerate the state for them. This will horrible break on mainnet where syncing to even one of these heads might take multiple minutes to hours.",
        "created_at": "2022-01-12T09:47:50.853000+00:00",
        "attachments": [
            {
                "type": "text/plain; charset=utf-8",
                "origin_name": "message.txt",
                "content": "b67dee09f51fdf349777bd0e42d851f5b666c7fad219c7ed2107b8918b01e3c7"
            }
        ]
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Note that syncing process on EL side should be fork-specific, i.e. if the canonical chain is in sync and syncing process is happening on even multiple other forks a node should still be fully functioning. Not sure this note is directly related to you recent message, just want to mention it here just in case",
        "created_at": "2022-01-12T09:50:52.618000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "executePayload is not an indication of the chain head - it‚Äôs the blocks we need to validate. forkChoiceUpdated is what tells us the head. \nThe CL *must* call executePayload on every post-merge block it imports as it‚Äôs the only way to validate the block hash.",
        "created_at": "2022-01-12T09:58:22.873000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "In more normal situations we likely only have one chain head but currently on kintsugi there are a ton of forks are we need to try to follow them all.",
        "created_at": "2022-01-12T09:59:24.653000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "It would be reasonable for the EL to decide to only sync one of those chains at a time btw (probably best to pick the one forkChoiceUpdated is indicating). The others could check the block hash and return SYNCING and the CL will have to retry it later (or a descendant if there are any).",
        "created_at": "2022-01-12T10:33:03.088000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "At some point though all those chains likely need to be imported unless finalisation invalidates them first.",
        "created_at": "2022-01-12T10:33:38.368000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Yeah we need to change how we pick which chain to sync",
        "created_at": "2022-01-12T11:39:04.348000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Something in the middle between syncing with everything and with only one chain is to decide to sync with the chain once it's signified by fcU, and still support multiple chain to sync with concurrently",
        "created_at": "2022-01-12T11:41:53.249000+00:00",
        "attachments": null
    },
    {
        "author": "yperbasis",
        "category": "general",
        "parent": "",
        "content": "Erigon doesn't support multiple chains concurrently. At one point in time there can be only a single current state. A re-org is implemented by reverting state changes from the loser blocks and executing the winner blocks.",
        "created_at": "2022-01-12T11:57:15.707000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "It does mean that when the head is changed the sync process gets its new target and stops syncing with any other chain, right?",
        "created_at": "2022-01-12T12:08:48.859000+00:00",
        "attachments": null
    },
    {
        "author": "yperbasis",
        "category": "general",
        "parent": "",
        "content": "The head being ForkchoiceState.headBlockHash, right? We haven't implemented it yet, but that's the idea, yes. To only sync what engine_forkchoiceUpdated tells us and don't sync any other chains.",
        "created_at": "2022-01-12T12:11:07.366000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I see, any of these strategies are viable and the final choice is after implementers. Probably, it's really complicated to support multiple syncing processes at a time and doing so doesn't benefit that much. The process of syncing with only a single chain that changes over time should eventually converge despite of the number and frequency of the switching",
        "created_at": "2022-01-12T12:15:31.811000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "I'm going to start wiping some kintsugi nodes and try to get them all on the same fork. I think we've addressed/have ideas for most of the bugs we encountered. I've stored the databases of quite a few nodes and taken some snapshots, Additionally some protoarrays of random lighthouse nodes. \n\nIncase someone would prefer the testnet be in its current state for longer to debug any error, lemme know ASAP.",
        "created_at": "2022-01-12T14:46:15.609000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I came here to say what everyone else said üòÖ \nThis highlights the dangers of just using executePayload as a signal if there is deep work to do. fcu ftw",
        "created_at": "2022-01-12T15:11:27.558000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "Is there some aggregated list of what CL clients changed/need to change?",
        "created_at": "2022-01-12T15:39:07.188000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "This sounds like it‚Äôs going to be a problem to me. There are multiple chains because forks happen and you need to be able to process blocks on all forks in order to a) validate them and b) process attestations for them which lets you decide which fork is canonical. \nMost forks are only one or two blocks long so Erigon could probably reorg, process the block and reorg back (as long as the json rpc requests in the mean time are delayed so they don‚Äôt report from the wrong fork), but during non finality forks can be hundreds of blocks long or more and we still need to be able to process blocks from both sides. Otherwise any network split becomes irreversible.",
        "created_at": "2022-01-12T20:39:31.113000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e You *must* be able to use heuristics to decide if something is worth processing (akin to if a block had some silly low pow). Otherwise, pos gives pretty abritrary dos vectors by proposers being able to build at abritrary depths inducing very old state lookups/recalculations\nMy claim was about which branches an EL node should sync but it is also a consideration on which branches to even execute (due to the potentially very expensive state diffs)  \nThe optimal is to be able to calculate all but that is not what likely can happen in practice\nIn teku, if non-finality and you get a block  from current epoch that builds off a block from 24 hour ago *and* zero attestations are known for the block, do you just get the very old state and execute? Or do you have some stronger signal to execute (e.g. some minimal fork choice weight)",
        "created_at": "2022-01-12T22:16:11.953000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "Which generator was used to prepare genesis state file? (ssz). It was `eth2-testnet-genesis`(protolambda) and `phase0` subcommand?",
        "created_at": "2022-01-12T22:17:38.447000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I think we may have some limit to how many empty blocks we'll process but I'm not sure.  How would a block you haven't imported have any fork choice weight - you can't process attestations until the block is processed?",
        "created_at": "2022-01-12T22:25:37.236000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Yeah was going to say that the meer existence of attestations is not enough because you need the shuffling. Still though, I suspect each client manages heuristics here. E.g. if I see \u003e50% weight on branch A, then random head from lower depth on branch B is def not the head",
        "created_at": "2022-01-12T22:34:14.239000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e A question for geth and el maintainers \nDo you run the forkchoice and only then execute a new block if it would win the fork choice?\nRather than execute the block then decide if it wins",
        "created_at": "2022-01-12T22:34:56.665000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e I presume the former now that I think about it",
        "created_at": "2022-01-12T22:35:06.718000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e And if that is the case, CL nodes need to have their message calls designed a bit differently if we accomodate for that assumption \nThat is, run beacon chain execution on a branch but only fill in EL execution of that branch if that branch is slated to become the head (assume EL processing ends up VALID)",
        "created_at": "2022-01-12T22:36:22.429000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e [Not saying this is the way it must be done but it seems more harmonious with todays EL design constraints due to the very large state being managed (or unable to)  across forks]",
        "created_at": "2022-01-12T22:37:16.126000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Doesn't that give us block hash problems again because we're not calling executePayload before importing a block?",
        "created_at": "2022-01-12T22:38:17.561000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e I dont think so\nThis is the design I meant:\nIm saying if CL sees branch A as head, it executes EL in lockstep, building on it just fine\nIf simultaneously its managing branch B but not head, it would not call any executePayload\nOnly if B is slated to become head would it then go back to B's last EL execution depth and execute sequentially from there. If that chain is all VALID, then it sets the head on cl and el",
        "created_at": "2022-01-12T22:41:09.461000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "But how are we managing B if it's not in the store or protoarray?  Or are we expanding optimistic sync to cover every non-canonical fork and then we have to walk back through every block on that fork that's optimistic and call `executePayload` when switching it to canonical (which potentially makes reorg's very expensive)?",
        "created_at": "2022-01-12T22:46:26.139000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e In what I am suggesting, I suppose its optimistic but without triggering sync in EL in the normal case because you can walk up the executions on the reory\nReorgs on EL are very expensive. Thats what we have to manage appropriately.\nOtherwise EL must maintain many state tips, which is also presumably expensive but in other ways. Expensive on what is a legitimate reorg signal (enough weight or enough pow in header verification) is at least bound in most cases. Expensive on maintaining and executing N arbitrary tips due to cheap block proposal seems untenable wrt EL state from what I gather",
        "created_at": "2022-01-12T22:49:42.101000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Then I suspect we have a problem because importing blocks on the CL side without calling executePayload adds a ton of technical complexity and risk. And then a reorg becomes a hugely expensive event as we have to load and execute every block.",
        "created_at": "2022-01-12T22:52:16.222000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I mean I can see the challenge from the EL side if you're using a single-state type approach but it's heading us back towards the original optimistic sync which was way more complex to implement and wound up requiring special handling in a huge range of places in the CL.",
        "created_at": "2022-01-12T22:54:03.201000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e The expense of a  reorg is bound by the expense of whichever side is more costly. I assume this is EL and that such a reorg in EL would require reexecution in any case",
        "created_at": "2022-01-12T22:54:21.440000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "It shouldn't need re-execution, just application of state diffs which should be significantly cheaper (no EVM execution)",
        "created_at": "2022-01-12T22:54:56.436000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e So this attempts to not have every fork block execute a reorg on EL",
        "created_at": "2022-01-12T22:55:05.257000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e 1. Do state diffs exist to be used in this way\n2. It is still expensive if you are sending head signals repeatedly from two very different branches (re @merge_chat_bot: \u003cAdrian Sutton\u003e It shouldn't need re-execution, just application of state diffs which should be significantly cheaper (no EVM execution))",
        "created_at": "2022-01-12T22:55:49.730000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e I need better information about the state of EL, multi-branch execution, reorgs, and statediffs to speak any more intelligently about the problem",
        "created_at": "2022-01-12T22:56:47.530000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "1. Possibly depends on clients, but my understanding of bonsai trees in besu is that's the way it works.  They aren't free to apply but cheaper.\n2. Yes agreed, I can see the problem - just that we have two quite different models between the EL and CL and it looks like it will take quite significant work to align them.",
        "created_at": "2022-01-12T22:58:20.297000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "For the record, I'm not so much arguing that CL's shouldn't change to resolve this issue - just pointing out this doesn't seem to be a simple tweak to optimistic sync, it sounds like a pretty major rearchitecting (or an awful lot of work arounds scattered through the code base).",
        "created_at": "2022-01-12T23:00:43.851000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Yeah, I see that. I dont want to induce a deep change but this discontinuity in assumption here has to be explored. Heh",
        "created_at": "2022-01-12T23:04:28.743000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e CL call tmw!",
        "created_at": "2022-01-12T23:04:39.605000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I'm not against making a deep change if it gets us into a better place - in fact I'd rather that to trying to patch over problems too much. But we have to be prepared to say we're going to make a big change and push back timelines (which is why I'm keen to not commit to any timelines yet).",
        "created_at": "2022-01-12T23:28:11.590000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "What if an EL maintained a map of `block_hash -\u003e execution_payload`. Each executePayload call would push into that map. The map can be pruned based on finality in fcUpdated messages.\n\nThen, the EL can choose to sync based on fcUpdated messages rather than executePayload. The EL will have the full un-finalized tree of payloads, should it get a fcUpdated message that swaps it to another fork. No need for the CL to re-issue payloads.\n\nIt means the EL needs to keep the full set of unfinalized payloads around (ram/disk), but that seems like a fairly reasonable requirement to me.",
        "created_at": "2022-01-12T23:41:44.403000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e right, I was just pondering that ‚Äî can the tracking work go on the other side\nthat said, yuo still have potentially another return from executePayload which is ‚Äúwellformed request (blockhash, etc) but I don‚Äôt assess this as being worth my time to execute‚Äù \u003c- which can be overridden with a fcu call",
        "created_at": "2022-01-12T23:45:38.976000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "In that case `executePayload` would check the block hash, store the block in this map then return `SYNCING`  right? That seems reasonable, though ideally if `executePayload` is building on the current head then it would actually execute and return `VALID` but I suspect the CL could handle always getting `SYNCING` and wait until `forkChoiceUpdated` returns before deciding if it's going into optimistic head mode or not.",
        "created_at": "2022-01-12T23:47:16.089000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e but SYNCING isn‚Äôt quite the same thing, right?\nSYNCING -\u003e I don‚Äôt have the info to respond to this request but I‚Äôm trying to figure it out\nTHISOTHERRESPONSE -\u003e I have the info to respond to this request but I don‚Äôt want to execute it because you haven‚Äôt signalld it‚Äôs valuable enough to run\nMaybe SYNCING is sufficient for both?\nBut knowing THISOTHRRESPONSE makes it so that I know if I switch my fc over there it will be resolved",
        "created_at": "2022-01-12T23:48:55.135000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I think `SYNCING` winds up with the same result on the CL side but I'm not against a more explicit message.  Regardless of why the EL didn't execute the CL still has to treat it as an optimistic block because it can't tell if the payload is fully valid or not.",
        "created_at": "2022-01-12T23:49:52.301000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Would the CL do anything differently around fork choice based on whether the EL returned syncing or other response?",
        "created_at": "2022-01-12T23:50:26.659000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e ah but this is the difference. I think it‚Äôs in the FC or wait this is a race condition. I want to be able to signal to EL to actually execute a chain because I *think* it will become my new fc head",
        "created_at": "2022-01-12T23:51:33.077000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e so fcu would essentially trigger the EL re-org and then you want to know if VALID. so you could fcu(head), then executePayload(head) \u003c‚Äî if VALID great, CL head to this head. If INVALID, tell EL prev head and invalidate the CL branch\n^ or something.",
        "created_at": "2022-01-12T23:52:57.685000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "i would expect the EL to always execute a payload if it's a descendant of the head",
        "created_at": "2022-01-12T23:54:40.178000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e sorry, I mean fcu(new_head)",
        "created_at": "2022-01-12T23:55:22.534000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e if branch B is in the state of unknown execution, but CL tihnks B should become the head, then CL needs to actually signal to EL that such a branch should be executed",
        "created_at": "2022-01-12T23:55:52.557000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "\u003e but CL tihnks B should become the head\nWouldn't the CL send an fcu when it learns that B is the head?",
        "created_at": "2022-01-12T23:56:37.473000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e in your example/solution, was branch B known by EL but not yet executed?",
        "created_at": "2022-01-12T23:57:43.544000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "yep",
        "created_at": "2022-01-12T23:57:59.749000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e okay, so CL has validated beacon chain of B but doesn‚Äôt actually know if EL of B is valid",
        "created_at": "2022-01-12T23:58:20.998000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e and fc on CL is saying ‚Äî looksl ike B is head",
        "created_at": "2022-01-12T23:58:34.357000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e but B is only head if EL is valid",
        "created_at": "2022-01-12T23:58:40.445000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e so sure, it should send fcu to EL to trigger execution of that branch",
        "created_at": "2022-01-12T23:58:57.227000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e but then it still doesn‚Äôt know if the result was VALID or INVALID",
        "created_at": "2022-01-12T23:59:04.339000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e (given current call/response on those methods)",
        "created_at": "2022-01-12T23:59:19.468000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "So B would be the CL's optimistic head (because it's not fully validated by EL) and fcu is sent based on the optimistic head.  Once fcu comes back VALID, the CL would actually set it as CL validated head.",
        "created_at": "2022-01-12T23:59:34.318000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e only if it reexecuted EL head or put a block on top would it then find out if VALID or INVALID",
        "created_at": "2022-01-12T23:59:35.642000+00:00",
        "attachments": null
    }
]