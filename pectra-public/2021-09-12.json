[
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "right, there is discussion here: https://github.com/ethereum/consensus-specs/pull/2197",
        "created_at": "2021-09-12T00:09:20.528000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "comments towards the end highlight an issue w/ enshrining an empty slot in the event that the block just takes a while to process (bc of all the sweet MEV in it)",
        "created_at": "2021-09-12T00:10:20.223000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I think currently any block after 8 seconds can be safely ignored",
        "created_at": "2021-09-12T01:49:21.723000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Currently any block that reaches the next proposer before they create their block will replace the empty slot as the chain head. Because fork choice only deals with blocks any valid block you receive that is the child of your current head is automatically the new head. It doesnâ€™t need to have any attestations. \n And if as the next block proposer you ignore a late block and it has any attestations at all it will be what goes on the canonical chain and yours will be orphaned. If it has absolutely none itâ€™s a 50/50 chance which will be orphaned (the tie is broken by the block hash).",
        "created_at": "2021-09-12T02:01:30.648000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I understand this but the point is that the soft fork that clients can ignore blocks after 2/3 of a slot (instead of 1/3) can safely avoid the previous counterpoint",
        "created_at": "2021-09-12T02:04:12.511000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Iâ€™m not sure I follow but I think weâ€™re getting way off topic for this channel. The key message for here is that we want to design around blocks being produced as soon as possible after the slot starts because thatâ€™s the honest behaviour we want. Weâ€™ll have to work on incentivisation fixes separately to punish block producers who do delay their block creation. While we donâ€™t currently have a plan for how to do that I think there is strong agreement we need to fix it so attesters donâ€™t keep being penalised unfairly.",
        "created_at": "2021-09-12T03:03:03.085000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If I understand the problem you are describing correctly, I would rate this as a pretty significant problem that needs to be fixed before The Merge.",
        "created_at": "2021-09-12T03:08:16.947000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I didn't realize that late proposers weren't being punished, and given there is financial incentive to propose as late as possible it feels like if we don't fix it we'll see people producing blocks late all the time.",
        "created_at": "2021-09-12T03:09:05.669000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "There was no strong disagreement on my side. Originally I was just looking for the right way to handle `getPayload` if there was no prior call to `preparePayload`.\n\nWith questions that have been raised and opinions that have been shared during the call and in discord, I am leaning towards the following design for these two messages:",
        "created_at": "2021-09-12T05:39:34.539000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "- The mechanincs of `getPayload` should be similar to `getWork` that returns immediately, actually, `getPayload` is the successor of the `getWork`.\n- There are two reasons for `preparePayload` to exist:\n    - Execution client doesn't have all inputs that are required to produce a payload e.g. `random`\n    - Updating the payload constantly is suboptimal and doesn't make any sense without knowing the inputs\n- Calling to `getPayload` w/o prior `preparePayload` call with the corresponding parameter set must be treated as consensus client failure and responded with error code\n- Upon receiving `preparePayload` an execution client must first create an empty payload and then start to update it with transactions from the mempool and do its best on bringing as many transactions as it could before the corresponding `getPayload` call\n- If `getPayload` is called *before* any payload has been prepared then the response must wait for the first payload (in this case an empty payload would be the one that is returned)\n- The process initiated by the `preparePayload` call should be cancelled after `timestamp + 1 Slot` is reached; thus, `getPayload` may or may not stop the process, it should be up to implementation but there is a guarantee that `getPayload` will be called only once given the parameter set\n- We should rather use an identifier to match `getPayload` call onto corresponding `preparePayload` call as once we start passing beacon block roots it will be subomptimal to pass this long parameter set twice. I don't know if it makes sense to re-use JSON-RPC request-id for this purpose, it might not work as expected depending on the implementation. So, respective parameter digest or just an id could be added to these two calls. Thanks \u003c@!539495253418180618\u003e for raising this",
        "created_at": "2021-09-12T05:39:42.044000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "If I haven't missed anything this directions should be enough to have a strict and responsive protocol from the consensus side perspective and should give some freedom for execution client implementations. Please, point out to the edge cases that are not covered by the above.\n\ncc \u003c@!144468805697929216\u003e \u003c@!291925846556540928\u003e \u003c@!340345049063882753\u003e \u003c@456226577798135808\u003e",
        "created_at": "2021-09-12T05:39:46.023000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "You don't want to use the JSON-RPC ID for this since it spans multiple JSON-RPC requsets.",
        "created_at": "2021-09-12T05:41:43.684000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "In my perspective proposer assigned to SlotN will do the following:\n\n- Send `preparePayload` upon SlotN-1 tick\n- Send `preparePayload` upon any head change that occurs during SlotN-1\n- Send `getPayload` upon SlotN tick and propose a block with the payload from the response",
        "created_at": "2021-09-12T05:42:23.154000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Given that most slots have a block I suspect it makes sense to wait 4 seconds (or when the block is received) until attestations are due before calling prepare block the first time. But that really comes down to an implementation detail so need to see whether block production actually benefits from that extra 4s in the case of an empty slot or not.",
        "created_at": "2021-09-12T07:13:24.800000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425572898787426305\u003e my thoughts:\n  - requiring a call to `preparePayload` prior to one for  `getPayload` seems like it hurts in the exact place that the protocol is weakest, _i.e._ for slot 0 of the epoch.  That said, I understand and agree with the rationale behind it for every other slot.  Sounds like we need to spend a bit more time understanding the probability of the validator set changing between epochs to see if we can reliably prepare on on the 31st slot of the epoch\n  - somewhat related to the prior point, should we bother with a cancel operation in case the validator set does change and a prior prepare is invalid, or are you happy that the timeout will fix this is soon enough?  Although the existing mechanism does raise a question: does the execution client have the concept of a consensus slot, and more specifically of `SECONDS_PER_SLOT`, so that it knows when to cancel or should `preparePayload` have a deadline parameter?\n  - regarding an identifier: can we not just use the execution block timestamp, or the consensus slot?  There should not be competing blocks for a single slot, so any second call to `preparePayload` with a change of data but the same timestamp should result in the existing preparation with the same timestamp being cancelled and replaced.",
        "created_at": "2021-09-12T08:41:39.032000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "\u003e Sounds like we need to spend a bit more time understanding the probability of the validator set changing between epochs to see if we can reliably prepare on on the 31st slot of the epoch\n\nQuite some time back (pre-mainnet) Teku had this bug and it did hurt us. Mostly during periods of non-finalization where effective balances can really vary but once you start getting validators below 32ETH it is noticeable.  I can't give specific numbers on that as it was quite a while back, but we noticed. ðŸ™‚",
        "created_at": "2021-09-12T08:51:48.242000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "However, you could call prepare as soon as the block in the previous slot is received, and should call it as soon as 4 seconds has passed, assuming the slot is empty.  So that gives you 8 seconds warning.  The only downside with that is that you'd be doing the epoch transition to check if you are the proposer at the same time as you are publishing attestations (and then receiving an onslaught of them from the network to verify).\n\nSo there is a huge benefit here if we can establish that the execution engine only needs say 2 seconds notice. It would worry me a little if it couldn't sort through the transactions in its mempool in that timeframe but I'm not sure if MEV requires executing every transaction in multiple orders to find the best or something like that.",
        "created_at": "2021-09-12T08:56:34.460000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "If the execution engine needs absolutely as much time as possible, constantly keeping a suitable block up to date is probably the best strategy.",
        "created_at": "2021-09-12T08:57:39.921000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It is up to block builders to build the best block possible in whatever time they have.  2 seconds is plenty IMO.  It does help them to be sure they know how much time they have, so they can adjust strategies based on that.",
        "created_at": "2021-09-12T09:00:40.819000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I don't see difference of calling to `preparePayload + getPayload` vs `getPayload` if message ordering is preserved, even in the case of the first slot of the epoch.\n\nGood question on the `SECONDS_PER_SLOT`, another trigger for cancellation could be `executePayload` with the timestamp greater or equal to the `preparePayload` timestamp. \n\nGood idea on using the timestamp as identifier, the other option is to have an `id: uint64` and allow consensus client to use whatever is suitable for it.",
        "created_at": "2021-09-12T11:14:21.312000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Btw, `timestamp` in the `preparePayload` call gives an estimation of when `getPayload` is gonna be called",
        "created_at": "2021-09-12T11:15:31.580000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Sort of, but that doesn't take into consideration things like latency between consensus client and execution client.",
        "created_at": "2021-09-12T11:28:55.104000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "At the least, the consensus client should be configured with that latency (as expected by the operator) so it can send the getPayload enough in advance.",
        "created_at": "2021-09-12T11:29:34.391000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I would rather only have to configure that on the consensus client, not *also* configure it on the execution client which is why I like the idea of including an `estimatedTimeUntilGetPayload` parameter on the `preparePayload`.",
        "created_at": "2021-09-12T11:30:19.005000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "What advantage does this estimation bring to the building process disregarding whether it's a `timestamp` or an explicit parameter?",
        "created_at": "2021-09-12T11:32:11.056000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "An execution client may have different strategies for block production, some of which take longer than others.",
        "created_at": "2021-09-12T11:36:02.640000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If the execution client knows that it has about 750ms before the `getPayload`, it may engage in a different block building strategy then if it knows it only has 250ms.",
        "created_at": "2021-09-12T11:36:33.408000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The more precise information we can give the execution client, the better it can be at choosing an appropriate strategy.",
        "created_at": "2021-09-12T11:36:54.152000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "You mean it may include less transactions into the first payload if it has less time?",
        "created_at": "2021-09-12T11:42:44.731000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Or update a payload per each new transaction included vs updating it with a batch of transactions?",
        "created_at": "2021-09-12T11:43:12.705000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Or it may focus on building a local block instead of fetching a remote block.",
        "created_at": "2021-09-12T11:44:06.482000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Or any other strategy we may not have thought of yet.",
        "created_at": "2021-09-12T11:44:13.430000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "wouldn't the `timestamp` give enough estimation to make a decision about which strategy to use? It is very unlikely for consensus client to call `getPayload` *before* the `timestamp`.",
        "created_at": "2021-09-12T11:50:28.889000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The consensus client *should* call getPayload before the timestamp if it expects to have it by the timestamp.",
        "created_at": "2021-09-12T11:56:02.394000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Imagine the execution client is 100ms away from the consensus client.  This means 200ms round trip.  If the consensus client wants to publish a block at timestamp 123456 seconds since unix epoch, then it needs to call `getPayload` at 123455.8.",
        "created_at": "2021-09-12T11:56:57.508000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The consensus client needs to know what that latency is, and this can be a human configuration option or it can discover it via a heartbeat or something.  It is wasteful to have the execution client *also* have that information, especially since it can change.",
        "created_at": "2021-09-12T11:58:02.316000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think it is better to just have the consensus client tell the execution client how long it should expect before the getPayload.",
        "created_at": "2021-09-12T11:58:19.836000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I see what you mean but not sure that this fine tuning matter for choosing the strategy. My gut is that if you have seconds in advance then the strategy doesn't matter much, if you have less than a second than there is another strategy. But if the delay is 1 second then it probably starts matter ðŸ¤”",
        "created_at": "2021-09-12T12:11:53.452000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "250ms round trip can change between above 1 second and below 1 second.",
        "created_at": "2021-09-12T12:28:37.570000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I am also wondering how good operators are in estimating the roundtrip duration. And if we want consensus client to do this manually we'd need a ping request to measure the pure roundtrip. In other words, how helpful this parameter could be?",
        "created_at": "2021-09-12T13:09:44.877000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Are we basing this requirement for tuning round trip time on actual implementations or on theoretical ideas? Because this is getting extremely complex for developers and users to manage so Iâ€™m pretty against it unless we can show thereâ€™s a real benefit. \n\nIn my mind if you care about timing enough to configure the round trip time you should be running the execution engine locally and make the round trip time irrelevant.",
        "created_at": "2021-09-12T20:29:02.076000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e +1 \nConsensus can have a default time it triggers calls before having to release a block and potentially allow for a config override\nWe should strive for simplicity in the canonical api",
        "created_at": "2021-09-12T22:47:55.012000+00:00",
        "attachments": null
    }
]