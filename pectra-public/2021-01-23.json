[
    {
        "author": "jgm",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I've been thinking about a minimal merge _i.e._ a way to move from PoW to PoS for the Ethereum 1 chain.  I'd be interested if anyone had a view on the following:\n\n- at  block height _n_ on Ethereum 1:\n  - change ETH1 block structure to hold a BLS signature instead of mix hash/difficulty/nonce\n  - change block signature verification to verify signature against the Ethereum 2 proposer for the slot of the block's timestamp\n\nMeanwhile, on Ethereum 2:\n  - new operation made for an Ethereum 2 validator to set their coinbase, new field in the Validator struct to hold this address\n  - block proposers additionally request an unsigned block from their ETH1 node, sign it and return it to the ETH1 node for broadcast\n\nIn short: the validator client obtains and signs an ETH1 block in exactly the same way the validator client signs and ETH2 beacon block.\n\nThis seems to be a minimally invasive and relatively simple change, and gives us the benefits of PoS consensus whilst working on an actual merge.  Of course, it being so simple I'm wondering what I missed.  Are there ETH1 opcodes that would be broken by this change, for example?\n\n(Note that I have variations on the theme, but wanted to start with what I think is the simplest version with the smallest footprint for critique).",
        "created_at": "2021-01-23T10:12:25.853000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Iâ€™m assuming youâ€™re familiar with Mikhailâ€™s work: https://ethresear.ch/t/executable-beacon-chain/8271 Itâ€™s not far off what you suggest. \n\nThe BLOCKHASH opcode is a current problem. It is used both as a source of randomness (not a good one but better than an eth2 hash provides) and also for some light client stuff which depends on it actually being an eth1 hash (I think).",
        "created_at": "2021-01-23T10:25:37.267000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, that seems to be a much larger merge rather than a simpler change of consensus.  It talks about transaction processing on the ETH2 chain, for example, which wouldn't be part of this proposal.",
        "created_at": "2021-01-23T10:28:01.788000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "(As a complete aside, can I just say that sites which remap CTRL-F to their own purposes are pure evil)",
        "created_at": "2021-01-23T10:29:01.017000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm also a little unsure as to why `BLOCKHASH` has to change.  My proposal leaves it alone in its current form and derivation.",
        "created_at": "2021-01-23T10:30:30.457000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm not opposed to breaking blockhash randomness.  The security community has been telling people not to use it for a while, and so as long as we tell them ASAP that it is breaking, I think we can break it.",
        "created_at": "2021-01-23T10:41:52.592000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Although I agree it's a poor source of randmoness, does this proposal significantly change the properties of `BLOCKHASH`?  I'd guess the concern is somewhere around the hash being more open to manipulation given the much faster nature of creating the block, but does that have any practical consequences where `BLOCKHASH` is picked from the past 256 blocks?",
        "created_at": "2021-01-23T10:47:23.812000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I would assume that the new blockhash is trivially manipulable by the block proposer?",
        "created_at": "2021-01-23T11:14:06.896000+00:00",
        "attachments": null
    },
    {
        "author": "raphael1234",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "They are pure evil, luckily double pressing ctrl-f opens the browsers search box (just for reference, took me a long time to figure that out myself  ðŸ˜† )",
        "created_at": "2021-01-23T11:15:56.725000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Not entirely trivial to find a desired hash, but given the access to arbitrary `extradata` plus seeding it with a proposer-selectable set of transactions makes it trivial to avoid an undesirable value.",
        "created_at": "2021-01-23T11:21:17.530000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I mean you can alter the hash pretty freely, basically as fast as you can execute the hashing algorithm.",
        "created_at": "2021-01-23T11:22:08.802000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "When you have a game that has 49% chance of winning, it only takes a few different blockhash attempts to find a win.",
        "created_at": "2021-01-23T11:22:59.239000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Iâ€™ll have to think about this properly in the morning but I think it falls apart because the eth1 chain canâ€™t reliably know which validator should be the proposer. It can ask the eth2 node (which means youâ€™d need bidirectional communication) but the eth2 node may still be missing some blocks or on a different fork. You need some way to tie the eth1 block to a specific eth2 block. Maybe you can add the eth2 block hash to the eth1 block and make it work? Going to make for some interesting interactions between the two nodes in terms of timing at minimum.",
        "created_at": "2021-01-23T11:47:04.559000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!144468805697929216\u003e So thinking about this some more you should be able to put the root of the signed eth1 block into the eth2 block which would make a lot more sense.  Eth1 node can send the signature and block root to eth2 node to get it to verify the signature.\nBut the timing and availability issues make this quite complex. You have to handle the case where the eth1 node has the block before the eth2 node and the other way around.  Plus it feels kind of awkward to potentially have the eth2 block but have then lost the eth1 block. You've basically split the block in half and are sending it over two separate p2p networks.\nGiven you have to modify both the eth1 and eth2 blocks and add operations to set coinbase for validators, I suspect it actually winds up being simpler to just put the eth1 block content into the eth2 block.  Then I think you pretty much wind up at Mikhail's solution or at least very close to it.",
        "created_at": "2021-01-23T22:09:23.914000+00:00",
        "attachments": null
    }
]