[
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Gwei is actually an indivisible fraction of ETH on the beacon chain hence the API representation. The issue is that it's inconsistent with EL -- this was done on purpose and saves a lot of complexity by avoiding big int arithmetics in the spec and implementations as it's mentioned above. One may argue that it wasn't a good decision but I'd say there is a trade off and historically there were different plans on how two chains will communicate together. I don't think we should change beacon API; API clients will have to take the discrepancy between the layers into account.",
        "created_at": "2022-02-08T09:39:03.797000+00:00",
        "attachments": null
    },
    {
        "author": "killari.",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "oh wow, I didn't know the beacon chain doesn't deal with weis but in different units.",
        "created_at": "2022-02-08T11:02:22.420000+00:00",
        "attachments": null
    },
    {
        "author": "killari.",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think that will result in quite many bugs as people assume things from the API",
        "created_at": "2022-02-08T11:04:28.298000+00:00",
        "attachments": null
    },
    {
        "author": "3xmd1559sporebraytondingo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "how much of the tradeoff was the added development complexity vs the performance hit (slight increase in hardware requirements; higher precision requiring greater power usage and active device memory).\n\nWould it've affected state size at all if it's just extra 0s?",
        "created_at": "2022-02-08T12:26:10.611000+00:00",
        "attachments": null
    },
    {
        "author": "3xmd1559sporebraytondingo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'd naively imagine it was almost entirely development complexity though would be interested to know if performance and device efficiency was considered in avoiding U256.",
        "created_at": "2022-02-08T12:27:16.960000+00:00",
        "attachments": null
    },
    {
        "author": "pietjepuk",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I certainly hope that anyone using any API does at least some kind of sanity check on whatever they're using it for. If you don't realize you're off by 9 orders of magnitude, I don't know what to say...",
        "created_at": "2022-02-08T12:28:55.025000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I can't recall the exact decision making process. But I believe that all these arguments were taken into account",
        "created_at": "2022-02-08T12:51:13.446000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "At least for Nimbus, this would have, yeah, been the only uint256 arithmetic (BLS is handled by BLST as a black box, as with I think most CLs) required. I find it worth the unit difference. More broadly, it's consistent with the EF's stated goals of client diversity not to add essentially cosmetic requirements which bring in relatively heavy dependencies.",
        "created_at": "2022-02-08T13:02:11.807000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Heads up!\n\n* Engine Auth is merged -- https://github.com/ethereum/execution-apis/pull/167\n* `engine_exchangeTransitionConfigurationV1` is merged -- https://github.com/ethereum/execution-apis/pull/172\n\nthese are generally additive to Kiln v1. They'll be released in a \"Kiln v2\" very soon",
        "created_at": "2022-02-08T18:21:22.788000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So this *should not* be conflated with `INVALID` imo. This looks more like an error case. CL has sent an erroneous/malformed request to EL. Maybe it's worth defining clearly the an error code for such malformed requests\n\nI do believe `INVALID` is inappropriate and might lead to CL making strange decisions\n\ncc: \u003c@!425572898787426305\u003e",
        "created_at": "2022-02-08T18:25:11.770000+00:00",
        "attachments": null
    },
    {
        "author": "ethdreamer",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I've been working on updating lighthouse to v1.0.0-alpha.6 of the execution API spec. But I noticed the specification for the response from `engine_forkchoiceUpdatedV1`\nhttps://github.com/ethereum/execution-apis/blob/v1.0.0-alpha.6/src/engine/specification.md#specification-1\nsays `response.payloadStatus.latestValidHash` is ONLY populated when `response.payloadStatus.status == VALID`.\n\nIf this is the case, we have no information that we can use to rewind our forkchoice if the `headBlockHash` we sent was `INVALID`",
        "created_at": "2022-02-08T22:34:07.758000+00:00",
        "attachments": null
    }
]