[
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "It's interesting (but seemingly uneventful) that the same `ExecutionPayload` may appear in multiple beacon blocks, but only if those blocks are slashable.",
        "created_at": "2022-02-10T05:47:04.963000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Right, randao mix makes two blocks proposed by the same validator in one slot the only probable case for many-to-one relation between execution payload and beacon block. Curious how current implementations handle the case with two blocks in the same slot? Is there any specific handling there? In particular, which one of the two will be returned if requested by slot number?",
        "created_at": "2022-02-10T06:04:05.708000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "\u003e In particular, which one of the two will be returned if requested by slot number?\nWe will return whichever is an ancestor of (or equal to) the head.\n\nIt's been a while since I've considered 2 blocks 1 slot. We'll reject it via gossip and on the API due to some gossip validation conditions. So, it's unlikely to actually happen, but we generally support it. We do it in some tests IIRC.",
        "created_at": "2022-02-10T06:14:21.017000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Yeah itâ€™s basically just another fork since everything is based on block hash and parent hash.",
        "created_at": "2022-02-10T06:14:58.643000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "I'm going to adopt the same approach as Teku, where we only invalidate the hash chain if we know the latest valid hash (and it's the finalized block or a descendant). We'll log a critical error if we're unable to find the latest valid hash.\n\nI like this approach, it avoids killing the entire client and it also does a good-enough job at invalidating the things it needs to.",
        "created_at": "2022-02-10T06:29:45.006000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "We also don't delete nodes. I don't expect there to be many invalid blocks, so the space-saving doesn't seem so valuable.\n\nWe maintain one of these enums on each node and just flip it when invalidating blocks:\n\nhttps://github.com/sigp/lighthouse/blob/0177b9286edfdeb2782f74fc7fb1392b6459bfaa/consensus/proto_array/src/proto_array_fork_choice.rs#L19-L37",
        "created_at": "2022-02-10T06:31:26.987000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "One problem we have is that we have independent codepaths to prune the DB than forkchoice pruning, if we just mark a node as invalid in forkchoice and put it's weight to zero, then finalization will prune these nodes eventually. But this does not happen with our block DB that will keep these blocks forever.  I also don't expect many of these blocks so it shouldn't be much of a trouble. Unless there's a bug in one of the execution clients, in which case every validator running on this client will produce such an invalid block.",
        "created_at": "2022-02-10T12:02:57.377000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "Hi all, `mergemock` has been updated to support Kiln: https://github.com/protolambda/mergemock",
        "created_at": "2022-02-10T13:57:03.418000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "I've put together some milestones for Kiln, like we had for prior merge testnets: https://notes.ethereum.org/@timbeiko/kiln-milestones",
        "created_at": "2022-02-10T13:59:28.668000+00:00",
        "attachments": null
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "fyi  ðŸ™‚  geth kiln builds no longer accept(need) --catalyst arg (https://notes.ethereum.org/rmVErCfCRPKGqGkUe89-Kg?view) so the doc can be updated",
        "created_at": "2022-02-10T14:02:29.135000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "cc: \u003c@!360491619402776577\u003e  ðŸ™‚",
        "created_at": "2022-02-10T14:24:37.399000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Updated",
        "created_at": "2022-02-10T14:27:47.079000+00:00",
        "attachments": null
    },
    {
        "author": "yperbasis",
        "category": "general",
        "parent": "",
        "content": "Is it correct that per the Engine API spec EIP-2718 transactions won't be additionally wrapped as RLP strings? For example, the first byte of an EIP-1559 transaction will be 0x02, not something like 0xb7?",
        "created_at": "2022-02-10T16:45:29.676000+00:00",
        "attachments": null
    }
]