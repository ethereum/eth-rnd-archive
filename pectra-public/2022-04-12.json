[
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Continuing on LVH topic. Suppose there is the following edge case scenario:\n0) There are two chains `A` and `B`, `A` is canonical and re-org to `B` is happening in the network \n1) `fcU(B.head.blockHash) \u003c~ SYNCING`, as there are missing blocks or they are present in the storage but haven't been executed before\n2) `newPayload(B.head \u003c- P0) \u003c~ SYNCING`, a child of the head is submitted\n3) `fcU(P0.blockHash) \u003c~ INVALID`\n\nAnd there is no `latestValidHash` returned to CL. So, CL may not conclude what exact block is invalid. It could either be `P0` or `B.head`, or even an earlier block on the `B` chain. In this case knowledge of `latestValidHash` would help CL to make a correct decision, i.e. invalidate a chain starting from a really invalid payload. Otherwise, CL would have to invalidate the chain back to the first valid ancestor it knows about, which could be subjective to each CL.\n\nSo, the right action would be invalidating a subchain and attesting to the most recent valid ancestor on the `B` chain if this chain still stays canonical after the invalidation takes place.",
        "created_at": "2022-04-12T10:17:37.004000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In this case, while it is true that CL will benefit from knowing the right LVH. If the EL cannot handle it we are anyway in a good position. We will invalidate `P0` and this is enough to stop building on that chain. In the event that  `B.head` was actually INVALID, an attack will have to be smart enough to build `P1` on top of `B.head` causing yet another reorg instead of building on top of  `P0` since we will not sync a descendant of `P0`.",
        "created_at": "2022-04-12T10:32:40.849000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "What if the network will attest to `B.head`  and it appears to be invalid?",
        "created_at": "2022-04-12T10:38:06.974000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think my strongest point against overspecifying the API is that it forces the CL to perform checks when receiving `Invalid.parent` as `LVH` because we will have to check that the given payload is in forkchoice and that it is an ancestor of `Invalid`. We would just assume this by default if `LVH` is not there. We should just simply **require** that if LVH is there, then it should be correct. EL will be inclined to actually support this correctly instead of always returning the last parent because it will make them perform better and users will choose this. Whatever we do, I think geth current behavior for example of sending the last valid head is wrong, since this actually puts us in the worst possible case: We find the LVH in forkchoice, then we are forced to traverse the forkchoice up to find it as an ancestor, and we only find out when we reach the root of the tree that it's a competing hash.",
        "created_at": "2022-04-12T10:38:16.923000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We cannot attest to `B.head` in that situation cause we received `SYNCING` on fcu, and that's our head",
        "created_at": "2022-04-12T10:38:50.852000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If we don't receive anything while EL is still executing we will attest for `A`",
        "created_at": "2022-04-12T10:39:13.525000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "there is no scenario where we attest for `B`'s chain",
        "created_at": "2022-04-12T10:39:24.547000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But a node isn't `SYNCING` anymore, it's in the state when it knows that sync has finished and some block on `B` chain is invalid",
        "created_at": "2022-04-12T10:40:33.956000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ah no, the forkchoice node for `B.head` will still be optimistic",
        "created_at": "2022-04-12T10:41:49.309000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "therefore the head of that node is still optimistic, therefore the node is optimistic",
        "created_at": "2022-04-12T10:42:04.546000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If a node is still optimistic in this case then it shouldn't attest and propose. But this is a tricky case because it's not explicitly described by the Optimistic Sync spec. A `NOT_VALIDATED` status doesn't include the case where the head responded with `INVALID`, thus, there is no available information about validity of any payload between the head and latest valid ancestor (which will be a common ancestor of `A` and `B` in the above case).",
        "created_at": "2022-04-12T10:46:22.018000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I disagree:  this is explicitly descibed in the optimistic sync SPEC. The head of that node is B and that block has been optimistically synced, therefore the node is optimistic",
        "created_at": "2022-04-12T10:47:37.221000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think Optimistic Sync spec should be explicit about that. If there is no LVH in the response then `INVALID` response after `SYNCING` invalidates a block that is responded with `INVALID`, and keeps all other blocks on this chain in the `optimistic_roots` set. Probably, it's obvious from implementation standpoint but not that obvious from the spec side",
        "created_at": "2022-04-12T10:51:08.782000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Agree with that",
        "created_at": "2022-04-12T10:54:00.911000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In this case, a re-org to `B` will makes all nodes that follows this re-org become optimistic, thus, unable to attest and propose. Isn't it an attack vector?",
        "created_at": "2022-04-12T10:54:04.763000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think so, but after what happened in shadow fork zero we are evaluating sending fcu again if we don't see any block, which will return INVALID on B.head eventually",
        "created_at": "2022-04-12T11:04:07.390000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But indeed this requires thought, perhaps if we receive INVALID with no LVH and our head is still the parent we should send FCU immediately",
        "created_at": "2022-04-12T11:05:21.842000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But it will take some time for EL to pull the chain from the network as it's likely to be dropped, and during this time a subset of validators won't be operating. I would imagine attacker will try to induce this attack with invalid payload somewhere at the very beginning of the `B` chain to take validators out for as long period of time as it's possible",
        "created_at": "2022-04-12T11:06:42.519000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Right but if we immediately send FCU to our head when receiving INVALID, this is solved since the El should know it's status by now",
        "created_at": "2022-04-12T11:08:07.142000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "EL will have to cache information about invalid subchain to respond correctly to this immediate call, IIUC, ECs aren't caching it by default, some of them store hashes of recent invalid blocks which wouldn't be enough. If EC caches additional information about an invalid subchain it should be enough to serve LVH correctly",
        "created_at": "2022-04-12T11:13:56.744000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think somehow we are going in circles, it seems that in order for the EL to know that P0 was INVALID in the first place, it must have known the right LVH",
        "created_at": "2022-04-12T11:17:07.889000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh, right. EL will actually have to cache the most recent invalid block hash to be able to response with `INVALID` in this case. Otherwise, if nothing is cached it will keep responding `SYNCING` again and again",
        "created_at": "2022-04-12T11:32:46.965000+00:00",
        "attachments": null
    },
    {
        "author": "terencechain",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm reviewing weak subjectivity sync for the post-merge finalized context, this following case came out, and I'm wondering if anyone else has encountered it:\nA node starts syncing at epoch `N`. At epoch `N+1`, the epoch `N-1` gets finalized. When a node calls `notify_forkchoice_updated`, the node may not have `finalized_block_hash` for `N-1` yet. What should a node do here?",
        "created_at": "2022-04-12T16:15:04.960000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think that CL should always send the hash of the most recent finalized block; whatever this hash is",
        "created_at": "2022-04-12T16:17:56.216000+00:00",
        "attachments": null
    },
    {
        "author": "terencechain",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I was wondering if it should be `Hash32()` or the payload hash of the weak subjectivity block. I think the later also makes sense",
        "created_at": "2022-04-12T16:33:04.954000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It should rather be a hash of WS block, `Hash32()` should be set only before transition block gets finalized",
        "created_at": "2022-04-12T17:12:40.640000+00:00",
        "attachments": null
    },
    {
        "author": "terencechain",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I agree. I wonder if it's worth clarifying that in the spec",
        "created_at": "2022-04-12T20:42:16.526000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "During checkpoint sync the starting state is the finalized state as per https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/fork-choice.md#get_forkchoice_store It should *not* be set to the finalized checkpoint from the starting state or you'll potentially try to reorg to a chain you don't actually have.",
        "created_at": "2022-04-12T21:51:41.370000+00:00",
        "attachments": null
    },
    {
        "author": "terencechain",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Cool. Thanks for pointing me to `get_forkchoice_store `, it's much clear now. It's sounding more like the bug in our WSS where we didn't properly initialize the WS state as the finalized state.",
        "created_at": "2022-04-12T21:57:24.853000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It is a weird little quirk of how things work. ðŸ™‚ I believe that's why we need a state that is actually what was finalized not just any arbitrary finalized state because otherwise the initial status exchange with other peers reports a finalized block they don't recognise.  If we sent finalizedSlot instead of finalizedEpoch with status message I think any state would work.",
        "created_at": "2022-04-12T22:01:34.708000+00:00",
        "attachments": null
    }
]