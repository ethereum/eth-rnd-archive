[
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Great work! I've made some notes here: https://hackmd.io/KPNsWbonS_2OrUx1Qy5PKw",
        "created_at": "2021-09-03T12:17:51.879000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "hey, I see you have many comments about the API",
        "created_at": "2021-09-03T12:19:04.676000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I really don't want this sync document to be about the API",
        "created_at": "2021-09-03T12:19:21.987000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "it's only about the actual sync and how that works",
        "created_at": "2021-09-03T12:19:54.840000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "we will for sure find a way to make the sync work with the API that you guys are working on",
        "created_at": "2021-09-03T12:20:41.295000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I can link some of them to the EIP if it would be better",
        "created_at": "2021-09-03T12:21:47.274000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "And follow your notation to introduce new calls",
        "created_at": "2021-09-03T12:22:04.760000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "like I said, for now, I think the API is not important",
        "created_at": "2021-09-03T12:22:09.542000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "(for me)",
        "created_at": "2021-09-03T12:22:14.431000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "you are working on the API, that's great, but I just want to figure out how the sync can work *at all*",
        "created_at": "2021-09-03T12:22:34.057000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "so this is why I decided to use this 'abstract' kind of API, with calls that just communicate the necessary information for the sync to work",
        "created_at": "2021-09-03T12:23:16.665000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "It is important for the Engine API design as the sync will rely on it. This is why I am thinking with the API categories. Sorry, I am biased",
        "created_at": "2021-09-03T12:23:19.329000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Let me adjust my comments then",
        "created_at": "2021-09-03T12:23:38.907000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "how I want to do it is: we will keep working on the sync until we figured out a way to make it work in abstract terms",
        "created_at": "2021-09-03T12:24:02.947000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "then we can figure out how to use the engine API to trigger it correctly, and then we can also make changes to the engine API adding the missing information",
        "created_at": "2021-09-03T12:24:48.590000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Makes sense to me",
        "created_at": "2021-09-03T12:25:26.132000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "at the moment, the big issue is the state",
        "created_at": "2021-09-03T12:25:29.075000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "it's really the main thing that we should discuss about re. the sync",
        "created_at": "2021-09-03T12:25:48.206000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "how we are going to handle the state in finalization and reorg situations is my main question still",
        "created_at": "2021-09-03T12:26:29.249000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e As in  -- stretches of non-finality which may have deep reorgs",
        "created_at": "2021-09-03T12:27:10.900000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e As opposed to the standard sub-100 depth under normal operation",
        "created_at": "2021-09-03T12:27:38.951000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "there are some other remaining problems still",
        "created_at": "2021-09-03T12:30:46.959000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "for example, the handling of new blocks during sync",
        "created_at": "2021-09-03T12:31:12.490000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "in my doc, I think I found a pretty good solution where it will extend the database in two directions concurrently",
        "created_at": "2021-09-03T12:31:35.878000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "i.e. the historical headers are downloaded backwards by eth1, while eth2 also pushes newer headers on top of the most recent sync target block",
        "created_at": "2021-09-03T12:32:07.401000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "it kind of works, but proto already found an issue with it in case of a certain client restart combination",
        "created_at": "2021-09-03T12:32:33.877000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "so we need to rework this part a bit",
        "created_at": "2021-09-03T12:32:41.574000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "also, ain't nobody going to comment on this 'marker' thing?",
        "created_at": "2021-09-03T12:33:02.432000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "this was actually Peter's main worry, how we're going to handle restarts with several unfinished chain segments in DB during sync",
        "created_at": "2021-09-03T12:33:49.196000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "the marker stuff tries to solve that, together with this requirement to delete conflicting chain data from older sync runs",
        "created_at": "2021-09-03T12:34:25.644000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Which is it? There is an option with which consensus client doesn't send new blocks until the sync to the pivot block is finished",
        "created_at": "2021-09-03T12:39:16.001000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "yeah, but we can't have that",
        "created_at": "2021-09-03T12:39:33.744000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I've adjusted my comments. They have no references to the API doc anymore",
        "created_at": "2021-09-03T12:39:36.996000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "we need to move the pivot block during sync",
        "created_at": "2021-09-03T12:39:39.194000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "it's required for snap sync",
        "created_at": "2021-09-03T12:39:53.737000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Right, and we could have a separate message that manages sync process and avoid mixing it with the regular block processing flow",
        "created_at": "2021-09-03T12:40:06.587000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e And I think it natural for the consensus to feed new blocks and finality/head info continually and execution to decide what to do with",
        "created_at": "2021-09-03T12:40:12.833000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "yes I think so too, the question is just how exactly we will handle it in the database",
        "created_at": "2021-09-03T12:40:44.303000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Hmm. As long as consensus knows execution is syncing (by whatever means), i think it best for execution optionality to send new blocks",
        "created_at": "2021-09-03T12:40:52.738000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I am currently in favour of not having methods with double semantics and rather keep the sync separated from the main processing flow",
        "created_at": "2021-09-03T12:41:00.998000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "again, it's not really about *how* we send those blocks to the client, there will be a way",
        "created_at": "2021-09-03T12:41:04.475000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "it's more about *what we do with them* in the eth1 client exactly",
        "created_at": "2021-09-03T12:41:20.739000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Problem is, sync can be plenty different across clients so feeding new blocks in an agnostic way keeps open options",
        "created_at": "2021-09-03T12:41:49.431000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "My question is *how the messages are interpreted* by the execution client depending on its state",
        "created_at": "2021-09-03T12:42:07.742000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Instead of trying to design an adhoc dance per sync style",
        "created_at": "2021-09-03T12:42:11.675000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "And if we want to have an abstract sync approach I would keep the sync management messages separated in the sync doc and then tried to unify them when we start talking about the API for the sync process",
        "created_at": "2021-09-03T12:43:13.002000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I'd like to clearly see the semantics of the calls that sync is relied on",
        "created_at": "2021-09-03T12:43:59.631000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "so in the current document, the message handling on eth1 side is explained completely IMHO. The way it's written makes sense in this little world of final(B) / proc(B). The idea is, you get all final blocks via final(B), and all non-final blocks via proc(B).",
        "created_at": "2021-09-03T12:45:50.137000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "proc(B) is basically ignored during sync, it's only used after",
        "created_at": "2021-09-03T12:46:20.603000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "And you're getting them constantly, right?",
        "created_at": "2021-09-03T12:46:27.627000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "yes",
        "created_at": "2021-09-03T12:46:30.639000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "for every beacon block",
        "created_at": "2021-09-03T12:46:36.830000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "and that's kind of it already",
        "created_at": "2021-09-03T12:47:05.373000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "ok, I see. I might need to adjust some of my comments as it wasn't clear to me that `proc(B)` is being constantly called",
        "created_at": "2021-09-03T12:47:24.806000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I can also add additional text to clarify when exactly it will be sent by eth2",
        "created_at": "2021-09-03T12:48:05.533000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "My assumption was that eth2 cannot process blocks unless the state is available",
        "created_at": "2021-09-03T12:48:17.835000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "The confusing part is that the consensus client should send `proc(B)` upon receiving the signal that sync has been finished. That is why I thought that `proc(B)` is not happening during the sync",
        "created_at": "2021-09-03T12:48:18.441000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "so what I mean is, there is no way to process blocks in the execution layer until the sync is done",
        "created_at": "2021-09-03T12:48:48.435000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "this also means the eth2 can't really call it",
        "created_at": "2021-09-03T12:48:58.768000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I mean, it could call it, but it won't do anything.",
        "created_at": "2021-09-03T12:49:09.871000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "the simple sync process is: sync the final blocks first, then deal with the non-final blocks afterwards",
        "created_at": "2021-09-03T12:49:39.351000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "the part about non-final blocks isn't even really related to the sync IMHO",
        "created_at": "2021-09-03T12:50:02.921000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "when non-final blocks can be processed, the sync is already kind of over",
        "created_at": "2021-09-03T12:50:25.065000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "it does matter a bit for eth2 because for eth2, the sync is only really *done* when it has reached the head of the beacon chain",
        "created_at": "2021-09-03T12:50:58.522000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "so this is why I put in proc, so that I could talk about this part as well",
        "created_at": "2021-09-03T12:51:13.432000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "for the eth1 client, the interesting part is syncing the final blocks. when it's done with that, it's basically ready to do the normal, non-sync thing where it processes individual blocks from eth2",
        "created_at": "2021-09-03T12:51:53.572000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "---",
        "created_at": "2021-09-03T12:51:59.781000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "now, obviously we will have to change all that because of the state problem",
        "created_at": "2021-09-03T12:52:15.981000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "since it seems we will now also have to care about non-final blocks in the interesting part of sync, we will also need to handle proc(B) in eth1 during sync. and this also means there can be reorgs during sync, and stuff like that. it makes everything very complicated.",
        "created_at": "2021-09-03T12:53:27.134000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I hope you are less confused about proc() now.",
        "created_at": "2021-09-03T12:55:39.413000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "https://github.com/fjl/p2p-drafts/commit/2e6c157c77803e0c0ac01a42800dc9f0ef4c635c#diff-befa5f940ca0e1e764805213558d7513a083d69ee03f9a77a4ee33934f3126adL35",
        "created_at": "2021-09-03T12:59:38.080000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "yes, I see now. I've updated my comments/questions according to this new understanding. The state problem in the context of the non-finality periods is a big one",
        "created_at": "2021-09-03T12:59:54.924000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "https://github.com/fjl/p2p-drafts/commit/3259c2722f1cf2ee324a33d52136b6db9bb42fe3#diff-befa5f940ca0e1e764805213558d7513a083d69ee03f9a77a4ee33934f3126adR70",
        "created_at": "2021-09-03T13:12:12.481000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "it answers this question you had in your doc:",
        "created_at": "2021-09-03T13:12:21.275000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "\u003e It‚Äôs a bit unclear how does the client do this signalling.",
        "created_at": "2021-09-03T13:12:32.742000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Right, and we have options here. 1) execution client stores blocks that are communicated with `proc(B)` and then replays them from starting from the pivot block 2) execution client ignores these blocks while in sync and sends a signal to the consensus client to replays blocks starting from the pivot when sync is finished",
        "created_at": "2021-09-03T13:12:40.848000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "the problem is, we cannot use a finalized block as the pivot block because it may be too told",
        "created_at": "2021-09-03T13:13:12.687000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "in the case of non-finalization, we may need to use a non-final block instead",
        "created_at": "2021-09-03T13:13:33.302000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "the sync requires a recent (\u003c 512 away from head) as the target block",
        "created_at": "2021-09-03T13:13:54.599000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "we can't just sync to any block, at least not with snap sync",
        "created_at": "2021-09-03T13:14:05.262000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Right, and I've made a rough proposal on how we can extend the data set required  by the sync to handle this case. It's in the bottom of the doc",
        "created_at": "2021-09-03T13:14:13.512000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "we can do it with full sync, but it will take two weeks",
        "created_at": "2021-09-03T13:14:18.680000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "maybe another client like erigon can do the full sync faster right now, but it's not realistic to rely on it long term",
        "created_at": "2021-09-03T13:15:07.749000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "sure",
        "created_at": "2021-09-03T13:15:43.584000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "about this:",
        "created_at": "2021-09-03T13:15:45.922000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "\u003e Should it be ‚ÄúIf the client is done syncing to block Bx, ‚Ä¶‚Äù instead? Otherwise, the client sync could be somewhere between Bf and Bx when the message with the new finalized block is received and it wouldn‚Äôt be able to respond with either synced(Bx) or invalid(Bx).",
        "created_at": "2021-09-03T13:15:47.136000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "this thing is kind of a late addition to the doc",
        "created_at": "2021-09-03T13:16:03.271000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "so my idea was, since the eth1 client gets notifications about all final blocks, it will handle it like this:",
        "created_at": "2021-09-03T13:16:43.493000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "- (1) if necessary, move the pivot block of sync",
        "created_at": "2021-09-03T13:16:54.568000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "- (2) when sync is done to the most recent pivot block, it cannot report completion right away, so it has to wait for the next call to final",
        "created_at": "2021-09-03T13:17:17.335000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I get what it means now",
        "created_at": "2021-09-03T13:17:45.629000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "but this call will be about the next block already, so it will just process the block normally and then say it's done",
        "created_at": "2021-09-03T13:17:46.432000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "This is because `final(B)` is called for *every* block. I was thinking about checkpoints..",
        "created_at": "2021-09-03T13:18:31.377000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "so, it can be imported right away",
        "created_at": "2021-09-03T13:18:43.723000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "yeah, I'm really sorry about this confusion still",
        "created_at": "2021-09-03T13:18:50.560000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I should've done it differently maybe, and it will be changed later. It's the issue number (1) üôÇ",
        "created_at": "2021-09-03T13:19:10.190000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "You can just add a corresponding Note about this difference between the sync doc and the beacon spec",
        "created_at": "2021-09-03T13:19:49.148000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "basically, when we discussed the sync in geth team, we didn't really have a clue about how finalization actually works",
        "created_at": "2021-09-03T13:20:07.440000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "that's why we got it kind of wrong",
        "created_at": "2021-09-03T13:20:14.058000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "This is not that bad actually. It simplifies the sync spec but requires an additional understanding for those who are familiar with the finality on the beacon chain.",
        "created_at": "2021-09-03T13:21:55.234000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "So, Alexey checked some things and provided numbers from their reverse diff implementation",
        "created_at": "2021-09-03T19:54:11.479000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "The 90k diffs take ~4.35 GB on disk",
        "created_at": "2021-09-03T19:55:37.662000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Reorg back 10k on mainnet takes ~21 min",
        "created_at": "2021-09-03T19:55:57.002000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I would be a bit conservative and round those up",
        "created_at": "2021-09-03T19:56:31.580000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "So 10k block @ 30min * 9 = 4.5h is the worst case reorg time",
        "created_at": "2021-09-03T19:58:01.778000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "their reorg algorithm actually does the diff merging, but I think there will need to be a bound on the window size for that. So IMHO my * 9 should be pretty accurate even though their algo doesn't scale linearly with num blocks.",
        "created_at": "2021-09-03T20:00:38.267000+00:00",
        "attachments": null
    }
]