[
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Given a block hash, you can generate a proof for any piece of data in all of history (since the start of block SSZification).",
        "created_at": "2020-11-27T00:11:31.524000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This would include any storage slot, any bit of code (assuming code merklization I believe), any transaction receipt log, or even the value attached to a particular transaction.",
        "created_at": "2020-11-27T00:12:31.323000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "At the moment, if you want to prove a block in history you need the block hash from an authoritative source just to get started.  Then, you have to supply the entire transaction and a proof just to prove a single log was present.",
        "created_at": "2020-11-27T00:14:33.287000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It would be nice to know quantitatively how they compare, because the MPT also allows us to prove these things",
        "created_at": "2020-11-27T00:16:48.833000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "MPT isn't recursive.",
        "created_at": "2020-11-27T00:18:11.980000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So if the block was an MPT, and the transaction list was an MPT and the individual transactions were MPTs, you would need 3 proofs to go from block to tx list to tx.",
        "created_at": "2020-11-27T00:19:35.903000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And if you want to go back in history, you need a proof per parent.",
        "created_at": "2020-11-27T00:20:01.709000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Txs are already stored into an MPT whose root hash is part of the block header. If your proof includes the block header fields and the tx data, you effectively have one single proof. Granted, that might not be as efficient a proof as SSZ. I'd be interested in seeing a size comparision, though.",
        "created_at": "2020-11-27T07:26:35.291000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "By that, do you mean that proofs can be provided, that are valid for any range of blocks as long as the value itself doesn't change?",
        "created_at": "2020-11-27T07:28:25.644000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "SSZ merklization let's you have a single concise proof rooted in the latest block hash that proves the presence of any block in history with a single concise proof.  If you have fully SSZified blocks, you can get a concise proof of any piece of data in any block in history rooted in the latest block hash.",
        "created_at": "2020-11-27T07:36:47.333000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For this you need to provide the entire block header, along with the full transaction, along with a proof.  This would be rooted to the block hash for that block (not latest).",
        "created_at": "2020-11-27T07:38:34.062000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so to summarize, your point is that the SSZ proofs can give smaller proofs of a tx value of a previous block. If blocks where MPTs, you could have exactly the same sort of proof, however it wouldn't be as concise.",
        "created_at": "2020-11-27T07:42:04.347000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If you define \"can\" here as \"theoretically possible\".  ðŸ™‚",
        "created_at": "2020-11-27T08:27:16.491000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Imagine you want a proof that some data was in block 20,000,000 but all you have is the blockhash for block 30,000,000.  With the current system, you would need 10,000,000 block headers (which is a lot of data).",
        "created_at": "2020-11-27T08:28:17.401000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "With SSZified blocks, you would need a single concise proof.  Maybe a few kilobytes or whatever the size of a normal proof is.",
        "created_at": "2020-11-27T08:28:35.602000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In the current system, once you have proven block header 20,000,000, you could use the MPT proof using the transaction root in that block header to prove that a particular transaction was in a block, but this would require both the roof and the entire transaction (which can be quite large as well).",
        "created_at": "2020-11-27T08:30:16.362000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "With SSZified blocks, you could prove a single piece of data within that transaction, like the gas price, or the destination, or the value, without having to provide the entire transaction.",
        "created_at": "2020-11-27T08:30:54.569000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So in the most simple terms, yes, it is just \"smaller proofs\".  But the order of magnitude difference between \"large\" and \"small\" is massive, to the point of that statement not being particularly meaningful.",
        "created_at": "2020-11-27T08:31:38.753000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah but the comparison that Matt was asking about, is between an MPT-block and an SSZ-block. You wouldn't need to pass all the block data either with an MPT block.",
        "created_at": "2020-11-27T08:32:41.932000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so it wouldn't be orders of magniture larger.",
        "created_at": "2020-11-27T08:33:00.068000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ah, yes. There are definitely some things that MPT does just as well as SSZ.",
        "created_at": "2020-11-27T08:34:29.431000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The point of SSZification of blocks is to expand the set of things that are possible, and reduce the cost of some things that are currently possible but expensive.",
        "created_at": "2020-11-27T08:35:01.917000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But it isn't universally better than MPT at all tasks.",
        "created_at": "2020-11-27T08:35:16.147000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Though, reading this question again I may be misunderstanding:\n\u003e If I have only have the tx root for an eth1 block I can also calculate the header's root\nIf you have a transaction root, you cannot derive the block header or the block header root from it.",
        "created_at": "2020-11-27T08:36:30.915000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Proofs go the other direction.  Using current ETH1 architecture, a block hash can validate a block header, and the block header has a transaction root a that can validate a transaction hash presence proof, and that transaction hash can validate a transaction.",
        "created_at": "2020-11-27T08:38:01.920000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Using SSZified architecture, a block root (aka: block hash) can validate a proof of inclusion of a particular piece of data in a particular transaction in that block (or any ancestor block).",
        "created_at": "2020-11-27T08:39:13.482000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think that what Matt meant is that current blocks also have the property that the full-bodied block and the block header have the same hash.",
        "created_at": "2020-11-27T08:39:39.310000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yes, but with no ability to recursively prove anything across that boundary with a single proof.",
        "created_at": "2020-11-27T08:41:49.287000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "assuming MPT-blocks, a single proof can also be used. I perceive Matt's question as being one about trade-offs: It is arguably safer to use MPTs because it's battle-tested, so what would balance the risk of replacing it with a still unproven technology?",
        "created_at": "2020-11-27T08:45:01.695000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't believe this is true.  You need multiple proofs with RLP blocks.",
        "created_at": "2020-11-27T08:45:27.083000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I didn't say RLP, I said MPT",
        "created_at": "2020-11-27T08:45:46.362000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Terms get fuzzy with that because SSZ does merklization.",
        "created_at": "2020-11-27T08:46:14.066000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It is an important distinction that you SSZ encode the data in the block, and you use the SSZ merklization system (or something with similar designed properties).",
        "created_at": "2020-11-27T08:46:44.804000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If you just try to naively use an MPT (without the SSZ merklization magic) I don't believe you can do a single proof like you described.",
        "created_at": "2020-11-27T08:47:04.044000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "```py\ntransaction = [gasPrice = 5, ...]\ntransactionRoot = mpt([transaction, ...])\nblockHeader = rlp([transactionRoot, ...])\nblockHash = keccak256(blockHeader)\ntransactionProof = mptProof(transactionRoot, transaction)\n\n# assuming you know the block hash already (trusted), you need these 3 additional pieces of information to prove there was a transactino with a gas price of 5\nassert 5 == getGasPrice(blockHeader, transactionProof, transaction)\n```\n```py\ntransaction = [gasPrice = 5, ...]\ntransactionRoot = sszHashRoot([transaction, ...])\nblockRoot = sszHashRoot([transactionRoot, ...])\ntransactionGasPriceProof = sszProof(blockRoot, [[transaction, ...], ...])\n\n# assuming you know the blockRoot already (trusted), you need just this proof to prove there was a transaction with a gas price of 5\nassert 5 == getGasPrice(transactionGasPriceProof)\n```",
        "created_at": "2020-11-27T08:51:19.467000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Just changing `blockHash` to `mpt(blockHeader)` will help slightly (no longer need to provide the entire block header, just a proof of the transaction root), but it won't allow you to do recursion down into the transaction list with a single proof.",
        "created_at": "2020-11-27T08:52:28.417000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It is worth noting, I believe the proofs here are similar sized to MPT proofs.  We don't end up with just one mega proof that is the same size as multiple smaller MPT proofs.",
        "created_at": "2020-11-27T08:53:17.902000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Here's what a single, MPT proof would look like:\n```\nproof = mpt([parent= [parent = [parent = [transactionRoot, ...], ...], ...], ...])\n```\nBasically, block `N` is the child of block `N+1`.",
        "created_at": "2020-11-27T08:58:30.730000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Without SSZ merklization techniques, I believe that requires an ever-growing block header, since every block header will need to include the previous block header.",
        "created_at": "2020-11-27T09:00:02.891000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "With SSZ merklization, you can replace any layer of that nested structure you have described with a hash root, so you can have constant size block headers rather than `O(block_number)` sized block headers.",
        "created_at": "2020-11-27T09:01:03.518000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The size will remain constant, because at each level, the block header proof just contains a proof to a subtree, which is constant-size.\nFor sure, I need a SSZ refresher, maybe there's something I'm missing here that makes SSZ clearly better. I'll mull it over the weekend.",
        "created_at": "2020-11-27T09:09:54.857000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e at each level, the block header proof just contains a proof to a subtree\nThis is exactly the feature that SSZ merklization gives us that traditional merklization doesn't, as I understand it.",
        "created_at": "2020-11-27T09:11:04.655000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The ability to seamlessly swap out a data structure with its root without breaking recursiveness.",
        "created_at": "2020-11-27T09:11:47.654000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The main restriction with RLP is that bits of data encoded with it can't be separately proved. E.g. if eth1 block is RLP encoded in a beacon block body then there is no possibility to build a proof linking a data of particular contract storage slot to beacon block root. I.e. merkle proof can't bypass RLP.",
        "created_at": "2020-11-27T09:35:43.948000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Technically RLP string is merkleized as well and it's (technically) possible to build a proof for RLP-encoded data but it puts additional complexity",
        "created_at": "2020-11-27T09:41:19.939000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Even if you did that, you couldn't prove recursively with a single proof could you?",
        "created_at": "2020-11-27T09:42:04.882000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah I just debated this during the geth's team standup. Indeed, the complexity (like everything RLP) compared to SSZ is a strong argument for SSZ. I'm pretty close to flipping on this issue ðŸ™‚",
        "created_at": "2020-11-27T09:44:29.672000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "A bit off topic, but speaking of Geth team standup... any chance someone on the team has had a chance to go over \u003chttps://notes.ethereum.org/kvDtI9BsS6qFdsLDY_YwpQ\u003e prior to the ACD meeting?",
        "created_at": "2020-11-27T09:45:38.920000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Basically I need to walk the walk and see the horrors for myself",
        "created_at": "2020-11-27T09:46:06.407000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'll ask",
        "created_at": "2020-11-27T09:46:21.542000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I can very much appreciate this desire/need.",
        "created_at": "2020-11-27T09:46:37.118000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You could but at RLP part of the proof you would have to use tricky logic that matches RLP-encoded roots on SSZ chunks",
        "created_at": "2020-11-27T09:54:33.567000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think that at this phase of my life, going deeper down that rabbit hole is likely to lead to an aneurism... so I'm not going to probe further.",
        "created_at": "2020-11-27T09:55:33.206000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "By \"You could\" I meant \"It's technically doable\" but this is not the best path to follow, IMO",
        "created_at": "2020-11-27T09:57:51.586000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Just the fact that it is *possible* means I don't fully grok things, but for now I think I'm OK with that.",
        "created_at": "2020-11-27T09:59:18.254000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm not disagreeing that current merklization scheme in eth1 requires additional data than a single uniform proof from block header to individual piece of data. The points I'm trying to make are i) both the current scheme and SSZ allow us to authenticate a piece of data against a block root (yes, MPT is worse, but I would like to understand *how* much worse things that are often proved -- e.g. when do i need to prove something in an old block through a newer header?) and ii) we *could* offer the same functionality as SSZ using an MPT (or soon to be a binary tree) by just defining some extra merklization rules. Many things in eth1 are already merklized. Why should we change to SSZ instead?",
        "created_at": "2020-11-27T13:49:41.375000+00:00",
        "attachments": null
    }
]