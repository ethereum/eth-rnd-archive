[
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Won't we have a split only if attestation distribution between these two blocks is 50/50?",
        "created_at": "2021-09-10T06:25:33.554000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "* 50/50 or any other equal proportion",
        "created_at": "2021-09-10T07:46:54.286000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "In principle yes the next proposer will base his block on the best he found, and the network continues fine. But depending on network fragmentation and delays proposer three may have seen the other TTD block only and thus will base his block on that one. And can take a little longer. I guess  if a validator is willing to slash himself to produce two blocks right at the merge, then he should also submit them relatively late, to different peers and, and as big as possible. I suppose this is a an expensive way of just giving everyone a headache for a few seconds",
        "created_at": "2021-09-10T10:23:32.697000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Submitting them late also increases the risk of ending up with an empty slot and missing the proposal opportunity while still keeps the possibility to get slashed",
        "created_at": "2021-09-10T10:25:04.202000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@425572898787426305\u003e Want to talk about what the expectation of `getPayload` is?  It sounded like on the call we were not in agreement as to its expectation.",
        "created_at": "2021-09-10T15:52:40.875000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I feel like `getPayload` should *always* be expected to return ASAP, and if you want to do any more work than \"empty block\" you should listen for `preparePayload` and start building the block in advance, not wait for `getPayload`.",
        "created_at": "2021-09-10T15:53:14.048000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Reasoning: It allows consensus clients to be hyper-optimized for waiting until the last possible millisecond to request a payload, rather than needing to ask some amount of time in advance \"just in case the execution engine decides to do something time consuming\".",
        "created_at": "2021-09-10T15:53:57.097000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "Is that consistent with the vision put forward of splitting consensus and execution clients across different Internet hosts? At that point, the last-millisecond game becomes less viable.",
        "created_at": "2021-09-10T16:01:49.064000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Yes, because the individual consensus node operators can figure out what round trip latency is and configure their consensus client to request the block that much in advance.",
        "created_at": "2021-09-10T16:02:34.383000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The change I propose would remove yet-another-variable that is out of the control of the operator.",
        "created_at": "2021-09-10T16:02:52.451000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "More broadly, I'm not 100% convinced around hyper-optimizing for this goal in terms of the official API, potentially at the cost of creating obligatory complexity even for people who don't want to engage in MEV or completely optimal block-packing.",
        "created_at": "2021-09-10T16:03:19.526000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "IMO this would be a complexity *decreaser*.  What do you think makes it more complex?",
        "created_at": "2021-09-10T16:05:08.451000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "It's not intrinsic, but it then suggests the question of if/when/how the consensus client should cue (or queue up) the execution client to be prepared to create blocks. There was discussion in the call a day or two ago around this point.",
        "created_at": "2021-09-10T16:06:16.135000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "Because one tradeoff on the execution client becomes either be\n\n- (a) always able to respond immediately by some constant block (mempool access etc) maintenance so that `getPayload` could be fast even without prior warning;\n\n- (b) only be able to return optimal blocks if given prior warning (but creating multiple flows, some of which would have to be supported but some of which would likely become seldom-used, creating a kind of dead code/calling surface in spec form);\n\nor other options.",
        "created_at": "2021-09-10T16:09:13.339000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "That said, in a standalone way, I see no issues in this regard, just potential downstream effects.",
        "created_at": "2021-09-10T16:12:58.671000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "That is why we have `preparePayload`.",
        "created_at": "2021-09-10T16:16:28.776000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "As soon as the consensus client knows the details, it sends `preparePayload`.  This allows an execution to start building/preparing a block.  Sometime later, they'll get a `getPayload` request and the expectation is they respond to the `getPayload` request immediately.",
        "created_at": "2021-09-10T16:17:25.572000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "This makes sense to me, and I agree that it seems like a solution with minimal complexity.  A few more thoughts on this:\n  - pairing `preparePayload` and `getPayload` makes sense.  Consensus nodes will know in advance (for some value of \"in advance\" between 0 and 372 seconds) that they will require a block so will be able to tell the execution node to start preparing a suitable time in advance (\"suitable\" being whatever is optimal for the particular combination of hardware, software and architecture)\n  - if an execution node receives a `getPayload` without a prior `preparePayload` it is up to the node as to what to do.  It could fill the block with the simplest/fastest algorithm for selecting transactions, grab the block from an external source, or go through some sort of optimized packing.  This will be a relatively common case, though (1/32) so does need to be considered\n  - if an execution nodes receives a `getPayload` after a `preparePayload` it should probably stop attempting to build blocks, as it can assume its work is done.  If a consensus node needs another block it can send another `preparePayload` directly after the `getPayload` has returned (or perhaps after the block has been submitted so the execution node knows the state from which it should build the next block)",
        "created_at": "2021-09-10T16:30:27.660000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think you mean execution node in the last two bullets?",
        "created_at": "2021-09-10T16:43:51.984000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I disagree on the middle one.  `getPayload` IMO should mean \"no time left to execute a block, give me *anything* right now\".",
        "created_at": "2021-09-10T16:44:38.553000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If you want to execute a block, you need to start when you get the `prepare` call.",
        "created_at": "2021-09-10T16:45:05.796000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "I do indeed, thanks for pointing it out.  I've edited the post accordingly.",
        "created_at": "2021-09-10T17:21:59.038000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Tricky.  As I say, 1/32 of the block proposers will find themselves in this situation so if _anything_ means \"an empty block\" we're going to have a fair impact on the chain's throughput.  We could have additional options in `getPayload` to ask for an empty/minimal/time-bound block, perhaps?",
        "created_at": "2021-09-10T17:25:21.638000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Why will 1/32 validators end up in this situation?  My understanding is that it should be a very rare occurance.",
        "created_at": "2021-09-10T17:35:49.680000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Proposer duties are only known at the beginning of the epoch, so the validator who has to propose in the first slot of each epoch will not know in advance.",
        "created_at": "2021-09-10T17:36:32.773000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "They still have 4 seconds to prepare a block don't they (and then another 4 seconds for validators to vote)?",
        "created_at": "2021-09-10T17:37:54.421000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "(or something like that)",
        "created_at": "2021-09-10T17:37:59.336000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Ish.  Although there are 4 seconds until other validators start to attest to the state of the head, we lose some time either side.  At the beginning of the 4 seconds is the epoch transition, which has been known to take a bit of time on both the beacon node (updating its internal state) and the validator client (initiating subnet subscriptions).  And the 4 second mark is the time by which the block should have been successfully propagated around the network, rather than just produced.  So there is some time, but it certainly isn't a full 4 seconds (the actual value could be very dependent on the setup, hence the suggestion of the time-bound parameter to pass to `getPayload`).\n\nHistorically, blocks in the first slot of the epoch are more likely to be orphaned because of this.  Adding to the time taken between a validator client knowing it needs to propose for the slot and it pushing the block out will only make this worse (although to be fair it's a lot better than it used to be, due to various node optimizations).  Certainly broadcasting the block in the first second results in a healthier network than broadcasting it in the following seconds.\n\nIt may be that we end up going down the road of all consensus nodes sending a `preparePayload`  to their execution nodes in the seconds before the epoch transition, just in case.  But that's a lot of wasted computation given that it's a 1-in-200-odd-thousand chance of the work bearing fruit.",
        "created_at": "2021-09-10T17:52:00.843000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Either there is time to build a block, in which case `prepare` should be called, or there isn't, in which case `get` should be called.",
        "created_at": "2021-09-10T18:05:55.256000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It is the consensus client that has the information and understanding necessary to make that decision, not the execution client.",
        "created_at": "2021-09-10T18:06:07.439000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The way the consensus client conveys that information to the execution client is by choosing which of the two methods to call.",
        "created_at": "2021-09-10T18:06:39.300000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Agree that it's the consensus client that has the info, but not sure that the binary \"prepare or not prepare\" gives the best options.\n\nIf the consensus client knows that it has (for example) 60 seconds before it needs the execution payload that could be a very different situation than if it has 0.2 seconds.  The latter may still be enough to put together a basic populated block, but without any sort of information from the consensus side the execution node will most likely be forced in to some sort of layered approach (build an empty block / fill it with whatever it has to hand / incrementally add higher-value batches through searching) rather than the picking just one of the approaches depending on how long it has before `getPayload` is expected to be called.",
        "created_at": "2021-09-10T18:23:07.512000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Does the consensus client know how long it has until it needs a block when it sends the prepare payload?",
        "created_at": "2021-09-10T18:25:45.403000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Most of the time it will know it has around `slot in epoch * 12` seconds before it needs a block.  For the proposer of the first slot in the epoch it's more subjective, but if the capability for providing the time bound is there it gives us the option of adding to the consensus node (logic to pick the time bound) and execution node (logic to select the best block given the time bound) as we gain experience.\n\nMain thing for me would be to have some way of doing this in-protocol from the beginning, giving us the option to add the intelligence on both sides as and when.",
        "created_at": "2021-09-10T18:30:33.843000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I wouldn't be opposed to the `prepare` request including a `duration` that signals to the execution client how long it has to prepare the block.  The execution client can then optionally adjust it's strategy based on that.",
        "created_at": "2021-09-10T18:32:27.500000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "It does seem to be an option that provides flexibility without loading the protocol itself with complexity.",
        "created_at": "2021-09-10T18:33:34.220000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e to add some more color, proposers do have lookahead on their shuffling more than 0 epochs, it is just _possible_ that the shuffling does change going into an epoch due to effective balance changes in the epoch processing of the prior epoch; it is also my understanding that the “slot 0 orphaned block” issue was more about long epoch processing times and not that proposer do not know (bc they do and worst case they make an invalid but non-slashable block erroneously) — there is a separate question if any clients actually implement the proposer duty scheduling this way — they may all just wait until the first slot and so we see the same observed effects",
        "created_at": "2021-09-10T18:35:16.552000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e and to be precise, the proposer shufflings have the same lookahead as the attestation duties",
        "created_at": "2021-09-10T18:37:28.143000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e so a client could optimistically schedule w/ this shuffling and abort only at the last minute if the effective balances change enough to change the shuffling — i don’t think this happens that often",
        "created_at": "2021-09-10T18:38:20.980000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "The idea of fetching proposer duties beyond the current epoch has, to my knowledge, been considered a Bad Thing.  Trying to fetch the next epoch's proposer duties from a lighthouse node, for example, gives:\n\n```\n{\"code\":400,\"message\":\"BAD_REQUEST: request epoch 38524 is ahead of the current epoch 38523\",\"stacktraces\":[]}\n```\n\nBut if we can look ahead with some level of reliability that becomes interesting.  Would a change in the active validators set reduce the reliability of this method, though?  Once withdrawals become available it may be that changes in the active validator set are expected every epoch.",
        "created_at": "2021-09-10T19:18:53.587000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e I don’t see why it is Bad (tm)",
        "created_at": "2021-09-10T19:34:28.721000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e Otherwise it does seem like the block production API needs a lot of context",
        "created_at": "2021-09-10T19:34:55.575000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e We could actually just scan the chain and see how often an epoch processing changes the proposer shuffling for the next epoch",
        "created_at": "2021-09-10T19:36:23.750000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e That would give us some more data before going further down this route",
        "created_at": "2021-09-10T19:36:35.110000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e The “proper” fix is adding the proposer shuffling to the state each epoch but that would involve substantive changes to the consensus clients which we want to avoid",
        "created_at": "2021-09-10T19:37:34.487000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e The improper fix is to just query one epoch ahead anyway — although this may also require some client changes if APIs and things are coded against it",
        "created_at": "2021-09-10T19:38:24.578000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e Changes to the active set would change the shuffling more often although withdrawals itself won’t change it — only that the ability to withdraw means more exits/turnover in the active set",
        "created_at": "2021-09-10T19:40:25.865000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e And I don’t know if that will happen frequently enough to not rely on the “effective” look ahead",
        "created_at": "2021-09-10T19:40:54.956000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "You can accurately calculate the proposers for the next epoch as soon as you have the block for the last slot of the previous epoch. So even there you get some look ahead (teku precalculates the epoch transition by taking advantage of this).",
        "created_at": "2021-09-10T21:02:55.918000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "But there’s still a lot of difference between calling prepare when you have almost a whole epoch’s notice and calling prepare when you have maybe a second or two.",
        "created_at": "2021-09-10T21:03:49.908000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I’d be pretty strongly against anything that supports or encourages validators to produce their block at anything later than the very start of the slot. Late blocks are a great frustration and we really need to find a way to fix the incentives to penalise them so don’t want to start building apis that assume waiting until the last possible moment.",
        "created_at": "2021-09-10T21:05:32.625000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e there is _some_ backpressure bc the longer a proposer waits to publish a block, the higher the orphan risk",
        "created_at": "2021-09-10T21:19:39.461000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e does anyone know of any digestible written material on how execution block building works right now?",
        "created_at": "2021-09-10T21:22:15.786000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e anything other than “go read the geth source” would be helpful",
        "created_at": "2021-09-10T21:22:36.392000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Yes but the risk of orphan really starts at close to 12 seconds whereas the cost to attesters starts at 4 seconds.",
        "created_at": "2021-09-10T21:28:42.029000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e which exactly is the cost to attesters?",
        "created_at": "2021-09-10T21:30:47.631000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e attesters downstream of an orphaned block will act like it doesn’t exist and as long as there is blockspace then attestations in the orphaned block can go into future blocks",
        "created_at": "2021-09-10T21:31:26.301000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "If they don’t have the block when they attest they attest to the slot being empty and then are penalised when the block later turns up for missing the head vote. And if it’s the first slot of the epoch they also miss the target vote",
        "created_at": "2021-09-10T21:31:58.601000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "If the block is orphaned it’s ok but there’s a lot of blocks that turn up between 4 and 12 seconds which are then included on the canonical chain but attesters have no chance of voting correctly.",
        "created_at": "2021-09-10T21:32:46.466000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e right — this is where we should consider dropping the LMD part of the attestation for slashing consideration",
        "created_at": "2021-09-10T21:33:11.715000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e then an attester could re-broadcast assuming they notice they ran ahead of a slow block",
        "created_at": "2021-09-10T21:33:30.339000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e fixing for the target block is trickier...",
        "created_at": "2021-09-10T21:34:03.791000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I guess that’s one option but personally I’d prefer to penalise the late block publisher by ensuring the block gets orphaned.",
        "created_at": "2021-09-10T21:34:12.705000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Republishing attestations is going to add a huge amount of extra bandwidth and cpu processing to the chain.",
        "created_at": "2021-09-10T21:34:34.664000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Not to mention complexity.",
        "created_at": "2021-09-10T21:34:44.072000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e agreed",
        "created_at": "2021-09-10T21:34:50.805000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cralexstokes\u003e clients could certainly soft-fork to only accept a block w/ first 1/3 of a slot",
        "created_at": "2021-09-10T21:35:56.753000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "And on top of that rebroadcasting will still surely incur in penalties cause after Altair the timely flags are strict",
        "created_at": "2021-09-10T21:56:44.818000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Aggregators are not going to be waiting forever",
        "created_at": "2021-09-10T21:57:05.539000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "It is tempting, but with the way things currently work I'm pretty sure ignoring the late block makes it much more likely that your block gets orphaned because the late block always winds up with some attestations and so when compared to the next block which has none still winds up being the canonical head.  There's probably a way to do it but it's not as straight forward as just not building on the late block - you need to somehow adjust the fork choice weightings as well.",
        "created_at": "2021-09-10T21:59:00.511000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "This probably does not belong to this channel but is relevant to the discussion. One of the constants that I haven't seen discussed is the difference between 4 and 8 seconds. It seems to me that given the latency that we accept in the network, the distance between attestation and aggregation can safely be reduced. I tested this on pyrmont back when we were looking into the slot zero problem and wasn't penalized attesting at 6 seconds.",
        "created_at": "2021-09-10T22:00:05.667000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "And also there's the issue that late blocks may be coming from clustered pools so they produce it late and already has thousands of attestations when it comes out",
        "created_at": "2021-09-10T22:01:14.192000+00:00",
        "attachments": null
    }
]