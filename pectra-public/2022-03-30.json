[
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Will the El block until finishing validation in the canonical chain?",
        "created_at": "2022-03-30T00:02:35.054000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I'll have to check the spec, I think it would be a major liveness failure if it didn't as it could switch large numbers of nodes into optimistic sync at the same time.",
        "created_at": "2022-03-30T00:04:09.992000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I'll revisit this in a couple of days, what worries me is having two completely separate implementations of forkchoice that will behave differently, this may not be maintainable",
        "created_at": "2022-03-30T00:04:10.788000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Yes the EL MUST execute the block as part of engine_newPayloadV1 if it's extending the canonical chain:\n```\nClient software MUST validate the payload if it extends the canonical chain and requisite data for the validation is locally available. The validation process is specified in the Payload validation section.\n```",
        "created_at": "2022-03-30T00:05:15.491000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I  agree then that this can only be applied to changing forks and it's not so clear then if the target vote compensates the weight in the possible wrong fork",
        "created_at": "2022-03-30T00:09:59.601000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Cool.  Just note Paul's last comment above about erroring out before making any fork choice changes.  I have alarm bells ringing in my head based on your comments about timeouts - hopefully it's just my very limited understanding of what you're doing being wrong but it's worth being very careful about any fork choice changes prior to the EL responding.",
        "created_at": "2022-03-30T00:13:11.971000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yeah if we don't implement the SYNCING behavior is just a couple of lines to wait for newpayload before inserting in forkchoice",
        "created_at": "2022-03-30T00:14:35.243000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "There's no reason not to do it, I'll push that tonight",
        "created_at": "2022-03-30T00:15:01.181000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I was hoping to treat both cases the same way",
        "created_at": "2022-03-30T00:15:23.618000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "We all were and then Marius's fuzzer went and ruined everything by creating an execution payload where the block hash didn't match the actual block contents and it caused a chain split.",
        "created_at": "2022-03-30T00:16:09.652000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I don't think this is part of the suggestion but wanted to chime in while talking about timeouts. \n\n rejecting something that takes too long (thus looking like INVALID) is dangerous because given some crafted dos payload, I can try to play on that timeout due to variable execution times depending on hardware to split the network",
        "created_at": "2022-03-30T00:39:38.917000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "+1 - for teku if it times out or otherwise errors from the EL it just goes into the pool of blocks we periodically retry execution for.",
        "created_at": "2022-03-30T00:41:43.403000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yeah so this is even suggested in the specs, I wonder about this though, I do not know how the EL works, I suppose the EL will most probably keep the payload if it was valid, and on the CL side validation is quite fast. So what would happen if some future block builds on top of this one is that we will request the block again (assuming we didn't keep a cache) and call newPayload again and this time the EL will return VALID (or ACCEPTED)",
        "created_at": "2022-03-30T00:58:05.763000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Whatever it is, as long as the EL keeps the payload (which I do not know if it's the case, but assuming it is) then the heaviest part of that attack works only for one slot",
        "created_at": "2022-03-30T00:58:47.871000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Yeah I think its important that the EL continues processing the block even if the request times out and is capable of dealing with repeated requests from the CL efficiently (ie don't try to import the same block multiple times in parallel and cache the result in some way). Otherwise a block that's slow to import will break the node.",
        "created_at": "2022-03-30T01:00:32.222000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "In Lighthouse we're currently dealing with the edge case of producing proposer preparation data (`PayloadAttributes`) for the \"transition block\" (the first beacon block containing a non-empty `ExecutionPayload`). Whilst we're doing a best-effort to provide preparation data for this scenario, it's fairly tricky since the TTD block can arrive at the EE at anytime and we're not using subscriptions to be alerted of each block. It's going to be rather tricky to ensure this works properly, since it's a bit racey and only *maybe* happens once per testnet!\n\nThis edge-case, plus some other possible post-transition edge-cases with beacon chain reorgs, makes me wonder if all EEs are OK to produce a payload *with no lookahead*? I understand the payload might have a sub-optimal (or empty) transaction set, but I'm thinking that we could get ourselves into trouble if EEs can't produce something with no notice.",
        "created_at": "2022-03-30T05:38:01.306000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "For example, I think it would be bad if EEs had some sort of logic that said \"i didn't get more than *n* seconds lookahead so i'm going to return an error\".",
        "created_at": "2022-03-30T05:39:13.451000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "According to the spec EL should respond to `getPayload` immediately but the build process should start with preparing an empty payload to have something to return if `getPayload` comes shortly. Actually, it requires blocking `getPayload` call processing until empty payload is ready, not sure how it's implemented in EL clients though. And this scenario rather needs to be fuzzed",
        "created_at": "2022-03-30T08:49:05.641000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "re: timeouts\n\nSuppose there is an exhaustion attack and every payload contains at least one exhausting transaction because they are being constantly sent to the mempool. In this case if processing time of exhausting transaction exceeds the timeout then no payload will be processed and we will have a liveness failure, even if EL continues to process a payload in the background when timeout is exceeded it won't be able to notify CL when payload processing has finished. Thus, CL will not apply *any* block that has such a transaction.\n\nIMHO, the timeout should be pretty high, something like seconds per *epoch*. Because if payload execution takes more than an epoch it breaks Casper FFG synchrony assumption and we're in a bigger trouble then.",
        "created_at": "2022-03-30T09:04:49.177000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Do I understand correctly that timeouts are only meaningful for HTTP, for Websocket there should be no timeouts at all?",
        "created_at": "2022-03-30T09:06:07.094000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I am thinking about this requirement a bit more. And there is an edge case when it may not work as expected:\n```\nA \u003c- B\n \\\n  \u003c- B'\n```\nConsider below message flow applied to the above chain:\n```\n1) newPayload(A) \u003c~ VALID\n2) fcU(A) \u003c~ VALID\n3) newPayload(B) \u003c~ VALID (extends the canonical chain)\n4) MISSED fcU(B) -- the message has been missed for any reason\n5) newPayload(B') \u003c~ ACCEPTED (extends the canonical chain but there is no state available to validate a payload)\n```\nI think this edge case shouldn't affect the situation that you guys have been discussing above. The next `fcU` call will either designate `B` or `B'` as the head and it will either be responded with `VALID` or `SYNCING` depending on the client implementation. For instance, `fcU(B')` may return `VALID` if a shallow-state EL client (a client that keeps only one state version) is optimised for short-range re-orgs, or `fcU(B')` may return `SYNCING` if a shallow-state client doesn't implement any short-range re-org optimisation.\n\ncc \u003c@!755590043632140352\u003e",
        "created_at": "2022-03-30T09:17:26.936000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I'm not sure the missed fCU makes any difference there. The EL has effectively updated it's state as part of the newPayload(B) call anyway, otherwise it would still have the state from A and would be able to apply B' immediately.",
        "created_at": "2022-03-30T09:22:38.418000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yes, you're right. Even, though, `B'` wins afterwards, if `A` were the head and `B` were imported before `B'` then it becomes the head for at least a short period of time.",
        "created_at": "2022-03-30T09:27:12.958000+00:00",
        "attachments": null
    }
]