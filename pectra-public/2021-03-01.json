[
    {
        "author": "holgerd77",
        "category": "general",
        "parent": "",
        "content": "Just wrapping my head a bit around the question how an eth1 client will get its state (assuming that this is included in this beacon block `executable_data` (or similar) field, some possibilities I can think of:\n\n1. Does this needs to be requested from the eth2 client via RPC (respectively is pushed from the eth2 client)?\n2. Do both clients share the same DB or both need to keep in sync with the beacon chain state (likely not I would suppose)?\n3. Or do we assume everything (on the eth1 side) to be stateless already so that this problem - somewhat - will go away?\n\nðŸ¤”",
        "created_at": "2021-03-01T23:04:54.981000+00:00",
        "attachments": null
    },
    {
        "author": "holgerd77",
        "category": "general",
        "parent": "",
        "content": "(generally: if someone has already some bigger picture on client responsibilities and execution flows and is able to compose some kind of diagram out of this this would be really helpful)",
        "created_at": "2021-03-01T23:06:23.454000+00:00",
        "attachments": null
    },
    {
        "author": "holgerd77",
        "category": "general",
        "parent": "",
        "content": "Ah, sorry, just stumbled upon https://ethresear.ch/t/eth1-eth2-client-relationship/7248\n\nWill give this a read first.",
        "created_at": "2021-03-01T23:15:55.097000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e Yeah, the 13s block time \"invariant\" has been broken many times before, with ice ages, uncle rate changes and formula changes",
        "created_at": "2021-03-01T23:35:25.310000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e Just look at the chart: https://etherscan.io/chart/blocktime",
        "created_at": "2021-03-01T23:35:56.818000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "In the purest form of the split\neth2-client: pos consensus \neth1-client: application layer\n\nthe application layer client (eth1-client) manages the application layer state as it does today and just gets directives (e.g. verify and insert this application-layer block payload, give me a application layer payload (TXs), reorg to this head, etc) from the consensus client (eth2-cleint). These directives come with whatever bits of consensus state (beacon chain state) that it needs to verify/execute things (e.g. maybe the RANDAO for the randomness opcode and BEACONROOT for other beacon accessor opcodes, etc)\n\nIn a stateful model (i.e. like today), the eth1-client is stateful and manages the full application layer state by itself. In a stateless model (maybe of the future), the requisite state and witnesses would be part of the `executable_data` payload (likely to be remained `application_payload` or something)\n\nThe eth1-client manages the application layer state and is *directed* by the eth2-client about new blocks, reorgs, and finality (for pruning)",
        "created_at": "2021-03-01T23:39:41.397000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": ".\nSo consensus client (eth2) manages beacon state. Application layer client (eth1) manages application layer state with directives from consensus about the head. Anything the application layer needs to know about the beacon chain is provided along with the `executable_data`",
        "created_at": "2021-03-01T23:40:39.693000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": ".\nAs for state sync to initially get that application layer state. In the purest  and simplest form of the split, the application layer chain is actually maintained as a subset of the beacon chain (built by components of `executable_data`). With the application layer chain still existing, the eth1-client  can perform fast state sync (and block state sync) exactly as it does today with the same network protocols. Leaving the notion of the vestigial eth1 block also leaves most application RPC calls entirely unchanged which is pretty nice.\n\nThis minimal version is the first thing being spec'd and prototyped. At the same time, we are investigating versions of the merge that do some more in depth surgery that might be *cleaner* from a design perspective but require more work on modifying eth1 clients and RPC endpoints",
        "created_at": "2021-03-01T23:45:22.539000+00:00",
        "attachments": null
    }
]