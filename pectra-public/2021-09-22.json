[
    {
        "author": "mariusvanderwijden",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "QQ: We have two calls `engine.consensusValidated()` and `engine.forkChoiceUpdated()` which both can mark a blockhash as valid.\nDo we require every block to be marked valid by consensusValidated? Or do we mark all previous blocks as valid if we receive either conValid or forkChoice for a block? Do we require conValid before we can call forkChoiceUpdated?",
        "created_at": "2021-09-22T10:00:42.862000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!203220829473996800\u003e could we currently use `selector=100` for legacy transactions for the beacon chain?",
        "created_at": "2021-09-22T10:09:56.622000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I am going to simplify this part of the spec (of the EIP-3675 in particular) as we will have sequential message ordering which gives us guarantee that conValid always precedes forkChoice in a normal case and conValid for parent precedes conValid for a child. I think it makes sense to have it implemented with this guarantee in mind.\n\nBut we should handle failures somehow, right? When a message has been missed and another message which depends on the missing one arrives. Like forkChoice arrives after the had has received conValid. I would explicitly respond with error to avoid hindering communication issues between consensus and execution.",
        "created_at": "2021-09-22T10:17:51.086000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "With some modifications in the SSZ library to be more explicit about selector -\u003e type mappings, yes. Right now it's just starting from 0 and upwards.",
        "created_at": "2021-09-22T12:43:24.059000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That said, the transaction types have IDs 1 and 2, and I was under the impression that 0 was left to identify the legacy case.",
        "created_at": "2021-09-22T12:43:52.721000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So I mirrored that in the proposal, and I think many other people also consider 0 to be the legacy case",
        "created_at": "2021-09-22T12:44:35.705000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Splitting legacy into multiple new types on the consensus layer, and not mirroring that on the execution layer, is very messy IMHO.",
        "created_at": "2021-09-22T12:45:03.462000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "At that point I would rather not have the `Union` at all",
        "created_at": "2021-09-22T12:45:54.062000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e May have `None` as first type option, i.e. selector == 0\nDoes it make sense to use `None` instead of `TransactionType(0)` in the beacon chain to handle the `LegacyTransaction` case which effectively has no type, i.e. the type is `None`?",
        "created_at": "2021-09-22T12:47:13.876000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh, sorry, this is a `None` value. Nevermind",
        "created_at": "2021-09-22T12:48:37.992000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You mean `Transaction = Union[None, Eip2930Payload, Eip1559Payload]` ? Then the legacy transaction payload is not encoded at all anymore, that seems wrong yes",
        "created_at": "2021-09-22T12:48:58.116000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "What if we not use `0` and instead have `3` and `4`  as identifiers for new transaction types?",
        "created_at": "2021-09-22T12:49:37.487000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Then we need an EIP to mirror that on execution layer",
        "created_at": "2021-09-22T12:50:17.419000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "My intention was that to try mirror the EIP-2718 types as closely as possible, so we can use the EIP 2718 encoding as a natural way to translate the union contents into. I.e. no new EIPs",
        "created_at": "2021-09-22T12:51:31.292000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I meant that we will use these ids in the planned EIP, skipping `0` id at all",
        "created_at": "2021-09-22T12:51:33.309000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Right now the `Transaction = Union[OpaqueTransaction]` is just flawed, as there is no way to translate any additional future type parameter of the `Union` into a payload that fits into the API / execution layer without breaking changes",
        "created_at": "2021-09-22T12:52:57.687000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So either we should mirror EIP-2718, and not try to come up with additional types, or not do the `Union` thing at all",
        "created_at": "2021-09-22T12:53:46.301000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If type ID `0` is not actually the legacy type, then I don't know what it's supposed to be, and I'd rather not do `Union` at all",
        "created_at": "2021-09-22T12:54:27.100000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If we introduce 3 and 4 on the consensus layer before the execution layer with proper EIP, then we're just very likely to diverge, and make things even more complicated",
        "created_at": "2021-09-22T12:55:38.867000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I agree with not doing this right now. I am trying to understand why can't we avoid using `0` as one of the new transaction types in the future EIP that \u003c@!301186049323958275\u003e has mentioned. Can we use `3` and `4` instead of `0` and `4`, if we agree around this then we can rely on it and use `selector == 0` for legacy transactions. I guess `LegacyTransaction` and these new types will need to co-exist for some period of time after the hard fork that deprecates `LegactyTransaction` and substitutes it with these new types, from this standpoint having `0` identifier for legacy transactions does also make sense.",
        "created_at": "2021-09-22T13:02:04.401000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In the execution layer legacy transactions do not have a type.  They are *not* type 0.",
        "created_at": "2021-09-22T15:01:43.953000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This was the original proposal for creating typed wrappers for legacy transactions: https://eips.ethereum.org/EIPS/eip-2972",
        "created_at": "2021-09-22T15:04:09.654000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That EIP was withdrawn because we weren't planning on launching it right away, but no reason not to implement it in the future (with updated numbers, maybe 3,4).",
        "created_at": "2021-09-22T15:11:44.439000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!425572898787426305\u003e Regarding the type `QUANTITY`, should they be marshalled to hex strings or as raw numbers in the API?",
        "created_at": "2021-09-22T15:11:51.332000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We usually use hex strings for numbers in eth1's json-rpc",
        "created_at": "2021-09-22T15:12:46.173000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "They should be HEX strings as per Ethereum JSON-RPC spec. big-endian, right?",
        "created_at": "2021-09-22T16:45:13.663000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I am advocating for 3, 4. Some selector value is required to handle `LegacyTransaction`, `selector = 0` is a special case in terms of encoding, transaction object with this selector is encoded as legacy transaction rather than `TransactionType || ...`",
        "created_at": "2021-09-22T16:50:03.204000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If we do wrapped legacy transactions we don't need a special case for legacy transactions anymore.",
        "created_at": "2021-09-22T16:51:50.421000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "it seems that confusion is coming from this line\n\u003e *Note:* Fields having `QUANTITY` type are serialized in big-endian.\nWill explicitly mention HEX string here",
        "created_at": "2021-09-22T16:52:00.305000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This is true but we can't do this right now as execution layer doesn't support these new wrappers",
        "created_at": "2021-09-22T16:52:41.689000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Option 1 in \u003chttps://github.com/ethereum/consensus-specs/issues/2608\u003e would make that not matter.",
        "created_at": "2021-09-22T16:54:28.383000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Same with option 2.",
        "created_at": "2021-09-22T16:54:42.318000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Option 2 would require pushing EIP-2972 through, but that seems like a rather small thing relative to adding SSZ support to the execution clients.",
        "created_at": "2021-09-22T16:55:34.888000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e Translate EIP-2718 transaction IDs into the Union type, and translate back before insertion into execution layer\n\nTo be precise, It should say: \n\u003e Translate EIP-2718 transaction IDs into the Union type, and translate back before insertion into execution layer except for union `selector = 0` which is used to handle legacy transactions and must be excluded from the space of transaction type values",
        "created_at": "2021-09-22T16:57:25.845000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "```\nTransaction = Union[{\n  EIP_2930_TRANSACTION: TransactionPayload,\n  EIP_1559_TRANSACTION: TransactionPayload,\n  MULTI_CHAIN_TRANSACTION: TransactionPayload,\n  SINGLE_CHAIN_TRANSACTION: TransactionPayload,\n\n  FUTURE_FOOBAR_TRANSACTION: FooBar,  # extension for illustration\n}]\n```",
        "created_at": "2021-09-22T16:57:50.948000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If you have to run things through an adapter it is trivial to adapt `[3].payload` to `payload`.",
        "created_at": "2021-09-22T16:58:30.241000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In fact, even easier than converting `[2].payload` to `2 || payload`.",
        "created_at": "2021-09-22T16:59:12.097000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We could propose that 2972 be pushed through as part of The Merge.  It *feels* like that is the right solution.",
        "created_at": "2021-09-22T17:00:24.745000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "As I mentioned previously, 2972 was dropped because it added a tiny bit of complexity and without changing gossip it didn't provide any significant value.  With The Merge, that calculus changes as consensus clients don't have legacy baggage and it would be better to do things right from the start because changing later is much more expensive than just doing it right in the first place.",
        "created_at": "2021-09-22T17:01:24.293000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Where \"right\" here means everything is a typed transaction.",
        "created_at": "2021-09-22T17:01:30.708000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I see, would we need to support legacy transactions for some period of time to allow for smooth transition to the stage where only typed transactions are valid?",
        "created_at": "2021-09-22T17:12:21.491000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It depends on how much of ☝️ we want to do.",
        "created_at": "2021-09-22T17:30:54.637000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If we go with Option 1 from \u003chttps://github.com/ethereum/consensus-specs/issues/2608\u003e then we can do only (4).  If we go with Option 2 then we could still do only (4) from that list plus add in one for \"add wrapped legacy transaction adapter to consensus API client\".",
        "created_at": "2021-09-22T17:32:25.205000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Really the only difference between option 1 and option 2 is just whether the adapter is in the consensus client or the execution client.",
        "created_at": "2021-09-22T17:33:01.541000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In either case, we can have wrapped legacy transactions everywhere in the consensus client *except* between that adapter and the wire, or (if we go with option 2) everywhere in the consensus client entirely.",
        "created_at": "2021-09-22T17:33:41.981000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I have a *weak* preference for putting the adapter in the execution client, but I can appreciate why some may not like that since I think it involves putting SSZ into the execution clients.",
        "created_at": "2021-09-22T17:34:06.354000+00:00",
        "attachments": null
    }
]