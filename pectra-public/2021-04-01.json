[
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "I added a bit of a \"glossary\" to the beginning of the document to try to make sure that we all speak the same tongue, feel free to improve upon that.",
        "created_at": "2021-04-01T08:31:44.880000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "not exactly sure about the \"backward\" sync proposal for the POW part of the chain, in turbogeth we tried that and apart from more complicated code we didn't find any benefits in perf or safety.\nin the end, you still have the root hash of the last POW block to check, and for that you need to execute all blocks before that and the biggest issue is what to do if it doesn't match the expected value",
        "created_at": "2021-04-01T08:33:18.386000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "thanks a lot for your contribution!",
        "created_at": "2021-04-01T08:54:23.532000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "It could be a hybrid forward+backward sync process. I see it in the following way. Forward sync starts to work as usual with ethash verification and at the same time headers are being downloaded from the head down to genesis. Backward header sync stops when it meets the first header the node is familiar with (that has been downloaded by the forward part). And then the process goes as usual. \n\nThis is just more complicated in terms of implementation and would require forward sync to check ethash until the moment the two syncs converges. Though, the forward part may sync optimistically without verifying ethash and then jump off to the canonical chain if it followed the wrong fork.",
        "created_at": "2021-04-01T08:59:57.803000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "Yeah, turbo-geth basically right now downloads all the headers it can, forward, all the forks, etc, and follows the longest-chain rule. All the headers that are non-canonical are still stored but \"banned\".\n\nIf hash of the tip doesn't match, we ban this header and try to go back to search for the other ones. That way ethash is always verified, but sometimes we need to rollback (but very rarely in practice)",
        "created_at": "2021-04-01T09:04:13.348000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "you potentially might have \"checkpoints\" along the way to simplify that, because the chain is immutable",
        "created_at": "2021-04-01T09:04:48.166000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "maybe not very pretty and dynamic, but that should work",
        "created_at": "2021-04-01T09:05:06.670000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "The game changer in terms of sync and chain management after the merge is the proof of the head of the chain that is available before the chain is fully downloaded. We should leverage on this new knowledge",
        "created_at": "2021-04-01T09:06:50.510000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "true, I have nothing against that, but you will have to sync both forward and backward before the hardfork happens, if I understand correctly",
        "created_at": "2021-04-01T09:09:20.183000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "e.g. if our hardfork is at block 14.000.000, before that POW node should just work as usual",
        "created_at": "2021-04-01T09:09:40.194000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "or is the consensus on which block is the first POS block will happen somehow dynamically?",
        "created_at": "2021-04-01T09:10:08.363000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "unlike, say Berlin or whatever hardfork when the block number is basically hardcoded",
        "created_at": "2021-04-01T09:10:32.054000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Total difficulty is chosen as a transition condition. So, strict block number will be available once transition block is finalised. There could be a check that block at this particular height has particular hash (like for the DAO hardfork).\n\nThe client syncs as usual unless transition is happened. The question is how do client with transition process onboard bootstraps after the merge has happened. I think it could do this without and explicit knowledge of whether transition is already passed or not and adjust accordingly by listening to consensus-layer messages. Though, it will impact state downloader bootstrap which is based on the `Status` message, I don't see any specific issue with that but need to think that through",
        "created_at": "2021-04-01T09:21:42.740000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "okay, so there isn't a risk in this schema so some nodes that are up to date but with no consensus counterpart will go \"rogue\" and keep doing the POW chain?",
        "created_at": "2021-04-01T09:24:27.005000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "aka, if the block num is hardcoded they will just error out",
        "created_at": "2021-04-01T09:24:41.673000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "\"please, add a consensus node to continue syncing\"",
        "created_at": "2021-04-01T09:24:55.129000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I think that once the transition is finalised the application clients will be updated and won't start any activity until get corresponding signal from consensus counterpart. But there will be a period when software starts working in a PoW mode and then switches to PoS mode upon receiving consensus messages. And I think it could be designed in a way that makes it possible to recover if such byzantine scenario takes place",
        "created_at": "2021-04-01T09:30:49.192000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "I'm still not exactly sure why is it based on the consensus message and not on a block number/TD in the application node... I am probably missing something there",
        "created_at": "2021-04-01T09:33:37.432000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "We really want to have application block header fields and its hash on the beacon chain in SSZ structures to be able to read them and build proofs linked to beacon state/block roots. We could start from an RLP byte string in a block but then it should be turned into SSZ on the consensus side. Current proposal is to SSZ it from the beginning as it doesn't look too complicated to be done.",
        "created_at": "2021-04-01T09:34:47.675000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Probably we can jump on a quick call?",
        "created_at": "2021-04-01T09:36:49.129000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "sure, here in discord works",
        "created_at": "2021-04-01T09:37:00.622000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "yep",
        "created_at": "2021-04-01T09:37:08.593000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Correct, transaction fees goes to the `coinbase`, proposer rewards are issued on the beacon chain. Validator withdrawals are not planned to be shipped along with the consensus upgrade.\n\nThe most recent withdrawals proposal is here: https://ethresear.ch/t/simple-eth1-withdrawals-beacon-chain-centric/8256\nThe prototype of this proposal is here: http://github.com/zilm13/withdrawal-simulation\n\u003c@!425907307621122049\u003e (my teammate) is working on this prototype.\n\nIn a few words. There is a withdrawal receipts tree on the beacon chain. A contract (probably a system contract) accepts withdrawal receipt with a proof linked to beacon block root, verifies it with `BEACONBLOCKROOT` opcode, wastes the receipt and issues ETH to the eth1 address specified in withdrawal credentials.There are various implications regarding how the contract issues ETH (`MINT` opcode or it's pre-mined with decent amount of value).",
        "created_at": "2021-04-01T10:28:15.569000+00:00",
        "attachments": null
    },
    {
        "author": "karim.dev",
        "category": "general",
        "parent": "",
        "content": "Can I get a link to the meeting please?",
        "created_at": "2021-04-01T10:54:53.591000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Is there a live broadcast? I would want to watch without participating if possible",
        "created_at": "2021-04-01T10:59:37.121000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "The link will be dropped here a few minutes before the call. There will be no livestream but the call will be recorded",
        "created_at": "2021-04-01T11:07:37.442000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Call in 1 hour",
        "created_at": "2021-04-01T11:59:14.378000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "There can be a rogue PoW chain but the software that chooses to follow PoS\n(1) during the transition would favor it as the head compared to PoS blocks after the TD threshold\n(2) after finality of anything on the PoS chain after transition would never consider any forks on the legacy PoW portion of the chain. This stretch would forever be a single chain with no possible changes. So historic sync on that stretch is just a chain. Similarly, when the pos chain tells the application-layer a head to sync to, this also can be done at a recent point of finality and thus restricts sync to be a chain and not have any forks. Thus the backwards sync works particularly well for *headers*",
        "created_at": "2021-04-01T12:26:36.648000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yep, it makes sense for headers downloader to wait for the first finalized block while the state one may get started with the first new head message",
        "created_at": "2021-04-01T12:37:42.709000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "right, but I think it makes sense for beacon node to wait until the first embedded block is voted enough before sending `NewHead` message to the application-layer to get the guarantee that the block is correct",
        "created_at": "2021-04-01T12:39:19.374000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "but then who produces the first block, or app nodes sync up to a certain hardcoded TD and they just wait for the consensus nodes?",
        "created_at": "2021-04-01T12:45:34.988000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "so potentially during the transition n-1 node will sooner or later get `newBlock` and 1 node -- `assembleBlock`",
        "created_at": "2021-04-01T12:46:18.288000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Long before TD is hit, mainnet nodes run the adjunct beacon chain which has validators waiting for the TD trigger",
        "created_at": "2021-04-01T12:46:38.568000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e At that point validators include application payload on their beacon blocks and the transition happens without downtime",
        "created_at": "2021-04-01T12:47:08.627000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Call in 10 minutes\nZoom: https://consensys.zoom.us/j/91606229416",
        "created_at": "2021-04-01T12:50:42.431000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "Okay, so everything is initialized by a consensus node",
        "created_at": "2021-04-01T12:51:47.636000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "right, but the application-layer is running the rules prior to the merge so that at the merge point, it is ready to switch to listening to the beacon chain",
        "created_at": "2021-04-01T12:53:49.358000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "so both nodes should be aware of the TD limit, for one to be \"ready\" and for the other to actually send events",
        "created_at": "2021-04-01T12:56:06.436000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "One should be ready by default once the version of client with transition process is launched",
        "created_at": "2021-04-01T12:57:14.347000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "\u003e right, but the application-layer is running the rules prior to the merge so that at the merge point,\nokay, so maybe I misunderstood something in this message",
        "created_at": "2021-04-01T12:57:57.637000+00:00",
        "attachments": null
    },
    {
        "author": "maxvoltage.",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425572898787426305\u003e was the merge call streamed via youtube?",
        "created_at": "2021-04-01T13:50:55.420000+00:00",
        "attachments": null
    },
    {
        "author": "maxvoltage.",
        "category": "general",
        "parent": "",
        "content": "Is it possible to make the call available via replay from Zoom?",
        "created_at": "2021-04-01T13:53:49.121000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "general",
        "parent": "",
        "content": "i think its being recorded but not streamed",
        "created_at": "2021-04-01T13:56:51.587000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "yes, it was just also answered in the \u003c#598292067260825641\u003e channel. Recording, no stream",
        "created_at": "2021-04-01T13:57:12.356000+00:00",
        "attachments": null
    },
    {
        "author": "maxvoltage.",
        "category": "general",
        "parent": "",
        "content": "\u003c@!520564582196969472\u003e thanks.  Tim said he will upload it to youtube later today.",
        "created_at": "2021-04-01T13:57:25.379000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "I don't think even that is necessary; and if we do that then it would actively mislead clients for a short duration because they would think that some not-actually-canonical PoW chain is the head",
        "created_at": "2021-04-01T14:03:34.595000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "The *expected case* (\u003e80% probability) is a totally smooth transition where the first time a beacon block contains an embedded application block that just ends up being part of the canonical chain",
        "created_at": "2021-04-01T14:04:17.878000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I agree with this. Any valid PoS block built on top of the TD pow difficulties does win the fork choice over pow blocks so it should be signaled as soon as possible as such",
        "created_at": "2021-04-01T15:27:28.943000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Here is the link: https://youtu.be/b3hfgLa_GHw",
        "created_at": "2021-04-01T15:31:59.688000+00:00",
        "attachments": null
    },
    {
        "author": "maxvoltage.",
        "category": "general",
        "parent": "",
        "content": "Thanks.",
        "created_at": "2021-04-01T15:32:12.323000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "FYI, i have restricted the access to the doc https://hackmd.io/@n0ble/ethereum_consensus_upgrade_mainnet_perspective\nIf anyone want write access, please, DM me",
        "created_at": "2021-04-01T16:42:33.906000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "general",
        "parent": "",
        "content": "Ah gotcha.  That does make it tricky.  I wonder if we can embed the SSZ hash of the block in one of the now unused eth1 fields?  Like set `nonce` to `hash(SSZ BlockHeader w/ nonce field set to all zeroes)`.  That way there's some binding between the SSZ and RLP hashes.  Caveat: I'm not familiar with SSZ encoding or what hashing algorithms are used in eth2 so fully recognize I might be totally off base here, gonna go read up on SSZ and its use in eth2 now.",
        "created_at": "2021-04-01T23:40:55.264000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e Sorry what problem is this addressing?",
        "created_at": "2021-04-01T23:44:36.964000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e (did I miss some earlier message?)",
        "created_at": "2021-04-01T23:44:48.701000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "general",
        "parent": "",
        "content": "It's more likley I'm missing something. ðŸ™‚ If the beacon chain needs block header in SSZ format but the application layer BlockHash is in `keccak(RLP)` format how do the two sides know that they are referring to the same block?",
        "created_at": "2021-04-01T23:51:02.269000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e You can convert from SSZ to RLP",
        "created_at": "2021-04-01T23:53:54.423000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "general",
        "parent": "",
        "content": "Ah ok, ya that makes sense.  Nevermind!",
        "created_at": "2021-04-01T23:54:52.896000+00:00",
        "attachments": null
    }
]