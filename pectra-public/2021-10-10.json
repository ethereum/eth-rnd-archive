[
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "SSZ in the consensus layer is little-endian, the execution layer is big endian based",
        "created_at": "2021-10-10T12:25:11.052000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Idea is to have fields in ExecutionPayload map as tightly as possible to the fields that are required for execution and hashing on that layer\n\n`base_fee_per_gas` is a bit ugly due to the mixed endianness across layers but since computations are not required on CL, we keep it in the encoding of EL to avoid having to translate whne crossing CL\u003c-\u003eEL boundary",
        "created_at": "2021-10-10T12:27:09.115000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The network protocol *should* be big endian, as that is a pretty ubiquitous standard for Network Byte Order.",
        "created_at": "2021-10-10T12:29:56.245000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003cvbuterin\u003e hmm I'd rather ethereum eventually move toward consistently having one endianness throughout, though I realize that that would require a new ABI and is generally difficult to accomplish....",
        "created_at": "2021-10-10T12:39:22.815000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003cvbuterin\u003e I guess for a minimal merge we're going to have lots of these hacks and that's unavoidable",
        "created_at": "2021-10-10T12:39:45.791000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If you want one endianness throughout, Big Endian is recommended because that is *effectively* the standard for network protocols.",
        "created_at": "2021-10-10T12:40:00.703000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think we should have a very good reason for deviating from industry standards.",
        "created_at": "2021-10-10T12:40:15.084000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Calling in \u003c@!449019668296892420\u003e who convinced CL to go with little-endian. Apparently almost all processors are optimized for little endian these days.\n\nthat said, I believe libp2p is big-endian so the networking messages are in fact as you'd like to see them. Just when you parse the payloads you utilize SSZ and that schema is little endian",
        "created_at": "2021-10-10T12:43:22.633000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, little endian is the most common at the hardware level.  But nearly the whole of the public internet uses big endian for wire format.",
        "created_at": "2021-10-10T12:43:51.197000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So you are trading some amount of speed (I suspect almost none) for breaking expectations of all future developers.",
        "created_at": "2021-10-10T12:44:06.907000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hmm, can you clarify that last bit a bit?  I'm confused by it.",
        "created_at": "2021-10-10T12:44:28.919000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Are you saying that the envelopes are big endian but the payloads are little endian?",
        "created_at": "2021-10-10T12:44:46.184000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yes, the envelopes and general networking protocol of libp2p uses big-endian. but this is at a separate layer to the payloads. The payloads are most often just typed SSZ payloads where the schema is known a-priori.\n\nThe mismatch between these layers has zero interaction",
        "created_at": "2021-10-10T12:48:59.007000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Sure.  It is still unfortunate that bytes on the wire are in a non-standard format.",
        "created_at": "2021-10-10T12:51:28.713000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The common paradigm is that if it touches a network it is big endian byte order.  Little endian is used for in-memory or on-disk if the associated hardware executing the code is little endian.",
        "created_at": "2021-10-10T12:52:18.977000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The reason for this standard is so that when someone sits down to work on some code that they are otherwise unfamiliar with, they are much more likely to get it right on the first try.  By putting little endian bytes on the wire, it is more likely that someone will introduce a bug into some code at some point because their expectations aren't met.",
        "created_at": "2021-10-10T12:53:22.058000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I know I'm likely shouting into the wind here since I suspect no one is up for changing it at this point.  It is just frustrating to see yet-another little thing that we are going to be paying for for years.  üò¢",
        "created_at": "2021-10-10T12:54:04.546000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I hear you, but have to recuse myself from this debate. I do not have the requisite expertise or experience to make a compelling case one way or the other. It is a shame the two layers are of different endianness, but (1) fortunately, they are separate layers and (2) changing either would be difficult at this point",
        "created_at": "2021-10-10T12:56:00.190000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "little endian was chosen mainly because wasm is little endian - decoding from big to little would have cost lots of instructions in contracts, should they wish to interact with the format directly and perform arithmetic - likewise modern hardware in general, decoding and encoding is an unnecessary cost. it is true that _some_ internet protocols use big endian, specially at the lower osi levels and those that were developed when big-endian was dominant - application level protocols however use _anything that goes_ - there are as many varieties as there are protocol developers (text, binary, little, big, variable length, unix newlines, windows newlines, nulls etc etc etc) - libp2p in particular uses neither big nor little, though arguably it uses an encoding closer to little endian - varint - it's fact of life that encodings are like assholes, everyone's got their own - there's no such thing as an \"industry standard\" here",
        "created_at": "2021-10-10T13:20:56.745000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Claiming there is \"no industry standard\" here feels quite incorrect to me.  While there isn't a spec (that I know of) that asserts network byte order, the lower layers of the stack use big endian, and many low level languages (like C) have functions like `hton` functions which stands for (and is documented as) \"host to network\" and the \"network\" is defined as big endian and the \"host\" is defined as whatever the local platform order is.",
        "created_at": "2021-10-10T13:29:25.733000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm going to keep that last part as a quote for next time this inevitably comes up.",
        "created_at": "2021-10-10T13:29:54.840000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "While yes, there are people out there who ignore the defacto standard, I posit (strongly) that there *is* a defacto standard that most people (and many languages) expect.",
        "created_at": "2021-10-10T13:30:03.507000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For example: \u003chttps://linux.die.net/man/3/htonl\u003e\n\u003e On the i386 the host byte order is Least Significant Byte first, whereas the **network byte order, as used on the Internet, is Most Significant Byte first.**",
        "created_at": "2021-10-10T13:33:31.327000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'd be fine with uint64 instead of bytes32 for that field there if eth1 had an explicit enforcement against such high values. Without, it's just hoping nobody with very deep pockets screws with it.",
        "created_at": "2021-10-10T13:35:30.026000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, that I understand, but the choice of 32 bytes is what surprises me. And anyway if we choose an integral type it will merlkleize as 32 bytes little endian, just as is now in the merge spec",
        "created_at": "2021-10-10T14:32:52.537000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "lol, let's take a typical attestation - it begins it life as a mostly little-endian binary format (in the memory of the machine) - on encoding it to wire representation, it _mostly_ stays the same which is great - we can memory map and perform arithmetic without further conversion, _but_ one field is actually big endian (the signature) - then, it becomes decimal-encoded text with some splashes of hex - except it's all \"strings\" and not numbers - and we hit the big difficulty because in some languages it's hard to strip the 0x prefix or not, depending on who you ask - we're in newline separated land here, regardless, as far as framing goes - the windows kind - then it goes back to little endian/bigendina mix and we start massaging it, adding compression and envelopes - it's quite a good exercise in \"standard encodings\" üôÇ for example, we frame the ssz data with a \"varint\" length prefix - however, because we compress it with snappy no little-endian bytes actually travel on the wire - snappy _also_ has a varint length prefix, the same one repeated - then another one for gossip - gossip are varint-lenght-prefixed as well - then, we add an mplex header - again a varint length prefix - then we add a noise prefix - this one is big endian (we're still in libp2p here, so libp2p itself is a happy mix) - we're now down to tcp level and here, as we all know, big endian is the thing - now reverse everything on the other end - you quickly come to realise that at every level of the stack, you actually need to know what you're encoding but one thing is certain: it's massively convenient to not have to do anything at the ssz level, in actual clients on actual hardware.",
        "created_at": "2021-10-10T14:36:48.720000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't know what is the way that eth1 specification works but the EIP states that field as an `int`, whatever that means (as int in itself is not specified).  I suppose this should be specified on eth1 and then execution clients should enforce that limit. The thing is that this is naturally an arithmetic type and we want clients to be secure in their modular arithmetic. I think all types that are going to be used in arithmetics should be an arithmetic type and not a bytes type, so that clients know unequivocally what is their overflow limit",
        "created_at": "2021-10-10T14:41:48.432000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "indeed - the only time you ever use these functions is when interacting with bsd sockets - otherwise, you're in application land, and again, here, anything goes, whatever is most convenient for your application - coming back to the wasm point, wasm itself chose little endian _even though_ it's mostly a network / internet standard because the benefits outweigh the potential for confusion - now, at the time, we still had hope we'd get rid of this funny idea of a 256-bit VM but alas, the path we're on takes us into a world where we run two network stacks, with two RPC protocols, two representations and two of pretty much everything. we'll see - I'm hoping for a cleanup merge, but .. er .. well, they say hope is the last thing that leaves you.",
        "created_at": "2021-10-10T14:42:01.352000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This feels like an argument that \"everything is bad, so we shouldn't bother trying to fix any of it\" which IMO isn't a particularly strong argument.  We should fix the places we can, and try to avoid making the situation worse.",
        "created_at": "2021-10-10T14:45:40.514000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "the point is more that \"fix it\" is different depending on who you ask - someone more familiar with 70's internet protocols or someone accustomed to .. er, post-y2k hardware and the realities of modern virtual machines, or someone that worked at google (where all the varints come from, because they like protobuf over there)",
        "created_at": "2021-10-10T14:50:17.761000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "somewhat amusingly, at the time, the strongest argument _was_ \"we're fixing it\" (by aligning it with relevant standards)",
        "created_at": "2021-10-10T14:51:23.642000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I definitely understand that this debate is about \"what is best for Ethereum\", and I understand that not everyone agrees at the moment.  I'm arguing that following established standards here outweighs the benefits provided by being hardware native.",
        "created_at": "2021-10-10T14:51:28.635000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "More specifically, aligning with developer expectations is more important in this case than the performance gains to be had.",
        "created_at": "2021-10-10T14:52:10.703000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003cdankrad\u003e I would personally have much preferred big endian. little endian is little more than a screwup intel made in the 70s and everyone has to follow. but seems too late now",
        "created_at": "2021-10-10T14:52:29.864000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "well, we _are_ aligning it with developer expectations - just not the same developers as you're referring to üôÇ the _most_ relevant standard at the time was wasm and the hardware that actually runs the thing, where this data in particular is used - the network doesn't really care about it so what the tcp/ip standard is is only moderately interesting",
        "created_at": "2021-10-10T14:53:53.938000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "anyway, time for üçø",
        "created_at": "2021-10-10T14:54:42.183000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@555483069038198827\u003e maybe not - you can still take back the world just like the unix newline won over the windows one, even though the latter was quite dominant at some point",
        "created_at": "2021-10-10T14:55:59.681000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "bad news would be that ARM nowadays also is little endian, meaning big endian is mostly a thing of dinos that people have to learn about to deal with those pesky network protocols",
        "created_at": "2021-10-10T14:57:18.312000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003cdankrad\u003e when eth2 is finished and post quantum and all vms are snarked this will be my battle",
        "created_at": "2021-10-10T14:57:47.424000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003cdankrad\u003e and my twitter bio will be \"I restored the natural byte order in eth2\"",
        "created_at": "2021-10-10T14:58:14.696000+00:00",
        "attachments": null
    }
]