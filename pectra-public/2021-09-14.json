[
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Regardless of who sets the field, I think `coinbase` is a poor name as it doesn't give any indication of whose address it is.  I think it has never been a good field name, ever since it was added in Bitcoin.  The \"owner\" of that field is now changing, so now seems like a good time to update the name to *something* reasonable.",
        "created_at": "2021-09-14T03:58:55.606000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "`fee_recipient` seems as accurate as anything...",
        "created_at": "2021-09-14T04:00:28.030000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "My opinion on this is that making the API field both optional and a suggestion gives us the most future flexibility.  Consensus clients can choose to allow for execution clients to respect it or not, and execution clients can choose to respect it or not when it is provided and can default it to something if it isn't provided.",
        "created_at": "2021-09-14T04:01:36.476000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "In my head, this doesn't add any meaningful complexity because the most naive implementation of a consensus client will just pass in the validator address and not check that the returned block used that, and the most naive implementation of an execution client will just use the provided address or a configured fallback.  In both cases, the naive implementation isn't made any harder by the API specification *allowing* overriding of that variable, and it leaves doors open for more clever designs in the future.",
        "created_at": "2021-09-14T04:02:59.672000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "You mean the VCs are also run by node operators? BN should proxy the field (whatever we call it) to the execution client while VC is the place where the value for this field should be configured. I am assuming the party that runs VC might be optional and depending on the pool design.",
        "created_at": "2021-09-14T05:16:50.117000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "\u003c@!784446040073175040\u003e are there node operators who run validator clients or validator owners?",
        "created_at": "2021-09-14T05:23:16.345000+00:00",
        "attachments": null
    },
    {
        "author": "jcrtp",
        "category": "general",
        "parent": "",
        "content": "In our case, a node operator runs a Beacon Client, a Validator Client, and is partially the owner of all of their validator keys",
        "created_at": "2021-09-14T05:24:55.361000+00:00",
        "attachments": null
    },
    {
        "author": "jcrtp",
        "category": "general",
        "parent": "",
        "content": "They split ownership with the deposit pool, since the deposit pool paid for half of the validator",
        "created_at": "2021-09-14T05:25:19.409000+00:00",
        "attachments": null
    },
    {
        "author": "jcrtp",
        "category": "general",
        "parent": "",
        "content": "At least, that's the intent - 0x01 ensures it for attestation and proposal rewards, 0x02 would have ensured it for priority fees (though the side channel / MEV problem precluded it)",
        "created_at": "2021-09-14T05:26:23.557000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I see. Thanks!",
        "created_at": "2021-09-14T05:27:36.218000+00:00",
        "attachments": null
    },
    {
        "author": "jcrtp",
        "category": "general",
        "parent": "",
        "content": "Many choose to run Execution Clients as well, though some prefer services like Infura or Pocket due to ISP issues",
        "created_at": "2021-09-14T05:28:16.548000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I see, when proof-of-custody for execution is introduced outsourcing execution payload verification will become slashable. With PoC for execution in the roadmap I doubt Infura or any similar 3rd party service that is trustworthy will spend cycles on providing payload verification as a service. There should be no other option for stakers to run their own execution client starting from the Merge. It could be, though, until the PoC is introduced but we strongly encourage everyone to avoid doing that as it impacts the security of the network.",
        "created_at": "2021-09-14T05:38:22.788000+00:00",
        "attachments": null
    },
    {
        "author": "jcrtp",
        "category": "general",
        "parent": "",
        "content": "I'll be keeping a very close eye on this as it develops then",
        "created_at": "2021-09-14T05:41:18.404000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Right, this is the main question: whether the given field is the *coinbase* (in-protocol beneficiary address) or might be used in another way. In the latter case the API  will use _SHOULD_ instead of _MUST_ wrt the action taken with the field value leaving us some future compatibility. If we're sure that there will be no case where this optionality might be utilized, i.e. might allow for a solution that is more optimal than in the case where we don't have such optionality, then I agree that the stricter the API is the better for implementations, configurations, spec and so forth.\n\n\u003e I either control that execution engine or not (proof of custody would make it so I must)\nYou must have a pocket execution client to verify the payload (i.e. to attest to it) but you may use an external one for the proposal.\n\n\u003e I still think that if a builder is added, it is 1. at another layer beyond the validators execution engine and 2. That a builder would naturally pay the requested coinbase and collect fees via other means as it is generically the simplest way for a proposer to assess value of block\nDoesn't collecting fees via other means create an incentive for side payment channels? It is easy to design the system when MEV goes to the coinbase because there is the corresponding opcode in the EVM. And if we have a complicated system of MEV extraction with searchers + builders (i don't know if it even make sense) then extracting MEV to the coinbase might be useful.",
        "created_at": "2021-09-14T07:21:45.522000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "The other potential way to reach this optionality is the following:\n- We say that `preparePayload` is used for literally building a payload and passing the value for the `coinbase` field of this payload, this method should be used with the execution client that is run by validator owner\n- Once block builders' concept is introduced to the network the new method should be added to the API, something like `buyPayload` which will have different semantics and potentially different field set\n- Consensus client will have and option for whether to buy or build a payload or do something in between depending on the state of the node and the network\n\nThe rationale behind standardasing the new method is reaching clients interoperability.",
        "created_at": "2021-09-14T07:21:48.550000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "cc \u003c@!385978868131168259\u003e \u003c@!301186049323958275\u003e",
        "created_at": "2021-09-14T07:22:38.693000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What I'm missing is what we gain by making the API more strict here.",
        "created_at": "2021-09-14T08:57:04.321000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What functionality or performance do we lose, what doors will be closed, or what technical complexity is introduced by including an optional feeRecipient field in the preparePayload and getPayload functions and leaving it up to the execution client to decide what to do with it.",
        "created_at": "2021-09-14T08:58:59.731000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I am thinking of the following alternative. 1) There is the `preparePayload` method which behaviour depends on the implementation e.g. one implementation builds the payload using its mempool when another one gets the payload from the market. 2) These two semantics are expressed with two different methods, e.g. `preparePayload` for the former and `buyPayload` for the letter. \n\nHaving a strict semantics sounds better from the design perspective but it adds the complexity of standardising and implementing new methods.",
        "created_at": "2021-09-14T09:09:44.376000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "I don't see having separate `preparePayload` and `buyPayload` methods bringing much benefit here.  Ultimately it's down to the caller of `preparePayload` to either know in advance what to expect from who they are talking to, or to verify the information in the block returned by `getPayload` is what they want it to be.\n\nBasically, there is nothing to stop a malicious execution client from diverting a call to `preparePayload` to `buyPayload`, so it doesn't give any additional guarantees that I can see.",
        "created_at": "2021-09-14T09:25:49.597000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "If a staker runs an execution client itself there is low chance for it to be malicious. And also having a separate method opens an opportunity to have a mixed strategy of obtaining a payload",
        "created_at": "2021-09-14T10:25:40.052000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The idea here is that you think the consensus client should be the one that decides and feeds that information to the execution client?",
        "created_at": "2021-09-14T10:30:28.958000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "In your mental model, does the consensus client do 100% of the decision making and execution client is dumb?",
        "created_at": "2021-09-14T10:31:03.438000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I have always modeled it that the execution client makes some decisions, the consensus client makes others.",
        "created_at": "2021-09-14T10:31:22.990000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "And in my model, I had the execution client as the one making decisions about what goes in the block (all fields).",
        "created_at": "2021-09-14T10:31:43.533000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "You're right. It should better be this way than the other. Execution client may be started with options that configures the strategy, like trying to get the payload from the market and to build simultaneously and return what comes first with favouring one over the other upon receiving the `getPayload`.",
        "created_at": "2021-09-14T10:36:08.810000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Implementing this kind of things are out of the scope of client devs, right? It will rather be forked e.g. geth like we have today. Or we are good with that?",
        "created_at": "2021-09-14T10:37:54.556000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Nethermind is building it into their execution client I think.",
        "created_at": "2021-09-14T10:38:17.303000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "For Geth, it is a fork currently, but I have heard talk about trying to integrate those changes upstream.",
        "created_at": "2021-09-14T10:38:35.984000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I like the idea that we can leave that decision up to each client, and it can be a differentiator between clients.",
        "created_at": "2021-09-14T10:39:05.470000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "By the end of the day, if we strictly define the semantics of `preparePayload` today we will be able to relax it when see the real use case in the future, this should be a matter of updating the standard.",
        "created_at": "2021-09-14T10:41:30.966000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I will admit, relaxing an API is easier than making an API more strict.",
        "created_at": "2021-09-14T10:46:25.915000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Well, that isn't entirely true... relaxing the API is easier on one side, harder on the other.  Making it more strict is the inverse I believe.",
        "created_at": "2021-09-14T10:46:48.025000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "In this case though, it isn't even the API that we are talking about but the meta-protocol.  I am not sure if it will be harder to relax or constrain that later.  ðŸ¤”",
        "created_at": "2021-09-14T10:47:33.904000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "In this particular case it seems to be a matter of replacing *MUST* with *SHOULD*. But what if there will be some guarantees that could be broken by this change ðŸ¤”",
        "created_at": "2021-09-14T10:50:04.062000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think that a consensus client can still choose to make the same set of decisions.",
        "created_at": "2021-09-14T10:51:32.618000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If a consensus client is configured such that the provided `feeRecipient` is required in constructed blocks, then they can refuse to include a block that doesn't have the suggested `feeRecipient`.",
        "created_at": "2021-09-14T10:52:24.344000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Even if we made that a `MUST`, the consensus client would still need to do the exact same check and follow the exact same behavior if the block didn't conform to what they expect.",
        "created_at": "2021-09-14T10:52:44.942000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I wouldn't even make it a `SHOULD` personally.  I would use `MAY`.",
        "created_at": "2021-09-14T10:52:55.469000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Why would the software it uses to run an execution engine not follow the protocol in this case? If it's not outsourced of course, which is not the case for an execution client that is being run locally.",
        "created_at": "2021-09-14T10:56:30.824000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Misconfiguration, attack, or the execution client has information the consensus client doesn't.",
        "created_at": "2021-09-14T10:57:29.218000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yeah, `MUST` vs `SHOULD` might be good for highlighting and alternative. `MAY` should be more suitable for the spec",
        "created_at": "2021-09-14T10:57:32.019000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "In this case the proposal should fail and validator owner should investigate and find the issue, right? And your point is that it could be done even with relaxed statement in the standard?",
        "created_at": "2021-09-14T10:58:42.098000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Consensus client tells execution client, \"I need a block soon, it MUST use this randao and timestamp, and it MAY use this feeRecipient.\nExecution client then may see a block available that is very profitable for the feeRecipient, but that block is constructed with a different feeRecipient.  In such a situation, the execution client SHOULD include that block against the suggested feeRecipient of the consensus client.",
        "created_at": "2021-09-14T10:59:01.356000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Yes, exactly.",
        "created_at": "2021-09-14T10:59:13.822000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Whether we say MUST use the provided `feeRecipient` or MAY use the provided `feeRecipient`, in either case if the consensus client wants to enforce this (e.g., it was configured to enforce it) then it needs the same code whether it is a MUST or a MAY.",
        "created_at": "2021-09-14T11:00:02.438000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Meanwhile, if execution clients always use the provided `feeRecipient`, then MUST vs MAY doesn't matter, and if they sometimes ignore it, then presumably it is for a good reason and we should support that (with MAY).",
        "created_at": "2021-09-14T11:01:02.999000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Essentially, MUST doesn't buy us anything here really IMO.",
        "created_at": "2021-09-14T11:01:22.472000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "+1 for MAY in this situation.",
        "created_at": "2021-09-14T12:42:18.018000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "(Just a general point, but I always think that SHOULD is a terrible option.  MUST and MAY are both clear, SHOULD is not.)",
        "created_at": "2021-09-14T12:42:18.630000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Doesn't RFC spec set a clear semantics for these words? Or you don't like `SHOULD` because the meaning it has is coming with uncertainty likewise `MAY` and understanding of the flavour of this uncertainty is a subjective thing?",
        "created_at": "2021-09-14T14:00:10.942000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It does, and `MAY` is what you want here I think.",
        "created_at": "2021-09-14T14:34:27.694000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "`SHOULD` means this is the behavior you should do unless you have a good  reason not to.\n`MAY` means that this is a behavior you could follow if you want.",
        "created_at": "2021-09-14T14:34:55.482000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "Iâ€™ve said it already: It is not feasible for block builders to wait for preparePayload in order to know the coinbase address to use in block construction",
        "created_at": "2021-09-14T14:45:54.217000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "MEV-geth-like clients will ignore this message completely",
        "created_at": "2021-09-14T14:46:45.887000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "This was my previous message on this topic",
        "created_at": "2021-09-14T14:49:52.015000+00:00",
        "attachments": [
            {
                "type": "image/png",
                "origin_name": "unknown.png",
                "content": "45b8089c757fb791052a61d30b1f28d0e654f38e6605efcb0de71f272d68f65f"
            }
        ]
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "\u003e60% of blocks are being produced on ethereum today use mev-geth-like clients, so block builders already exist and will exist on day 1 of the merge",
        "created_at": "2021-09-14T14:53:45.074000+00:00",
        "attachments": null
    },
    {
        "author": "thegostep",
        "category": "general",
        "parent": "",
        "content": "if you make a design decision like \"getPayload must return a block with the same coinbase address as defined in preparePayload\" then we will be in a world of with mev forks of consensus clients too",
        "created_at": "2021-09-14T14:56:22.339000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "The thing I'm missing here is that `COINBASE` can be known well ahead of time but the world state storage, which also allows EVM path dependent logic obviously, cannot be known until the point at which we'd be calling prepare (when the parent block for the proposal becomes known). So I'm unclear why it's critical for COINBASE to be known further ahead of time than the world state (and RANDOM and other things) would be. What am I missing?",
        "created_at": "2021-09-14T20:54:11.101000+00:00",
        "attachments": null
    }
]