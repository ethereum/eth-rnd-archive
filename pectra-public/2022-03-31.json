[
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm starting work now to remove support for multiple EEs from Lighthouse. I think the task is better served by a separate HTTP proxy.\n\nMore information here: https://github.com/sigp/lighthouse/issues/3118",
        "created_at": "2022-03-31T02:45:28.841000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "nice. main thing that would need to be configured specially even with the proxy is how to return a payload built \n\n* proxy could just have a master EE that it gets builds from \n* proxy would query all for builds and just send one to the CL",
        "created_at": "2022-03-31T02:47:19.078000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "re: mev -- I think that CL should always signal their local EE to build in the even that mev-boost (or othrwise) doesn't return anything or fails",
        "created_at": "2022-03-31T02:48:25.789000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Something worth mentioning is that `mev-boost` (and other, future mev things) will present in CL code as a separate EE, with limited functionality (never used to verify payloads). Maintaining multiple EEs *and* MEV EEs is getting pretty complex.",
        "created_at": "2022-03-31T02:48:56.273000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "hmm I would be hesitant to call this as a \"Separate EE\" in code",
        "created_at": "2022-03-31T02:49:16.979000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "in that it is a place that it can send particular messages to get builds from",
        "created_at": "2022-03-31T02:49:35.767000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "but not really an EE",
        "created_at": "2022-03-31T02:49:50.280000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I also am pretty against the currnt abuse of fcu as a request made to mev-boost",
        "created_at": "2022-03-31T02:50:09.845000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "and should instad be an independent method `build_startBuildingMeSomething`",
        "created_at": "2022-03-31T02:50:30.364000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "was reviewing this today actually\n\nhttps://notes.ethereum.org/WX1hwcMRRzy5oh-zHyzqOA",
        "created_at": "2022-03-31T02:51:02.104000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I guess my concern with conflating it with an EE is really it is very particular functioanlity and your EE is still going to do full verifications *and* be the build process in the event that mev-boost fails at any point",
        "created_at": "2022-03-31T02:51:42.161000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so the fact that mev-boost exists should likely only prevent the CL from *using* the payload it gets from the local EE but all methods should likely be calld the same way",
        "created_at": "2022-03-31T02:52:06.789000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah cool, what we communicate to users can be more nuanced. it's just that regardless of naming and specifics of request/response bodies, it looks a lot like an EE and needs to hook into a lot of the same parts of code",
        "created_at": "2022-03-31T02:52:51.464000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so having that *thing* combined with multiple EEs is complexity",
        "created_at": "2022-03-31T02:53:11.015000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "right, I see that",
        "created_at": "2022-03-31T02:53:33.924000+00:00",
        "attachments": null
    },
    {
        "author": "ja_0001",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hi. Is there an eip for the amount of miners that each EL client will run ? Or the eip for EL mining specs !?",
        "created_at": "2022-03-31T04:21:23.808000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "what mining?",
        "created_at": "2022-03-31T05:39:59.433000+00:00",
        "attachments": null
    },
    {
        "author": "ja_0001",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "How do blocks will be generated in EL ?",
        "created_at": "2022-03-31T10:24:48.629000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "CL will provide the EL with all necessary information (timestamp, fee recipient, randao field) and the EL will build a block with the transaction it has.\nThe Block is returned to the CL which signs and distributes it to the network",
        "created_at": "2022-03-31T10:27:07.506000+00:00",
        "attachments": null
    },
    {
        "author": "ja_0001",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Thanks. I understood it. But EL will use GPU or no need. It will be mint or just called now ‚Äúbuild‚Äù the block. \nI just want to know the proper terminology. Thats why I ask if there is an EIP.",
        "created_at": "2022-03-31T10:30:23.359000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "No need for a GPU. Building the block is just executing the transactions as described in the yellowpaper. There is no single EIP that describes how a block is constructed",
        "created_at": "2022-03-31T10:31:31.728000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hello, suppose I synced a block in a side fork and the engine has returned `VALID` for `engine_newPayloadV1`.  Then in the middle of the slot I process enough attestations for it to become head. Do you guys update the head immediately or after FCU has returned?",
        "created_at": "2022-03-31T12:55:22.564000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm wondering if I can update immediately and call FCU on the background in this case.",
        "created_at": "2022-03-31T12:56:01.031000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "after FCU for Nethermind üôÇ",
        "created_at": "2022-03-31T13:06:24.679000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But I thought you guys wold never be in this situation. Do you return VALID on sidechains?",
        "created_at": "2022-03-31T13:10:07.311000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For now, we're returning VALID on sidechains too. We will consider changing it to ACCEPTED  üôÇ",
        "created_at": "2022-03-31T13:15:24.787000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ah thanks, that's good to know there are more clients doing this. So why is it that I need to wait for FCU before switching heads? Is there a chance that the block will not be valid if you returned VALID before?",
        "created_at": "2022-03-31T13:16:41.614000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "hmmm not sure if I understood you correctly, but EL shouldn't update head in newPayload even if block is VALID. We can validate the block, but according to the spec we should wait for fcU",
        "created_at": "2022-03-31T13:21:55.330000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "sure, my question is about the CL side: we have a current head, we know that we will change to a new one and we call FCU, during the time that FCU takes to return we keep our previous head so that we can perform duties on that one. But if we already know beforehand that the new head is VALID, we can probably switch before FCU returns.",
        "created_at": "2022-03-31T13:24:49.814000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think that if EL has fully validated a block which must have happened if it has returned `VALID` then it would use this validity information during processing related `fcU` call.\n\nIn general case`fcU` may be responded with anything else and you might want to wait for it response before applying a block to the fork choice. As it could be that it have to be applied optimistically and then you want to check whether it's eligible to be applied optimistically or not because of the transition `SAFE_SLOTS...` timeout",
        "created_at": "2022-03-31T13:26:22.209000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "not in this situation, we already have the block in forkchoice because the call to `newPayload` has already returned VALID.  Let me describe the situation cause it is a bit of a gray area",
        "created_at": "2022-03-31T13:28:58.001000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh, it seems that I understood. You send `fcU` *after* a block has been applied and use the response status to `newPayload` to figure out whether the block should be applied to the fork choice state or not",
        "created_at": "2022-03-31T13:31:16.599000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The question I am analyzing is when to update what our node believes is it's current head in the event of a reorg. This scenario is on a fully synced node. \n1) If the new head had been imported optimistically due to an `ACCEPTED` reply. We have two options when we are about to execute a call to FCU. If we update our head immediately and then call FCU, then the node will be optimistic and will not perform any duties between the time that we have switched heads and FCU returns. If we wait for FCU, then the validator can safely attest for it's previous head. We are going with this latter approach so far. \n2) If the new head is already `VALID` it seems to me that it's fine not to wait for FCU and just update our head. FCU need to be called anyway for the EL to be synced, but that can be done in the background.",
        "created_at": "2022-03-31T13:33:06.246000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For option 1, I would not enter optimistic mode and instead be waiting for fcu return to actually do a full update of BN",
        "created_at": "2022-03-31T13:37:58.377000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For two that is fine technically but might then create room for bugs and race conditions if not coded with care",
        "created_at": "2022-03-31T13:38:29.945000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "E.g. update BN to new head assuming EL will get to that head from fcu shortly. But then make some request based on BN head  to EL assuming it already got there",
        "created_at": "2022-03-31T13:39:13.789000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The other edge case is the event that EL was swapped for a different one and VALID is no longer the case for that side branch",
        "created_at": "2022-03-31T13:39:46.454000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Alright what you are describing is our current behavior so I don't feel bad, I wonder what others are doing",
        "created_at": "2022-03-31T13:43:50.307000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think for option 1 is fine to enter optimistic mode for a bit at then enter back to a normal mode when `fcU` is responded with `VALID`. \n\nThe question is if `fcU` response should be a part of applying a block to fork choice state ü§î Like if EL stops responding then no block will be applied to fork choice state. The Engine API spec states that CL must send `fcUs` in the same order as the corresponding updates occur in the system (in the local representation of the system which is a local node) and EL must process these messages respecting the order of receiving them. This means that causal consistency will be maintained eventually, while if CL blocks until receiving a response to `fcU` it will rather be a sequential consistency wrt `fcUs` which is too strict IMO.",
        "created_at": "2022-03-31T13:49:40.757000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "re: option 1. It might be the case that there is a pretty short re-org but EL responds with `SYNCING` to `fcU`, an optimisation would be for CL to poll `fcU` in this case and if EL happens to process the re-org in a subslot interval VC will be able to propose next slot as it will turn back from an optimistic mode before the beginning of the next slot. We have been discussing this optimisation some time ago. It's not necessary but can be considered",
        "created_at": "2022-03-31T13:52:11.259000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We may argue on the consistency model we want to maintain. I am leaning towards more relaxed one. On the other hand, if it were a single software unit then fork choice state updated would be expected to be atomic across the layers, i.e. it would maintain a more strict model.",
        "created_at": "2022-03-31T13:58:59.265000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think Misha you're mixing two things: there's never an option of sending fcu to a block that hasn't been applied to forkchoice: if a block arrives, we must call newPayload and we must apply it to fork choice when that returns",
        "created_at": "2022-03-31T14:00:48.053000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so every time we call fcu the block is already in forkchoice.",
        "created_at": "2022-03-31T14:01:04.667000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "As for option 1) the time is not \"little\" since we do not keep polling our endpoints to check if we can attest, if we request an attestation during the time that fcu is not returning (which could be a bit I'm told) and we had updated our head, then the node will say \"I can't give it to you cause I'm optimistic\" and we will loose the slot. I understand from Adrian that Teku behaves the same as us in this scenario, I think LightHouse too",
        "created_at": "2022-03-31T14:02:42.613000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It was more a discussion around what Danny has said\n\u003e For two that is fine technically but might then create room for bugs and race conditions if not coded with care\n\u003e E.g. update BN to new head assuming EL will get to that head from fcu shortly. But then make some request based on BN head  to EL assuming it already got there",
        "created_at": "2022-03-31T14:02:43.552000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e re: option 1. It might be the case that there is a pretty short re-org but EL responds with SYNCING to fcU, an optimisation would be for CL to poll fcU in this case and if EL happens to process the re-org in a subslot interval VC will be able to propose next slot as it will turn back from an optimistic mode before the beginning of the next slot. We have been discussing this optimisation some time ago. It's not necessary but can be considered\nYes this is perfectly reasonable, we were thinking on adding an extra call just before attestation deadline in these cases.",
        "created_at": "2022-03-31T14:04:50.447000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "My mental model:\n`A \u003c- B`, `A \u003c- B'`\n1) `newPayload(B')` ~\u003e `ACCEPTED`\n2) CL observes that `B'` becomes a head\n3) CL applies `B'` optimistically and becomes optimistic\n4) CL sends `fcU(B')`\n5) EL processes a re-org and response `VALID` to `fcU(B')`\n6) CL returns back from optimistic\n\nAnd you mean that attestation threshold happens between 3 and 6. And the strategy that you have described is to wait for `fcU(B')` response before applying a block to the forkchoice? So, VC will be able to vote for the previous head",
        "created_at": "2022-03-31T14:09:19.340000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For the first part, it does not need to be attestation threshold as the VC may want to attest as soon as it received it's block, but yes, the problem is if the validator request to perform any duty between 3 and 6 then it won't do it because it's optimistic. As for the second part: no, I am not suggesting not applying these blocks to forkchoice: the block is already in fork choice  between 1) and 2) above, as soon as `newPayload(B')` returns `ACCEPTED` the block is inserted in forkchoice as optimistic. What I am suggesting is that 3) does not happen: the BN still will track it's previous head until 5) returns, in which case, and only then, the BN saves it's head",
        "created_at": "2022-03-31T14:14:14.645000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "perhaps to clarify this as this is implementation dependant: in our implementation, the head is tracked in the blockchain package, and does not need to coincide with the head that would be returned from forkchoice, we just make sure of calling forkchoice to update our head accordingly when it's needed",
        "created_at": "2022-03-31T14:16:02.399000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Interesting. Out of curiosity could you please provide more details on how this delay is implemented?",
        "created_at": "2022-03-31T14:16:10.369000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh, I see. I would assume that it's always taken from the fork choice state with a sort of cache that is invalidated when whatever new data is applied to the fork choice state.",
        "created_at": "2022-03-31T14:17:40.819000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah I figured this was our source of confusion that's why the comment above",
        "created_at": "2022-03-31T14:18:11.974000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Or, the head would be recomputed and broadcasted whatever new information is applied to the fork choice",
        "created_at": "2022-03-31T14:18:54.364000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And it would be difficult to keep two different heads in two places in terms of avoiding race conditions",
        "created_at": "2022-03-31T14:19:28.060000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Anyway, it's all engineering stuff, sorry for abusing this channel",
        "created_at": "2022-03-31T14:20:26.562000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm not convinced by Danny's reply though since we don't really request anything from the EL unless FCU returns, but it's true that it should be a really minimal gain (assuming the EL is smart enough to return immediately from FCU if it's already validated the block on `newPayload`) so perhaps it's not even worth the overhead of spawning a new routine.",
        "created_at": "2022-03-31T14:20:35.937000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Not sure I understand which exact reply are you referring to?",
        "created_at": "2022-03-31T14:23:06.516000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This specifically:\n\u003e E.g. update BN to new head assuming EL will get to that head from fcu shortly. But then make some request based on BN head  to EL assuming it already got there\n\u003e The other edge case is the event that EL was swapped for a different one and VALID is no longer the case for that side branch\nThe first one is very hard to happen in our case, the second one I just don't understand enough of the EL side so I'll take it as a possibility üôÇ",
        "created_at": "2022-03-31T14:33:07.478000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The first one is what I have been commenting with consistency models stuff. The second one is an edge case that in some parts of merge design, in particular optimistic sync, we have decided to not take into account. We assume that EL is consistent with respect to block's validity, I think that this assumption also includes the case when one EL client is swapped with another one or a newer version of itself",
        "created_at": "2022-03-31T14:37:46.646000+00:00",
        "attachments": null
    },
    {
        "author": "marioevz",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hey Folks, \u003c@!758579010027782144\u003e and I have been discussing about testing for the ExchangeTransitionConfiguration, in particular the TERMINAL_BLOCK_HASH parameter of EIP-3675, it mentions that the canonical blockchain must contain such block but, for purposes of testing, what would the expected outcome of the following tests be:\n\na) Parameter is configured, but the block does not exist on the canonical chain (e.g. misconfiguration)\n\nb) Parameter is configured and the block exists, but an fcU from the CL is in direct conflict with this value?",
        "created_at": "2022-03-31T16:27:36.749000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "a) It might not only be the result of misconfiguration, it might be EL client haven't seen this block yet. The merge transition won't begin in this case\nb) `INVALID_TERMINAL_BLOCK` must be returned in this case",
        "created_at": "2022-03-31T16:34:33.085000+00:00",
        "attachments": null
    },
    {
        "author": "tennisbowling",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so how could I get the coinbase's balance change when doing `getPayload`?\nI see this https://github.com/ethereum/execution-apis/pull/150\nbut it wasn't added",
        "created_at": "2022-03-31T23:03:36.415000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003cdannyryan\u003e The engine API does not give it direct. I suppose this could instead be gathered via the eth api through balance queries",
        "created_at": "2022-03-31T23:06:59.076000+00:00",
        "attachments": null
    },
    {
        "author": "tennisbowling",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "how would one get the balance of a account of a block from getPayload but not included in chain?",
        "created_at": "2022-03-31T23:10:18.775000+00:00",
        "attachments": null
    }
]