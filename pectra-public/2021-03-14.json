[
    {
        "author": "darius510",
        "category": "general",
        "parent": "",
        "content": "Honest question - is it like a design goal of the merge to be as disruptive as possible to make a statement about the superiority of PoS vs. PoW? Or is it just the point where anyone involved in 2.0 simply ceases to care about PoW because it's no longer relevant going forward?",
        "created_at": "2021-03-14T02:37:44.658000+00:00",
        "attachments": null
    },
    {
        "author": "raphael1234",
        "category": "general",
        "parent": "",
        "content": "Actually following the discussion I see the goal for it is to cause as little disruption as possible",
        "created_at": "2021-03-14T02:58:52.540000+00:00",
        "attachments": null
    },
    {
        "author": "raphael1234",
        "category": "general",
        "parent": "",
        "content": "PoW becoming irrelevant shortly after is in the nature of it after all",
        "created_at": "2021-03-14T02:59:41.985000+00:00",
        "attachments": null
    },
    {
        "author": "darius510",
        "category": "general",
        "parent": "",
        "content": "That's more of an expectation than an intent though?",
        "created_at": "2021-03-14T03:00:22.585000+00:00",
        "attachments": null
    },
    {
        "author": "raphael1234",
        "category": "general",
        "parent": "",
        "content": "since nothing is specced out yet I dont see a difference in those yet",
        "created_at": "2021-03-14T03:00:51.822000+00:00",
        "attachments": null
    },
    {
        "author": "darius510",
        "category": "general",
        "parent": "",
        "content": "It's a difference in principle that would guide the spec",
        "created_at": "2021-03-14T03:01:17.455000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "With Vitalik's merge doc: what is the rationale behind storing the entire application block in the beacon block, rather than its and its parent's hash?",
        "created_at": "2021-03-14T08:05:30.002000+00:00",
        "attachments": null
    },
    {
        "author": "notmcd",
        "category": "general",
        "parent": "",
        "content": "Would appreciate it if we could keep the \u003c#692062809701482577\u003e channel technical.",
        "created_at": "2021-03-14T08:06:11.610000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Is this purely to ensure validity of the application block, and hence validity of the beacon block?",
        "created_at": "2021-03-14T08:07:34.134000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e validity of both parts of a block. tight coupling makes it easier to disseminate a block as it could be verified without waiting for any additional info from the wire (re @ef_general_chat_bridge_bot: \u003cjgm\u003e Is this purely to ensure validity of the application block, and hence validity of the beacon block?)",
        "created_at": "2021-03-14T08:40:56.102000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "This adds up to ~1MB/s to the bandwidth requirements (and storage) of the beacon chain, which is significant.  Is there really a requirement to verify that the beacon block proposer created a valid application block, given that they have a built-in incentive to do so in the form of transaction rewards?",
        "created_at": "2021-03-14T09:14:51.734000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e how would you propagate the application block then?",
        "created_at": "2021-03-14T09:16:31.733000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Through the application layer same as today?  Validator client would provide the block to the application node, application node would check with the beacon node to see if the hash of the block is known, if so propagate it (and if not hang on to it for whatever time is considered suitable, e.g. 1 epoch, retrying occasionally and discarding if the block still not known after that time).",
        "created_at": "2021-03-14T09:19:31.739000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e then it will become possible to spam app layer with invalid blocks",
        "created_at": "2021-03-14T09:21:08.601000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e or, wait. they won't be propagated until the app node receives a confirmation from consensus layer, right?",
        "created_at": "2021-03-14T09:22:05.908000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Yeah, an application node only propagates blocks that it thinks are valid i.e. those it has confirmed the root of on the beacon chain.",
        "created_at": "2021-03-14T09:22:52.339000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e isn't it an additional complexity with near the same bandwidth reqs?",
        "created_at": "2021-03-14T09:23:02.547000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e it would also delay app blocks propgation and will require to keep unverified app blocks in a kind of pool which is a dos vector",
        "created_at": "2021-03-14T09:24:10.029000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "It separates the application data from the beacon chain, which reduces the size of the beacon chain.  The application node already has features in place to discard old blocks and only keep the useful information (transaction headers, resultant state) so it won't have the same long-term requirements.",
        "created_at": "2021-03-14T09:25:29.117000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Regarding the dos vector: yes that is a potential problem, however peer scoring would solve that.",
        "created_at": "2021-03-14T09:26:53.058000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e beacon chain does not need to store block bodies or even blocks forever",
        "created_at": "2021-03-14T09:26:55.452000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "I think the general point here is that embedding the application block in the beacon block is a pretty heavyweight solution.  Given all of the effort to move to roots it seems anachronistic, and if the only real issue is a dos vector it also seems overkill.  The block dos vector does not seem very different from mempool dos vectors, which as far as I'm aware are pretty much a solved problem through use of maximum pool sizes and ejection criteria.",
        "created_at": "2021-03-14T09:30:26.614000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e btw, why 1MB? is this an avg mainnet block today? (re @ef_general_chat_bridge_bot: \u003cjgm\u003e This adds up to ~1MB/s to the bandwidth requirements (and storage) of the beacon chain, which is significant.  Is there really a requirement to verify that the beacon block proposer created a valid application block, given that they have a built-in incentive to do so in the form of transaction rewards?)",
        "created_at": "2021-03-14T09:42:42.742000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cn0ble\u003e or a gossip amplification?",
        "created_at": "2021-03-14T09:43:21.103000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "I'm going on the size of the application block data structure in the beacon block, at 2^24 bytes.",
        "created_at": "2021-03-14T09:50:41.868000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cbenjaminion\u003e Eth1 blocks are around 40kB (kilobytes) today iirc.",
        "created_at": "2021-03-14T09:51:13.333000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cbenjaminion\u003e https://etherscan.io/chart/blocksize",
        "created_at": "2021-03-14T09:52:16.289000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e Max is ca 1mb",
        "created_at": "2021-03-14T10:01:25.101000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Any idea why the data structure is 16x that size, then?",
        "created_at": "2021-03-14T11:37:22.890000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e That's a maximum â€” I assume that that is implemented as a variable length array. If you want to have the ability to increase block sizes later, without having to change all Merkle proof logic, you set that to the reasonable expected maximum",
        "created_at": "2021-03-14T11:56:08.756000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "So could a beacon block have a correct encoding of an application block, and fill the rest of the space with junk?  Not sure if it would propagate (if the block is validated by a beacon node and then passed on as-is it may, if it was taken apart and reconstructed it may not), but as an attack vector could be a possibility.",
        "created_at": "2021-03-14T14:32:50.663000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e I assume there should be an assertion that guarantees that the encoded block length = the data structure length",
        "created_at": "2021-03-14T14:33:35.661000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e otherwise the Beacon block is invalid",
        "created_at": "2021-03-14T14:34:01.811000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Regarding this, my original point that embedding the application block in the beacon block would add \"up to ~1MB/s\" appears to still stand.  Are there any reasons to put the application block inside the beacon block outside of the potential dos attack where you could flood an application node with potential good blocks?",
        "created_at": "2021-03-14T14:41:53.465000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e If you don't embed it in the beacon block, then how do you guarantee that you will get the actual block data given just the hash?",
        "created_at": "2021-03-14T14:43:40.044000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e you can't really use the normal eth1 gossip anymore, as the PoW as a \"DOS protection\" is now missing, thus it would be easy to flood it if Eth1 is still gossiping blocks",
        "created_at": "2021-03-14T14:44:17.006000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e so you really have to make it part of the beacon chain block, I don't see another way",
        "created_at": "2021-03-14T14:44:36.455000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "The application layer can gossip the block same way it does today, *after* it has confirmed that the block is referenced in the the beacon chain.",
        "created_at": "2021-03-14T14:45:16.224000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "We already have DOS protection for mempool in the case of local flooding, and the requirement to confirm the block before it is forwarded would reduce the impact of malicious block proposers",
        "created_at": "2021-03-14T14:46:03.594000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e but how do you check whether a beacon block is valid if you don't have the corresponding eth1 block?",
        "created_at": "2021-03-14T14:46:42.581000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "(Or perhaps for validation add a proposer index and BLS signature, and only accept those that match the expected proposer)",
        "created_at": "2021-03-14T14:47:00.241000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "You don't make a valid ETH1 block a prerequisite for being a valid beacon block.  If a proposer wants to not create an ETH1 block and as such forego transaction rewards that's up to them.",
        "created_at": "2021-03-14T14:48:36.283000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e what if they include an invalid ETH1 block root or one that is not available (i.e. they don't propagate the eth1 block)?",
        "created_at": "2021-03-14T14:49:09.505000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e you need to handle these cases",
        "created_at": "2021-03-14T14:49:21.936000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Then the block isn't included in ETH1 and they don't receive rewards.",
        "created_at": "2021-03-14T14:49:26.148000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e are we talking about this proposal? https://notes.ethereum.org/m9IX3OkkTveXCCOSzGkUiw",
        "created_at": "2021-03-14T14:49:58.597000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e then what you suggest doesn't work, because it is tightly coupled",
        "created_at": "2021-03-14T14:50:08.972000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Yes",
        "created_at": "2021-03-14T14:50:10.103000+00:00",
        "attachments": null
    },
    {
        "author": "dkdkdkdkdkdk",
        "category": "general",
        "parent": "",
        "content": "but the beacon block is valid anyway?",
        "created_at": "2021-03-14T14:51:57.834000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e as in, each subsequent block needs to build on the previous blocks eth1 hash. So if a block gets accepted that has an invalid or unavailable eth1 root, then it would block the beacon chain forever, as the next block can't build on it",
        "created_at": "2021-03-14T14:51:58.810000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e no, according to Vitalik's proposal, a beacon block is *only* valid if the contained eth1 block is valid! That's why the eth1 block is part of the beacon block, so that you can immediately check if it's valid\nOnly including the block root, as jgm suggests, doesn't work",
        "created_at": "2021-03-14T14:53:12.789000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "My point is that it shouldn't need to be so tightly coupled (or at least I cannot see what it has to be so tightly coupled).\n\n  - change the application block to be an application block root\n  - remove the requirement that a valid beacon block must contain a valid application block\n  - allow separate propagation of beacon and application blocks\n  - only add an application block to the application chain when its root is confirmed on the beacon chain\n\nI may be missing something, but not sure where",
        "created_at": "2021-03-14T14:53:34.095000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e and you are saying, I can build on and attest to a beacon block, even if I don't have the eth1 data and/or the eth1 data is invalid?",
        "created_at": "2021-03-14T14:54:39.488000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e if block n includes an invalid/unavailable eth1 root, how does this get resolved in your proposal?",
        "created_at": "2021-03-14T14:55:03.417000+00:00",
        "attachments": null
    },
    {
        "author": "dkdkdkdkdkdk",
        "category": "general",
        "parent": "",
        "content": "are you proposing to remove this condition?\n\u003e RLPDecode(block.application_block).parent_hash == state.previous_application_block_hash",
        "created_at": "2021-03-14T14:55:33.221000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "If a beacon block wants to build an application block then it asks the application node for a block proposal, same way that a miner would today.  If it's happy with the application block (perhaps validating it totally, perhaps just confirming that the parent hash of the proposed block is `state.previous_application_block_hash`, perhaps just trusting it) it puts the hash of the application block in to the beacon block and gives the application block to the application node to propagate.",
        "created_at": "2021-03-14T14:59:41.095000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e This reduces the ability for the appnode to validate the block on gossip becuase there is neither a pow nor a proposer signature",
        "created_at": "2021-03-14T15:00:37.460000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e I dont see much reason to decouple and can only see some issues arrise in the comms and duties betwern the layers",
        "created_at": "2021-03-14T15:00:59.465000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Eliminates  the ability*",
        "created_at": "2021-03-14T15:01:18.389000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Unless you have to receive the beacon blick first to then approve the appblockroot to the appnode",
        "created_at": "2021-03-14T15:01:49.758000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e the question is, before you add a block to your fork choice rule [and then attest to it or build a block on it], do you make sure the eth1 block is valid or not?\n - make sure it's valid -\u003e tight coupling\n - don't make sure it's valid -\u003e need a way to resolve invalid/unavailable blocks",
        "created_at": "2021-03-14T15:01:51.250000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e you still haven't said how you would want to do the resolution if you don't want tight coupling",
        "created_at": "2021-03-14T15:02:09.238000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e But then the beacon node doesnt know if the block is actually valid unless he keeps asking the appnode about it",
        "created_at": "2021-03-14T15:02:20.251000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e hint: it's a very difficult problem, that's why we're going for tight coupling",
        "created_at": "2021-03-14T15:02:25.038000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e (if you don't want tight coupling, you basically have made eth1 a shard, and there are several things we need to do before that's really possible, in particular statelessness)",
        "created_at": "2021-03-14T15:03:08.077000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "When you say invalid/unavailable blocks do you mean application (ETH1) blocks?  And who is doing the resolving?",
        "created_at": "2021-03-14T15:05:15.040000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "One reason to decouple would be the fact that the beacon network is already struggling with propagation of beacon blocks, and making them significantly larger and/or increasing the resources required to validate them can only make this worse.",
        "created_at": "2021-03-14T15:06:19.008000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e Yes, I'm talking about eth1 blocks. Well I am asking you who is doing the resolving! If you don't have tight coupling you need to answer this\nWith tight coupling, it's easy â€” each beacon node does it every time they receive a block, immediately, and they reject if invalid (unavailable isn't even possible since it's part of the block) (re @ef_general_chat_bridge_bot: \u003cjgm\u003e When you say invalid/unavailable blocks do you mean application (ETH1) blocks?  And who is doing the resolving?)",
        "created_at": "2021-03-14T15:07:42.514000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e This doesnt increase propagation time wrt validations\nWe are seeing issues with epoch transition blocks because of non-precompute of epoch transition and thus late proposal and late forwarding. This is generally being resolved. \nYou can similarly prepackage a app payload and when forwarding, you only check proposer sig, you dont first compute the block",
        "created_at": "2021-03-14T15:08:25.626000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e We have no evidence the block size (which is small) has anything to do with the current network issue",
        "created_at": "2021-03-14T15:08:54.609000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Note, just checking proposer sig and not running evm calculations is how it is done in eth1 today with pow check",
        "created_at": "2021-03-14T15:10:01.101000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Load here is important though and validating that load can be handled needs part of the process\nNote, beacon block validations are a small fraction of the compute time of an eth1 block today and these operations can be done in parallel",
        "created_at": "2021-03-14T15:13:04.157000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e And again, most compute operations arent performed before block forwarding. Epoch transition to get the shuffling is an outlier and is being optimzied in all clients today",
        "created_at": "2021-03-14T15:13:40.380000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "So I _think_ the question is how does an application node decides if it should include a proposed application block in the chain (as I already suggested that the beacon chain would no longer validate the application block due to it no longer being present in the beacon block).\n\nIn the situation that the application node already has the application block, it checks the root of the block against the beacon chain to see if it is known (possibly requiring that the parent hash is also valid to ensure ordering).  This appears to be analogous to the current proposal of including the application block in the beacon block.\n\nIn the situation that the application node obtains an application block and its check against the beacon chain for the presence of the application block hash returns negative it can hold on to the block until either a new block turns up, at which point it runs the checks again for the current and new application blocks, or it times out and drops the block.",
        "created_at": "2021-03-14T15:18:36.349000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Under what conditions are application blocks forwarded on the independent gossip network?\nIm claiming that without a pow and without a proposer sig (or known shuffling), this is simply a dos vector",
        "created_at": "2021-03-14T15:20:20.367000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Gossip dos vector*",
        "created_at": "2021-03-14T15:20:29.469000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Either a proposer sig, or a \"don't propagate until locally confirmed against the beacon chain\" condition if we don't want to change the application block structure.",
        "created_at": "2021-03-14T15:21:12.453000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e That doesn't solve anything, you still have tight coupling, except that now the eth2 and eth1 blocks are propagated over different p2p networks (re @ef_general_chat_bridge_bot: \u003cjgm\u003e So I _think_ the question is how does an application node decides if it should include a proposed application block in the chain (as I already suggested that the beacon chain would no longer validate the application block due to it no longer being present in the beacon block).\nIn the situation that the application node already has the application block, it checks the root of the block against the beacon chain to see if it is known (possibly requiring that the parent hash is also valid to ensure ordering).  This appears to be analogous to the current proposal of including the application block in the beacon block.\nIn the situation that the application node obtains an application block and its check against the beacon chain for the presence of the application block hash returns negative it can hold on to the block until either a new block turns up, at which point it runs the checks again for the current and new application blocks, or it times out and drops the block.)",
        "created_at": "2021-03-14T15:21:16.022000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e so it just makes it worse by not bundling them",
        "created_at": "2021-03-14T15:21:36.088000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e as in you have two things propagating separately, but they are only valid if you have them both â€” it's clearly better to just propagate them together",
        "created_at": "2021-03-14T15:22:06.282000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Propagated and *stored* on different networks, which as kind of my point.",
        "created_at": "2021-03-14T15:22:27.802000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e they will essentially be the same network at this point",
        "created_at": "2021-03-14T15:22:46.952000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "And the change would mean that beacon blocks did _not_ require application blocks to validate.",
        "created_at": "2021-03-14T15:23:05.729000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e since every eth2 node needs an eth1 node (to verify validity) and every eth1 node needs an eth2 node (for the fork choice)",
        "created_at": "2021-03-14T15:23:12.190000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e then you still haven't answered how you resolve it if an invalid beacon block included in the heaviest (or even finalized chain) (re @ef_general_chat_bridge_bot: \u003cjgm\u003e And the change would mean that beacon blocks did _not_ require application blocks to validate.)",
        "created_at": "2021-03-14T15:23:55.241000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e maybe you should make a full proposal, because in isolation, what you suggest doesn't make sense IMO",
        "created_at": "2021-03-14T15:24:16.454000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e you will need fraud proofs for eth1 blocks to do what you want, but we don't have these for eth1 atm",
        "created_at": "2021-03-14T15:25:01.055000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e One possible alternative is to have a delayed tight coupling, delayed by k blocks. Then you have more time to propagate and validate eth1 blocks (k slots)",
        "created_at": "2021-03-14T15:25:45.771000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "If the beacon block was invalid surely the application block hash included in it would never be on-chain, so not sure how this matters.",
        "created_at": "2021-03-14T15:25:57.075000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e You can decouple propogation but its dangerous to be able to vote on an invalid beacon blicks",
        "created_at": "2021-03-14T15:26:15.443000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e I'm talking about the eth1 block being invalid but included in a valid beacon block",
        "created_at": "2021-03-14T15:26:20.280000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Well, you can semi decouple propagation",
        "created_at": "2021-03-14T15:26:27.613000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Beacon block must be first for anti dos of app block",
        "created_at": "2021-03-14T15:26:37.874000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e I made a proposal for k=1 here: https://ethresear.ch/t/commit-to-pre-state-instead-of-post-state-on-the-executable-beacon-chain/8802/10 (re @dankrad: One possible alternative is to have a delayed tight coupling, delayed by k blocks. Then you have more time to propagate and validate eth1 blocks (k slots))",
        "created_at": "2021-03-14T15:26:43.471000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Im not certain what this buys you though. Maybe marginal better load on network? But also prevents attesters from being able to vote until the app block is validated anyway",
        "created_at": "2021-03-14T15:27:22.203000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Folks, if you both believe it's a non-starter I won't keep bothering you with it.  My fundamental concern was that this would add load to the beacon nodes that could be instead replaced by a hash (and the requirement for a beacon node to have to wait for the application node to accept a block before propagating the beacon block was also worrying).  On a philosophical basis I'd far rather that the application layer carried on doing much as it did today, including its own block propagation, and the beacon chain just provided the minimum information to allow the application layer to finalize individual application blocks and form the chain.  But if it's been looked at and dismissed I understand the benefits of having the application block inside the beacon block in terms of simplicity.",
        "created_at": "2021-03-14T15:31:51.869000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Do we have current numbers from infura on how many current mainnet validators are using their services? I worry that this latency will play a big role under current merge proposals.",
        "created_at": "2021-03-14T15:37:26.939000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "which latency?",
        "created_at": "2021-03-14T15:42:54.545000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Network latency of asking back and forth for eth 1 data",
        "created_at": "2021-03-14T15:43:33.596000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "To validate",
        "created_at": "2021-03-14T15:43:42.989000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "If the option is only a local Eth1 node as I suspect",
        "created_at": "2021-03-14T15:44:12.991000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Then we need numbers on how many validators will be offline",
        "created_at": "2021-03-14T15:44:27.976000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "There are plenty of rpi validating, given that this was even on the EF webpage as possible",
        "created_at": "2021-03-14T15:45:04.500000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e And there are people with geth and beacon on a raspi",
        "created_at": "2021-03-14T15:45:28.354000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I doubt those will be able to continue with a hard retirement of a full node in the side",
        "created_at": "2021-03-14T15:45:31.904000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Theres definitely been no promise that you can offload eth1 validation and we might see validators exit and withdraw as this requirement becomes apparent",
        "created_at": "2021-03-14T15:46:23.929000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Exactly, I doubt this is viable if the ETH 1 data needs to be current as opposed to querying just deposits",
        "created_at": "2021-03-14T15:46:25.137000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "2048 blocks behind",
        "created_at": "2021-03-14T15:46:32.504000+00:00",
        "attachments": null
    },
    {
        "author": "chat-bridge",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e My understanding is both follow head, no problem",
        "created_at": "2021-03-14T15:47:02.276000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "This is fine, as long as withdrawals are implemented with such a merge",
        "created_at": "2021-03-14T15:47:02.762000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I can't vouch for RPI, but I run a ryzen 5, 6 cores, 16GB of RAM and a very fast NVME, and since I switched off geth, bad head votes went from 20/day/validator to just 3 and only on the blocks that everyone is seeing late. I doubt a RPI can handle validating an aplication layer block and a beaconchain block at the same time. And the proposals for a merge so far do not include a withdrawal mechanism. And in the last call this was mentioned explicitly, as an option to implement a merge in case it's necessary, and leave withdrawals for later",
        "created_at": "2021-03-14T15:49:58.631000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "that's why I think we need to have some numbers as to how many bad blocks we will expect to see",
        "created_at": "2021-03-14T15:50:18.034000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "sorry, 12/day/validator, 20-24 total.",
        "created_at": "2021-03-14T15:51:52.682000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "still very much significant",
        "created_at": "2021-03-14T15:51:58.797000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "hm, that's an interesting correlation ðŸ¤”",
        "created_at": "2021-03-14T15:54:41.174000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I'm not the only one that has seen this, I claim that there are plenty of people that switched off their geth nodes, and this shouldn't be hard to check, perhaps the people at Infura can actually tell us about his",
        "created_at": "2021-03-14T15:55:26.875000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "knowing numbers from Infura and perhaps Alchemy should give us an idea",
        "created_at": "2021-03-14T15:55:47.708000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "it worth checking definitely",
        "created_at": "2021-03-14T15:59:44.657000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I am wondering what is the resource which geth is most hungry for, disk, cpu? Haven't you monitored that?",
        "created_at": "2021-03-14T16:00:32.984000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "geth by far is disk hungry, but this wasn't the issue with my computer, it was the very localized CPU hikes that screwed up the voting on the blocks that required processing immediately",
        "created_at": "2021-03-14T16:01:49.927000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "and I could easily correlate this by looking at bad head blocks and I had precise timestamps of the blocks and the CPU load at the moment",
        "created_at": "2021-03-14T16:02:20.763000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "so bad head votes went up in periods of high ETH1 activity, and you can find countless reports like this on Discord. At some point I decided that it was cheaper and simpler to just wipe geth off and resync whenever an eth1 node becomes mandatory",
        "created_at": "2021-03-14T16:03:35.923000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "But the point I want to make is that I truly expect many validators to have hardware worse than mine, and therefore not being able to handle an eth1 node if it's necessary for validating instead of just proposing. And we should really have some gauge as to how will this be impacting participation",
        "created_at": "2021-03-14T16:05:23.191000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I get it, thanks for sharing the details",
        "created_at": "2021-03-14T16:08:07.453000+00:00",
        "attachments": null
    },
    {
        "author": "cryptoblockchaintechnologies",
        "category": "general",
        "parent": "",
        "content": "I also switched my geth node off on my validator after having similar issues. I am running a very high end custom built validator with 2TB NVME running in Raid 0 with 14GB/S speeds. 64GB ram. Been using Infura now for a month with no more issues. https://pcpartpicker.com/list/MjgWcT",
        "created_at": "2021-03-14T16:53:14.857000+00:00",
        "attachments": null
    },
    {
        "author": "0xsadcat",
        "category": "general",
        "parent": "",
        "content": "the main problem with geth is that it relies mostly on sequential random reads, so even nvme speed drops to maybe 40MB/s, and raid 0 doesn't help at all. giving geth lower priority than the beacon node with ionice could help.\nalso it should be better now with the snapshot mode",
        "created_at": "2021-03-14T17:00:26.685000+00:00",
        "attachments": null
    },
    {
        "author": "cryptoblockchaintechnologies",
        "category": "general",
        "parent": "",
        "content": "Yeah was easier just to switch it off. I did try other eth1 clients but had other issues mostly time it took to sync. In the end went with 3rd party Infura endpoint. Also would be great if someone would put together an optimal system build spec for geth. You only ever get minimum requirements and then leads people to try and figure out on their own how to build a high end system short of buying a $50K server",
        "created_at": "2021-03-14T17:12:45.149000+00:00",
        "attachments": null
    },
    {
        "author": "cryptoblockchaintechnologies",
        "category": "general",
        "parent": "",
        "content": "Next time I will go with Optane system then",
        "created_at": "2021-03-14T17:17:51.487000+00:00",
        "attachments": null
    },
    {
        "author": "cryptoblockchaintechnologies",
        "category": "general",
        "parent": "",
        "content": "",
        "created_at": "2021-03-14T17:18:45.784000+00:00",
        "attachments": [
            {
                "type": "image/png",
                "origin_name": "burst-rr.png",
                "content": "d32345b66fe2bbc0cc7396a8497f1efdf4bd98c2e16b38e75667cc1e055060ec"
            }
        ]
    },
    {
        "author": "0xsadcat",
        "category": "general",
        "parent": "",
        "content": "telling people to buy a $5.5k optane (P4800X 1.5TB) isn't a solution for people with less than 1k eth. I think the beacon node could set a higher io + cpu priority itself automatically and it may solve the stalling problems",
        "created_at": "2021-03-14T18:46:52.128000+00:00",
        "attachments": null
    },
    {
        "author": "0xsadcat",
        "category": "general",
        "parent": "",
        "content": "but raspberry pis are imo hopeless without weak statelessness, no amount of fiddling is going to fix performance issues on something so weak.",
        "created_at": "2021-03-14T18:51:09.302000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I tried renicing geth to no avail for a few days before switching it off",
        "created_at": "2021-03-14T18:52:46.246000+00:00",
        "attachments": null
    },
    {
        "author": "0xsadcat",
        "category": "general",
        "parent": "",
        "content": "did you set nice or ionice? I think nice is only for cpu time (not sure)",
        "created_at": "2021-03-14T18:55:19.394000+00:00",
        "attachments": null
    },
    {
        "author": "0xsadcat",
        "category": "general",
        "parent": "",
        "content": "maybe it's not because of io but cpu cache thrashing, which would require pinning processes to cores (taskset) instead of changing priorities. geth and beacon node to separate ones. unfortunately I'm not staking so I can't test it",
        "created_at": "2021-03-14T18:56:43.974000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Nice, disk was not an issue in my case, cpu spikes were",
        "created_at": "2021-03-14T19:00:27.013000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I guess now it's a bit late for me to test :)",
        "created_at": "2021-03-14T19:01:24.831000+00:00",
        "attachments": null
    },
    {
        "author": "agusx1211",
        "category": "general",
        "parent": "",
        "content": "Adding some anecdotal comments, I run 30716 on a Raspberry Pi 8gb, it has an EVO 870 SSD and it's running both prysm and geth without snapshots (full node), nothing fancy on the setup and it's handling it very well, it looses some attestation every couple of hours but it's still rentable for such a cheap machine.",
        "created_at": "2021-03-14T20:03:43.475000+00:00",
        "attachments": null
    },
    {
        "author": "cryptoblockchaintechnologies",
        "category": "general",
        "parent": "",
        "content": "Have you considered not running eth1 client localy and using infura?",
        "created_at": "2021-03-14T23:24:51.078000+00:00",
        "attachments": null
    }
]