[
    {
        "author": "garyrong",
        "category": "general",
        "parent": "",
        "content": "\u003c@!273808422753796097\u003e \u003c@!425572898787426305\u003e Another question regarding the sync. If a new node joins after the merging, it needs to sync the pre-merge blocks and post-merge blocks. The chain sync is triggered by a `NewBlock(blockHash=X)` message and `NewHead(blockHash=X)` message. Then the eth1 node is supposed to reverse sync header chain first from this point.\n\nSo about the header verification, in this scenario, this is no clean boundary about the pre-merge headers and post-merge headers. Because the fresh new eth1 node knows nothing about the transition. While different consensus verification rules should be applied to them.\n\n\u003e Once the merge has happened, it's easy to see what the PoW chain that needs to be downloaded is It's the chain of ancestors of the first embedded execution block.\n\nYes but it's transparent in the eth1 side, all the blocks are baiscally same. So how can eth1 node figure out what's the eth2 header and even stricter what's the transition point for switching the verification rules?",
        "created_at": "2021-04-25T04:11:23.344000+00:00",
        "attachments": null
    },
    {
        "author": "garyrong",
        "category": "general",
        "parent": "",
        "content": "One potential solution is to check some special fields. For example the mixDigest is non-empty, then we think it's the pow blocks. It's ok in the downloader I think because the event source is trusted.",
        "created_at": "2021-04-25T04:26:48.104000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Right, you can tell from PoW data whether or not a header is an embedded header",
        "created_at": "2021-04-25T17:57:45.974000+00:00",
        "attachments": null
    }
]