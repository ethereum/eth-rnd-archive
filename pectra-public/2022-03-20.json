[
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Hello \u003c@!425572898787426305\u003e, we've been discussing something which I would like to hear your thoughts about. Within prysm we seem to be converging to the point that supporting optimistic sync for *regular operations* after the merge is not worth the complexity of the code and risks consensus failure in case of a bug introduced in fork-choice. I want to lay out here loosely what I think may be a good compromise (I'm not 100% everyone in our team supports this). The biggest advantage of optimistic sync is letting the EC sync using their preferred method instead of being spoon-fed blocks. This is only visible when the EC is far behind the tip of the chain. Clients vary in their implementation, but within prysm, we have two modes of syncing, an initial sync is when we requests batches of blocks trying to catch up the head (think when we just startup the node) and a regular sync which is what happens when we are importing blocks from the regular gossip network and acting on those blocks (attesting, proposing etc). If the EC is far behind the head, for example if both the CL and the EL are just starting up, the CL will go into this initial syncing mode. and not do anything until the EC catches up. In this mode it makes a lot of sense to support optimistic sync fully. However, when we are performing regular operations, and eventually the EC may return SYNCING for a reorg, dealing with this situation adds unnecessary complexity to a sensible area of code that can cause a consensus failure. Se we thought of dropping support for optimistic sync in this mode. Now optimistic sync is optional by itself, but not that much: clients not supporting optimistic sync will not be allowed to sync a non-canonical block that the Engine returns as ACCEPTED (instead of VALID). This probably is prohibitively slow for any client. So I propose a variant where any non-canonical block returned as ACCEPTED can be synced, but no action can be taken on those blocks, since if they become head,",
        "created_at": "2022-03-20T09:29:02.658000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "a call to ForkChoice_Updated would have to have returned either VALID or SYNCING or INVALID, but never ACCEPTED.",
        "created_at": "2022-03-20T09:29:08.802000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Incidentally, \u003c@!360491619402776577\u003e I would want to confirm something with you regarding this: if I pass a **non-canonical** block to `engine_newPayloadV1`, can geth return VALID for this block or will it always return ACCEPTED/SYNCING ?",
        "created_at": "2022-03-20T09:31:52.480000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "The above proposal has two immediate drawbacks: one is a breaking change in the API, If it's true that EL can return VALID to newPayload messages, then a user will not be able to know the optimistic status of a block requested by RPC which is not canonical and has never been part of the canonical chain, this block may have been ACCEPTED or VALID and the node will not know this. (if the EL always returns ACCEPTED/SYNCING for non-canonical blocks then this is not a breaking change: every canonical block is VALID and every block that was never part of the canonical chain is Optimistic). The second drawback is a microoptimization that a node cannot immediately attest to a block after a reorg without waiting for the return of FCU, if we are reorging to a block that was never part of the canonical chain and somehow the EL returned VALID when importing it, then we can directly attest to it instead of waiting. This optimization would be lost if we do not keep optimistic status in fork-choice. I asked for feedback from other teams and got mainly these points against.",
        "created_at": "2022-03-20T09:38:58.058000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "On the other hand, by restricting the implementation to only nodes that are booting up or are in this *initial sync* status (admittedly only loosely defined), then we can trigger a consensus breaking bug only in those nodes instead of on every running node.",
        "created_at": "2022-03-20T09:40:09.493000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "FIY grandine-geth pair runs on 98k-99k validators.",
        "created_at": "2022-03-20T09:50:08.471000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "It depends on the depth",
        "created_at": "2022-03-20T14:37:03.793000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "And the client",
        "created_at": "2022-03-20T14:37:08.454000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Some will always no execute at any depth because of their block tree/state structure",
        "created_at": "2022-03-20T14:37:26.537000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Some will execute side branches of certain depths",
        "created_at": "2022-03-20T14:37:36.148000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "That was Adrian's explanation, but even executing I want to confirm that geth returns VALID on non-canonical blocks instead of ACCEPTED",
        "created_at": "2022-03-20T14:39:04.972000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "If they are close to the tip",
        "created_at": "2022-03-20T14:39:19.083000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Marius said they do within 128 depth",
        "created_at": "2022-03-20T14:39:28.118000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "On forked branches",
        "created_at": "2022-03-20T14:39:34.241000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "That is not the case for all EL clients",
        "created_at": "2022-03-20T14:39:50.631000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I'm not sure I understand your porposal\n\nBut I don't think you can get rid of optimistic sync in any of these cases because of the highly varied EL clients and the many failure modes that CL cannot independently diagnose. E.g. in the extreme, the EL is wiped and restarted",
        "created_at": "2022-03-20T14:43:04.758000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "This is why it MAY return valid/invalid on side branches. But not must execute until fcu. Because some clients in some cases maintain fully validated subsets of the block tree beyond just the canonical head",
        "created_at": "2022-03-20T14:47:03.462000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Yes we return VALID if we have the parent available and the block is correct, and if we have the block in our blocktree already",
        "created_at": "2022-03-20T14:50:41.059000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Within a certain depth of branch? 128, right?",
        "created_at": "2022-03-20T14:52:56.675000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Perfect, thanks. So we would miss just that optimization: of not having to wait for fcu if we had already received that the block was VALID",
        "created_at": "2022-03-20T16:07:10.801000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I'm still not sure I understand your proposal",
        "created_at": "2022-03-20T16:09:20.806000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "The point is that if you sync an ACCEPTED block as if it was VALID with the caveat that you will call FCU anyway if it becomes head, then you don't need to keep the complexity of  optimistic sync in fork choice, and the only cost is the time that it takes FCU to return on those blocks",
        "created_at": "2022-03-20T16:10:03.126000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "But you do need opti sync",
        "created_at": "2022-03-20T16:10:35.183000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Because EL can have failures at any point on head or tell you syncing when switching branches",
        "created_at": "2022-03-20T16:10:53.937000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "What does \"sync an ACCEPTED block as if it was VALID\" mean?",
        "created_at": "2022-03-20T16:11:48.341000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yes, we would be taking the ACCEPTED block,  just not storing the status which is what adds complexity and risks yo fork choice",
        "created_at": "2022-03-20T16:11:50.275000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "You can put it in your block tree and then fcu when it's time",
        "created_at": "2022-03-20T16:12:07.004000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "The main thing is that if you knew it was VALID before fcu then you know you can reorg there",
        "created_at": "2022-03-20T16:12:28.367000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yes, this is what we suggest exactly",
        "created_at": "2022-03-20T16:12:32.660000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Whereas if it's ACCEPTED, you might be able to reorg there",
        "created_at": "2022-03-20T16:12:38.535000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yes",
        "created_at": "2022-03-20T16:12:50.663000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Only after you get a return from fcu do you the know fully",
        "created_at": "2022-03-20T16:12:52.514000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yes we are on the same page",
        "created_at": "2022-03-20T16:13:03.031000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "So that's fine. You can just maintain a block tree of what is correctly formed (ACCEPTED  as in literally forms a hash chain)",
        "created_at": "2022-03-20T16:13:13.117000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "And then deal with validity when you actually fcu",
        "created_at": "2022-03-20T16:13:21.647000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "The point I'm making is that if we do this then we do not need to know if blocks are optimistic or not",
        "created_at": "2022-03-20T16:13:35.348000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "So we can't serve RPC according to spec",
        "created_at": "2022-03-20T16:13:52.055000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I see",
        "created_at": "2022-03-20T16:14:16.914000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Blocks not on canonical chain",
        "created_at": "2022-03-20T16:14:35.328000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "The thing to lose is very minor, just the optimization of a reorg to a previously validated block, I'm guessing that fcu is nothing in this case, we're benchmarking it to negligible in our state transition, and the gain is huge in terms of complexity",
        "created_at": "2022-03-20T16:15:34.697000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "The thing is, EL literally does fully validate these side branches in some cases. CL doing little with that info is one thing but I don't understand the complexity of flagging branches as valid or simply just accepted",
        "created_at": "2022-03-20T16:16:52.941000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Is it the same complexity if you consider all side branches as optimistic?",
        "created_at": "2022-03-20T16:17:37.237000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "That's in line with some ELs",
        "created_at": "2022-03-20T16:17:54.697000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "So the CL doing so is not crazy",
        "created_at": "2022-03-20T16:18:02.380000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "As in ACCEPTED rather than VALID",
        "created_at": "2022-03-20T16:18:19.675000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "That pretty much just means forgetting if a prior branch was fully valid wrt el once you leave it",
        "created_at": "2022-03-20T16:18:49.133000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "The complexity comes from pruning mostly and updating the statuses if you need to keep them up, it's not costly, but it has tons of edge cases and there's literally the cost of just calling fcu on an already validated block in case of a reorg back to a previous head",
        "created_at": "2022-03-20T16:19:02.697000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Then you can in fact serve the optimistic API, within reasin",
        "created_at": "2022-03-20T16:19:08.252000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "You would do this fcu call anyway",
        "created_at": "2022-03-20T16:19:34.056000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Regardless of if you remembered it was VALID or just ACCEPTED",
        "created_at": "2022-03-20T16:19:52.181000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Because you need to update EL with head",
        "created_at": "2022-03-20T16:19:59.823000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Exactly! The optimization is that if you're keeping track of statuses (that I propose not do) then you can call fcu in parallel and attest to these blocks if they are VALID",
        "created_at": "2022-03-20T16:20:49.225000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "It's a very minor optimization that we would lose",
        "created_at": "2022-03-20T16:21:14.867000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I think a CL client can choose to forget fully validness of noncanonical branches and call them optimistic wrt API and still be conformant in a sense \n\nSuch a client will have less utility in some edge cases than a client that remembers",
        "created_at": "2022-03-20T16:21:20.713000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "You wouldn't even lose it",
        "created_at": "2022-03-20T16:21:28.092000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "If EL had capability of maintaining caches of this previously validated state, it would reorg efficiently",
        "created_at": "2022-03-20T16:21:54.968000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Right this is why I think this is very minor",
        "created_at": "2022-03-20T16:22:24.765000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "The main thing is that you would have less certain info to share via API than a client that tracks these valid branches",
        "created_at": "2022-03-20T16:22:59.707000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Or have one less check sometimes when doing a reorg",
        "created_at": "2022-03-20T16:23:18.504000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "But that's not an invalid way to operate and I don't think requires any change to spec",
        "created_at": "2022-03-20T16:23:32.785000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "general",
        "parent": "",
        "content": "There was a discussion about a month ago in one of these channels about whether (and which) ELs can switch branches to reorg quickly, and which have to unwind and reply state to do it.  Outcome was that EL performance at this is quite varied, due to different state representations.",
        "created_at": "2022-03-20T16:24:04.197000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Right, the API semantics allow for the variedness in EL",
        "created_at": "2022-03-20T16:24:39.358000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "That's why ACCEPTED exists",
        "created_at": "2022-03-20T16:24:46.809000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yes, on the API side, the **only** difference that I can find is that we would not know the status of a block that is both non canonical and was never part of the canonical chain. I get from your writing that if we call these blocks optimistic you'd consider this spec compliant",
        "created_at": "2022-03-20T16:24:59.346000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "My thought experiment is this\n\nSay you are using an EL client that never says VALID on non canonical branches. Only ACCEPTED until fcu",
        "created_at": "2022-03-20T16:25:55.648000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Then there's no change in behavior",
        "created_at": "2022-03-20T16:26:17.231000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "A CL client connect to such an EL would not know more info that what you are suggesting to do on prysm",
        "created_at": "2022-03-20T16:26:19.771000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Such an EL is conformant to spec",
        "created_at": "2022-03-20T16:26:38.869000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "(and iiuc erigon will use such functionality)",
        "created_at": "2022-03-20T16:26:51.886000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Exactly. We would be lying if we get VALID on geth and don't record this and then serve as optimistic",
        "created_at": "2022-03-20T16:27:42.961000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "The cost of such an EL (or a CL that essentially treats any underlying EL as such) is to have less robust information available for noncanonical branches for API purposes",
        "created_at": "2022-03-20T16:27:52.615000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yes",
        "created_at": "2022-03-20T16:28:07.500000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Well sure",
        "created_at": "2022-03-20T16:28:09.177000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "But it's then like prysm simulates all ELs as the limited wrt side brnach info type",
        "created_at": "2022-03-20T16:28:33.588000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "But I'm going a little further here. I think this is the **right behavior** since it's way less bug prone",
        "created_at": "2022-03-20T16:29:01.459000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I won't make a claim on that. I do not know the complexity first hand. And don't know the differences in such across CL implementations",
        "created_at": "2022-03-20T16:29:43.779000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I would make a strong argument to not break the API and at most make a note about VALID on newPayload being an optimization that doesn't have to go into API requests\n\n(If others agreed)",
        "created_at": "2022-03-20T16:30:42.196000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "general",
        "parent": "",
        "content": "In PoW a block can in principle oscillate many times, between being part of the canonical chain and non-canonical, as it's part of two branches mined in parallel and competing.  Though of course this is very unlikely to happen to a block more than once. I'm not clear, can such oscillations happen post-merge?",
        "created_at": "2022-03-20T16:30:42.952000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Yes",
        "created_at": "2022-03-20T16:30:58.143000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "They can",
        "created_at": "2022-03-20T16:31:00.444000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "We rely on fcu to decide if it's \"worth it\" (cryptoeconomically) to execute such oscillations",
        "created_at": "2022-03-20T16:31:13.538000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "They can but it's harder, at least in our implementation we will call fcu only on new blocks or twice per slot to account for new attestations. The latter is probable to make a head come back",
        "created_at": "2022-03-20T16:32:46.162000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "The former is harder",
        "created_at": "2022-03-20T16:32:52.847000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Head can easily jump between two branches, but it's harder for it to jump between two blocks",
        "created_at": "2022-03-20T16:34:17.219000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "And just for the record, we have this implemented (twice actually) the algorithm is efficient and it doesn't cost us much on block processing. The worry here is the risk of having all prysm nodes (or lighthouse for that matter) believing a whole branch is optimistic due to a bug, when we shouldn't care much if the El is not actually syncing lots of blocks",
        "created_at": "2022-03-20T16:41:03.760000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "We found twice bugs in forkchoice by e2e test on interop with lighthouse on an implementation that passes spec tests",
        "created_at": "2022-03-20T16:42:37.972000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "general",
        "parent": "",
        "content": "Hello, do anyone know how the size blocks batches we can process with optimistic sync? a safe/default value that is",
        "created_at": "2022-03-20T17:08:38.533000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "You can process all you want, there's only a constraint near the fork",
        "created_at": "2022-03-20T17:09:21.554000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "general",
        "parent": "",
        "content": "there is a default value for how much we can see further i would assume",
        "created_at": "2022-03-20T17:09:54.099000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Optimistic sync is about the cl, it dictates which blocks can the cl sync without validating the execution payload. And for simplicity: after the merge, it can sync every single block up to the current head",
        "created_at": "2022-03-20T17:12:03.064000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "general",
        "parent": "",
        "content": "got it, was just confused sorry",
        "created_at": "2022-03-20T17:30:14.034000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Reading the above conversation I’m slightly worried that there’s some confusion and different things being discussed. \n\nIt sounds like Danny is saying it’s valid to treat all non canonical blocks as optimistic (which simulates an EL that never executed non canonical blocks). \n\nBut:\n\u003e The worry here is the risk of having all prysm nodes (or lighthouse for that matter) believing a whole branch is optimistic due to a bug, when we shouldn't care much if the El is not actually syncing lots of blocks\n\nMakes it sound like prysm would assume all blocks are VALID - otherwise the change will increase the risk of believing a branch is optimistic because it thinks every other branch is optimistic. I don’t believe that’s safe and it’s certainly not the same as an EL that doesn’t execute non canonical forks.",
        "created_at": "2022-03-20T20:51:27.661000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "no, first of all prysm will not do anything without agreement here or in the spec of what we want to do. \nSecond, the proposal can be rephrased in the simple sentence: `a validator will not perform any duty to a block that has not been returned VALID by a call to FCU`. \nThe issue with this and the API: for blocks satisfying this very restrictive condition: they are non-canonical and never a call to FCU was made to those blocks. Then those blocks would have an unknown optimistic status. We would return optimistic in the API, although they may have been VALID. As Danny points out, if the EL was Erigorn for example, this would be the case.",
        "created_at": "2022-03-20T21:03:37.343000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Right so that's definitely safe, but it will significantly increase the risk of thinking a fork is optimistic incorrectly rather than decrease it.",
        "created_at": "2022-03-20T21:04:53.078000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "There will not be any optimistic status tracking in this proposal: that's the whole point with the sentence `a validator will not perform any duty to a block that has not been returned VALID by a call to FCU` what we lose is the optimization of not having to wait for FCU if we had received VALID before. And what we gain is that we do not need to keep track of optimistic status which reduces greatly complexity. The only critic to this proposal that I am reading in all of the above is the missing of the micro-optimization above which sounds minimal. I can give another one that I think its a stronger counter-argument: it may be actually complex to differentiate initial sync from regular sync. But I honestly think this proposal needs to be thought seriously.",
        "created_at": "2022-03-20T21:08:27.473000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "As long as you reject any submitted attestations, sync committee messages, aggregates, blocks etc on the API that point to non-canonical blocks yes it will work.  But that just means that you're tracking optimistic vs valid in the same was as tracking canonical/non-canonical.  In Teku checking the optimistic state of a block is trivial but checking canonical vs non-canonical is more expensive and has potential race conditions because the chain head might change part way through processing an API request. So not tracking optimistic per block is actually increasing our complexity.\n\nIf it makes things simpler for Prysm then that's fine to assume all non-canonical blocks are optimistic as long as you don't accept any attestations, sync committee messages, aggregates, blocks etc via the API that point to a non-canonical block.",
        "created_at": "2022-03-20T21:23:54.521000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I don't want to get to a point where we have different behaviors that fit different each clients, specially on something that has to be specified. I am a bit surprised that removing the tracking of optimistic status will not decrease complexity on Teku, but I take your word for it and there's no need to change anything. We do have two different implementations of this and in both there are lots of edge cases when prunning invalid nodes and their children or when updating a SYNCING-\u003eVALID node and going up their ancestry.",
        "created_at": "2022-03-20T21:28:28.937000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "Teku and Lighthouse independently came up with very similar methods for dealing with optimistic status in protoarray and I find it quite easy to reason about, personally.",
        "created_at": "2022-03-20T21:30:46.783000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I'll review your implementations, one of the things I remember we did differently is that you'd mark a node as invalid and not remove it from the protoarray, and let finalization deal with this",
        "created_at": "2022-03-20T21:32:09.776000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "Yep, that’s right. Invalid nodes still exist in the block tree.",
        "created_at": "2022-03-20T21:33:05.203000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "We’re still working on filtering those blocks from the API, that’s part of some ongoing work. It should be quite simple, though.",
        "created_at": "2022-03-20T21:34:02.182000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yes, this is something I didn't want to do thinking in the worst case scenario of having a long period of non-finalization with plenty of those blocks. In the happy case the prunning of those blocks (if one for example) is immediate. In the non-happy case it takes time because we aren't tracking the last valid hash",
        "created_at": "2022-03-20T21:37:11.254000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "But it also keeps forkchoice clean",
        "created_at": "2022-03-20T21:37:30.268000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "in the linked tree implementation is just as simply as removing a single node from the tree. But that isn't our default implementation.",
        "created_at": "2022-03-20T21:37:50.391000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "The nodes in the protoarray for LH are order of 100s of bytes. Only validators can cause one of those nodes to be inserted in the tree so the attack surface seems quite small to me.",
        "created_at": "2022-03-20T21:42:32.867000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "A malicious actor could just ensure they use valid payloads and fill up the block tree in the same way.",
        "created_at": "2022-03-20T21:44:15.621000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "yeah the worry comes from the time of Medalla where RAM exploded after a few days. But I do agree that it may be an over complication. I don't worry too much about this one cause this is only going to be noticeable in lots of forks with invalid payloads.",
        "created_at": "2022-03-20T21:48:55.360000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "Regarding the “micro-optimisation” of avoiding waiting for fcU, I think it’s worth noting that it’s something that will slow down a head update. Getting a block to be an (attestable) head as fast as possible means less votes for old heads/targets and therefore better rewards. This is especially important on mainnet now where we see blocks arriving very close to the 4s mark.\n\nYou can mitigate this by making attestations wait if you’re currently waiting on a fcU response. This might be easy or hard, depending on your impl. That will have the downside that you delay attestation publishing by however long it takes to reach a remote server (the EL).",
        "created_at": "2022-03-20T21:52:40.587000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "It might be a very small amount of attestations that are affected by this, but CL clients are competing on very small margins when it comes to rewards. It’s hard to say if it would be significant or not.",
        "created_at": "2022-03-20T21:54:27.991000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "After reviewing how this works on geth, this can only happen for us when we reorg into a relatively short fork that geth has already computed and FCU returns immediately. It doesn't even seem worth the call to get the optimistic status and spin a separate goroutine in case it's VALID. We are benchmarking on Kiln, and from the  whole state transition, the calls to FCU are very deep down our profile, so it will take a long time to get to a point where this optimization is actually relevant. In fact now we don't even use the return from new_Payload to update optimistic status, we only update it on calls to FCU. And we wait for FCU on each head update. These are paths that certainly will be optimized and profiled in the coming months, but it's very unlikely that this particular one will be relevant in our profiles for a while. Still hashing the payload is taking way longer and effort is underway to paralelize this.",
        "created_at": "2022-03-20T22:01:16.629000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "I guess it depends on the connection speed to the EL as well.",
        "created_at": "2022-03-20T22:02:38.787000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "It's true however that network latency will have to be evaluated",
        "created_at": "2022-03-20T22:02:52.371000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "Geth is not the only EE of course, and Adrian did make a point in another channel that fcU is likely to involve some heavy lifting on the EE side. Inserting a call to a remote server and those fcU updates as blockers on a good head vote seems like a hefty price to pay to avoid adding one byte to each node in the protoarray. I think this erodes the argument that it’s objectively a “micro” optimisation.",
        "created_at": "2022-03-20T22:08:09.649000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "yeah but so far I only found from geth that it returns VALID on non-canonical blocks. I'm not really much concerned on jumping from head to another head and then coming back, this is very rare. So the common case scenario for this would be to get VALID from a call to newPayload.  Anyway this is something that it's not hard for us to add, we most probably will, it's not about adding a byte or not to forkchoice nodes (one of our implementation has the boolean, the other computes it quickly), the problem is that we don't have access to the HTR of the block to which we are calling newPayload, so we can't index it from forkchoice to update it's status. It's a matter of moving things around so that we avoid hashing the block twice, it shouldn't be difficult",
        "created_at": "2022-03-20T22:12:50.089000+00:00",
        "attachments": null
    }
]