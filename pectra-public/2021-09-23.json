[
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Should the modification to the Header (adding the BeaconRandomness field) be part of the merge spec for the f2f already?",
        "created_at": "2021-09-23T06:18:59.780000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Good question. This gap will be filled in the Merge Interop meta spec. The idea is to have it communicated back and forth as a part of `ExecutionPayload` structure without including it into a block that is constructed from the payload.",
        "created_at": "2021-09-23T06:23:36.388000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Cool, yeah that's the way it's implemented right now, so I'll leave it like that",
        "created_at": "2021-09-23T06:24:57.019000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Oh and the difficulty is hardcoded to 0 still, right?",
        "created_at": "2021-09-23T06:44:51.128000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "It doesn't require fully featured SSZ implementation to be added to the execution client. Execution client would only need to implement SSZ Union which is encoded as `Selector || serialize(value)` -- pretty much the same as typed transaction is if the value has a `ByteList` SSZ type.\n\nI have a preference to implement this on the consensus side as it should be easier in terms of speccing and governance. We would need an EIP for such a change on the execution side, right?",
        "created_at": "2021-09-23T06:45:48.604000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yes, as it's stated by the EIP",
        "created_at": "2021-09-23T06:46:03.372000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "This EIP proposes SSZ encoding for transaction objects. Introducing SSZ on the execution layer increases implementation complexity. I don't think it worth doing at the Merge.",
        "created_at": "2021-09-23T06:49:03.899000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003e It doesn't require fully featured SSZ implementation to be added to the execution client.\nA long time back I tried to make this argument, it didn't go over well with the execution client teams.  ðŸ˜–",
        "created_at": "2021-09-23T06:50:41.796000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "No EIP required I think, since this would be part of the consensus/execution API layer which isn't currently using the EIP process I don't think.",
        "created_at": "2021-09-23T06:51:29.121000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Engine API currently refers to EIP-2718 in the `transactions` field specification. But I agree that it could be done on the Engine API handler without affecting the execution layer at all, so, transaction gossip won't be affected",
        "created_at": "2021-09-23T06:59:28.687000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "What the benefit of Option 2 do you see in comparison with Option 1?",
        "created_at": "2021-09-23T07:03:53.726000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "IMO the only difference is whether the adapter lives in execution client or consensus client.  In either case, the adapter *should* live very close to the wire, so it should have relatively little impact on the client overall.  I think 2 is better because it allows the consensus client to not have to adopt the technical debt of the execution clients.",
        "created_at": "2021-09-23T07:05:30.851000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think both options are close enough to each other that it doesn't matter much, my preference for putting the adapter in the execution client is mild.",
        "created_at": "2021-09-23T07:05:58.487000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "The EL clients currently have no notion of SSZ whatsoever, and I would love to keep it that way ðŸ™ˆ",
        "created_at": "2021-09-23T07:07:24.405000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "As was mentioned above, you wouldn't actually need an SSZ client.",
        "created_at": "2021-09-23T07:41:38.828000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The way SSZ encodes simple unions like this you could very easily write like a 5 line function to deserialize without an actual SSZ encoder.",
        "created_at": "2021-09-23T07:42:02.606000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Maybe less than that.",
        "created_at": "2021-09-23T07:42:07.099000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "I see, so basically \n```\nswitch Selector {\ncase 0: UnmarshalLegacyTx\ncase 1: Unmarshal2930Tx\ncase 2: Unmarshal1559Tx\n}\n```",
        "created_at": "2021-09-23T07:44:40.907000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Not if I have my way!  ðŸ˜†",
        "created_at": "2021-09-23T08:06:37.056000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "```ts\nswitch (tx[0]) {\n    case 1: Unmarshal2930(tx)\n    case 2: Unmarshal1559(tx)\n    case 3: UnmarshalLegacy(tx.slice(1))\n    case 4: UnmarshalLegacy(tx.slice(1))\n}\n```",
        "created_at": "2021-09-23T08:07:39.444000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Something like that I think.  I haven't looked at SSZ for a while, but I *think* unions are just byte prefixes?",
        "created_at": "2021-09-23T08:08:45.838000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "That's right, a union is a 1-byte prefix.",
        "created_at": "2021-09-23T08:10:09.278000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "My proposal for `Union` usage doesn't involve SSZ in the execution layer at all. The Union is translated to the envelope format that's already in use today. But the legacy case has many ugly edges, so I am starting to prefer not using an Union type at all",
        "created_at": "2021-09-23T08:47:16.500000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What ugly edge cases do you see if we put wrapped legacy transactions on the wire?",
        "created_at": "2021-09-23T08:50:38.053000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "May we use `transactions: List[OpaqueTransaction]` and then convert it to the `Union` with related changes to the consensus layer once unwrapped legacy transactions are removed entirely?",
        "created_at": "2021-09-23T09:40:03.109000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It will probably be a *very* long time before legacy transactions are removed from the execution layer entirely.",
        "created_at": "2021-09-23T09:51:15.590000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "However, we may get wrapped legacy transactions sooner than that.",
        "created_at": "2021-09-23T09:51:27.260000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What are all the places where consensus clients deal with transactions?",
        "created_at": "2021-09-23T09:52:29.534000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Currently, it's only `ExecutionPayload` structure with its JSON encoding as a part of Engine API implementation",
        "created_at": "2021-09-23T09:53:26.457000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Consensus client doesn't send/receive transactions between each other or encode them anywhere else?",
        "created_at": "2021-09-23T09:55:07.787000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It just gets them from the execution client, stores them, and then locally (in whatever way the client wants) and then sends them back to the execution client later?",
        "created_at": "2021-09-23T09:56:18.467000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Sounds correct to me",
        "created_at": "2021-09-23T10:09:44.852000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It is *much* harder to change an API than to change an implementation later, which is why I have a pretty strong preference for designing the API for the future and then authoring adapters inside implementations to deal with converting between the future-targeted wire protocol and the current implementation.",
        "created_at": "2021-09-23T10:17:06.479000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "The question for the API is encoding:\n1) Binary format used by execution layer to encode tx objects in the wire\n2) Binary SSZ format\n3) JSON format, used by execution layer to encode tx objects in JSON-RPC API\n\nWhat about option 3? Then we could use SSZ Union and container per each type to store transaction objects but it increases implementation complexity. Also, option 3 allows for using SSZ on the consensus layer and whatever is used today on the execution layer. Not sure that having different tx objects encoding across layers is valuable.",
        "created_at": "2021-09-23T10:25:02.713000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "If we use `List[OpaqueTransaction]` today then the only option for the future would be to convert tx objects to the binary format that is used by execution layer",
        "created_at": "2021-09-23T10:26:18.307000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "For (3) would we have something like this?\n```json\n{\n    \"transactions\": [\n        { \"type\": 3, \"payload\": some_pre_155_rlp },\n        { \"type\": 2, \"payload\": some_1559_rlp },\n        ...\n    ]\n}\n```",
        "created_at": "2021-09-23T10:45:08.330000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yeah, and if we look for more granular decomposition of the payload (and we do as I understand) we will have to either update Engine API in the future which may be difficulty or do it right now",
        "created_at": "2021-09-23T10:58:45.378000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Oh, you are thinking something like this?\n```json\n{\n    \"transactions\": [\n        {\n            \"type\": 2,\n            \"maxFeePerGas\": 100,\n            \"maxPriorityFeePerGas\": 1,\n            \"nonce\": 5,\n            \"chainId\": 1,\n            \"signature\": { \"r\": ..., \"s\": ..., \"yParity\": 1 },\n            ...\n        },\n        {\n            \"type\": 4,\n            \"gasPrice\": 100,\n            \"nonce\": 6,\n            \"chainId\": 1,\n            \"signature\": { \"r\": ..., \"s\": ..., \"v\": 35 },\n            ...\n        },\n        ...\n    ]\n}\n```",
        "created_at": "2021-09-23T11:09:54.146000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yeah, ultimately we want this data to be understandable by both layers. And it could be achieved without unifying binary representation of transaction object. Not sure if there are corner cases where we would like to have the representation unified though.",
        "created_at": "2021-09-23T11:17:01.171000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Simplification of this part of the spec that has been mentioned previously, https://github.com/ethereum/EIPs/pull/4203",
        "created_at": "2021-09-23T11:30:06.842000+00:00",
        "attachments": null
    }
]