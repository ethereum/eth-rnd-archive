[
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e fcu doesn‚Äôt respond VALID or INVALID, right?",
        "created_at": "2022-01-13T00:00:05.793000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Oh true - it has `SUCCESS` or `SYNCING`.",
        "created_at": "2022-01-13T00:00:39.683000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "\u003e only if it re-executed EL head or put a block on top would it then find out if VALID or INVALID\nyeah, that's right. BNs will need to poll if they want to avoid waiting for the next block",
        "created_at": "2022-01-13T00:00:48.928000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e so say there fcu induced an expensive 100 block reorg‚Ä¶ does it hang while executing the blocks it has available (i.e. doesn‚Äôt have to sync)",
        "created_at": "2022-01-13T00:01:33.605000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I'd say if we're making this change then fcu should probably be able to return VALID, INVALID or SYNCING.  Otherwise we'd have to issue fcu followed by executePayload which seems pointless.",
        "created_at": "2022-01-13T00:01:43.813000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e right. because fcu *in this design* can induce execution of some branch for the first time",
        "created_at": "2022-01-13T00:02:18.533000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I'd like to say return `SYNCING` if some threshold of reorg depth is reached, but that would cause the CL to enter optimistic sync mode - in some ways that's good but it would prevent it performing duties which may introduce liveness issues until it polls exeuctePayload and finds the EL has finished the reorg.",
        "created_at": "2022-01-13T00:03:27.193000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "even without forking or any new considerations, we still have the issue where there's no backwards event to signal that a SYNCING block has become INVALID/VALID",
        "created_at": "2022-01-13T00:03:31.843000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e \u003e no backwards event to signal that a SYNCING block has become INVALID/VALID\nI understandd that. I just claim this case is slightly different than SYNCING and I‚Äôm trying to consider if it has different needs (or capabilities)",
        "created_at": "2022-01-13T00:04:26.551000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "As a general rule I quite like getting more meaningful responses even if they wind up triggering the same behaviour.  It makes debugging a lot easier if nothing else and potentially in the future there may be optimisations we think of that can benefit from it.",
        "created_at": "2022-01-13T00:05:20.901000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "but I think at the moment there's no behavioural difference for a CL between SYNCING and NOT_EXECUTING_YET.  There may be a difference between SYNCING and LONG_REORG for fcu in terms of how quickly you retry but I'm not sure of that.",
        "created_at": "2022-01-13T00:06:42.082000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "It's not a deal breaker, but if we add INVALID to fcu then we'll also need `latestValidHash`",
        "created_at": "2022-01-13T00:07:17.678000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e right.",
        "created_at": "2022-01-13T00:07:29.329000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "I'm also not opposed to more detail in messages.\n\nMy mental image is that the CL doesn't care what the EL does, as long as it eventually catches up to the canonical chain. All the CL needs is a verified payload at the head of the chain, so the CL can attest and build blocks. If the EL can't fulfil this, then the CL doesn't really care *why* since there's nothing it can do.\n\nI see adding VALID/INVALID to fcu as a \"tidiness\" change, it avoids some polling but it doesn't change the structure of the comms between the EL and CL. \n\nThe change where the CL goes back and supplies old payloads to the EL is a structural change. It means there's now something a CL can do for an EL that's behind, so the CL starts to care more about *why* the EL isn't synced-enough.\n\nRegarding INVALID/VALID on fcu, it might be a nice thing to have but I'm not sure exactly how useful it will be. Regarding the structural change of supplying old payloads, I'm a bit unsure. I think it would be nice to keep the CL in a scenario where it doesn't need to care about the specifics of how the EL is choosing to follow the chain tips.",
        "created_at": "2022-01-13T00:20:14.819000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e as currently discussed, the structural change is wrt EL only MUST execute and validate branches if in [build on head, fcu to branch], but always MAY execute non-head branches",
        "created_at": "2022-01-13T00:24:38.607000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "sgtm",
        "created_at": "2022-01-13T00:27:45.123000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "general",
        "parent": "",
        "content": "FWIW, I think that the CL can not care about that and we don't *need* change the message types.",
        "created_at": "2022-01-13T00:28:23.732000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e I think I agree",
        "created_at": "2022-01-13T00:28:33.079000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Yeah I'm pretty sure it will work out, but will mean there's probably more delay than required when the beacon chain reorgs because it would issue fcu and wind up in optimistic sync mode, then at some point later execute executePayload for the head or a child block which would validated that chain and switch it back to in sync.",
        "created_at": "2022-01-13T00:31:19.513000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "CL can probably be reasonably smart about immediately executing an executePayload call if it knows it just reorged to an optimistic block though so it's probably not too bad (and definitely worth starting there to keep things simple - we can optimise later if it turns out to be needed)",
        "created_at": "2022-01-13T00:32:05.011000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "is this confidential information? or should I ask somewhere else?",
        "created_at": "2022-01-13T08:56:18.481000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "You can find the explainer here: https://github.com/protolambda/eth2-testnet-genesis\n\nI use: `eth2-testnet-genesis phase0 --preset-phase0 mainnet --preset-altair mainnet --preset-merge mainnet --config config.yaml --eth1-block \u003cblock hash\u003e  mnemonics mnemonics.yaml --timestamp \u003ctimestamp\u003e` when i need to create a phase0 state. If you want to start from an altair or merge state, the commands differ.",
        "created_at": "2022-01-13T09:20:37.606000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "ok, thank you \u003c@!199561711278227457\u003e üëç",
        "created_at": "2022-01-13T09:48:32.687000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "I was struggling issues with the latest `prysm` implementation, like `ERROR main: could not load genesis from file: bad` and I think this is because of some changes in theirs codebase between 15th'Dec and now... I've also figured out the change in:\n```go\ncase *merge.BeaconStateView:\n        forkVersion = spec.BELLATRIX_FORK_VERSION\n``` \nfrom `MERGE` into `BELLATRIX`",
        "created_at": "2022-01-13T09:51:00.928000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "https://github.com/silesiacoin/zrnt/commit/eeeb759792d22fa6d49a8f42109034d9df207203 - `prysm` chain configs are using new naming for example, so that's why I've modified MERGE into BELLATRIX, but that's not the root case, case is with Unmarshaling SSZ into `BeaconState` when loading genesis state file in `prysm` beacon-chain",
        "created_at": "2022-01-13T09:55:16.339000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "Yea we're still trying to co-ordinate a release cycle where everyone updates their versions with the new configs. The testnet issue sorta sidetracked us for a while, I'll bring it up in the CL call today and maybe we can plan it out üôÇ",
        "created_at": "2022-01-13T10:23:11.268000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "I can imagine, there are many clients for eth2 with different languages...",
        "created_at": "2022-01-13T10:27:29.111000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "My lighthouse node is 26GB right now (due to the time of non-finalization).\nIt grew roughly with 7GB per day in the time of non-finalization. \nIf we aim for 2 weeks of non-finalization max, that would be 98GB of additional space needed.\nI suspected the node to prune these states once we reached finalization.\nIs that something that clients do?\nOtherwise two or three periods of non-finalization would blow up most nodes",
        "created_at": "2022-01-13T11:11:13.156000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Continuing on multiple forks topic. I was mistakenly decided that Erigon doesn't support multiple forks during the sync process but it is supported when in sync. I suppose when Erigon receives these blocks from the wire, it stores them somehow and this mechanism can be re-used fro payloads received from CL. Am I correct \u003c@!583892532644151312\u003e? Also, IIRC, geth currently don't execute blocks from non-canonical chain and does it only when the chain becomes canonical.\n\nTaking this in consideration I think it's reasonable to assume executing semantics for both `executePayload` and `forkchoiceUpdated`. Though, `executePayload` currently, in its name and specification, requires payload to be executed. We may alter these methods in the following way (summarising the above discussion):\n\n* `executePayload -\u003e newPayload` with `SYNCING`, `EXECUTION_VALID`, `INVALID`, `EXECUTING`, `STRUCTURE_VALID` statuses. `EXECUTING` means that more than one block is executing and the next method call is required to obtain a status of the execution.\n* `forkchoiceUpdated` with `SYNCING`, `EXECUTION_VALID`, `INVALID`, `EXECUTING` statuses and `latestValidHash` field in the response. Note that `STRUCTURE_VALID` is not presented here as this is the responsibility of `newPayload` method. This method call may not respond immediately if execution of one block is required; wait until it's done and then respond back. Also, need to be sure that we haven't made any assumptions on how fast the `fcU` roundtrip is and that it allows us to execute a block.",
        "created_at": "2022-01-13T11:31:45.147000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "The drawback of executing on `fcU` as it's been mentioned is temporal out of sync if there is a switch to a fork which length is more than one block. This scenario would look as follows:\n\n`newPayload(A') ~\u003e STRUCTURE_VALID`, `newPayload(B') ~\u003e STRUCTURE_VALID`, `forkchoiceUpdated(B') ~\u003e EXECUTING`, here CL turns optimistic until it sends `fcU(B')` once again after a timeout (it's not certain which timeout to use as it's unknown how many blocks are being executed and how much time it will take for EL). So, the reasonable approach is to wait for the next `newPayload(C')` or `forkchoiceUpdated(C')`\n\nWith re-org to the fork which length is one block everything seems fine:\n`newPayload(A') ~\u003e STRUCTURE_VALID`, `forkchoiceUpdated(B') ~\u003e EXECUTION_VALID`\n\nWith triggering execution on `fcU` things are similar to 1 block re-org.\n\nCL will have to be ready to finish SYNCING on `forkchoiceUpdated` -- this is one of the implications of this new approach",
        "created_at": "2022-01-13T11:35:59.523000+00:00",
        "attachments": null
    },
    {
        "author": "yperbasis",
        "category": "general",
        "parent": "",
        "content": "Erigon could store blocks/payloads from multiple forks, shouldn't be a problem. Have to think some more, but the new approach seems reasonable to me.",
        "created_at": "2022-01-13T11:55:12.345000+00:00",
        "attachments": null
    },
    {
        "author": "yperbasis",
        "category": "general",
        "parent": "",
        "content": "Are there any guidelines on the acceptable max times for EL to respond to executePayload/forkchoiceUpdated/getPayload?",
        "created_at": "2022-01-13T11:56:48.137000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "`getPayload` should be responded immediately. Other two doesn't seem to have any guidelines this far. We have been discussing the max delay after which `executePayload` should respond SYNCING, i.e. if execution took too much time. Here is the issue https://github.com/ethereum/execution-apis/issues/91\n\nThe idea is that it takes a little time for EL to get blocks (say only one block is missing) and execute it in time, i.e. under some threshold, then it should respond VALID. IMO, this mechanism doesn't buy us much and doesn't worth implementation complexity.",
        "created_at": "2022-01-13T12:00:59.269000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "What would happen in times of non-finality if we only sync on fcu and there are no fcu's?",
        "created_at": "2022-01-13T12:04:45.718000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "There will be `fcUs` anyway as the head is constantly being updated",
        "created_at": "2022-01-13T12:05:51.261000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "do I understand correctly that geth in its current implementation only execute blocks when the fork becomes canonical chain?",
        "created_at": "2022-01-13T12:07:24.435000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Ah the latestvalidhead",
        "created_at": "2022-01-13T12:07:29.426000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "No, we try to execute every block if we have the state for it",
        "created_at": "2022-01-13T12:08:13.691000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Even in the PoW network?",
        "created_at": "2022-01-13T12:08:53.304000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Meaning if the parentblock is canonical, we will execute the block.\nA block becomes canonical on fcu",
        "created_at": "2022-01-13T12:08:56.137000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "In PoW, we will not execute sidechains until the difficulty overtakes our current chain (afaik)",
        "created_at": "2022-01-13T12:09:49.888000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "yep, sorry I meant PoW under \"current\"",
        "created_at": "2022-01-13T12:10:08.292000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "What worries me with executing on `fcU` is the following case. Suppose a portion of validators is on a fork that eventually will become stale. If EL were execution on `executePayload` then this portion would seamlessly jump on the canonical chain. If `fcU` triggers execution then if this stale fork is \u003e 1 block length (or more than 5 blocks or whatever number is responded with `EXECUTING / SYNCING`) then this portion of validators temporarily becomes unable to attest because of SYNCING.",
        "created_at": "2022-01-13T12:16:15.366000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "depending on the EL implementaiton this might just be the case in any structure. Essentially, if EL can only follow one branch of state at a time, re-org is going to cost something",
        "created_at": "2022-01-13T13:21:44.529000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "I remember something. We didn't use fcU to sync, because we don't have a valid header there, and we need a header to kick of the sync",
        "created_at": "2022-01-13T13:22:16.522000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "We can only assemble a header if we have valid payload Attributes",
        "created_at": "2022-01-13T13:23:21.349000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "right, but fcu only comes after ep",
        "created_at": "2022-01-13T13:24:54.706000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "and ep's and associated fcu's are relatively continuous",
        "created_at": "2022-01-13T13:25:12.305000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "so even if you see fcu on a payload you haven't seen, you'd see the next payload and the next fcu",
        "created_at": "2022-01-13T13:25:41.445000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "So we would need to shove all headers from ep into some map and then retrieve them on fcu?",
        "created_at": "2022-01-13T13:25:42.550000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "as current methods stand, yes",
        "created_at": "2022-01-13T13:26:19.443000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "you presumably do this if you see small branches in PoW such that you can execute a branch if pow takes over",
        "created_at": "2022-01-13T13:26:55.757000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "right?",
        "created_at": "2022-01-13T13:26:56.605000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "as in, you maintain a block tree",
        "created_at": "2022-01-13T13:27:06.010000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I suppose the maintaining of anything persistent is strange before and when *kicking off the sync*",
        "created_at": "2022-01-13T13:27:27.898000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I do think that the alteration suggested that only *requires* EL to execute on executePayload when ither it builds on head or sees fcu, is actually way more in line with how geth handles block processing today",
        "created_at": "2022-01-13T13:28:22.793000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "I'm not sure if we can insert blocks into the blocktree of which we don't know if they actually relate to the chain (since we don't know their ancestors yet)",
        "created_at": "2022-01-13T13:33:20.408000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "yeah, I'm not saying inserting into a tree is must when kicking off sync (but being able to still kick off sync in a sane way is)\n\nbut once you are synced to head, inserting into the tree seems very natural wrt how pow works today",
        "created_at": "2022-01-13T13:34:22.556000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Yeah sure, that is what we do right now. If we have the parent, we insert the block into the blocktree, but not mark it as canonical until we get the fcu",
        "created_at": "2022-01-13T13:35:25.428000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "but in the PoS construction, y'all immediately try to execute, right?",
        "created_at": "2022-01-13T13:38:31.486000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "It kind of feels like we might be better off with having `executePayload` become insert into block tree and `forkChoiceUpdated` as execute and set chain head. That would mean `forkChoiceUpdated` would have the valid/invalid/syncing responses which is a change but it seems to fit both the EL and CL models better. `executePayload` would still have to check the block hash and be able to report if that's invalid.",
        "created_at": "2022-01-13T13:38:36.815000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "even if it's not been set as head",
        "created_at": "2022-01-13T13:38:38.124000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Yes as we insert it into the blocktree",
        "created_at": "2022-01-13T13:38:57.685000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "and just be to be clear, you *do not* execute in PoW until the difficulty of such a branch overtakes canonical",
        "created_at": "2022-01-13T13:39:29.924000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "exactly (afaik)",
        "created_at": "2022-01-13T13:39:59.609000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "okay, cool\n\nso agreed with others in this chat that the semantics of execute and fcu are actually a bit off compared to (baseline) EL realities\n(although an EL *may* execute on all branches, it's not necessarily the case that each EL does do this)",
        "created_at": "2022-01-13T13:40:55.888000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "ep would only be able to verify that block is correctly constructed (block hash matches the parameters), but it wouldn't be able to verify e.g. if the state root was correct.\n(Still think it might be a good change though)",
        "created_at": "2022-01-13T13:41:58.208000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "right, so being *well-formed* is the minimum CL needs to know on a non-fcu blocktree insert",
        "created_at": "2022-01-13T13:42:26.738000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Yep, that's what I was expecting.  It would also be a reasonable signal for the EL to try and backwards sync any ancestors of that block it doesn't yet have, so that it's ready to execute them if an fcu comes through for that block.",
        "created_at": "2022-01-13T13:44:52.172000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "But that backwards sync would only be fetching blocks, not executing them which I suspect you do today for blocks received over gossip if you don't have the parent?",
        "created_at": "2022-01-13T13:45:18.761000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Well we would find the last common ancestor with the canonical chain and find all blocks between that and then execute them.\nWe don't have a way to just download some blocks without executing them (at least in beaconsync mode) afaik",
        "created_at": "2022-01-13T13:50:52.723000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Sorry, I mean in PoW mode - if you receive a block from a peer that you don't have the parent for.  Would you then just download the missing blocks back to the common ancestor or would you also execute that fork?",
        "created_at": "2022-01-13T13:52:02.713000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "(I assume only execute if difficultly signals to do so)",
        "created_at": "2022-01-13T13:52:19.241000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Nvm looks like we can sync blocks without executing them with the beaconsync",
        "created_at": "2022-01-13T13:53:40.359000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "The problem still persists though, if the CL expects us to start syncs in ep and feeds us a lot of conflicting forks, we will need to start a lot of different syncs which will confuse the node and impacts performance",
        "created_at": "2022-01-13T13:55:50.403000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "so getting those branches in a sane way does seem valuable",
        "created_at": "2022-01-13T13:56:21.635000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "executing them all without a fcu signal should maybe be left to EL design decision",
        "created_at": "2022-01-13T13:56:34.733000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "BTW one change currently in the works is to reject payloads that revert finality \n(Finality can still be reverted with a manual setHead)",
        "created_at": "2022-01-13T13:58:16.936000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "So in my mind `executePayload` needs to change to be something more like `blockReceived` and it's essentially the equivalent of receiving a block from a peer in PoW. You validate that the block is well formed, backfill anything missing (potentially limiting the number of backfills you do etc) but don't execute it.  The `forkChoiceUpdated` is what triggers block execution and sets the chain head.",
        "created_at": "2022-01-13T13:58:28.275000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "The downside is that `executePayload` doesn't give you any equivalent of the claimed total difficulty for the block so it's harder to know which forks to prioritise when you have a lot to choose from.  fcu will tell you which is the most important but beyond that you can largely only guess.",
        "created_at": "2022-01-13T13:59:56.210000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Exactly, so changes in fcu should be as little as possible (so we don't get the same issue in fcu as well, conflicting flip flopping forks)",
        "created_at": "2022-01-13T14:01:13.978000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "the plus side is that it's expensive for the CL to flip flop between forks with fcu as well, so that should work out fine.",
        "created_at": "2022-01-13T14:02:08.949000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "right fcu to flip to another branch is relatively cryptoeconomically gated like difficultly is in pow",
        "created_at": "2022-01-13T15:15:21.656000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "got it, but in case of `kintsugi` I see https://explorer.kintsugi.themerge.dev/block/0/transactions which means eth1 block timestamp was set to `0`?",
        "created_at": "2022-01-13T16:26:54.506000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "The genesis block of the execution layer is always at timestamp 0",
        "created_at": "2022-01-13T16:40:28.768000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "timestamp 0? or block 0\n\nTIL if timestamp 0",
        "created_at": "2022-01-13T16:41:06.348000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Block 0 has timestamp 0",
        "created_at": "2022-01-13T16:41:25.287000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "got it",
        "created_at": "2022-01-13T16:41:30.212000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "Well we use the `eth2-testnet-genesis` for the CL testnet. So timestamp isn't 0, the block hash is 0 for the CL testnet üòÑ\n`eth2-testnet-genesis phase0 --preset-phase0 mainnet --preset-altair mainnet --preset-merge mainnet --config config.yaml --eth1-block 0x0000000000000000000000000000000000000000000000000000000000000000  mnemonics mnemonics.yaml --timestamp 1639659600`\n\nwas used for kintsugi",
        "created_at": "2022-01-13T16:41:57.162000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "yes, that's correct",
        "created_at": "2022-01-13T16:42:06.748000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "But that's the timestamp for the beaconchain genesis, no?",
        "created_at": "2022-01-13T16:42:33.413000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "for block 0 I've used geth console",
        "created_at": "2022-01-13T16:43:02.788000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "so I can see `eth.getBlockByNumber`",
        "created_at": "2022-01-13T16:43:11.933000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "ahh, mixed questions. I just saw the link now. Yea it is 0 for EL.",
        "created_at": "2022-01-13T16:43:15.224000+00:00",
        "attachments": null
    },
    {
        "author": "matt_mm",
        "category": "general",
        "parent": "",
        "content": "yes `eth2-testnet-genesis` will use `eth1` chain config timestamp as a genesis start",
        "created_at": "2022-01-13T16:48:22.898000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "Does anyone have thoughts on JSON-RPC batching vs. integrating the batching logic directly into the request? (this is re: `engine_getPayloadBodies`)",
        "created_at": "2022-01-13T16:56:55.793000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "genesis timestamp",
        "created_at": "2022-01-13T17:02:34.209000+00:00",
        "attachments": null
    },
    {
        "author": "sma4321",
        "category": "general",
        "parent": "",
        "content": "if there's another spec bump, is there value in a /version request which gives the version of the spec that is implemented? will allow easier diagnostics of when CL and EL are slightly out of sync",
        "created_at": "2022-01-13T17:58:59.471000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e the thing about a spec bump at this page is that it will be breaking and the old one will be deprecated",
        "created_at": "2022-01-13T17:59:59.044000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e and this testnet will be dropped in favor of a pure estnet of the new version",
        "created_at": "2022-01-13T18:00:10.706000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e Until it‚Äôs deployed in production, it is unlikely we‚Äôll be maintaining a past compatibility",
        "created_at": "2022-01-13T18:00:34.391000+00:00",
        "attachments": null
    },
    {
        "author": "chris2_2_2",
        "category": "general",
        "parent": "",
        "content": "To simplify things for the average stakeholder could merge preparations be divided into a checklist of steps? Like finalizing spec, finalizing clients, testnet 1,2,3, merge testnet, fork, merge?\n\nI think I‚Äôve seen this done informally but would be good if there was something people could follow. We‚Äôre asked daily when merge by random people ü•∫",
        "created_at": "2022-01-13T18:33:00.504000+00:00",
        "attachments": null
    },
    {
        "author": "chris2_2_2",
        "category": "general",
        "parent": "",
        "content": "Doesn‚Äôt have to be 100% accurate and obviously some of these things are being done at the same time.",
        "created_at": "2022-01-13T18:34:20.584000+00:00",
        "attachments": null
    },
    {
        "author": "chris2_2_2",
        "category": "general",
        "parent": "",
        "content": "That way even if things are delayed people can see steps are being accomplished towards it.",
        "created_at": "2022-01-13T18:35:16.566000+00:00",
        "attachments": null
    },
    {
        "author": "benjaminion",
        "category": "general",
        "parent": "",
        "content": "There's this: https://github.com/ethereum/pm/blob/master/Merge/mainnet-readiness.md",
        "created_at": "2022-01-13T18:59:08.611000+00:00",
        "attachments": null
    },
    {
        "author": "chris2_2_2",
        "category": "general",
        "parent": "",
        "content": "Thanks I forgot this existed üòÇ",
        "created_at": "2022-01-13T19:01:54.460000+00:00",
        "attachments": null
    },
    {
        "author": "chris2_2_2",
        "category": "general",
        "parent": "",
        "content": "My bad",
        "created_at": "2022-01-13T19:01:56.289000+00:00",
        "attachments": null
    },
    {
        "author": "chris2_2_2",
        "category": "general",
        "parent": "",
        "content": "I‚Äôm probably going to invite everyone to come test and bring their fuzzers on the final testnet üòõ",
        "created_at": "2022-01-13T19:03:01.120000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "general",
        "parent": "",
        "content": "Raising this concept of a \"heartbeat\" on the engine API again, I think it provides a couple of highly beneficial things:\n\n- It lets node operators know they've actually configured things correctly before the merge happens (my main concern)\n- if the heartbeat channel fails (because CL is missing it's EL) the failure will happen at CL upgrade/install time rather than at the time of TTD being reached\n- this will get rid of invalid validators early (as they install the new version) rather than all at once, which should help with overall network stability at the time of the merge.  Basically \"proof of custody of execution light\".",
        "created_at": "2022-01-13T22:06:14.395000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "general",
        "parent": "",
        "content": "My preference is definitely for adding the batching logic in the method itself rather than relying on JSONRPC batch support.  At fair number of clients/libraries don't have full support for JSONRPC batch requests (including IIRC `github.com/ethereum/go-ethereum/ethclient`).",
        "created_at": "2022-01-13T22:11:08.353000+00:00",
        "attachments": null
    }
]