[
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Is it accurate to say that `ByteList[MAX_BYTES_PER_OPAQUE_TRANSACTION]` == `List[Bytes1, MAX_BYTES_PER_OPAQUE_TRANSACTION]`?",
        "created_at": "2021-04-20T04:12:33.379000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm mainly interested in the behaviour in SSZ (particularly merkleization)",
        "created_at": "2021-04-20T04:17:26.322000+00:00",
        "attachments": []
    },
    {
        "author": "terence0083",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's how I interpreted it and implemented it!",
        "created_at": "2021-04-20T04:55:18.801000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Same here!",
        "created_at": "2021-04-20T05:32:57.632000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I've added some examples of the JSON going to/from Geth to help write our parsers.\n\nPR: https://github.com/protolambda/mergenet-tutorial/pull/1\nExamples: https://github.com/protolambda/mergenet-tutorial/blob/09ecd751349bf78bdce1bdcf3efa74fd58e6120d/rpc_examples/README.md",
        "created_at": "2021-04-20T06:32:31.347000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm interested in this field:\n\n```\n\"transactions\": []\n```\n\nI would have expected this to be `0x`-prefixed hex. I haven't got around to creating transactions yet, but I'm guessing it's going to look like `[0, 1, 2]`?",
        "created_at": "2021-04-20T06:36:44.257000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!353136597522448385\u003e perhaps you have thoughts?",
        "created_at": "2021-04-20T06:45:25.621000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh, don't worry ðŸ™‚ I made a transaction and here's the output:\n\n```\n      \"transactions\": [\n        \"0xf8698004825208944a776e9369831f50564e430aacdd58b6be78a10b880de0b6b3a76400008082059ca07c3cc5403b459b15ff24a961d58d525c860b432fa3dc98c914342f8089a766bba02d6402409be46cec176d180d04f9f0cc0c00bb20c254a633949aff1b0962f2ab\"\n      ]\n\n```",
        "created_at": "2021-04-20T07:28:29.716000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So, I think that this means that `ByteList[MAX_BYTES_PER_OPAQUE_TRANSACTION]` is in fact `List[List[Bytes1, MAX_BYTES_PER_OPAQUE_TRANSACTION], UNDEFINED?]`.",
        "created_at": "2021-04-20T07:29:47.114000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ooh, the spec already declares that. Sorry, I misread.",
        "created_at": "2021-04-20T07:35:51.381000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Not all transactions will have the initial type byte, only the new 'typed' transactions have it",
        "created_at": "2021-04-20T11:23:14.855000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This question is rather about SSZ type description and byte string encoding (which is HEX) than the actual transaction format",
        "created_at": "2021-04-20T11:25:22.331000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I was just wondering about this `List[Bytes1, ...` part",
        "created_at": "2021-04-20T11:36:41.143000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I get it. This is basically a list of bytes in SSZ notation",
        "created_at": "2021-04-20T11:37:21.553000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ahh, right",
        "created_at": "2021-04-20T11:37:47.249000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "though, looks a bit confusing",
        "created_at": "2021-04-20T11:38:10.262000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hmm, doesn't SSZ have a mechanism for encoding fixed length values?  A tuple there seems wrong to me.",
        "created_at": "2021-04-20T12:19:28.828000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "`List[bytes1, N]` is bad notation, and not the same as `List[byte, N]` in terms of merkleization (if you interpret bytes1 as a vector with 1 byte). I believe we already fixed that in the eth2 specs though. The opaque transaction should have a `List[byte, N]` type. Note that we use `ByteList[N]` as alias for the same SSZ type, but more specialized implementation (dealing with It a `bytes`-like object in python, instead of a list of int values that all have to be range checked as uint8)",
        "created_at": "2021-04-20T12:36:53.803000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It is `ByteList` in the spec, actually",
        "created_at": "2021-04-20T12:37:54.907000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Where is the `List[bytes1, N]` still referenced then? Did we miss anything in code review?",
        "created_at": "2021-04-20T12:38:40.612000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003chwwang\u003e @protolambda I just opened a PR minutes ago: https://github.com/ethereum/eth2.0-specs/pull/2340\nDoes that make sense to you?",
        "created_at": "2021-04-20T12:39:59.408000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I guess it is referenced in Paul's message only (and in the old version of the spec which is in hackmd and is not used anywhere)",
        "created_at": "2021-04-20T12:40:11.670000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ok, let's make sure that the hackmd is clear that it's old, and where the actual latest spec version is then. We don't want the older specs to be implemented",
        "created_at": "2021-04-20T12:41:39.605000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The hackmd I've mentioned is a draft of executable beacon chain spec which is now is in eth2.0-specs repo. I am sure nobody will seek this hackmd draft as eth2.0-specs repo is an obvious source of merge spec",
        "created_at": "2021-04-20T12:43:35.726000+00:00",
        "attachments": []
    },
    {
        "author": "raulj",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Update from the Prysm side:\n- We are done updating our geth dependency to the latest spec, and are able to use the go bindings to call the proper rpc endpoints for catalyst\n- We are working on integrating these calls into our beacon node\n- We finally need to ensure Prysm runs fine without interop mode and catalyst according to https://github.com/protolambda/mergenet-tutorial, hoping to finish that today",
        "created_at": "2021-04-20T15:02:59.440000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "`List[byte, N]` does this mean \"a byte array with `byte` in the first position and then `N` bytes in the second position through `N.length` positions\"?",
        "created_at": "2021-04-20T16:33:50.002000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "No, it means `List` type as specified in the SSZ spec, with `byte` elements. Lists with basic elements (like `byte, uint64, etc.`) are just concatenated data. The length is inferred from the scope of the decoder.",
        "created_at": "2021-04-20T16:40:28.344000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The `N` is the list-limit, a thing enshrined in SSZ, to limit the decoding scope, and ensure the merkle tree is big enough",
        "created_at": "2021-04-20T16:41:44.915000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That is an \"incorrect\" encoding of typed transactions then.",
        "created_at": "2021-04-20T16:41:58.486000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It's the full envelope",
        "created_at": "2021-04-20T16:42:18.444000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Per spec, the transaction type is prepended on the transaction bytes payload.",
        "created_at": "2021-04-20T16:42:18.529000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That type byte is included as part of the bytes",
        "created_at": "2021-04-20T16:42:31.657000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So you have opaque data with a single leading type byte.",
        "created_at": "2021-04-20T16:42:34.136000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yes, but it's just a big bytes array to the consensus, nothing special there",
        "created_at": "2021-04-20T16:42:59.340000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ah!  `List[byte, N]` isn't a tuple, it is a list of type `byte` of length `N`?",
        "created_at": "2021-04-20T16:43:00.074000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "a list of type `byte`, and limit `N`",
        "created_at": "2021-04-20T16:43:15.012000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "it can be `0...N` in length. Edit: clarifying the bounds: `N` is the max length, `N-1` is the max index.",
        "created_at": "2021-04-20T16:43:28.197000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Sounds great! Looking forward to interop",
        "created_at": "2021-04-20T16:59:01.572000+00:00",
        "attachments": []
    }
]