[
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "Are the parts around IL equivocations speced already?",
        "created_at": "2025-07-30T05:07:35.765000+00:00",
        "attachments": null
    },
    {
        "author": "jih2nn",
        "category": "Cross-layer",
        "parent": "",
        "content": "Yes: https://ethereum.github.io/consensus-specs/specs/_features/eip7805/inclusion-list/#new-process_inclusion_list",
        "created_at": "2025-07-30T05:45:27.606000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "ah wait, I meant the equivocation proof that proposers include?",
        "created_at": "2025-07-30T05:46:36.595000+00:00",
        "attachments": null
    },
    {
        "author": "jih2nn",
        "category": "Cross-layer",
        "parent": "",
        "content": "There is no equivocation proof. The equivocating ILs itself are proof",
        "created_at": "2025-07-30T05:49:14.955000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "right, but aren't proposers supposed to signal for which ILs they saw equivocations? Like, I'm the proposer and I exclude a certain tx because it was on an IL that had an equivocation. How would I proof that?",
        "created_at": "2025-07-30T05:51:11.562000+00:00",
        "attachments": null
    },
    {
        "author": "jih2nn",
        "category": "Cross-layer",
        "parent": "",
        "content": "The equivocating IL will continue propagated over the P2P network and attesters should have enough time to listen to it",
        "created_at": "2025-07-30T05:55:16.419000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "I see! So, proposers would also need to propagate equivocating ILs, but not include them in their blocks. This would ensure that the attesters of their slot should see them and validate that certain transactions were rightfully excluded.",
        "created_at": "2025-07-30T05:57:45.471000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "Makes sense yeah. These ILs still need to propagate through the whole network though. How is this done? Is there a global topic for ILs?",
        "created_at": "2025-07-30T06:00:21.937000+00:00",
        "attachments": null
    },
    {
        "author": "jih2nn",
        "category": "Cross-layer",
        "parent": "",
        "content": "Yes and not only IL proposers but also other validators as well",
        "created_at": "2025-07-30T06:00:43.412000+00:00",
        "attachments": null
    },
    {
        "author": "jih2nn",
        "category": "Cross-layer",
        "parent": "",
        "content": "https://ethereum.github.io/consensus-specs/specs/_features/eip7805/p2p-interface/#inclusion_list",
        "created_at": "2025-07-30T06:00:48.274000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "It would probably reduce bandwidth if there'd be a separate topic for equivocations + having a rule that you never forward a second IL from the same member. But ya, not sure, more a random thought.",
        "created_at": "2025-07-30T06:05:28.055000+00:00",
        "attachments": null
    },
    {
        "author": "soispoke",
        "category": "Cross-layer",
        "parent": "",
        "content": "ah can you say why you think it would reduce bandwidth in principle? the number of ILs propagated would remain the same with 1 or 2 topics no?",
        "created_at": "2025-07-30T06:06:58.064000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "Yeah you're right. Doesn't make sense, never mind. Only if you somehow be able to make the equivocation message smaller.",
        "created_at": "2025-07-30T06:12:23.272000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "or.. you don't propagate equivocations at all but let the proposer do an equivocation proof in the block. Then, validators wouldn't need to propagate 2 ILs on the global topic but instead, if the proposer saw an equivocation, it would be proven in the block (for that, you'd probably need to separate signature from full txs to make it smaller and prevent free DA).",
        "created_at": "2025-07-30T06:15:47.467000+00:00",
        "attachments": null
    },
    {
        "author": "jih2nn",
        "category": "Cross-layer",
        "parent": "",
        "content": "ILs are not part of the block but putting equivocation proof there might not be ideal",
        "created_at": "2025-07-30T06:28:49.108000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "Why?",
        "created_at": "2025-07-30T06:32:46.424000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "Assuming they can be made small (128 bytes), we'd have slightly bigger blocks but wouldn't need to propagate additional `INCLUSION_LIST_COMMITTEE_SIZE * MAX_BYTES_PER_INCLUSION_LIST`.",
        "created_at": "2025-07-30T06:36:14.981000+00:00",
        "attachments": null
    },
    {
        "author": "jih2nn",
        "category": "Cross-layer",
        "parent": "",
        "content": "Not about size, just semantically. That's how I feel it",
        "created_at": "2025-07-30T06:36:48.086000+00:00",
        "attachments": null
    },
    {
        "author": "soispoke",
        "category": "Cross-layer",
        "parent": "",
        "content": "we would also need to know how much time it takes to generate the proof, and to verify the proof so it would open a design space that's quite large",
        "created_at": "2025-07-30T06:38:03.233000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "this is a simple merkle proof. I had the PR for that already",
        "created_at": "2025-07-30T06:38:26.104000+00:00",
        "attachments": null
    },
    {
        "author": "soispoke",
        "category": "Cross-layer",
        "parent": "",
        "content": "but merkle proofs are known to be quite big (relative to other proofs)",
        "created_at": "2025-07-30T06:38:57.452000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "not in ssz",
        "created_at": "2025-07-30T06:39:38.792000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "it's just comparing two attestation objects as defined here:\nhttps://github.com/ethereum/EIPs/blob/05945305ba18c8a7764871b0af7fffeab61bad0b/EIPS/eip-7805.md\n\nshould be a few hundred bytes max",
        "created_at": "2025-07-30T06:40:08.212000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "This would reduce the absolute number of data downloaded per validator  but contribute a bit to history (not saying this is an issue). I don't see the semantics argument.",
        "created_at": "2025-07-30T06:43:04.243000+00:00",
        "attachments": null
    },
    {
        "author": "soispoke",
        "category": "Cross-layer",
        "parent": "",
        "content": "so it would go like this right?\n- builder sees two ILs from the same sender\n- it doesn't include any of the ILs, and generates an equivocation proof for it, and then includes that proof in its block header \n- attesters have to verify the IL proof, and if it's all correct it means they wouldn't expect txns from these ILs to be in the builder's block",
        "created_at": "2025-07-30T06:44:33.655000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "We generally architect things around one entity proving - others verifying ( e.g. this is how slashing proofs work) so, this feels like semantically correct instead of requiring everyone to do additional work.",
        "created_at": "2025-07-30T06:45:22.839000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "yeah right, attesters would check the equivocation (almost the same as the p2p check today) and then don't enforce those txs",
        "created_at": "2025-07-30T06:46:11.724000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "if attesters saw more equivocations they wouldn't care (and woudn't forward them).",
        "created_at": "2025-07-30T06:46:47.082000+00:00",
        "attachments": null
    },
    {
        "author": "terencechain",
        "category": "Cross-layer",
        "parent": "",
        "content": "it's also implementation complexity, today focil does not touch beacon block and it's quite nice, if we have to make beacon block changes then implementation and spec complexity increases linearly  \nif we really want to save bandwidth, under equivocation case, another option is to use ssz optional for `transactions` field, such that it's either 32 bytes or a whole list of txs. So on the 2nd inclusion list, the node could gossip the 32 byte instead of full txs instead",
        "created_at": "2025-07-30T06:47:47.373000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "but then you'd need signatures over both, with and without transactions. At that point the separation is cleaner",
        "created_at": "2025-07-30T06:48:52.259000+00:00",
        "attachments": null
    },
    {
        "author": "terencechain",
        "category": "Cross-layer",
        "parent": "",
        "content": "its the same signature right, just hash tree root the entire list of txs",
        "created_at": "2025-07-30T06:49:36.158000+00:00",
        "attachments": null
    },
    {
        "author": "terencechain",
        "category": "Cross-layer",
        "parent": "",
        "content": "we do this for payload vs payload header as well",
        "created_at": "2025-07-30T06:49:54.004000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "I agree with the header field changes. This would be additional complexity that might not be worth it but unsure.",
        "created_at": "2025-07-30T06:50:07.311000+00:00",
        "attachments": null
    },
    {
        "author": "terencechain",
        "category": "Cross-layer",
        "parent": "",
        "content": "yes, agree on complexiity, everything is complexiity at this point, the tradeoff here is using ssz optional which is [unproven in client implementation] for the inclusion list's transaction field",
        "created_at": "2025-07-30T06:50:52.784000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "you're right yeah, this sounds even simpler!",
        "created_at": "2025-07-30T06:52:18.612000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "So, validators would forward the full attestation object but for every equivocated IL, they replace the full transactions with the hash tree root of `Transactions` , making the object smaller while still being able to prove equivocations.",
        "created_at": "2025-07-30T07:04:31.535000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "During the last call I mentioned a problem that seems to be a fundamental issue of the interaction of FOCIL with any system with a late DA check: the IL includer needs to make their IL without knowing the validity of the latest payload. I know you guys have talked about this problem before but this channel is very hard to follow. I think I've read Francesco say that building ILs with a not fresh head is not much of a problem (it just makes the IL less valuable perhaps by including tx that may not be includable). Some particular details that are valid for the current flavour of ePBS are:\n- Includers will know the txs that have been included\n- Includers may even know that the payload execution is actually valid\n- Includers may know their own columns are available, and if they are supernodes they may know the full payload is available\n\nHowever, a non-supernode will now know if the payload is available. The risk is that an includer fails to include an actual censored tx because it sees it in the payload, but the payload reverts by not being available. \n\nThis is one of those instances in which assuming a minimum number of supernodes solves the problem at the protocol level: if there are enough supernodes we can guarantee up to a level of probability that there will be one includer that is a supernode and therefore will include the censored tx that was in the payload.",
        "created_at": "2025-07-30T14:57:48.213000+00:00",
        "attachments": null
    },
    {
        "author": "soispoke",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003e but the payload reverts by not being available\n\nhere you mean a blob is not available right, not the execution payload",
        "created_at": "2025-07-30T15:08:05.444000+00:00",
        "attachments": null
    },
    {
        "author": "soispoke",
        "category": "Cross-layer",
        "parent": "",
        "content": "A few thoughts:\n- Didn’t think of the supernode idea, I think that’s neat. I have no idea how many supernodes we expect to have in the network when peerDAS goes live tbh\n- A builder reveal a payload but then reverting it because a blob is not available means it would lose its bid right? So the cost of censoring a given transaction using this strategy is basically foregoing any profit made in a block, and is not really better economically than just causing a missed slot?\n- And then in practice you also have the reputational damage a builder reverting payloads would cause to its order flow providers",
        "created_at": "2025-07-30T15:18:09.171000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "Yes, more than the attack angle I'm worried about the inclusion list construction algorithms. And more generally how mempool management works in a world of decoupling payload and DA validity. This is a topic of discussion more for the \u003c#874767108809031740\u003e channel than here perhaps but the issue is that the engine will receive a `notify_NewPayload` and start executing it to check it's validity. It returns VALID and I assume (cc \u003c@360491619402776577\u003e to correct me) that any txs that were included in the payload are pruned from the mempool. Now later on the payload is declared not available and thus those txs that were prunned should be includable again.  It would be much better if the mempool prunning happens on FCU rather than new Payload (perhaps that's the EL behavior?). \n\nInterestingly everything mentioned above can actually happen today, since the CL validates DA and the EL validates execution.  What gets' more complicated is what should be the strategy of an includer that is not a supernode? If we go with the vanilla algorithm which is look at all txs in your current mempool that are includable then the behavior would be as follows. \n\nIf prunning happened on newPayload: then txs that were included in the payload will no longer be included, in the happy case this is exactly what we want. \n\nIf prunning happened on FCU: then txs that were included in the payload will be included again in the IL, in the happy case this will render most ILs useless.",
        "created_at": "2025-07-30T15:30:01.226000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "We put the transactions back into the txpool if a head is reorged",
        "created_at": "2025-07-30T15:33:07.520000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "yeah but this happens before it's reorged",
        "created_at": "2025-07-30T15:40:10.342000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "it happens even before it's head",
        "created_at": "2025-07-30T15:40:16.332000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "so when is the prunning on NewPayload or on FCU?",
        "created_at": "2025-07-30T15:40:25.992000+00:00",
        "attachments": null
    }
]