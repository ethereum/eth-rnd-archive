[
    {
        "author": "lukaszrozmej",
        "category": "Cross-layer",
        "parent": "",
        "content": "Can someone explain me: https://discord.com/channels/595666850260713488/892088344438255616/1220517235785859092",
        "created_at": "2024-03-23T02:12:28.721000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "Already Marius described the reason. It's to keep the state transition as a function that depends only on the incoming block and the current state, and not add a dependency in the previous block",
        "created_at": "2024-03-23T02:16:12.051000+00:00",
        "attachments": []
    },
    {
        "author": "lukaszrozmej",
        "category": "Cross-layer",
        "parent": "",
        "content": "But current nonce is in the state, again I don't get why the complication",
        "created_at": "2024-03-23T09:30:48.395000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "That's the point. Since you already have nonce in the state, you don't need to commit also addresses from the last block to the state. \n\nThe situation is this. You receive a payload for N+1 with a signed summary that contains an address `A` but no transaction from that address. Is the payload valid or invalid? \nWell, you need to see if the summary was already satisfied in the previous block. So either\n- your state transition function depends on the previous block and you look up the transactions from it.\n- you save the addresses that sent transactions in the previous block to the state and now you look there.\n- You send the expected nonce from the address in the summary and now you only need to check that the nonce that you have in the state actually matches this",
        "created_at": "2024-03-23T09:35:29.946000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cmikeneuder\u003e so is this enabled by changing the honest reorg length to 2? because if all the honest attesters are voting for n-1 then you (slot n+2 proposer) need to build on that and reorg out n-1 and n? (re @InclusionList_bot: \u003cpotuz\u003e and somehow that's the key of the matter: in the situation above, if N+1 is late, honest validators should vote for N-1 and not N)",
        "created_at": "2024-03-23T13:31:04.012000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cmikeneuder\u003e 100% (re @InclusionList_bot: \u003cpotuz\u003e [reply]: That's the point. Since you already have nonce in the state, you don't need to commit also addresses from the last block to the state. \n\nThe situation is this. You receive a payload for N+1 with a signed summary that contains an address `A` but no transaction from that address. Is the payload valid or invalid? \nWell, you need to see if the summary was already satisfied in the previous block. So either\n- your state transition function depends on the previous block and you look up the transactions from it.\n- you save the addresses that sent transactions in the previous block to the state and now you look there.\n- You send the expected nonce from the address in the summary and now you only need to check that the nonce that you have in the state actually matches this)",
        "created_at": "2024-03-23T13:31:58.894000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "This is independent of reorgs or not. There are many subjects being discussed with regards to forkchoice. Yes, if we do relax the condition and allow depth two reorgs, I think in the above scenario, honest validators would have to reorg to N-1. However, the formal problem persists: what happens if you have `k` consecutive blocks for which you haven't seen an IL, and then a block comes late? do you keep as head `N-k`? This is not viable: `N-k` may not be FFG compatible with your store's head and such a reorg may be impossible. I can't see other ways to harden forkchoice here other than making the availability a validity condition (not put in forkchoice the block, something that we ruled out as dangerous already) or making it mandatory that you can always recover a full for a payload `N` from the payload itself and any of its children (something that constrains account abstraction)",
        "created_at": "2024-03-23T13:46:02.447000+00:00",
        "attachments": []
    },
    {
        "author": "realbigsean",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003e or making it mandatory that you can always recover a full for a payload N from the payload itself and any of its children (something that constrains account abstraction)\ni feel like this is the way to go cause this does work with the status quo, right? then when we know what AA will look like we could change ILs to suit them",
        "created_at": "2024-03-23T14:16:37.426000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "It does work today, the caveat is that the endpoint itself will not be \"pure\", the EL will be required to have two blocks to return the right IL, I assume this is why \u003c@520034910149410861\u003e didn't like this approach, but I think the current options we have for filtering are worse.  I have no opinion set with regards to AA, still feel very disappointed that I didn't know the txs would not be includable instead of reverting, so would take the EL experts' opinion on the matter.",
        "created_at": "2024-03-23T14:20:04.111000+00:00",
        "attachments": []
    }
]