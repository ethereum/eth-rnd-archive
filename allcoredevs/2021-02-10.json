[
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "Is the main reason for only allowing access to the most recent 256 block roots with `BLOCKHASH` to avoid slow reads from chain history (+ the dependency of having chain history itself?) or are there other stronger reasons to not allow it?",
        "created_at": "2021-02-10T15:48:00.892000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Are you familiar with the proposal to write all blockhashes to state?",
        "created_at": "2021-02-10T16:01:17.182000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e i am, was wondering why store protocol data in a contract rather than just store the hashes in a kv store",
        "created_at": "2021-02-10T16:02:51.781000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I believe the argument was just because we already have a database for storing data, not creating *yet another storage system* makes it much easier to get buy in.",
        "created_at": "2021-02-10T16:12:39.164000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "I think that this is pretty important thing to consider for the next hard fork, because it will really help rollups. Right now, rollups need to calculate their own tx trie root and place it in contract storage. This protects against a data unavailability attack by a proposer - without doing this, a proposer could create a state transition and not upload one of the transactions. If they can make 256 blocks without being challenged, there would be no way to verify against a trusted root (except to start at block N-256 and recursively prove backwards until the desired block is reached). The would be easily be remedied if `BLOCKHASH` was simply not bounded to the most recent 256 blocks.",
        "created_at": "2021-02-10T16:23:45.813000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "See https://eips.ethereum.org/EIPS/eip-2935",
        "created_at": "2021-02-10T16:26:40.095000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I don't remember if there was any strong opposition to it.",
        "created_at": "2021-02-10T16:27:18.545000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "You may be able to become a champion/author of it and get it pushed through.",
        "created_at": "2021-02-10T16:27:41.858000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "Iâ€™m not really a fan of storing in the hashes state trie, maybe \u003c@489256758989029405\u003e, \u003c@259648573401071617\u003e, or \u003c@273808422753796097\u003e can explain why thatâ€™s a good idea?",
        "created_at": "2021-02-10T16:27:56.213000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Ah, there were some concerns over the needing a gas repricing if we add this.",
        "created_at": "2021-02-10T16:28:11.535000+00:00",
        "attachments": null
    },
    {
        "author": "tkstanczak",
        "category": "general",
        "parent": "",
        "content": "extremely useful for lightclients (what an irony you do not find it useful)",
        "created_at": "2021-02-10T16:30:46.238000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Looks like some answers may be found in the discussion link.",
        "created_at": "2021-02-10T16:30:47.472000+00:00",
        "attachments": null
    },
    {
        "author": "tkstanczak",
        "category": "general",
        "parent": "",
        "content": "also allows to do verify any state statements through merkle proofs for any historical events",
        "created_at": "2021-02-10T16:31:10.387000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "ah okay i see, it needs to be authenticated against the block root",
        "created_at": "2021-02-10T16:31:21.758000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "why not introduce a new field to blocks `BLOCKHASHROOT`?",
        "created_at": "2021-02-10T16:32:11.092000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "More bytes-per-block-header and doesn't give much benefit to add yet-another-state-root I think?",
        "created_at": "2021-02-10T16:32:38.058000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "imo the benefit is not entangling protocol ops with contract storage",
        "created_at": "2021-02-10T16:33:18.730000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "proofs should also be a bit shorter since it would `log2(blocknum)` instead `log2(leafnodes)`",
        "created_at": "2021-02-10T16:35:13.133000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "And it could be a binary tree instead of a merkle tree.  ðŸ™‚",
        "created_at": "2021-02-10T16:36:29.183000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Maybe even an SSZ tree.  ðŸ˜„",
        "created_at": "2021-02-10T16:36:34.639000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "at present it becomes a trade-off between complexities.  Using contract storage is simple because we already have prior work that has invested in how we sync that state.  Adding new storage mechanisms that are part of the state required for block execution  means that all sync approaches will also need to have a way to sync those alternative storage backends.",
        "created_at": "2021-02-10T16:40:53.468000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I have come to believe that if you want Piper to contribute you just have to say the word `SSZ` somewhere in your discussion.",
        "created_at": "2021-02-10T16:42:16.892000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I make no claim that it is ideal but, from my perspective, the ease of entangling protocol ops with contract storage is more appealing than the complexity it introduces at the client and network protocol development level.",
        "created_at": "2021-02-10T16:42:21.423000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "However, I really am interested in the idea of precompile contracts with alternate (optimized) storage engines.",
        "created_at": "2021-02-10T16:43:02.534000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "I do agree, the will be introduce complexity by introducing it into the blockheader as a distinct field. However, I think it is the more proper way to do it and I don't think we should shy away from introducing some complexity. I will think more about it though, maybe it's harder than what I am thinking.",
        "created_at": "2021-02-10T16:45:24.553000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "Canonical transaction index would be a possible candidate for this.  A precompile that exposes the index...",
        "created_at": "2021-02-10T16:45:34.705000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "Smaller would be canonical block index (which goes hand-in-hand with the previous EIPs that look to store and expose BLOCKHASH opcode stuff via a contract)",
        "created_at": "2021-02-10T16:48:06.917000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Assuming we did introduce such a mechanism, could it be used to help us with the \"index transactions by hash\" problem we have?",
        "created_at": "2021-02-10T16:50:09.542000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "That is, could we bundle up a few different solutions to problems into a single new blockheader entry?",
        "created_at": "2021-02-10T16:50:39.078000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "It converts it into an on-demand state access problem...",
        "created_at": "2021-02-10T16:50:41.101000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "Yup, but the counter-point is that all 3 of header accumulator, the canonical block number index and canonical transaction index are not critical functionality for the consensus part of the protocol, and adding them would \"bloat\" the state by ~40GB plus some linear accumulation over time in order to better serve lightweight nodes (light and stateless).  The canonical indices in particular are to support external client functionality (aka JSON-RPC).",
        "created_at": "2021-02-10T16:53:50.256000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "Header accumulator should be largely uncontroversial as it's benefits are large and the added data is small.  But the canonical indices are definitely questionable when viewed through a strict-ish lens of what belongs in the core protocol.",
        "created_at": "2021-02-10T16:55:04.280000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If we added a transaction hash =\u003e transaction accumulator, could we turn the transaction root in the header into index =\u003e hash?",
        "created_at": "2021-02-10T16:57:23.088000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "That would avoid us *increasing* the rate of growth by much (just larger paths really).",
        "created_at": "2021-02-10T16:57:54.052000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I think there a line of research worth exploring for how we could expose a hash at the protocol level that would make it easier for the canonical transaction index to be managed and accessed by lightweight nodes, but it's not clear to me exactly how that would work.  The shape of the index is relatively simple.  The problem I see is that it's a large data set and it gets updated randomly and frequently.  You can model it roughly the same as the main account trie.  So a hash is nice because it anchors you to the data.... but you need to be able to somehow get the data...   and the data is constantly changing out from under you because it gets updated constantly and randomly...  so a hash at the protocol level still leaves you needing a lot of extra machinery to make use of it.",
        "created_at": "2021-02-10T17:05:59.043000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "the blockhashes are an implicit input to the eth1 state transition function *in addition to the other implicit input of the full state*.\nBy moving the block hashes into state, you at least cut down on this additional implicit input. And if you move to statelessness (witnesses for processing a block) and you already put block hashes in state, things just work. If you haven't put blockhashes in state you still have the additional implicit input into the state transition function",
        "created_at": "2021-02-10T20:14:07.860000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "This certainly has implications on light clients\nand also has implications on sharding designs (where you might need to jump into a shard  and quickly validate things)",
        "created_at": "2021-02-10T20:14:22.946000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "why put last 256 hashes in the blockheader? that seems wasteful when you can easily have blocks that don't access most of the previous hashes.\nWhereas if in state and in a stateless model, witnesses would just have the hashes/proofs that the block needs",
        "created_at": "2021-02-10T20:17:20.662000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "ah, I see BLOCKHASHROOT and proofs against that. I misread",
        "created_at": "2021-02-10T20:21:21.793000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "could do a double batch merkle accumulator too\n(regardless of in state or block header)",
        "created_at": "2021-02-10T20:22:05.338000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Two reasons:\n\n1. Make it possible to have easy witnesses into deep historical blocks\n2. Move toward the philosophical norm that the \"state root\" actually does cover all \"state\" that is relevant to execution",
        "created_at": "2021-02-10T20:23:24.978000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "(2) would simplify stateless execution, fraud proofs and the like, for example",
        "created_at": "2021-02-10T20:23:46.805000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "does adding the root of blockhashes to header address 1)?",
        "created_at": "2021-02-10T20:26:37.045000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "re 2): how do things like `DIFFICULTY` and `GASLIMIT` interact with that philosophy?",
        "created_at": "2021-02-10T20:27:44.815000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Ah sorry, the exact philosophy is \"the post-state can be computed knowing ONLY (i) the pre-state and (ii) the block\"",
        "created_at": "2021-02-10T20:30:03.283000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "oh okay - so placing rooting the historic hashes in the header would expand that to \"the post-state can be computed knowing ONLY (i) the pre-state (ii) the block and (iii) the historic hashes tree\"",
        "created_at": "2021-02-10T20:31:17.801000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "right",
        "created_at": "2021-02-10T21:57:06.056000+00:00",
        "attachments": null
    }
]