[
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "The existing `revmc` benchmarks only bench runtime performance, and I did some testing with it and added compile-time bench (`compiler.jit_function`), using the `no_gas` config (the best case scenario for JIT):\n```\nfibonacci/comptime [9.5286 ms 9.5764 ms 9.6352 ms]\nfibonacci/revmc/default [279.22 ns 279.39 ns 279.64 ns]\nfibonacci/revm-interpreter [3.0228 µs 3.0464 µs 3.0762 µs]\n\ncounter/comptime [17.037 ms 17.170 ms 17.336 ms]\ncounter/revmc/default [171.54 ns 171.62 ns 171.71 ns]\ncounter/revm-interpreter [379.94 ns 380.30 ns 380.68 ns]\n\nsnailtracer/comptime [3.7387 s 3.7541 s 3.7722 s]\nsnailtracer/revmc/default [63.996 ms 64.253 ms 64.687 ms]\nsnailtracer/revm-interpreter [96.024 ms 96.138 ms 96.286 ms]\n```\nYou can see that any runtime performance gain is entirely offsetted by compile time. For larger programs, the compile time is really slow (`snailtracer` for example, takes 3s). This is probably partially due to the fact that the optimization level is by default set to `OptimizationLevel::Aggresive`, which means that the LLVM backend is taking the time it wants to get optimized native code. On the other hand, if we reduce `OptimizationLevel`, then we'll see less and less performance gain in runtime, and in that case the compile time is still not fast enough.\n\nHowever, the essential issue is that **a JIT designed for a blockchain environment must be single-pass**. We therefore don't have much optimization opportunities when JIT-ing a smart contract. The design of the instruction set then becomes especially important because of this. It must be simple enough that a direct single-pass translation can already produce really efficient results. This is why integrating an additional instruction set (either EVM64 or RISC-V) is rather important for JIT, and why regular EVM is probably better to stay interpreted.\n\nAnyway, I think there are still a lot of benchmarking to do before I can convince everyone, but I hope you see my point here.",
        "created_at": "2025-06-11T08:42:11.581000+00:00",
        "attachments": null
    },
    {
        "author": "chay_z123",
        "category": "general",
        "parent": "",
        "content": "Has anyone else started running into long transaction delays on holesky? I.e transactions sitting in pending state for hours, have seen this through meta mask and in house wallets. Etherscan and other block explores show a pending state with some messaging around this tx was picked up in our secondary node. \n\nChecked participation rates and generally it’s \u003e80% on holesky still. If there’s a better place to pose this question happy to move it!",
        "created_at": "2025-06-11T12:16:21.825000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "hmm, what RPC provider are you using? is it in the inbuilt metamask one?",
        "created_at": "2025-06-11T12:56:12.762000+00:00",
        "attachments": null
    },
    {
        "author": "chay_z123",
        "category": "general",
        "parent": "",
        "content": "It happens most frequently with metamask which I’m using 1rpc.io/holesky as the RPC url for Holesky. \n\nAs for our in house wallet we’re running our own Geth / Prysm nodes. While it happens less frequently, it definitely still happens.",
        "created_at": "2025-06-11T13:49:48.392000+00:00",
        "attachments": null
    },
    {
        "author": "chay_z123",
        "category": "general",
        "parent": "",
        "content": "\u003c@199561711278227457\u003e do you have an RPC provider that works for you on holesky?",
        "created_at": "2025-06-11T14:34:50.419000+00:00",
        "attachments": null
    }
]