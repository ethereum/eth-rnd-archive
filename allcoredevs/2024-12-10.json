[
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Where do I find the most up-to-date source of information for the execution spec? in EIP-1559 data structures like `gas_limit` appear as `int`  which is a 256 bit structure, while in the consensus spec they are defined as `uint64`.  I'm looking for a central repo where I see the conversion from one to another or the updated version of the former.",
        "created_at": "2024-12-10T10:06:01.066000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "gas limit is an exception, because we know it will never go larger than 64 bits",
        "created_at": "2024-12-10T10:36:31.169000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "all numbers in the protocol were defined to be 256bit in the OG Ethereum spec",
        "created_at": "2024-12-10T10:36:55.818000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "but for some of them, it doesn't make sense, so implementations use smaller types",
        "created_at": "2024-12-10T10:37:25.299000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "that's fine, but the EIP still refers to them as `int` so either that EIP needs to be changed or there must be a newer doc with the actual spec isn't it?",
        "created_at": "2024-12-10T10:45:47.637000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "more than this particular case I'm interested in where to look for information in general, I know that for the CL spec I have a single repo to check (unless it's an API issue)",
        "created_at": "2024-12-10T10:46:33.002000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "the canonical one is supposed to be https://github.com/ethereum/execution-specs/tree/master/src/ethereum",
        "created_at": "2024-12-10T10:51:53.044000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "That one **also** has them as `Uint`",
        "created_at": "2024-12-10T10:55:22.740000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "so for someone as me that doesn't really know the EL spec, I see a the `ExecutionPayload` container in the CL spec and see a `uint64`, I see a class `Header` container in that repo and see a `Uint` and now I can't really know if clients are converting to native types that differ by 184 bits. We somehow need to get at least these shared objects to agree in the definition.",
        "created_at": "2024-12-10T10:57:36.036000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The specification is that all numeric items in blocks are 256-bits.",
        "created_at": "2024-12-10T11:16:55.803000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Some implementations use smaller datatypes internally for things they know can never actually be big (like gas limit, nonce, etc.) but per spec, they are all 256-bits.",
        "created_at": "2024-12-10T11:17:24.888000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "There are some EIPs that want to change the spec to make some of these numbers smaller per spec, but I don't think any have actually made it through the standards process.",
        "created_at": "2024-12-10T11:17:49.114000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "But that's not the case if the actual consensus structure uses the smaller internet type. We hash something",
        "created_at": "2024-12-10T11:18:00.748000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "For EL, all numbers in consensus are 256-bit RLP encoded numbers, which means leading 0s are stripped off.",
        "created_at": "2024-12-10T11:18:22.240000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yeah but the Payload is part of the CL and it's hashed differently",
        "created_at": "2024-12-10T11:18:42.446000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "And we use the 64 bit representation",
        "created_at": "2024-12-10T11:18:52.933000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What are you trying to accomplish?  Understanding that may help answer your question, since there seems to be some confusion.",
        "created_at": "2024-12-10T11:19:05.332000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If you are trying to design a new protocol/API for transmitting information between CL/EL, then you can either assert that all numbers are 256-bits like in the EL spec, or you could take the opportunity to assert that some of them are smaller and encode them as such and make the EL convert if they are internally storing as 256-bits.",
        "created_at": "2024-12-10T11:20:54.529000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I am required to review a PR that does arithmetics with elements like `gas_limit` and `gas_used` and these numbers are defined as 256 bits on some places and 64 bits on others. Now these arithmetics happen to be equivalent no matter which representation is used, but this requires me to actually check this statement, to care about whether or not these difference matter, to look up the specification of an area of Ethereum that I do not know etc... Unfortunately we need to deal with these things, and having consistency across spec repos for people like me is useful. The flip side of the coin is that I don't get to review anything because the mental toll and time of going behind the source of truth is tiresome and these end up being merged without a proper thorough review",
        "created_at": "2024-12-10T11:22:58.501000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "reject crazy-high gas limits?",
        "created_at": "2024-12-10T11:23:35.681000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The python spec linked above is now considered \"canonical\" I believe.  Anywhere you see `Uint` it means 256-bits.",
        "created_at": "2024-12-10T11:24:16.307000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If someone does something different, they aren't coding \"to spec\".",
        "created_at": "2024-12-10T11:24:29.244000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "yes but the CL spec defines them as uint64",
        "created_at": "2024-12-10T11:24:32.722000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Correct.  The EL and CL don't agree on everything.",
        "created_at": "2024-12-10T11:24:43.388000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It would be cool to get them aligned.",
        "created_at": "2024-12-10T11:24:50.178000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "that's all I'm saying",
        "created_at": "2024-12-10T11:25:00.847000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Oh, sorry.  It looks like \u003c@425279588009246720\u003e finally managed to get EIP-2681 pushed through so Nonce is `2^64`.  ðŸŽ‰",
        "created_at": "2024-12-10T11:26:34.886000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003chttps://eips.ethereum.org/EIPS/eip-2681\u003e",
        "created_at": "2024-12-10T11:26:41.846000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003chttps://eips.ethereum.org/EIPS/eip-4803\u003e is for gas limit, but not final yet.  You could join Alex in trying to get it pushed through.",
        "created_at": "2024-12-10T11:27:22.958000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Note, 4803 would make gas limit fit in a *signed* integer, because it simplifies some math in execution clients.",
        "created_at": "2024-12-10T11:28:04.402000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "still higher than it's going to reasonably be in a long time, and the lower half of the range is identically represented in the only numeric encoding which anymore matters",
        "created_at": "2024-12-10T11:47:29.372000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Yeah, I think 2^63-1 is fine, but I'm guessing it doesn't match the CL spec which is what \u003c@755590043632140352\u003e is hoping to achieve.",
        "created_at": "2024-12-10T11:50:02.521000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "that's true",
        "created_at": "2024-12-10T11:50:12.669000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "right, and more than this, it's not much about the limits as it is about defining the structures in the same way or at least have a common place where it is explicitly stated how these structures are transformed. It's fine if the CL payload is different than the EL payload as long as the mapping is explicit somewhere",
        "created_at": "2024-12-10T11:51:25.143000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "was it worked out whether the 256-bit wei/64-bit gwei thing mapped 1:1, or did it not end up mattering?",
        "created_at": "2024-12-10T12:05:57.120000+00:00",
        "attachments": null
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "this would be my prefered way to set/target EL gas limit: https://github.com/ethereum/execution-apis/pull/608",
        "created_at": "2024-12-10T12:13:46.650000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "general",
        "parent": "",
        "content": "i.e. `uint64`",
        "created_at": "2024-12-10T12:15:24.681000+00:00",
        "attachments": null
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "we can have a uint64 structure/spec  for it (mostly for cross CL\u003c\u003eEL communication as Potuz is hightlighting) with max limit defined as per EIP so the clients can still make the optimization they want",
        "created_at": "2024-12-10T15:18:32.226000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "One thing we're realizing as we look more into EIP-7742 is that ELs do kind of care about the max blob count. Certainly the current eth_feeHistory api requires it. So looking into how clients will get this value, there are a few options.\n\n* add max blobs to header: this is pretty wasteful (as is putting the target that rarely changes IMHO)\n* communicate it only via engine api: works but kinda requires EL to then store the value somewhere and has a higher cost of specifications\n* define a config value in the `genesis.json` file: kinda the simplest solution, but doesn't allow CL to make a fork increasing the max / target on it's own\n\n7742's goal was to make it possible for CL to have a CL-only fork increasing the blob limit / target. Tbh this is just kinda unrealistic. The EL is not completely agnostic to the blob count. The current txpool design would likely bottleneck other (more important) client operations if the blob target were increased to, say, 64. We'd need to be better about propagation to avoid that - so it's not like the CL will do it on it's own.\n\nAlso, the EL has has several fast \"no-op\" forks to bump the difficulty bomb. If we *do* need a more marginal increase and the CL needs it ASAP, the EL does have plenty of experience with these types of forks.\n\nFor these reasons, I think we should remove 7742 from pectra. What we want is are easily configurable target / max value. We can easily achieve this without a protocol change by adding a new object to the genesis config format:\n\nsomething like:\n```json\n\"blobSchedule\": {\n  \"prague\": { \"target\": 6, \"max\": 9 },\n  \"osaka\":   { \"target\": 12, \"max\": 16},\n  ...\n}\n```",
        "created_at": "2024-12-10T17:34:21.515000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "What's the argument against sending the blob count over the engine API?  The information sent in the current fork choice updated call is already basically a requirement to build a block so why would adding in target and max blobs to the call be a problem?",
        "created_at": "2024-12-10T18:12:55.160000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "i think the main thing is that it is a bit unwieldy to take semi-ephemeral information from the engine API and get it to the right place ELs need it (e.g. RPC is the blocker that has come up, but possibly also in the mempool)",
        "created_at": "2024-12-10T21:18:20.693000+00:00",
        "attachments": null
    }
]