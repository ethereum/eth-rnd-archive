[
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@543900561460822016\u003e transactions aren't technically part of the block header.  They are part of a merkle Patricia trie whose root hash is included in the block header though.  The EIP specifies how they are put into that merkle patricia trie.",
        "created_at": "2020-09-07T01:33:56.810000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "\u003c@301186049323958275\u003e  But theyâ€™re included in full blocks that are announced to peers (e.g. 0x07 NewBlock messages). So Iâ€™m wondering how they should be represented there? I assume as RLP bytes so that a tx decodered can be applied afterwards instead of mixing the RLP decoding with the tx decoding logic",
        "created_at": "2020-09-07T01:47:30.827000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "They would follow the devp2p protocol in that case (which happens to be the same as how they are merklized), and the EIP should state how they are encoded over devp2p.",
        "created_at": "2020-09-07T01:52:44.300000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "On mobile right now, if you can't find it in the EIP I can point it out once at computer and you can hopefully help me understand what wasn't clear about the EIP so I can edit.  ðŸ™‚",
        "created_at": "2020-09-07T01:54:20.951000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003e As of `FORK_BLOCK_NUMBER`, all transactions sent over devp2p or included in a block **MUST** be of the form `TransactionType || TransactionPayload`\n\u003c@!543900561460822016\u003e This is the line I was referring to.  I need to delete the \"or included in a block\" bit since that is actually stated more clearly on another line.",
        "created_at": "2020-09-07T02:08:12.370000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "This is the bit about the transaction root:\n\u003e As of `FORK_BLOCK_NUMBER`, the transaction root in the block header **MUST** be the root hash of `patriciaTrie(leb128(transactionIndexInBlock) =\u003e TransactionType || TransactionPayload)`.",
        "created_at": "2020-09-07T02:12:20.038000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think \u003c@!273808422753796097\u003e was mildly against leb128.  Should we just have a 32 byte key instead?",
        "created_at": "2020-09-07T02:13:09.072000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Or perhaps simply strip leading 0s?",
        "created_at": "2020-09-07T02:13:47.877000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Alternatively we could define the transaction index as 16 bits or something (which should be plenty, and we can always increase the size in a future hard fork).",
        "created_at": "2020-09-07T02:15:05.745000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Going to go with big endian 16-bit for those indexes for now.  I don't feel strongly, so I'm welcome to debate/discussion around them!",
        "created_at": "2020-09-07T02:18:01.372000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003e I don't recommend RLP here, everyone seems to prefer \"something else\"\n\n\u003c@!301186049323958275\u003e hol' up. I'm not sure \"everyone\" is applicable. I think many client devs (including me) would prefer not to drastically change things if it can be avoided. I, for one, prefer RLP, since it's very well known and has stable implementations",
        "created_at": "2020-09-07T09:06:00.710000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "The `patriciaTrie( rlp(index) -\u003e rlp(data))` is used both for the root of transactions, aswell as the root of receipts. There's a build-in quirk, that the `0`th element is, key-ordering-wise, \"after\" the `0x7f`th element, but other than that it's a pretty simple thing that works already. I'll try to rope in some other devs here to get some more input... cc \u003c@!206016661470314496\u003e \u003c@!194432762315407360\u003e",
        "created_at": "2020-09-07T09:11:03.453000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003e \u003c@!301186049323958275\u003e hol' up. I'm not sure \"everyone\" is applicable. I think many client devs (including me) would prefer not to drastically change things if it can be avoided. I, for one, prefer RLP, since it's very well known and has stable implementations\n\u003c@!211091239112671234\u003e Thanks for speaking up!  The impression I got on the call and here in Discord the other day was that no one wanted to use RLP if given the choice, which is why I changed it from RLP.  My goal here is to get 2718 through as smoothly as possible, and if that means SSZ I'm fine with that and if that means RLP I'm fine with that too.",
        "created_at": "2020-09-07T09:18:03.748000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "We *will* have to change the transaction and receipt merkle trie, but we can *only* change the values (not the key) if changing the key complicates things.",
        "created_at": "2020-09-07T09:18:47.273000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "Why do the transactions/receipts trie need to change?",
        "created_at": "2020-09-07T09:19:13.698000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Because we will be adding the TransactionType, which will be part of the value.",
        "created_at": "2020-09-07T09:19:29.167000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "```\npatriciaTrie(transactionIndexInBlock =\u003e TransactionType || ReceiptPayload)\n``` is what the EIP currently has, we could change the key back to `rlp(transactionIndexInBlock)` if that simplifies things.",
        "created_at": "2020-09-07T09:20:22.923000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "The definition of it as `trieroot( rlp(index) -\u003e rlp(object))` doesn't have to change, does it?",
        "created_at": "2020-09-07T09:20:29.431000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "ðŸ¤”  There was quite a bit of \"demand\" on the call and in here to not RLP encode the transaction.",
        "created_at": "2020-09-07T09:20:58.652000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The original specification was `rlp([TransactionType, Payload])` and I received pushback against it from multiple people which is why it was changed to `TransactionType || Payload`.",
        "created_at": "2020-09-07T09:21:45.793000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I'm still unsure why is the transaction type and payload becoming part of the transaction receipt?",
        "created_at": "2020-09-07T12:01:53.390000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "Me too. A `hash` is a hash, no? I don't see why anything other than \"how to calculate the hash/signature/sender given a blob of transaction data\" needs to change.",
        "created_at": "2020-09-07T12:14:29.206000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "Ah wait. My bad. So the patricia trie is _not_ a list of hashes, but a list of bodies. But even so",
        "created_at": "2020-09-07T12:16:38.203000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I'm missing something here. Are we talking about the `receiptsRoot` in the block? That trie does not seem to contain the input transaction, unless I'm missing something?",
        "created_at": "2020-09-07T12:19:20.987000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "Or are we talking about `transactionsRoot`?",
        "created_at": "2020-09-07T12:19:53.589000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "\u003e This is the bit about the transaction root:\n\u003c@!301186049323958275\u003e Ah I see, the main discussion is that this proposal now changes the key from rlp to leb128.",
        "created_at": "2020-09-07T12:22:38.486000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Most recently I dropped leb128 due to feedback against it.",
        "created_at": "2020-09-07T13:03:28.595000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'm just trying to make everyone happy.  ðŸ˜©",
        "created_at": "2020-09-07T13:03:36.896000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "Ah ok, I started to locally edit the EIP, but will wait if you have other changes pending.",
        "created_at": "2020-09-07T13:04:38.754000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!211091239112671234\u003e Correct, the block header has two merkle roots, one for transactions and one for receipts.  The data that goes into the transactions trie is the transaction index (within the block) and the transaction itself.  So it is a consensus requirement that all clients build that merkle trie the same way, which means we all have to use the same encoding for the transaction.",
        "created_at": "2020-09-07T13:05:11.417000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425279588009246720\u003e They are all merged, do you still see LEB128 in master?",
        "created_at": "2020-09-07T13:05:23.285000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "No, it has no leb128 in it.",
        "created_at": "2020-09-07T13:07:01.816000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e right. And as long as \"encoding the transaction\" is well specified and defined, we don't have touch the rules for how the tx/receipt-roots are generated. (unless there's a strong urge to)",
        "created_at": "2020-09-07T13:07:17.092000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I think the EIP could be better organised ðŸ™‚",
        "created_at": "2020-09-07T13:07:19.518000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!211091239112671234\u003e Hmm, IIUC, you are arguing that we don't need to touch the receipts at all?  Originally I didn't and someone an an ACD call indicated that it was needed, and convinced me... but I don't remember what they said.",
        "created_at": "2020-09-07T13:09:10.190000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If I can't remember, and no one else can, then we can cut it and pretend this never happened.  ðŸ™‚",
        "created_at": "2020-09-07T13:09:58.404000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "I don't think I'm arguing that. I'm arguing that `DeriveSHA( \u003clist of things\u003e) =\u003e root` need not change. It can continue to use `rlp(thing)` for values and `rlp(index)` for key",
        "created_at": "2020-09-07T13:10:30.632000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "Would it mean that in `rlp(thing)`  `thing` becomes an opaque byte serialisation of the transaction?",
        "created_at": "2020-09-07T13:11:10.171000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "Or could we say it `key=rlp(index) value=\u003copaque tx bytes\u003e` ?",
        "created_at": "2020-09-07T13:11:54.939000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "I personally don't see the point in making `value=\u003copaque blob\u003e` in favour of `value=rlp(tx)`.",
        "created_at": "2020-09-07T13:13:52.963000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "We can retain `rlp(index)` if that is what people want.  I was *trying* to remove RLP as I saw it since there were multiple people who indicated they didn't like RLP and since we had to touch that code I figured we could drop RLP there while we were futzing in there, but we can keep it like that.  The value *will* need to change though if we do typed transaction receipts.",
        "created_at": "2020-09-07T13:14:31.848000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "What do you mean by `rlp(tx)`? Opaque bytes or not?",
        "created_at": "2020-09-07T13:14:35.190000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "... not sure what you are asking... `rlp(tx)` == rlp-representation of the transaction, however that is defined",
        "created_at": "2020-09-07T13:15:23.153000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "That is the main discussion, if the transaction is not using an outer RLP wrapping, then why define an RLP representation of it for the trie?",
        "created_at": "2020-09-07T13:16:46.855000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Not all transactions necessarily will use RLP (and in fact, there seems to be a strong push to explicitly *not* use RLP for future transaction types).",
        "created_at": "2020-09-07T13:17:25.738000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "What is the functional value of not using RLP for future tx types? It seems like the gains are minimal compared to the increased complexity of the EIP",
        "created_at": "2020-09-07T13:18:20.764000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think most people feel that RLP is hard to work with (which I agree with).",
        "created_at": "2020-09-07T13:19:05.525000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "There's strong push against RLP and it may happen, among other things, that the state trie will not use it.",
        "created_at": "2020-09-07T13:19:44.105000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It also is a bit large for some data structures, which is mildly annoying.",
        "created_at": "2020-09-07T13:19:45.998000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "It seems like other serialization schemes could be introduced at the web3 / RPC / devp2p level if people really want something nicer",
        "created_at": "2020-09-07T13:20:31.261000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I'd actually argue for the trie having a fixed size index and the opaque bytes would be good enough. The trie does not need to define how the data is transmitted on the wire? It is only used to create the hash.",
        "created_at": "2020-09-07T13:20:35.815000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "But I'm relatively clueless here for that part and client devs will know better.",
        "created_at": "2020-09-07T13:22:07.552000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "Well, in that case one could instead have the `value=tx.hash()`. That would make it easier on memory to construct the trie (in a naive implementation which builds the entire structure before collapsing it)",
        "created_at": "2020-09-07T13:23:14.694000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "But still, I think there's quite a leap between introducing a couple of more tx-types and redefining our basic encoding schemes...",
        "created_at": "2020-09-07T13:24:15.595000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "That's true. If it provides some improvements overall, is that a bad step though?",
        "created_at": "2020-09-07T13:26:17.832000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Friendly reminder we had a call scheduled in ~35 mins to discuss 2718 and other YOLOv2 EIPs: https://github.com/ethereum/pm/issues/204",
        "created_at": "2020-09-07T13:26:30.787000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Here is a zoom link we can use: https://consensys.zoom.us/j/97683842262",
        "created_at": "2020-09-07T13:28:04.133000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003e That's true. If it provides some improvements overall, is that a bad step though?\n\nWell, \"some improvements\" needs to be weighed against the complexity of having to support both legacy and new types. All current clients do retain the ability to process the chain from genesis, so it's not like we can just switch over to something new and nuke out all the old stuff.",
        "created_at": "2020-09-07T13:28:40.870000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "With the outer RLP wrapping, I believe there's still some changes. You have mentioned that a \"naive\" implementation could benefit from a simplification, but I believe geth would not have a naive implementation. Would the RLP-wrapped-RLP-transaction approach require any speed improvement from geth's side or is it transparent?",
        "created_at": "2020-09-07T13:30:19.194000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!211091239112671234\u003e It is possible I'm not understanding how your code is currently structured, which is why it is very valuable to get client dev input.",
        "created_at": "2020-09-07T13:31:42.488000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If you receive a transaction over devp2p in the form `ssz(a, b, c, d)`, is it *easier* for you to put that into the trie as `rlp(ssz(a, b, c, d))` than put it in as `ssz(a, b, c, d)`?",
        "created_at": "2020-09-07T13:32:30.011000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Even though that is obviously redundant, the way your code is structured may be such that doing the redundant wrapping is *easier*.",
        "created_at": "2020-09-07T13:33:02.202000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "Actually, geth does have a rather naive implementation, but me and \u003c@!353136597522448385\u003e were just trying to replace that: https://github.com/ethereum/go-ethereum/pull/21407",
        "created_at": "2020-09-07T13:33:13.747000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e well, I think the threshold to cross here is to receive `ssz` from the network in the first place.",
        "created_at": "2020-09-07T13:34:44.965000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "I think it would be messy to sometimes do ssz and sometimes to rlp, but \u003c@!194432762315407360\u003e is better suited than me to address that..",
        "created_at": "2020-09-07T13:35:24.306000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003e Would the RLP-wrapped-RLP-transaction approach require any speed improvement from geth's side or is it transparent?\n\nYou've lost me there, I think.. But regardless, I'm not too worried about speed, more about messiness and potential for screwing things up",
        "created_at": "2020-09-07T13:36:59.553000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Hmm, we'll have to get feedback from other client devs.  I have had I think 3 or 4 core devs now tell me they would rather *not* do RLP for new transaction types, and they would like to drop RLP in favor of \"other\" when the option presents itself.",
        "created_at": "2020-09-07T13:37:36.585000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I meant if `rlp([txtype, [nonce, gasLimit, ..]])` poses any speed change compared to `rlp([nonce, gasLimit, ..])` in terms of that optimised \"derivesha\"?",
        "created_at": "2020-09-07T13:38:21.376000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003e now tell me they would rather not do RLP for new transaction types, and they would like to drop RLP in favor of \"other\" when the option presents itself.\n\nMaybe I'm the odd one out here, hence why I've been trying to bring Felix in..",
        "created_at": "2020-09-07T13:38:37.677000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "But this entire discussion started with instead of having an outer RLP wrapping *on wire* and include a leading byte. That somehow evolved to changing things down the core ðŸ˜¬",
        "created_at": "2020-09-07T13:39:13.326000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'm not *personally* married to any particular encoding format, it isn't critical for the EIP and it is a choice that I think others are in a better position to make ultimately.  At the moment, I'm just trying to keep the EIP in line with \"popular feedback\" I have received so far, which currently favors not-RLP.  ðŸ™‚",
        "created_at": "2020-09-07T13:39:28.376000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425279588009246720\u003e I don't think that particular difference makes any real impact",
        "created_at": "2020-09-07T13:39:36.282000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "To me (not a client developer) I think having a different encoding on the wire and in the merkle trie sounds like the worst option of all.",
        "created_at": "2020-09-07T13:40:14.535000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I would rather see RLP both on the wire and in the trie, or SSZ on the wire and in the trie, or \u003cother\u003e on the wire and in the trie.",
        "created_at": "2020-09-07T13:40:43.081000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "So if we are going to move to SSZ on the wire for some transaction type, then it makes sense IMO to use that same encoding in the trie.",
        "created_at": "2020-09-07T13:41:18.129000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003e But this entire discussion started with instead of having an outer RLP wrapping on wire\n\nWell, wire-request are content-addressed. So if I request by  `hash`  and get something, I need to be able to verify it. And the same `hash` is used in other places, so there's a correlation between what's on the wire and what is intrinsically the transaction itself",
        "created_at": "2020-09-07T13:41:38.090000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "The reason I could live with a different encoding on wire vs. trie is because the incoming transaction format on the wire is something which is used widely (not only within clients) and it is the hardest to change (because a lot more infrastructure depends on it). Changing the trie is something which does not affect outside tooling in terms of changes, so it can be done \"behind the scenes\", at least for a non-client dev perspective (see \"binarification\" as an example).",
        "created_at": "2020-09-07T13:42:00.009000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Yes, but that doesn't *have* to match what is in the block header trie.",
        "created_at": "2020-09-07T13:42:05.149000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I definitely think it *should*, but it isn't technically required.",
        "created_at": "2020-09-07T13:42:13.766000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425279588009246720\u003e What tooling speaks devp2p other than Ethereum clients?",
        "created_at": "2020-09-07T13:42:49.258000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I mean if future transaction types would want to include the transaction type in the signature, all of that is prepared outside of devp2p.",
        "created_at": "2020-09-07T13:43:45.802000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "The legacy transaction wrapping is an exception.",
        "created_at": "2020-09-07T13:44:03.259000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "But even if it goes ahead with the outer RLP wrapping, that still keeps the door open to get rid of it in the future, given the leading byte as we discussed would be easily distinguishable from the first byte of any RLP array ðŸ™‚",
        "created_at": "2020-09-07T13:46:16.660000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think the reason for including the receipt change was because it was believed there would be value in being able to decode the receipt without looking up the transaction it was associated with.",
        "created_at": "2020-09-07T13:48:46.857000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Oh, no, I remember.",
        "created_at": "2020-09-07T13:49:03.185000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It is because of devp2p.  When you receive a receipt over devp2p, I believe the client needs the ability to decode it, which requires knowing its structure.  If we do nothing, then when the client receives a new transaction type receipt it will not be able to decode it and will likely disconnect that peer.",
        "created_at": "2020-09-07T13:50:05.217000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "So technically, we *could* leave legacy receipts the same as they are now, but as soon as we add a second transaction type we will likely need a new receipt type (since the new transaction may not have a receipt that matches the shape of legacy receipts), and that means we will have to define a new receipt type for devp2p layer.  By having the first byte of a receipt over devp2p be the transaction type, it makes it so clients can know *how* to decode the receipt they received over the wire.  If there was no identifier and they tried to decode it as a legacy transaction, decoding would fail.",
        "created_at": "2020-09-07T13:54:31.342000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "So, for all *future* transaction types we really want that leading byte to define the shape of the receipt so it can be decoded easily.  Rather than leaving a special-case branch for legacy transactions, we can instead wrap their receipts up in the new 2718 receipt envelope like all future transactions will be wrapped in.",
        "created_at": "2020-09-07T13:55:58.938000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "For devp2p, I don't think we need to retain backward compatibility like with consensus, so in this case I think we really can delete the old code.",
        "created_at": "2020-09-07T13:56:35.979000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "Will modifying the legacy receipt format cause any problems for downstream tooling?",
        "created_at": "2020-09-07T13:57:47.741000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The current recommendation in the EIP suggests that the client continue to return legacy receipts over their JSON-RPC interfaces and devise a strategy for migrating to new receipts.",
        "created_at": "2020-09-07T13:58:48.288000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Legacy transaction receipts can be converted between 2718 format and old format, so we don't have to break downstream users when we introduce 2718.",
        "created_at": "2020-09-07T13:59:18.594000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I don't understand why there needs to be a change to receipts",
        "created_at": "2020-09-07T14:40:02.790000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!211091239112671234\u003e Assuming we don't deprecate legacy transactions at all, and just introduce a new transaction type (which happens to be signature compatible with legacy transactions, but does not replace them), do you still have a preference for RLP over positional?  Does that feeling change if the `TransactionType` is the first byte (so the transaction type is positional, but the rest may not be)?",
        "created_at": "2020-09-07T15:30:57.452000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!194432762315407360\u003e (are you Felix?  If not, ignore this message) Do devp2p2 changes usually go through the EIP process, or is there a separate process for that?  I can either include the changes to devp2p in this EIP, or just leave out all mention of how the transactions gossip from it.",
        "created_at": "2020-09-07T15:53:12.096000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "We usually make changes through EIPs in the networking category",
        "created_at": "2020-09-07T15:58:39.070000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "https://eips.ethereum.org/networking",
        "created_at": "2020-09-07T15:58:58.486000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "You can see the EIPs that were applied on the eth protocol in the change log section of the spec: https://github.com/ethereum/devp2p/blob/master/caps/eth.md#change-log",
        "created_at": "2020-09-07T16:00:01.502000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003c@301186049323958275\u003e I can't say. If you have some examples I might understand the nuance better. And yes fjl is Felix",
        "created_at": "2020-09-07T16:03:40.242000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Maybe I'll leave mention of devp2p out of 2718 then, and then create a *separate* EIP for the devp2p change.  Especially since the two don't actually need to be tied to each other I don't think.",
        "created_at": "2020-09-07T16:04:31.866000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "ðŸ¤”  Hmm, actually, I may be wrong about that...",
        "created_at": "2020-09-07T16:04:40.407000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If a block contains a 2718 transaction, you need to be able to gossip that transaction with the block, which will require a devp2p change.",
        "created_at": "2020-09-07T16:05:01.129000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'll still split it up though.",
        "created_at": "2020-09-07T16:05:15.647000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The simplest example would probably be a \"cancellation transaction\":\n```\n0x05 || nonce || gasPrice || chainId || yParity || r || s\n``` where `0x05` is the transaction type and `yParity` is `v` but without the baggage.",
        "created_at": "2020-09-07T16:07:39.588000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The signature signs `0x05 || nonce || gasPrice || chainId`.",
        "created_at": "2020-09-07T16:08:02.959000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "~~The `0x05` is in there twice so that we don't need to manually construct the signed data, while still maintaining that the `TransactionType` is the first byte for rapid discrimination.~~",
        "created_at": "2020-09-07T16:09:02.545000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "Well why not reorder it to `0x05 || nonce || gasPrice || chainId || yParity || r || s ||` and sign the first part?",
        "created_at": "2020-09-07T16:09:58.241000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Ah, good point for this one.  ðŸ™‚",
        "created_at": "2020-09-07T16:10:09.569000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "The other approach was needed to have the ability to wrap legacy transactions.",
        "created_at": "2020-09-07T16:10:18.691000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "So is the question if I would prefer `rlp([0x05, nonce, gasPrice, chainId, yParity, r, s])` or binary concatenation of fixed-size fields? Personally I'd favour rlp-lists.",
        "created_at": "2020-09-07T16:24:53.635000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Most likely the alternative would be something like `rlp([0x05, rlp([[0x05, nonce, gasPrice, chainId], [yParity, r, s]]))`",
        "created_at": "2020-09-07T16:31:33.892000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Since if we did RLP over the whole thing we would still want the second outermost list item to be a byte array.",
        "created_at": "2020-09-07T16:32:05.865000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Actually, probably need another RLP in there...\n```\nrlp([0x05, rlp([rlp([0x05, nonce, gasPrice, chainId]), [yParity, r, s]])])\n```",
        "created_at": "2020-09-07T16:34:30.349000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Which actually exemplifies one of the problems I think people have with RLP.  It isn't trivial to extract pieces off the head or tail, you have to decode the whole thing, and you can't split it up into parts without decoding the whole thing.  This leads to rlp nested in rlp as seen above, rathere than the much simpler positional format which lets you split up the encoded payload into discrete pieces without any decoding.",
        "created_at": "2020-09-07T16:36:11.740000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "That looks a bit overkill, how about \u003c@273808422753796097\u003e 's proposal this morning?",
        "created_at": "2020-09-07T17:00:44.436000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003e Basically, instead of having the data structure be rlp([3, rlp([a, b, c, d, e, f, sig_v, sig_r, sig_s])]) where the signing root is rlp([3, rlp([a, b, c, d, e, f])]), the data structure would be rlp([3, rlp([[a, b, c, d, e, f], [sig_v, sig_r, sig_s]])]) where the signing root is hash(3, hash(rlp([a, b, c, d, e, f])))",
        "created_at": "2020-09-07T17:01:42.875000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I believe that suggestion still leaves us with the problem of having to decode and then encode to validate a signature.",
        "created_at": "2020-09-07T17:04:50.670000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Oh, maybe not.  He has you do an extra round of hashing to get around that problem.",
        "created_at": "2020-09-07T17:05:15.603000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "And I think you have to decode and then encode to verify signature?",
        "created_at": "2020-09-07T17:06:12.301000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "You cannot easily turn `rlp([a,b,c], [v,r,s])` into `rlp([a,b,c])` without decoding and then encoding.",
        "created_at": "2020-09-07T17:06:40.372000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "So I believe if you want to avoid that whole thing *and* you want transaction payload to be opaque before discriminating, then you have to have 3 layers of RLP.",
        "created_at": "2020-09-07T17:07:25.809000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "While Vitalik's suggestion is marginally better because at least we aren't having to tear apart lists and reconstruct them, it still has the problem of needing to decode =\u003e extract =\u003e encode.",
        "created_at": "2020-09-07T17:08:12.788000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "\u003e Which actually exemplifies one of the problems I think people have with RLP.  It isn't trivial to extract pieces off the head or tail, you have to decode the whole thing, and you can't split it up into parts without decoding the whole thing. This leads to rlp nested in rlp as seen above, \n\u003c@301186049323958275\u003e",
        "created_at": "2020-09-07T18:11:20.710000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "About this: I think there is a misunderstanding",
        "created_at": "2020-09-07T18:11:45.067000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "RLP is *recursive* length prefix",
        "created_at": "2020-09-07T18:12:01.162000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "When decoding, it is absolutely possible to walk the structure and get the element you want",
        "created_at": "2020-09-07T18:12:42.547000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "With a custom decoder, yes.  But I don't think you can with a simple RLP decoder (which I believe is what everyone has implemented).",
        "created_at": "2020-09-07T18:13:05.865000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "(it is late, my brain is fuzzy, I admit I may be very wrong about the things I am saying)",
        "created_at": "2020-09-07T18:13:31.950000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "You don't really need to write `rlp([x, rlp([y, z])])`, it's redundant",
        "created_at": "2020-09-07T18:13:57.223000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "We usually just write `[x, [y, z]]` when we mean that",
        "created_at": "2020-09-07T18:14:25.664000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "The `[]` implies that everything contained in the list is RLP",
        "created_at": "2020-09-07T18:14:58.326000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "(In this example, `x` `y` and `z` are byte arrays)",
        "created_at": "2020-09-07T18:15:51.834000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think I agree (again, very late, very fuzzy brained at the moment).  You'll still need two I believe, since we expressly want the outer array to be a two-item list with the second element being a byte array.",
        "created_at": "2020-09-07T18:16:44.196000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "`rlp(TransactionType, Payload)` where `Payload` may be RLP encoded, or may be encoded in some other way (to be defined by future transaction type EIPs).",
        "created_at": "2020-09-07T18:17:08.049000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Unless we just assert that \"We will use RLP everywhere forever\" which goes against what many people seem to want to avoid.",
        "created_at": "2020-09-07T18:17:42.663000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Yeah, this is what the discussion around the RLP is about I think",
        "created_at": "2020-09-07T18:17:53.744000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I don't get it, why avoid the RLP? TXs are RLP now, and it's not a problem.",
        "created_at": "2020-09-07T18:18:28.629000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I agree with the proponents of \"drop RLP\" in that RLP *is* annoying to work with at times, particularly when you have mostly fixed length fields or a schema.",
        "created_at": "2020-09-07T18:19:28.143000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "It sounds like a tooling problem to me",
        "created_at": "2020-09-07T18:19:54.300000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "At least in python and go, we have libraries that can work with a schema",
        "created_at": "2020-09-07T18:20:15.634000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Also I believe part of the argument is that ETH1x will *eventually* have SSZ in it because it will eventually need to integrate with ETH2, and so we cannot be RLP-for-life, and if we are going to get SSZ eventually, why-not-now?",
        "created_at": "2020-09-07T18:20:20.899000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "We just define structs for it and the decoder uses them to verify the input",
        "created_at": "2020-09-07T18:20:46.260000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I think the JS library also supports some kind of schema",
        "created_at": "2020-09-07T18:21:16.392000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I won't argue that RLP doesn't work.  It just can be awkward.  One of those things where when you are working with it a lot it constantly is mildly annoying.",
        "created_at": "2020-09-07T18:21:29.832000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "There are relatively few encoding systems that wouldn't work.",
        "created_at": "2020-09-07T18:22:21.924000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Not trying to defend it too much here, I don't care so strongly. Mostly, I just find it a bit annoying to mix encodings because that will for sure make it very complicated to deal with in the future.",
        "created_at": "2020-09-07T18:23:07.078000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If there wasn't already a plan to introduce SSZ into Ethereum I believe I would agree with that sentiment reasonably strongly, or at least not try to argue against it.",
        "created_at": "2020-09-07T18:23:42.524000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Actually, it would be interesting to know if this 'typed TX envelope' idea would work if transactions had been SSZ from the beginning",
        "created_at": "2020-09-07T18:24:11.910000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think it would have been slightly harder, since we didn't include versioning/discrimination from the start.",
        "created_at": "2020-09-07T18:24:52.693000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I mean, is it actually possible to define an SSZ type where the first byte determines what the schema of the remaining bytes is?",
        "created_at": "2020-09-07T18:25:12.189000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "RLP as encoding is not very convenient in 2 main cases: (1) when we generate input for cryptographic hash, RLP is redundant, because we will never need to decode. But because you have to provide prefix first, you are forced to buffer the entire input before you can start hashing. It is not a problem for fixed-size inputs or for small inputs, but becomes a problem for large inputs. (2) because RLP prefixes themselves are variable-length, it means again that for large payloads you cannot start sending the data before you have completely assembled it. For messages with small payloads it is not an issue. But for larger payloads, you end up first computing the length of the data, then the length of the prefix, etc. It is a minor inconvenience, I know, but could be avoided if, for example, data was chunked and each chunk has a fixed-size prefix",
        "created_at": "2020-09-07T18:25:15.319000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Could probably have made it work by utilizing the high bit since I believe `nonce` is first and the nonce will never set the high bit.",
        "created_at": "2020-09-07T18:25:19.173000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "\u003c@456226577798135808\u003e I can understand that, it's a common complaint that you can't do streaming encoding.",
        "created_at": "2020-09-07T18:26:52.307000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "\u003e I mean, is it actually possible to define an SSZ type where the first byte determines what the schema of the remaining bytes is?\n\u003c@194432762315407360\u003e answering my own question here, I think this would be done with a union type",
        "created_at": "2020-09-07T18:28:04.268000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003e I mean, is it actually possible to define an SSZ type where the first byte determines what the schema of the remaining bytes is?\n```ts\nswitch (transaction_bytes[0]) {\n    case 0:\n        ssz_decode(transaction_bytes, [{'transaction_type':uint8}, {nonce:uint64}, ...])\n        break\n}\n``` \u003c@!194432762315407360\u003e I would handle it like this personally.",
        "created_at": "2020-09-07T18:28:28.522000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Discriminated union effectively.",
        "created_at": "2020-09-07T18:28:51.177000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I just wanted to say that some opposition to RLP is not without grounds. If, for example we expect tx data to be quite large, computing the hash of the RLP becomes less convenient than computing the hash of concatenation of fields, because keccak is a sponge",
        "created_at": "2020-09-07T18:28:57.479000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "so the usage of the sponge is similar to usage of streaming",
        "created_at": "2020-09-07T18:29:24.169000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think the tagline here would be \"RLP doesn't stream well\".",
        "created_at": "2020-09-07T18:29:42.093000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "and RLP is not streaming friendly, so it is not sponge-hash friendly either",
        "created_at": "2020-09-07T18:29:44.458000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "It's generally not so friendly for any hash, sponge or not. Don't think the sponge part matters so much.",
        "created_at": "2020-09-07T18:30:29.437000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "Yes, that's true. So I suggest stop using RLP for inputs to hash",
        "created_at": "2020-09-07T18:30:54.580000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "at least",
        "created_at": "2020-09-07T18:30:59.168000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think that is where we use RLP the most currently?  ðŸ˜œ",
        "created_at": "2020-09-07T18:31:17.928000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "that's unfortunate, of course",
        "created_at": "2020-09-07T18:31:51.622000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "It doesn't matter too much when you do it in Javascript in the browser, but was a huge pain doing it on the trezor ðŸ™‚",
        "created_at": "2020-09-07T18:33:11.108000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Hmm, so let's get back to the original question",
        "created_at": "2020-09-07T18:33:12.332000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "I think both \"proponents\" and \"opponents\" agree that rlp is bad for streaming. The basis of my being proponent is not because it's the best protocol, but because it's what we already have. I think sliding ssz in there via the eip is a bit of a sidestep",
        "created_at": "2020-09-07T18:34:06.684000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "In this particular case, we aren't sliding in SSZ, just concatenation... which happens to be SSZ compatible.",
        "created_at": "2020-09-07T18:34:49.520000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "If we define the envelope as `[type, txdata]`, it doesn't actually matter whether the `txdata` is a byte array or list.",
        "created_at": "2020-09-07T18:34:51.547000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "I mean, it makes the eip implementation more complicated than they'd have to be (for existing clients)",
        "created_at": "2020-09-07T18:34:52.517000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "(we are lucky here in that there is only a single variable length piece of data, so we don't actually need an SSZ encoder/decoder to be SSZ compatible)",
        "created_at": "2020-09-07T18:35:11.940000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "But actually, I'm with \u003c@194432762315407360\u003e, so whatever you convince him of, I'm onboard too",
        "created_at": "2020-09-07T18:35:31.676000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "So what we can do is just leave it undefined what the type of `txdata` will be.",
        "created_at": "2020-09-07T18:35:59+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003e If we define the envelope as `[type, txdata]`, it doesn't actually matter whether the `txdata` is a byte array or list.\n\u003c@!194432762315407360\u003e The primary question is whether `[type, txdata]` or `type || txdata`.",
        "created_at": "2020-09-07T18:36:06.048000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Primary argument against `type || txdata` I *think* is that implementation complexity will be higher than `[type, txdata]`?",
        "created_at": "2020-09-07T18:36:43.986000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Ultimately, the `type || txdata` will need to be encoded as an RLP byte array in order to be in a block.",
        "created_at": "2020-09-07T18:37:17.439000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'm a *tad* dubious on this since I would expect popping a byte off the head of an array is pretty trivial in almost every language, but I certainly may be missing something with current client designs that makes that \"hard\" or complicated.",
        "created_at": "2020-09-07T18:37:21.600000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "How does `type || txdata` work? Doesn't that assume an length-prefixed envelope?",
        "created_at": "2020-09-07T18:37:30.581000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003e Ultimately, the `type || txdata` will need to be encoded as an RLP byte array in order to be in a block.\n\u003c@!194432762315407360\u003e Why?",
        "created_at": "2020-09-07T18:37:33.883000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Because blocks are RLP, and you can't just put arbitrary bytes into your RLP",
        "created_at": "2020-09-07T18:38:00.349000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Blocks headers don't have the transaction in them.",
        "created_at": "2020-09-07T18:38:16.929000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "They only have a transaction root.",
        "created_at": "2020-09-07T18:38:20.148000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Remember, it's  *recursive*",
        "created_at": "2020-09-07T18:38:24.518000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Block bodies do though, and these are sent in the network protocol",
        "created_at": "2020-09-07T18:38:43.472000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Ah, this may be the piece I was missing.  I thought you got the block header, and then separately got the transactions for that block?",
        "created_at": "2020-09-07T18:39:09.863000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "Yes, but the block bodies consist of two lists, transaction lists and receipt lists (EDIT, not quite right, see below)",
        "created_at": "2020-09-07T18:39:41.269000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "the concrete lists can then be fed into `DeriveSha` to see that they match with teh roots",
        "created_at": "2020-09-07T18:40:15.144000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "`block_body = [[tx1, tx2, tx3],[receipt1, receipt2, receipt3]]` (where `[]` is RLP list)?",
        "created_at": "2020-09-07T18:40:33.180000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "https://github.com/ethereum/devp2p/blob/master/caps/eth.md#blockbodies-0x06",
        "created_at": "2020-09-07T18:41:14.272000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "ah my bad",
        "created_at": "2020-09-07T18:41:43.284000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Also see the message below that, which has the full block (header, txs, uncles)",
        "created_at": "2020-09-07T18:42:07.806000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Unless we change all the encodings, there will always be a place where the payload needs to be wrapped in a byte array",
        "created_at": "2020-09-07T18:42:52.669000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I'm stepping in late to this discussion after a quick read through the history but probably missing some context.  Wouldn't the new block body just be `rlp([type_1 || txn_payload_1, ..., type_n || txn_payload_n], [type_1 || receipt_payload_1, ..., type_n || receipt_payload_n])` ?  This still keeps RLP out of the individual txn/receipt encodings but doesn't heavily modify the block structure in any significant way.",
        "created_at": "2020-09-07T18:43:27.213000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "\u003c@194432762315407360\u003e but `type || payload` *is* a byte array, why does it needs further wrapping?",
        "created_at": "2020-09-07T18:43:37.425000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Yes, it's a byte array, but when you put it into an RLP list, it will get a length prefix",
        "created_at": "2020-09-07T18:44:25.709000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e but is it a big win to not prefix the inner types, if we still have to prefix the outer envelope? I mean, it's just as bad for streaming anyway, right?",
        "created_at": "2020-09-07T18:44:26.052000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "isn't `type || payload` the entire envelope?",
        "created_at": "2020-09-07T18:44:51.176000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "\u003e Yes, it's a byte array, but when you put it into an RLP list, it will get a length prefix\n\nAnd why is that a problem?",
        "created_at": "2020-09-07T18:44:59.333000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "It's not a problem at all",
        "created_at": "2020-09-07T18:45:08.209000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "`type || payload` or `[type, payload]` \u003c@!364458974906548225\u003e (that is the current debate)",
        "created_at": "2020-09-07T18:45:14.397000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I don't really care which one",
        "created_at": "2020-09-07T18:45:26.272000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I'm strongly in favor of `type || payload`",
        "created_at": "2020-09-07T18:45:26.393000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003e  isn't type || payload the entire envelop\n\nHow do you know when the message ends?",
        "created_at": "2020-09-07T18:45:29.849000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "\u003c@!211091239112671234\u003e you have a bytearray, the first byte is the type, everything else is the payload",
        "created_at": "2020-09-07T18:45:56.801000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e Would be great to hear your argument why you strongly favor concatenation.  I was trying to defend it, but I'm definitely not the biggest proponent.  ðŸ™‚",
        "created_at": "2020-09-07T18:46:02.569000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I think the byte array approach is better because it leaves the incoming transaction untouched.",
        "created_at": "2020-09-07T18:46:11.440000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "What benefit does the `[type, payload]` provide?",
        "created_at": "2020-09-07T18:46:21.999000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "How did I get the byte array? How did I know when to stop reading the stream?",
        "created_at": "2020-09-07T18:46:29.092000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "The `type || payload` potentially saves one length prefix if `payload` is not RLP. That makes it slightly preferable.",
        "created_at": "2020-09-07T18:46:49.679000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "\u003c@!211091239112671234\u003e at the network level it is `rlp(type || payload)` and the RLP encoding tells you how long the stream is.",
        "created_at": "2020-09-07T18:46:54.625000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "Right. ok, then I'm with you. That's what I meant by an envelope",
        "created_at": "2020-09-07T18:47:19.125000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "IIUC, if it is `[type, payload]` and you run a BlockBody through your RLP decoder you'll walk away with type and payload already separated without having to do any further decoding/extraction.",
        "created_at": "2020-09-07T18:47:21.967000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "\u003e What benefit does the `[type, payload]` provide?\n\nLet's call `type || payload` as `raw_tx`.\n\nThis needs a byte for array, and a length prefix for payload, e.g `0xc1, type, payload_length, payload` or something like that.\n\nWheres `type || payload` just becomes `raw_tx_length, raw_tx`, of course `raw_tx_length`'s encoding depends on how big is the value.\n\n(Sorry for editing)",
        "created_at": "2020-09-07T18:47:36.552000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "If `payload` is just RLP, which it might be, then we don't save anything with `type || payload`",
        "created_at": "2020-09-07T18:48:28.131000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If you have `type || payload`, when you rlp decode your block body you end up with a transaction byte array that you then need to extract the type from.",
        "created_at": "2020-09-07T18:48:29.088000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "`payload` is just bytes, not RLP in the version I'm thinking about",
        "created_at": "2020-09-07T18:48:45.846000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "(eh, to clarify, it *might* be RLP, but it doesn't have to be)",
        "created_at": "2020-09-07T18:49:03.414000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Yes",
        "created_at": "2020-09-07T18:49:08.588000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e That is true still, but the argument here is that if a transaction type *happens* to use RLP then you get the decoding \"for free\" when you decode the block body/transaction.",
        "created_at": "2020-09-07T18:49:19.216000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "some txn types may use RLP for the payload, others might use something else, the option is open for either.",
        "created_at": "2020-09-07T18:49:22.117000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "What I'm trying to avoid here is `rlp(type || rlp([...]))`",
        "created_at": "2020-09-07T18:50:20.062000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'm a bit dubious about the benefits of that myself, but that is because of the specifics of how I imagine implementing a block/transaction parser/processor.  I can imagine a parser/processor that benefits from a single pass decode.",
        "created_at": "2020-09-07T18:50:30.114000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!194432762315407360\u003e ðŸšŽ we can achieve that by committing to never using RLP for transactions.  ðŸ˜‰",
        "created_at": "2020-09-07T18:50:48.209000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "\u003c@!194432762315407360\u003e can you explain why you want to avoid that?",
        "created_at": "2020-09-07T18:50:51.556000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Mostly because it would mean having two length prefixes for the payload",
        "created_at": "2020-09-07T18:51:18.370000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "\u003e I can imagine a parser/processor that benefits from a single pass decode.\n\nSo one thing we have in geth, courtesy of \u003c@194432762315407360\u003e, is typed decoders that are cached and reused. Having multiplexing decoding sounds a bit un-optimal to me",
        "created_at": "2020-09-07T18:51:39.709000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "@Micah is right, the solution is to just never to use RLP again for transactions",
        "created_at": "2020-09-07T18:51:51.694000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "\u003c@!194432762315407360\u003e only at the networking level when it's being transmitted over the wire and wouldn't it have multiple length prefixes anyways since that is what RLP does internally?",
        "created_at": "2020-09-07T18:52:09.073000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Yes, what I meant is that it would have two around the same object",
        "created_at": "2020-09-07T18:52:38.391000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "If you RLP encode the list, then RLP-encode the resulting byte array, there will be two prefixes in the output",
        "created_at": "2020-09-07T18:53:13.438000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Anyway, as we agreed, the concatenation is generally better",
        "created_at": "2020-09-07T18:53:47.740000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "It avoids the additional prefix on the payload for TX types where the payload doesn't need it because it's not RLP.",
        "created_at": "2020-09-07T18:54:23.967000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "but in general, using `envelope = type || payload` as the canonical encoded representation of a transaction keeps RLP out of the core envelope protocol and allows us to use something else.  For txn type `0` this would end up being `type || rlp(\u003clegacy-txn-params\u003e)` but newer types might be `type || ssz(txn)` or `type || cbor(txn)`...   And for blocks, it ends up being `rlp([txn_envelope_1, ..., txn_envelope_n], ...)`.",
        "created_at": "2020-09-07T18:55:03.193000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Yes",
        "created_at": "2020-09-07T18:55:20.163000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "So I think we *may* be talking about the same thing.  Is anyone still leaning towards `rlp([type, payload])` or have a case for it that seems to make it better than `type || payload`?",
        "created_at": "2020-09-07T18:55:45.052000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Unless they have changed their mind, I believe fjl and holiman want `[type, payload]`, I believe you, axic and alexey seem to want `type || payload`.  I mildly prefer `type || payload`, but care far more about this issue not blocking this EIP.",
        "created_at": "2020-09-07T18:56:58.453000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I'm OK with either of them",
        "created_at": "2020-09-07T18:58:10.776000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "It will be the same amount of work to implement",
        "created_at": "2020-09-07T18:58:25.155000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "... but as I said, I'll defer my opinion to Felix",
        "created_at": "2020-09-07T18:58:28.308000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Cool, it sounds like we are clearly going with the concatenation then",
        "created_at": "2020-09-07T18:58:57.026000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I don't care how it is encoded in the block body or for the transactionRoot (albeit would be nice simplifying those too), but would prefer `||` for the canonical on-wire representation.",
        "created_at": "2020-09-07T18:59:10.495000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425279588009246720\u003e You mean for `GetPoolTransactions` response?",
        "created_at": "2020-09-07T19:00:07.665000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I sometimes want one of those game-show style balloon drops where 1000's of balloons magically fall from the ceiling to happen in my living room when we agree on something and move onto the next thing.",
        "created_at": "2020-09-07T19:00:15.398000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I would only want that if the agreement is unanimous rather than \"I don't care enough to keep fighting\".  ðŸ˜–",
        "created_at": "2020-09-07T19:01:14.594000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I believe where || vs [] matters the most is how to calculate canonical transaction hash.",
        "created_at": "2020-09-07T19:01:45.389000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Would the value in the transaction trie match the value that is hashed to create the transaction hash?",
        "created_at": "2020-09-07T19:02:40.221000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "As RPC input, devp2p, and blockbody/transactionroot all could in theory just reformat between concatenation and RLPification, but there should be an agreement on how to calculate the transaction hash.",
        "created_at": "2020-09-07T19:02:51.299000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Soo.... that opens up the question as to whether the new transaction types should be RLP encoded or not.  ðŸ˜¬",
        "created_at": "2020-09-07T19:05:24.382000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "```ts\n0x00 || yParity || r || s || 0x65000000 || rlp(nonce, gasPrice, gasLimit, to, value, data)\n// or\n0x00 || rlp([[yParity, r, s], [nonce, gasPrice, gasLimit, to, value, data]])\n```",
        "created_at": "2020-09-07T19:07:03.699000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "(specifically the ones defined in 2718)",
        "created_at": "2020-09-07T19:07:26.506000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I would assume that `envelope = type || payload` and that all network messages would just use `envelope` where they previously used `rlp([txn_params, ...])`.  This would also apply to the transaction trie, which currently does `Trie([rlp(1), txn_1], ..., [rlp(n), txn_n])`,  and would now do something like:\n\n- `Trie([rlp(1) , envelope_1], ..., [rlp(n), envelope_n])`\n- or if we want to ditch RLP there as well:  `Trie([encode(1), envelope_1], ..., [encode(n), envelope_n])` where `encode(1)` could be simple big endian encoding, LEB128, whatever.",
        "created_at": "2020-09-07T19:08:17.604000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "There was some negative sentiment to LEB128 there, and also some negative sentiment to changing the trie key format in general.",
        "created_at": "2020-09-07T19:09:08.509000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "and that we would compute transaction hash via `hash(envelope)`?",
        "created_at": "2020-09-07T19:09:14.737000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Yeah, currently specification says hash is `hash(envelope)`.",
        "created_at": "2020-09-07T19:09:50.557000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "doesn't `rlp(integer)` just end up as `length_prefixe || big_endian(integer)`?",
        "created_at": "2020-09-07T19:10:02.286000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "that seems silly to keep around since we could just drop the length prefix and have it be `big_endian(integer)`",
        "created_at": "2020-09-07T19:10:27.288000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "(but please tell me if I'm missing some aspect of this)",
        "created_at": "2020-09-07T19:10:42.887000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Do we need to conserve space in the trie key?",
        "created_at": "2020-09-07T19:10:44.807000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If not then just declaring it as a 16-bit number seems sufficient to me (e.g., `0x0001`).",
        "created_at": "2020-09-07T19:11:26.024000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "*Assuming* we want to change the key.  I think \u003c@!211091239112671234\u003e expressed a preference for not touching it, mainly due to the fact that we don't *need* to touch it so we can reduce the scope of this EIP.",
        "created_at": "2020-09-07T19:12:12.601000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e I'm -0 on that.  The trie keys are unambigously transaction indices and thus a non-fixed length big-endian encoding seems totally adequate.",
        "created_at": "2020-09-07T19:12:23.925000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Just strip the zeros?",
        "created_at": "2020-09-07T19:12:44.101000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "```\n0x0001 =\u003e 0x1\n0x1000 =\u003e 0x1000\n```",
        "created_at": "2020-09-07T19:13:11.532000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "Yes",
        "created_at": "2020-09-07T19:13:21.211000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "It is a one way function so it doesn't matter if you pad or not, as long as the specification is clear, imho.",
        "created_at": "2020-09-07T19:13:29.339000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "Also, we already *sort of* have to touch the trie to specify that the values in the transaction trie are now `envelope` and thus, specifying the `key` format seems like a small extra bit.",
        "created_at": "2020-09-07T19:14:27.968000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Ah, right.  We just hash it and use the hash as the trie path.",
        "created_at": "2020-09-07T19:14:31.085000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "My biggest pet peeve about RLP is that it has no type information, everything is just a \"value\". So even though one can decode it, unless you have a schema, you may misinterpret each value wrongly.\n\nThere was an argument that SSZ is useless without a schema, and that is true. But so is RLP mostly. Now, CBOR on the other hand... ðŸ˜œ",
        "created_at": "2020-09-07T19:14:35.083000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425279588009246720\u003e I thought CBOR was missing fixed length bytearrays.  Am I mis-remembering?",
        "created_at": "2020-09-07T19:15:23.596000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "It has fixed and variable length byte arrays and mappings, among other things.",
        "created_at": "2020-09-07T19:15:40.709000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "And some special values like null, etc.",
        "created_at": "2020-09-07T19:15:52.423000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "However I think the ship has sailed with getting cbor into eth2, and maybe it is worth more making the two systems more similar, than different.",
        "created_at": "2020-09-07T19:16:36.330000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'm assuming we want `type || payload` for the receipts as well, for the same reasons?",
        "created_at": "2020-09-07T19:16:55.872000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I believe transactions and receipts show up in all of the same places throughout Ethereum, so we would likely follow the same set of rules for them?",
        "created_at": "2020-09-07T19:17:22.053000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "one thing that I'm really excited about having SSZ, is the trie hashing.  Currently, when you get an Eth1 hash, it's just `keccak(bytes)` which I've found very limitiing when trying to design some of the protocols where having the hash be a merkle root allows for things like proofs about sub-sections of the data as well as retrieving the data from multiple sources as if it was a torrent that you could pull individual pieces from different seeders.",
        "created_at": "2020-09-07T19:18:28.545000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "I think for the sake of preparing trie roots an encoding like ssz would be more adequate compared to rlp.",
        "created_at": "2020-09-07T19:18:37.126000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Why?",
        "created_at": "2020-09-07T19:21:29.420000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e I'm just going to drop this here because it is a bigger change but...  If we did `Header.transaction_root = SSZHash(SSZList[envelope_1, ..., envelope_n])` in the header... that would enable some things that we currently cannot do.  Specifically, if I want a to fetch a single transaction at a specific index \"trustlessly\", then I have to fetch them all to verify them against the header.  If we used SSZ here, then someone could provide me with only the element I asked for and a merkle proof (part of the SSZ spec, aka SSZ partials) and omit all of the other data.",
        "created_at": "2020-09-07T19:22:08.827000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "Because with ssz you would know the expected size of the data structure prior to encoding, for most of the cases, iirc. And this should allow for memory use optimisations, the amount of memory used is not a big deal nowadays, but memory management (malloc) can turn into a bottleneck.",
        "created_at": "2020-09-07T19:22:18.409000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "It would also remove the dependency on the hexary patricia tree which is also going away with binary trie change.",
        "created_at": "2020-09-07T19:23:04.943000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e I have no problem with that change, but I fear that it is likely to delay/push back 2718, which I would like to avoid as much as possible.  That being said, I wouldn't mind assisting with an EIP that changes to that.",
        "created_at": "2020-09-07T19:23:53.006000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "conversely, if we keep the hexary patricia trie for `Header.transaction_root`, then once we've done the binary trie transition, it would be this dangling dependency on the hexary patricia trie that we'd be stuck with....",
        "created_at": "2020-09-07T19:24:32.784000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think that changing what `block.transaction_root` means can be done in any hard fork, it doesn't have to coincide with transaction changes?",
        "created_at": "2020-09-07T19:25:26.401000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I realize my \"compelling\" reason above about fetching single transactions isn't actually correct, since you could do the same thing with the current hexary patricia trie and providing a proof.  I guess the only compelling piece here is that the hexary patricia trie is on it's way out and so it would be nice to not have the `header.transaction_root` be the only dependency left.",
        "created_at": "2020-09-07T19:25:44.188000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "It's just that nobody stores the block transaction in their trie format, maybe nobody would store them in their SSZList format either...",
        "created_at": "2020-09-07T19:26:53.402000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Why bother with a trie then instead of just a hash?",
        "created_at": "2020-09-07T19:27:22.885000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Was it just \"big dreams, didn't come to fruition\"?",
        "created_at": "2020-09-07T19:27:31.359000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I don't understand the question",
        "created_at": "2020-09-07T19:27:44.624000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "oh, why does the protocol use a trie in the `Header.transactions_root`?",
        "created_at": "2020-09-07T19:28:04.048000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If no one actually stores the transaction trie as a trie, and no one does transaction proofs, then why not just have `transaction_root` be `transaction_list_hash`?",
        "created_at": "2020-09-07T19:28:17.652000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "because there was forethought that we would *want* to do proofs, but it hasn't actually played out well that way since the `devp2p/eth` protocol really depends on clients having local indexes and being able to respond to requests for \"give me all the transactions/uncles for block X\".  But I think we're getting towards a point in the network (specifically in the DHT based chain history network I'm working on designing and building) where the ability to those proofs is going to be valuable.",
        "created_at": "2020-09-07T19:30:05.363000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I agree that I **do not** want to hold up EIP-2718 with anything that isn't necessary.  I do think that dropping the hexary-patricia trie dependency is potentially compelling since 1) we already have to re-specify how `header.transaction_root` is constructed and 2) we know that we have plans to drop all other uses of the hexary-patricia trie.",
        "created_at": "2020-09-07T19:33:11.289000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If the argument is compelling enough, then that change being in a separate EIP shouldn't make a difference.  ðŸ™‚",
        "created_at": "2020-09-07T19:33:50.064000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "I'll post it as a question on the forums and see if anyone speaks up as being against it.",
        "created_at": "2020-09-07T19:33:54.076000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think the biggest pushback is going to be that it will require implementing SSZHash and SSZList in ETH1 *today* rather than \"sometime in the future\".",
        "created_at": "2020-09-07T19:34:47.919000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "\u003e If the argument is compelling enough, then that change being in a separate EIP shouldn't make a difference.  ðŸ™‚\nAgreed, though I sometimes worry about our tendency towards avoiding change, but maybe we can just plan to drop it in at the same time we do binary trie so that we eliminate the argument of YAGNI",
        "created_at": "2020-09-07T19:34:50.021000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "Ok, I'm onboard with that.  I'll be planning to push such a separate EIP then in whatever the same Fork we do binary trie in.",
        "created_at": "2020-09-07T19:35:32.143000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "That \"binarification\" step is growing every single day ðŸ™‚",
        "created_at": "2020-09-07T19:38:08.030000+00:00",
        "attachments": null
    }
]