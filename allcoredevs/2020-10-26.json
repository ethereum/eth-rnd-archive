[
    {
        "author": "matkt0",
        "category": "general",
        "parent": "",
        "content": "\u003e We've sneak-launched Yolo-v2 now. Ethstats: https://yolov2.ethdevops.io/ (password `yolov2`) , faucet: https://faucet.yolov2.ethdevops.io/ and explorer https://explorer.yolov2.ethdevops.io/ . The genesis is here:  https://gist.github.com/holiman/b5f6e9a69cbe2c67c2b3822c15dbfc17 .\n\u003c@!211091239112671234\u003e \nit seems the links no longer work",
        "created_at": "2020-10-26T09:14:11.616000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "Ty!",
        "created_at": "2020-10-26T10:02:42.151000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "general",
        "parent": "",
        "content": "thanks for taking a look and catching those errors in AddMod \u003c@!381789485777682434\u003e .  Modulus specific optimizations could be an interesting route for speedups.  I am hoping that there may be lower-hanging fruit for bringing the performance of Geth-evm384 closer to evmone-evm384 (and exploring modulus-specific optimizations as a last resort for evm384).\n\ne.g. After doing some manual unrolling for the inner-loop of MulMod (and several other optimizations to reduce branching), I was able to bring `go-mulmod-time / cpp-mulmod-time` down to 1.5 from the 2x I posted above.",
        "created_at": "2020-10-26T18:33:40.834000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "general",
        "parent": "",
        "content": "outside of the EVM384 opcodes themselves, the overhead of Geth's interpreter loop also appears to be a significant factor in the overall cost of our synthetic pairing approximation (more so than evmone).  Maybe there are speedups to be found here.",
        "created_at": "2020-10-26T18:36:42.378000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "\u003e outside of the EVM384 opcodes themselves, the overhead of Geth's interpreter loop also appears to be a significant factor in the overall cost of our synthetic pairing approximation (more so than evmone).  Maybe there are speedups to be found here.\n\u003c@!427903869226582018\u003e What do you use as a reference for C performance? https://github.com/jwasinger/evmone/blob/cc1806f3ce2afc7b805a8ae1b38c23cca505cdff/lib/evmone/bigint.h#L302 or `montmul_noninterleaved`?",
        "created_at": "2020-10-26T18:40:32.807000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "general",
        "parent": "",
        "content": "interleaved",
        "created_at": "2020-10-26T18:41:06.498000+00:00",
        "attachments": null
    }
]