[
    {
        "author": "kanewallmann",
        "category": "general",
        "parent": "",
        "content": "I'd like to jump in and put my support behind this proposal on behalf of Rocket Pool. Without stable containers, beacon state proof verification does not have forward compatible guarantees which greatly reduces their usefulness for us. We are able to transition some of our trusted oracle duties over to trustless state proofs with the introduction of 4788 but the verification process is liable to change in future hardforks which means we still need to support a trusted upgrade path. This puts us back in the position relying on trusted parties for upgrades. Stable containers would be a great win for decentralized protocols utilising beacon state proofs.",
        "created_at": "2024-07-08T02:52:48.721000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The added complexity of having another transaction type probably outweighs the benefits of secp256r1 over secp256k1.  No meaningful security differences (e.g., same quantum susceptibility), so all you get is a bit better tooling.  Now if there is some class of existing hardware security devices that could easily add support for signing Ethereum transactions if they were secp256r1 that may be a compelling argument, but I'm not sure if that is the case.",
        "created_at": "2024-07-08T05:11:36.316000+00:00",
        "attachments": null
    },
    {
        "author": "gakonst",
        "category": "general",
        "parent": "",
        "content": "What complexity? It's giga simple to add a new variant and you allow EOAs to sign without hacky key management. If you add the precompile adding the TX variant is the same effort.",
        "created_at": "2024-07-08T05:37:36.129000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I agree that it is relatively small/negligible.  But the benefits of secp256r1 is *also* negligible as far as I know.",
        "created_at": "2024-07-08T06:37:51.002000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Hi, can we get a new issue to close this one? https://github.com/ethereum/pm/issues/1084, we said in Kenya that we'd have time to review Agenda items before the actual meeting.",
        "created_at": "2024-07-08T11:05:12.865000+00:00",
        "attachments": null
    },
    {
        "author": "gakonst",
        "category": "general",
        "parent": "",
        "content": "Is there an EIP for removing the 24KB codesize limit with EOF given JUMPDEST analysis no longer a DOS vector?",
        "created_at": "2024-07-08T13:07:08.044000+00:00",
        "attachments": null
    },
    {
        "author": "gakonst",
        "category": "general",
        "parent": "",
        "content": "I agree that it is relatively small/",
        "created_at": "2024-07-08T13:19:57.389000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "https://github.com/ethereum/pm/issues/1096",
        "created_at": "2024-07-08T14:35:40.003000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "JUMPDEST is still a problem until verkle.  I've done my part to ensure that verkle can handle large contracts now (24 bit size vs 16 bit).  My take is out of scope for pectra but in play at or after verkle.",
        "created_at": "2024-07-08T15:12:50.898000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "There was a L2 proposal for a TX container type that separates payload from signature.  If we do go down that path I would want to see it fixed for all theoretical signature types, so we would need to only specify the signature semantics.  Feels like a requirement for the people working on SSZ stable container.",
        "created_at": "2024-07-08T15:15:23.657000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "Their main target IIRC was to create a BLS compatible signature and aggregate all the TX sigs into one BLS sig.",
        "created_at": "2024-07-08T15:16:04.821000+00:00",
        "attachments": null
    },
    {
        "author": "gakonst",
        "category": "general",
        "parent": "",
        "content": "There was a L2 proposal for a TX",
        "created_at": "2024-07-08T15:48:56.711000+00:00",
        "attachments": null
    },
    {
        "author": "karalabe",
        "category": "general",
        "parent": "",
        "content": "HA. The `BeaconState` type defines two fields of the max size of `1099511627776`, which is invalid because SSZ specs the lengths as uint32 and that number doesn't fit inside. /facepalm",
        "created_at": "2024-07-08T18:38:31.465000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "general",
        "parent": "",
        "content": "It'd be awesome if EL implementations could implement that endpoint for getting EL version for graffiti watermarking... (https://github.com/ethereum/execution-apis/pull/517)\nWe've got 2 CL clients now watermarking (to different levels), hoping to see graffiti watermarking become more wide spread.\n\nIn terms of whats currently done, it looks like\n - Nethermind / geth have engine api endpoint implemented\n - lighthouse will publish graffiti watermark by default if graffiti is empty only? \n - teku will publish graffiti watermark by default (including append / shorten logic)\n\nI'm happy for that list to be incorrect, this is just based on looking at holesky / mainnet slots history from beaconcha.in and what is in graffiti column.",
        "created_at": "2024-07-08T20:31:42.149000+00:00",
        "attachments": null
    },
    {
        "author": "gakonst",
        "category": "general",
        "parent": "",
        "content": "HA. The `BeaconState` type defines two",
        "created_at": "2024-07-08T20:38:55.914000+00:00",
        "attachments": null
    },
    {
        "author": "rjected",
        "category": "general",
        "parent": "",
        "content": "engine_clientVersionV1 implementation status",
        "created_at": "2024-07-08T20:52:41.762000+00:00",
        "attachments": null
    }
]