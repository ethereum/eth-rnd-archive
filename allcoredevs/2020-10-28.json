[
    {
        "author": "geratbb",
        "category": "general",
        "parent": "",
        "content": "\u003c@!543900561460822016\u003e I did see SOLL. My concern is that it only advertises passing around 30% of the Solidity test cases and 70% of the YUL test cases. I am rather illiterate about this topic however so if this doesn't greatly affect SOLL's ability to correctly produce LLVM IR I might use it. Can YUL be decompiled easily?",
        "created_at": "2020-10-28T00:06:19.489000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "I think that we all agree that testing is necessary.",
        "created_at": "2020-10-28T01:15:02.264000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "But here are some examples in which testing missed attacker-triggerable bugs for rare inputs to crypto implementations.",
        "created_at": "2020-10-28T01:15:11.735000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "E.g. I recall someone said that they found a bug in our BN128 precompiles days before they went live. Phew! The bug was missed by fuzzing and the testnet, but found with analysis tools.",
        "created_at": "2020-10-28T01:15:28.579000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "E.g. CVE-2018-0733 is shocking: \"This allows an attacker to forge messages that would be considered as authenticated in an amount of tries lower than that guaranteed by the security claims of the scheme.\"",
        "created_at": "2020-10-28T01:15:39.881000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "E.g. A November 2019 paper by Nath and Sarkar finds bugs with rare probability ‚âà1/(2^64): \"On certain kinds of inputs, the code will lead to overflow conditions and hence to incorrect results. This, however, is a very low probability event and cannot be captured using some randomly generated known answer tests (KATs).\"",
        "created_at": "2020-10-28T01:16:00.980000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Nath and Sarkar's KATs sound like the \"algebraic fuzzing\" discussed above.",
        "created_at": "2020-10-28T01:16:54.103000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Please help me better understand \"algebraic fuzzing\". Does algebraic fuzzing just generate KATs or something else? Would algebraic fuzzing find bugs which have rare probability ‚âà1/(2^64) like Nath and Sarkar had to find analytically? What is the rarest probability of bugs algebraic fuzzing will capture?",
        "created_at": "2020-10-28T01:18:18.249000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003c@682078300234973185\u003e Am I correct in understanding that you are worried about BLS12-381 generally, not the implementation of it?  Is this the same worry others have?  I thought the concern was the implementations?",
        "created_at": "2020-10-28T02:44:07.764000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "My concern above is specifically about implementation bugs which are rare enough that fuzz testing is hopeless. I gave three examples.",
        "created_at": "2020-10-28T03:30:03.410000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Presumably, others are also concerned about implementation bugs, among other concerns.",
        "created_at": "2020-10-28T03:30:28.807000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "A fourth: e.g. CVE-2017-3738 in OpenSSL: \"There is an overflow bug in the AVX2 Montgomery multiplication procedure.\"",
        "created_at": "2020-10-28T03:33:36.837000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Oh, those are implementation bugs, not issues with the cryptography itself?",
        "created_at": "2020-10-28T03:34:05.794000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "My mistake, ignore above then.  :)",
        "created_at": "2020-10-28T03:34:25.761000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I would imagine that white box testing would cover these cases, assuming the white box tester understands the math.",
        "created_at": "2020-10-28T03:35:02.667000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "No, according to Nath and Sarkar.",
        "created_at": "2020-10-28T03:35:37.784000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "In theory, a white box tester should be looking for edge cases within the code to test.  There was a neat library for C# a while back called Pex or something that automatically did this, it was pretty neat.",
        "created_at": "2020-10-28T03:35:41.807000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "That does sound neat.",
        "created_at": "2020-10-28T03:36:17.365000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003e No, according to Nath and Sarkar.\n\u003c@682078300234973185\u003e do you have a link to such a claim?",
        "created_at": "2020-10-28T03:36:19.584000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "I quoted it above. Looking for the paper.",
        "created_at": "2020-10-28T03:36:52.895000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Seems pretty aggressive to say that a human is unable to find a particular class of bug.",
        "created_at": "2020-10-28T03:37:05.362000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Certainly, humans are quit fallable, but arguing that a human is incapable of finding something requires a particularly special class of thing.",
        "created_at": "2020-10-28T03:37:35.083000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "https://eprint.iacr.org/2019/1304 Edit: this link is wrong, correct link is below.",
        "created_at": "2020-10-28T03:39:12.802000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "I don't understand how one decides whether something is \"white-box fuzzing\". What if there are unknown unknowns?",
        "created_at": "2020-10-28T03:40:46.155000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'll glance over the paper, \"unknown unknowns\" seems pretty rare in math though.",
        "created_at": "2020-10-28T03:41:35.686000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Are you sure that is the paper you were thinking of?  I don't see any discussion about a vulnerability in there at a glance.",
        "created_at": "2020-10-28T03:44:08.078000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I don't see that quote in the linked paper.",
        "created_at": "2020-10-28T03:54:31.347000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I agree that proofs of correctness are valuable.  However, academic researchers often forget how astronomically expensive they are to generate in most cases.",
        "created_at": "2020-10-28T03:55:23.922000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I have seen people argue that all software should come with correctness proofs, which I can only imagine being said by someone who doesn't actually write software.  üòñ",
        "created_at": "2020-10-28T03:55:57.849000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "One can argue that, \"well, at least your cryptographic code should have correctness proofs\" and that is certainly more reasonable of a statement, but it still isn't costless, especially when you have a dozen implementations of that same cryptographic function across a consensus system.",
        "created_at": "2020-10-28T03:56:48.758000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "My argument here is basically that we need to be careful about putting unrealistic demands on client dev teams which are already stretched thin.  We also should be careful about creating an environment where anyone can demand some unreasonable level of confidence before a change can be made, as that gives anyone essentially veto power over any change.",
        "created_at": "2020-10-28T03:58:52.623000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "We saw this with ProgPoW, where unlike every other change in Ethereum the opponents demanded audits before they would accept ProgPoW and after someone spent time/money doing those audits the opponents just switched tactics and blocked it anyway.  This came across like a really dick/underhanded move to burn resources of the proponents and as core devs we allowed it unfortunately.  I think we should be very careful about not allowing such things to happen in the future.  This isn't to say that correctness proof is unreasonable here, just that we need to be very careful about creating unrealistic demands for things being included in Ethereum.  If we don't want a thing included for some reason, we should just say so rather than demanding something that is very expensive to produce.",
        "created_at": "2020-10-28T04:01:04.121000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "This is a polite request to please stay on topic.",
        "created_at": "2020-10-28T04:11:22.575000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "I just want to understand. What are \"algebraic fuzzers\"? What are their limitations?",
        "created_at": "2020-10-28T04:11:37.525000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "BTW here is a cached version of that paper which includes the quote: https://webcache.googleusercontent.com/search?q=cache:YmSvTZzaDvYJ:https://pdfs.semanticscholar.org/d55e/495afec348662a71d1078b1713d24f35fdae.pdf+\u0026cd=4\u0026hl=en\u0026ct=clnk\u0026gl=us",
        "created_at": "2020-10-28T04:16:30.093000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "And here is the (more readable) pdf: https://eprint.iacr.org/eprint-bin/getfile.pl?entry=2019/1304\u0026version=20191112:061154\u0026file=1304.pdf",
        "created_at": "2020-10-28T04:26:19.712000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "\u003c@!682078300234973185\u003e I think the definition of \"white box\" can come from this article which I liked a lot: https://dl.acm.org/doi/pdf/10.1145/3363824",
        "created_at": "2020-10-28T07:24:36.632000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "It is called: Fuzzing: Hack, Art, and Science. Black box fuzzing is \"hack\" and white box fuzzing is \"science\". In the middle is grammar-based fuzzing, which is \"art\" üôÇ",
        "created_at": "2020-10-28T07:25:47.116000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "i think the algebraic fuzzer is much more powerful than the black box fuzzers that I assume were used before for the other precompiles in 2017, but I do not know enough details of those",
        "created_at": "2020-10-28T07:26:58.619000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "algebraic fuzzer is aware of the elliptic curve and can construct random point that ARE on the curve, which probably makes the search space 1-dimensional rather than 2-dimensional (but that only if you draw the curves on the continuous plane for intuition)",
        "created_at": "2020-10-28T07:28:55.455000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "it generates points of the curve, performs the arithmetic operations and pairings on them, and checks the algebraic equivalences that are supposed to hold",
        "created_at": "2020-10-28T07:29:33.878000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "\u003c@456226577798135808\u003e This is exactly what my fuzzer did for 2537 https://github.com/holiman/goevmlab/blob/master/cmd/blsfuzz/main.go",
        "created_at": "2020-10-28T07:31:10.549000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "However \"fuzzing\" only one coordinate for the curve point does not provide a lot of code coverage",
        "created_at": "2020-10-28T07:32:03.164000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I really wanted us to have algebraic fuzzer for EIP-1962 (generalised Elliptic Curve arithmetics), but there the problem was that computing square root for an arbitrary field seemed like a (surprisingly) difficult problem. The reason you need square root is to compute `y` from generated `x` in the elliptic curve formula: `y^2 = a*x^3 + b*x^2 + c*x + d`",
        "created_at": "2020-10-28T07:32:13.936000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "because I assume the strategy for generating points is to randomly sample `x` and compute `y` as `y = sqrt(*x^3 + b*x^2 + c*x + d)`",
        "created_at": "2020-10-28T07:32:54.367000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "but for specific fields and curves where square root is implemented, this is easy, and this is why I think we have algebraic fuzzers for BLS curves now",
        "created_at": "2020-10-28T07:33:32.523000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "\u003e However \"fuzzing\" only one coordinate for the curve point does not provide a lot of code coverage\n\u003c@!360491619402776577\u003e one `x` coordinate can only correspond to 2 valid points, if the result of square root can have two values. So I think it can provide as much coverage as required",
        "created_at": "2020-10-28T07:36:37.064000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "so in black box fuzzing - you search throw 2-dimensional space of `(x, y)` \"hoping\" to bump into a curve, but in algebraic fuzzing you search throw the curve itself, which is 1-dimensional in comparison. There is a huge difference, and I don't know if you can do any better",
        "created_at": "2020-10-28T07:38:18.701000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "you can somewhat compare it to a biological example (if you forgive me) üôÇ",
        "created_at": "2020-10-28T07:38:44.488000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "inside the cell, stuff gets delivered into the nucleus all the time. So there are 3 possible strategies: 1) diffusion - which is wandering in 3-dimensional space and very inefficient 2) attaching to the surface of the nucleus and wandering on the surface looking for a pore - search in 2 dimensional space 3) using microtubule, which is a string that goes from the membrane straight to the nucleus pore and 1-dimensional. For most important deliveries, cell uses microtubules, that is how life can exist üôÇ",
        "created_at": "2020-10-28T07:41:18.088000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "OK, now I understand the situation.",
        "created_at": "2020-10-28T07:42:14.999000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "We are abusing vocabulary.",
        "created_at": "2020-10-28T07:42:20.699000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "as usual üôÇ",
        "created_at": "2020-10-28T07:42:31.186000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Algebraic fuzzing is just KATs, so it should be classified as \"black-box fuzzing\" or maybe \"dark-grey box fuzzing\".",
        "created_at": "2020-10-28T07:42:38.640000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "And \"white-box fuzzing\" should be reserved for when there are only known unknowns, perhaps through verification, i.e. all possible classes of bugs are known. At that point, either (i) it is still intractable to fuzz so we need formal verification or (ii) it is practical to do fuzzing to exhaust a meaningful number of possibilities.",
        "created_at": "2020-10-28T07:43:22.147000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Does this seem reasonable?",
        "created_at": "2020-10-28T07:43:37.101000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "From that paper, white box fuzzing is what that C# thing I mentioned previously did I think.  :)",
        "created_at": "2020-10-28T07:43:39.841000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Interestingly, the white box fuzzing described in that paper is impossible for cryptography since if you could successfully solve backward, you would have broken the cryptography.  üòÅ",
        "created_at": "2020-10-28T07:47:34.302000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "That is, the fuzzer notices an untaken branch, and then solves backward to figure out what inputs would lead to that particular branch.",
        "created_at": "2020-10-28T07:48:19.832000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "By design, cryptographic operations have no solution for going backward.",
        "created_at": "2020-10-28T07:48:34.178000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "\u003c@456226577798135808\u003e Still it is a pretty huge search space, even if we only search in one dimension (which we shouldn't because we also want to catch points that are not on the curve but still defy preconditions). The search is all valid points of the curve with all combinations (for binary operations) and multiple combinations for pairing. My point is that the mutator can not choose interesting inputs since it cannot reverse engineer the crypto (similar to what micah just wrote)",
        "created_at": "2020-10-28T07:49:51.767000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "Ok, I understand now",
        "created_at": "2020-10-28T07:50:39.271000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "algebraic fuzzer is not the same level as white box fuzzer, because white box fuzzer requires knowing semantics of the language in which implementation is written",
        "created_at": "2020-10-28T07:51:33.711000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "so, I agree with \u003c@!682078300234973185\u003e now that calling it whitebox fuzzing is probably an abuse of notation and it is my fault for starting it üôÇ",
        "created_at": "2020-10-28T07:52:21.805000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "On that fuzzer, \u003c@381789485777682434\u003e and \u003c@619357961923330051\u003e , where does it link/include the golang source under testing? Which libraries are being fuzzed?",
        "created_at": "2020-10-28T07:52:42.153000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "to state my positions - I like EVM384 as a better architectural solution, and I would like that to be continuing, so that we can have a hope of stopping crypto precompiles. But i also like the effort that has been done on BLS precompiles and previously. My personal view is there is probably room for compromise. But in no way this should mean to try to increase the pressure on client implementers - I know as much as anybody that we are quite bottlenecked. The prioritisation needs to be much more ruthless than it is now - I believe that AllCoreDev calls produce outcomes that are too \"diplomatic\" at the expense of people who have to do the work on the back on this. I do not take the frustration of people who say \"but you approved it last time\" as a means to increase pressure.",
        "created_at": "2020-10-28T08:02:50.138000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "I agree with you. Even though I spent much time fuzzing 2537, I also think EVM384 is the better solution. Our fuzzers can be extended pretty easily to create valid inputs to the EVM384 contract and we can create new ones for the Opcodes/Precompiles needed for EVM384. I rather have complex cryptography in user land than in kernel land. Keeping kernel land kiss means less surface for consensus issues.",
        "created_at": "2020-10-28T08:08:02.481000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Pure speculation: Could you effectively fuzz a particular curve by greatly constraining the field size?",
        "created_at": "2020-10-28T08:08:43.983000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I suppose the field size is an integral part of the curve and changing it would effectively change the curve to the point that any tests would be useless.",
        "created_at": "2020-10-28T08:09:40.018000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "\u003e On that fuzzer, \u003c@381789485777682434\u003e and \u003c@619357961923330051\u003e , where does it link/include the golang source under testing? Which libraries are being fuzzed?\n\u003c@!211091239112671234\u003e  I‚Äôve made a simple wrapper that build Go package as a static log, adds rust interface to it (passes raw bytes) and I use this wrapper in the Rust fuzzer https://github.com/shamatar/eip2537_go_bindings",
        "created_at": "2020-10-28T09:21:52.579000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "\u003e I really wanted us to have algebraic fuzzer for EIP-1962 (generalised Elliptic Curve arithmetics), but there the problem was that computing square root for an arbitrary field seemed like a (surprisingly) difficult problem. The reason you need square root is to compute `y` from generated `x` in the elliptic curve formula: `y^2 = a*x^3 + b*x^2 + c*x + d`\n\u003c@456226577798135808\u003e  I‚Äôve ended up adding square root for more cases at least for some set of classes of the field modulus. And we could limit the set of input fields to the 1962 with that classes, so we could fuzz them",
        "created_at": "2020-10-28T09:26:05.832000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "Rare case of 2^64 is linked to the carry propagation as far as I remember it would apply to any implementation (code underneath evm384 or native code implementations), but for this purpose we don‚Äôt need to fuzz the precompile, but to fuzz arithmetic implementation, namely addition, subtraction, multiplication and comparison. \u003c@570268431522201601\u003e has an example in his code how to do such a biased fuzzing",
        "created_at": "2020-10-28T09:29:20.597000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "In general ‚Äúalgebraic fuzzer‚Äù was a name I gave to the repo, but whether you call in whitebox or graybox it does the following: 1) identity error cases and categorize them (in a spec) 2) make functions to generate those cases. It would be hard for a fuzzer to hit a point on a curve and in invalid subgroup, but we make them easily 3) feed into few implementations and compare the result 4) todo: compare gas estimation functions too",
        "created_at": "2020-10-28T09:32:00.842000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "To clarify: I‚Äôm not against the idea of having fast opcodes for field arithmetic, but first I‚Äôd like to have full data on performance, and also a solution for end users to use it with reasonable efficiency, and hand crafted huff code for one specific curve (largely assembly) is not a solution I‚Äôd say. Also, all the comparison now is between one specific curve implementation in evm384 and some slow implementation in native code that is aimed for generic implementation, that is misleading as specialized implementation (e.g. Geth) are much faster (2x)",
        "created_at": "2020-10-28T09:35:46.074000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "BTW, related to the precompile discussion, but not directly. I have been thinking about our general strategy for dealing with DOS attacks arising not only from slow access to the state, but also from computations (like precompiles and some opcodes) that become underpriced if we raise block gas limit. Current approach is to raise gas costs of selected operations. I think this makes sense. But I would also suggest creating another, complementary layer of defence. My current idea (which to some people may seem controversial) is based on separation of transaction pool (mempool) into a separate process. When this is done, we can experiment with running multiple tx pool processes and get them to actually try to execute transactions to detect the ones that are trying to exploit mispricings, and stop propagating them. I know there are a lot of rough edges with this idea, but I keep exploring it",
        "created_at": "2020-10-28T10:06:21.790000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "Do you assume that 99% of users run reference code that would do it?",
        "created_at": "2020-10-28T10:10:55.984000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "99% is not required. We need enough of such filter nodes to stop the \"viral\" transmission üôÇ",
        "created_at": "2020-10-28T10:11:27.023000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "we can model the required number to achieve herd immunity üôÇ",
        "created_at": "2020-10-28T10:11:45.675000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "üôÇ",
        "created_at": "2020-10-28T10:12:15.497000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "but more sensitive nodes (like miners) can surround themselves with extra nodes for shielding",
        "created_at": "2020-10-28T10:12:27.480000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "this extra layer, of course, needs to be closely monitored so that it does not get overwhelmed if mispricing becomes severe",
        "created_at": "2020-10-28T10:13:55.445000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "eventually, the response in the form of repricing needs to come. But with the extra defensive layer, such responses can be done on fixed predictable schedule and vulnerabilities can be reported and discussed more openly",
        "created_at": "2020-10-28T10:14:52.622000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think we should assume that anyone executing a DOS attack has the ability to get a malicious transaction mined.",
        "created_at": "2020-10-28T10:22:11.478000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Unless the attack vector is *specifically* against the mempool, and the attack doesn't negatively impact the blocks.  Are there any such vectors we are currently using gas prices to deal with?",
        "created_at": "2020-10-28T10:22:41.673000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "these are two different threats - slow transactions in the block, and slow transactions in the pool",
        "created_at": "2020-10-28T10:23:10.836000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "At the least, you can rent hashing power and mine your own block.",
        "created_at": "2020-10-28T10:23:20.444000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If we are using gas pricing to deal with slow transactions in the pool then I weakly agree that is a bad solution to the problem.",
        "created_at": "2020-10-28T10:23:38.182000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "the defensive layer I am suggest protects from both, but more so from the second (slow tx in the pool)",
        "created_at": "2020-10-28T10:23:42.824000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Flat DB call in ~5 minutes. Zoom link: https://consensys.zoom.us/j/95482536548",
        "created_at": "2020-10-28T13:55:28.879000+00:00",
        "attachments": null
    },
    {
        "author": "zkfloof",
        "category": "general",
        "parent": "",
        "content": "\u003c@!552133098075193354\u003e will wait for recording to be uploaded üôÇ",
        "created_at": "2020-10-28T15:45:17.640000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "\u003c@!387536747476549632\u003e it won't be uploaded, but I can share the zoom recording with you if you want.",
        "created_at": "2020-10-28T17:33:30.277000+00:00",
        "attachments": null
    },
    {
        "author": "zkfloof",
        "category": "general",
        "parent": "",
        "content": "\u003c@!552133098075193354\u003e yes please üôè",
        "created_at": "2020-10-28T17:34:18.668000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Also, on the call it was mentioned that because a lot of the flat DB work ties into new sync protocols, it would be good to have a second call dedicated to that in a few weeks. Would the same time (Wed 14:00 UTC) two weeks from now (Nov 11) work for most folks? \u003c@!213672586264051717\u003e \u003c@!403707149043105803\u003e \u003c@!489256758989029405\u003e \u003c@456226577798135808\u003e \u003c@!206016661470314496\u003e \u003c@!211091239112671234\u003e \u003c@!364458974906548225\u003e",
        "created_at": "2020-10-28T17:37:33.215000+00:00",
        "attachments": null
    },
    {
        "author": "zkfloof",
        "category": "general",
        "parent": "",
        "content": "Want to +1 the suggestion of having a document highlighting the different approches of each implementation and pros/cons of the same. Can be a wiki that can be easily updated as things change",
        "created_at": "2020-10-28T18:50:45.993000+00:00",
        "attachments": null
    },
    {
        "author": "zkfloof",
        "category": "general",
        "parent": "",
        "content": "Would volunteer but am very underqualified for the task üòÑ",
        "created_at": "2020-10-28T18:53:38.323000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "I have a school conflict at that time.  Wednesday is the only day my oldest goes to school (because of covid).  I can do 90 minutes later (daylight saving time) or any other day at that time.",
        "created_at": "2020-10-28T18:54:20.718000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "I feel like because of Europe, 90 mins later won't work. What other days work for folks?\n1Ô∏è‚É£ Monday\n2Ô∏è‚É£ Tuesday\n3Ô∏è‚É£ Wednesday\n4Ô∏è‚É£ Thursday\n\n(no Friday because of ACD)",
        "created_at": "2020-10-28T19:18:47.888000+00:00",
        "attachments": null
    },
    {
        "author": "tkstanczak",
        "category": "general",
        "parent": "",
        "content": "I just could not resist making them all equal",
        "created_at": "2020-10-28T22:03:12.158000+00:00",
        "attachments": null
    }
]