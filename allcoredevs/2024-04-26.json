[
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "A quick note on elliptic curve precompiles for those interested:\n\n* The main \"nice feature\" of secp256r1 is that it's \"almost the same\" curve as secp256k1 (compare https://neuromancer.sk/std/secg/secp256r1 and https://neuromancer.sk/std/secg/secp256k1), and so you can reuse almost all of the same code to compute it\n* ed25519 is recently a popular curve, because it has a lot of benefits such as more efficient and constant-time computation. However, it has very significant differences to the secp family in how it's computed; see its addition law on page 6 of https://ed25519.cr.yp.to/ed25519-20110926.pdf . Technically, it is equivalent to a \"normal\" curve (called curve25519: https://en.wikipedia.org/wiki/Curve25519 ), but doing the computation by applying and de-applying the isomorphism adds inefficiency that ruins the benefits\n* An additional major challenge in making a \"general\" elliptic curve precompile is, as far as I can tell you have to verify that the modulus is prime. This is because there are many different ways to compute elliptic curve multiplications, which are useful for optimization, and they are mathematically equivalent to each other in general but it hasn't been explored what happens if you try to make them work in non-prime curves (will you get divide-by-zero errors in some impls but not in others?). And primality testing is hard, definitely waaaay too hard to add as an extra check in an elliptic curve multiplication function\n\nAs a result of these factors, my own instinct leans toward admitting secp256r1 as a precompile and going no further (except maybe BLS12-381), and waiting for EVMMAX or some similar generic feature to make other curves easier to handle in a generic way.",
        "created_at": "2024-04-26T04:25:56.700000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What is the advantage of secp256r1 over secp256k1?  My understanding was they are nearly identical in terms of utility, so adding a second after you already have one is somewhat pointless.",
        "created_at": "2024-04-26T04:42:37.552000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctimbeiko\u003e \u003e \u003ctimbeiko\u003e  Broad support of r1 across the tech industry, so you can enable use cases like the iPhone Secure Enclave holding a key whose signature is verified by the precompile (re @allcoredevs_bot: \u003csky.cactus\u003e [reply]: What is the advantage of secp256r1 over secp256k1?  My understanding was they are nearly identical in terms of utility, so adding a second after you already have one is somewhat pointless.)",
        "created_at": "2024-04-26T04:45:17.613000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "secure enclaves, basically",
        "created_at": "2024-04-26T06:21:52.004000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "~~Isn't it the same equation basically with just different constants?  It is unclear to me why that would provide any significant benefits.~~ Just read Tim's message, I get it now.",
        "created_at": "2024-04-26T06:24:16.564000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "general",
        "parent": "",
        "content": "Similarity of secp256k1 and secp256r1 is not helpful for ones using `libsecp256k1` (all of the clients?) because it is very specifically tuned to the parameters of secp256k1.",
        "created_at": "2024-04-26T07:27:26.519000+00:00",
        "attachments": null
    },
    {
        "author": "rodiazet",
        "category": "general",
        "parent": "",
        "content": "Adding new precompiles because there is a community need it's very important but I have a lot of doubts that this should the way we wanna go for long.  We should prepare a tooling which makes adding new ecc functionality in a generic way you mentioned. It' can be used not only to implement and ship new solution w/o a fork but also to prepare a reference implementation of new precompile which can be used as a contract or compiled to a native code and introduces as a precompile. We work on EVMMAX and specifying based on our experience we have in ecc implementing precompiles like bn254 and bls. But to introduce it we need to ship EOF. Without it it doesn't make a lot of sense. We are also open to additional suggestions from cryptographers no how to make EVMMAX as general as possible but still useful and fast.",
        "created_at": "2024-04-26T07:57:19.194000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "general",
        "parent": "",
        "content": "Is https://eips.ethereum.org/EIPS/eip-7610 accepted or not?",
        "created_at": "2024-04-26T07:57:56.398000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Procedurally, not accepted.  Not even up for review yet (just a draft).  Of course, often times things don't follow The Procedure so it may be unofficially accepted.",
        "created_at": "2024-04-26T08:04:44.915000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "general",
        "parent": "",
        "content": "That's what I'm asking.",
        "created_at": "2024-04-26T08:08:50.376000+00:00",
        "attachments": null
    },
    {
        "author": "ulerdogan",
        "category": "general",
        "parent": "",
        "content": "I think most of the languages have a wide support with libraries for secp256r1.",
        "created_at": "2024-04-26T14:02:53.636000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "It was accepted, I've put together this Meta EIP to list them out: https://github.com/ethereum/EIPs/pull/8389",
        "created_at": "2024-04-26T14:06:19.411000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It should be moved to *at least* Review then, unless the process has changed significantly since my day.",
        "created_at": "2024-04-26T14:17:30.898000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Yes, still trying to get it merged ðŸ™‚ Want to re-join as an editor ðŸ˜„ ?",
        "created_at": "2024-04-26T14:18:38.729000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "general",
        "parent": "",
        "content": "We also try to get something merged to EIPs... https://github.com/ethereum/EIPs/pull/8448",
        "created_at": "2024-04-26T14:22:23.363000+00:00",
        "attachments": null
    },
    {
        "author": "poojaranjan",
        "category": "general",
        "parent": "",
        "content": "After the ACDE meeting, EIP-7212 is now available in the list of HFM - Pectra \nhttps://eips.ethereum.org/EIPS/eip-7600\n\nThe backlink to the proposal is https://eips.ethereum.org/EIPS/eip-7212 which suggests that the proposal is \n- Standard Track - Core EIP \n- Status - `Review`\n\nIMO, this isn't accurate because:  \n\n- There is no EIP-7212 but it is RIP-7212 (and with uniform process of number allocation across EIP/ERC/RIP repos, there can not be two proposals with the same number in different repos) \n\n-  RIP-7212 is Standard Track- Core in  `Final` status (meaning no further changes can be updated to the proposal)\nhttps://github.com/ethereum/RIPs/blob/master/RIPS/rip-7212.md\n\n- According to the present network upgrade process \n\nStandard Track Core \"EIPs\" are selected for the Ethereum Network Upgrade. Also, EIP status\n\n- `Draft` or `Review` when proposed \n- `Review` when CFI'd\n-  `Last Call` when on \"Public Testnet\" (with Last Call end date = date of Mainnet Upgrade\")\n-  `Final`  when deployed on the Ethereum Mainnet.",
        "created_at": "2024-04-26T16:31:04.496000+00:00",
        "attachments": null
    },
    {
        "author": "poojaranjan",
        "category": "general",
        "parent": "",
        "content": "Please excuse me for resurfacing this issue, as I understand the ask for a **process to include RIP proposals to Ethereum Network Upgrade** may be less significant for client/testing teams but is important for proposers (authors) and the community to understand the next step.",
        "created_at": "2024-04-26T16:32:22.980000+00:00",
        "attachments": null
    },
    {
        "author": "poojaranjan",
        "category": "general",
        "parent": "",
        "content": "The inclusion of RIP-7212 to the next Ethereum Network Upgrade is the beginning of a new era of improvement proposals by Layer2 projects to support the ecosystem and requires a process to be established.",
        "created_at": "2024-04-26T16:32:43.801000+00:00",
        "attachments": null
    },
    {
        "author": "poojaranjan",
        "category": "general",
        "parent": "",
        "content": "Would anyone here object if the Author of RIP-7212 makes a pull request to https://github.com/ethereum/EIPs to create an equivalent EIP with a new number?",
        "created_at": "2024-04-26T16:32:49.285000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "I assumed that EIP-7212 was a \"copy\" of RIP-7212, given the authors/title/creation date were the same but didn't check the full diff",
        "created_at": "2024-04-26T16:40:11.633000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "I agree we probably want to document that process more explicitly somewhere, though! My very rough suggestion would be that we keep the same number and going from RIP -\u003e EIP means the feature goes from L2 -\u003e L1. While I would not have the EIP bot enforce this, it would also be nice to have some norms around the status of each. For example, we probably want the RIP to be final before the EIP gets moved to Last Call.",
        "created_at": "2024-04-26T16:41:55.955000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Looking now, the only substantial difference is the deploy address which is set in the RIP, but not EIP",
        "created_at": "2024-04-26T16:44:54.586000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "Can we just say RIP-7212 in the meta-spec?",
        "created_at": "2024-04-26T16:46:29.373000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "I'm not sure the bot will let me ðŸ˜…  Regardless of that, I think I'd want us to explicitly agree to that before we went down that route. There is value in having a single spec, but also in having all the L1 stuff in the same repo. This would be the first time an L1 change would be specified outside of L1 specs repo.",
        "created_at": "2024-04-26T16:52:33.221000+00:00",
        "attachments": null
    },
    {
        "author": "ulerdogan",
        "category": "general",
        "parent": "",
        "content": "I can say that the proposal in the EIPs repo is outdated, has moved to RIPs repo. Then, updated with minor changes as an RIP. There was a PR to EIPs repo to change the status of the EIP-7212, but it's still open. https://github.com/ethereum/EIPs/pull/8101",
        "created_at": "2024-04-26T16:56:49.612000+00:00",
        "attachments": null
    },
    {
        "author": "ulerdogan",
        "category": "general",
        "parent": "",
        "content": "I think the best way to start is actually moving the proposal like how ERCs has moved, the blocker is the missing RIP category defined in EIP-1.\nExample: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1271.md",
        "created_at": "2024-04-26T16:58:38.278000+00:00",
        "attachments": null
    },
    {
        "author": "ulerdogan",
        "category": "general",
        "parent": "",
        "content": "Then, maybe creating a new EIP that states \"Activate RIP-7212 in L1\" with activation specs and references RIPs repo, if bot can be configured to allow this as it can be a future requirement too.",
        "created_at": "2024-04-26T17:01:15.895000+00:00",
        "attachments": null
    },
    {
        "author": "poojaranjan",
        "category": "general",
        "parent": "",
        "content": "Generally, an advanced \"status\" proposal is allowed to be referenced in a new proposal. In this case, two proposals in mention will be on different repo, that can be a tricky situation. \n\nHowever, considering the RIP `Final` proposal will not be changed and live on the Ethereum GitHub as long as Ethereum GitHub will, I can imagine an update to EIP-1 to include RIP repo references. It can be perhaps added to the \"Requires\" section of the new proposal as well.\n\nHaving said that, my personal preference will be to have all specs on the EIP repo and make the new proposal as self sufficient, even if it is the exact copy.  I don't imagine any specs changes at all but, it may provide L1 team to make tweaks if at all needed. \n\nIt'll be valuable to collect input from EIP editors.",
        "created_at": "2024-04-26T17:36:55.487000+00:00",
        "attachments": null
    },
    {
        "author": "poojaranjan",
        "category": "general",
        "parent": "",
        "content": "I'd support this and would like to see \"RIP\" defined as a category in EIP-1 as ERC. \neg. For ERC, we have Type = \"Standard Track\" and Category = \"ERC\"  similarly, for RIP, it can be Type = \"Standard Track\"  and Category = \"RIP\"",
        "created_at": "2024-04-26T17:42:40.715000+00:00",
        "attachments": null
    },
    {
        "author": "niard.eth",
        "category": "general",
        "parent": "",
        "content": "Hey hey, I'd suggest a good look at https://github.com/ethereum/RIPs/pull/20/files",
        "created_at": "2024-04-26T19:15:13.091000+00:00",
        "attachments": null
    },
    {
        "author": "niard.eth",
        "category": "general",
        "parent": "",
        "content": "I'm asking the author to explain it further here. IMO it's worth a look if we are to take a \"not going further with precompile\" path. \nThe agility to be able to adapt to FIDO etc. and the exact same (but optimized) r1 as in 7212 sounds like a path to consider",
        "created_at": "2024-04-26T19:21:05.537000+00:00",
        "attachments": null
    },
    {
        "author": "rduboiscrypto_91682",
        "category": "general",
        "parent": "",
        "content": "Thanks \u003c@1219940276223606846\u003e for the invite.\n\nThe question is whether a precompile shall assess all properties of a given elliptic curve, or those verification be performed at a higher level.\n- In my past industrial experience, parameters where tested when introduced to the system once and for all, thus parameter verification is a one time check ( Primality can be proven quite efficiently using Miller Rabin test, )\n- In the EVM system this could be done at contract deployment. You will never use curve dynamically, but more certainly one or two. For 4337, those will be constant parameters of the UserOp (as well as the public Key when you use 7212).\n- the switch from ed25519 to wei25519 is the same as switching from Projective/Jacobian coordinates, basically you need some inversions, those are small compare to the whole cost of the scalar multiplication, the solidity code to do it is:\nfunction Edwards2WeierStrass(uint256 x,uint256 y) view returns (uint256 X, uint256 Y){\n//wx = ((1 + ey) * (1 - ey)^-1) + delta\nX=addmod(delta, mulmod(addmod(1,y,p),pModInv(addmod(1, p-y,p)),p) ,p);\n// wy = (c * (1 + ey)) * ((1 - ey) * ex)^-1\n\nY=mulmod(mulmod(c, addmod(1, y, p),p), pModInv(mulmod(addmod(1, p-y,p), x,p)),p);\n}\nwhere pmodinv (inversions) can be implemented using modexp precompile with 256 bits values. It is 2 inversions, compared to a whole loop (256 steps) of several modular multiplication.",
        "created_at": "2024-04-26T21:04:32.387000+00:00",
        "attachments": null
    },
    {
        "author": "rduboiscrypto_91682",
        "category": "general",
        "parent": "",
        "content": "Mainly 7696 was designed to be a RIP, because ZKevm won't just reuse existing libraries, but will have to implement it at circuit level, which is a huge work. I\nActually we have been contacted to provide temporary solidity code (cause L2s will have to run behind existing EIps to be compatible). This is also what LambdaClass did for ZKsync (provide Yul precompile).\nRealizing that genericity could be provided with a very small loss in performances (actually we managed\nto implement faster version than previous existing with extra algorithmic tricks, even without extra call data) we decided that it would provide more use cases.",
        "created_at": "2024-04-26T21:05:13.033000+00:00",
        "attachments": null
    },
    {
        "author": "niard.eth",
        "category": "general",
        "parent": "",
        "content": "No you're welcome it's a public channel actually. Thanks for the explainer. \nAh alright so IIUC this work is an extension that provides genericity with the same cost as 7212 ? what would be the loss ?\nWell if that's the case that's cool you should present it and discuss. Would be nice to have benches ðŸ™‚",
        "created_at": "2024-04-26T22:49:09.781000+00:00",
        "attachments": null
    },
    {
        "author": "niard.eth",
        "category": "general",
        "parent": "",
        "content": "Both 7212 and 7696 look like very cool options. Looking forward to see smart wallets with one of those on mainnet thanks for the contributions",
        "created_at": "2024-04-26T23:20:18.199000+00:00",
        "attachments": null
    }
]