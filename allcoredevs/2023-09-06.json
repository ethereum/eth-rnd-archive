[
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yeah so someone from that team posted a long ago that they were planning a C++ CL client. I pointed that the network stack is the biggest issue (see eg Grandine using LightHouse's for example). I am now experimenting with my own C++ design as a testbed before vouching these ideas for prysm. I can get state transition relatively easy, but sync is just too much undertaking for a toy project",
        "created_at": "2023-09-06T00:01:05.234000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "general",
        "parent": "",
        "content": "To my knowledge Silkworm (C++ implementation of Erigon) is close to being functional. They (Erigon) also has interesting design where the p2p runs in a separate process (sentry) and communication with the execution part is done via RPC. So maybe you could use the sentry in your project. But it is better to \u003c@583892532644151312\u003e to explain this.",
        "created_at": "2023-09-06T07:03:34.570000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "general",
        "parent": "",
        "content": "I think one idea you should try is to use rust bindings as unlike with go there is zero overhead",
        "created_at": "2023-09-06T07:14:05.879000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "general",
        "parent": "",
        "content": "Uhm I think there is a discv5 impl in silkworm need to check",
        "created_at": "2023-09-06T07:14:40.216000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "general",
        "parent": "",
        "content": "But If you want to use it as a testbed, you probably want to not reimplement the entire network stack",
        "created_at": "2023-09-06T07:18:55.928000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "general",
        "parent": "",
        "content": "I'm not actively researching the topic, but from the protocol perspective a home staker is indistinguishable from a large node operator running thousands of individual keys. The most we can do is ensure that large operators don't have advantages. But the other way around looks impossible to achieve to me",
        "created_at": "2023-09-06T08:16:56.858000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I believe there are clever techniques (maybe only theoretical) where you would need to store a separate copy of the state tree for every validator.  This at least reduce the scaling benefits of validators.  You could also add some \"work\" to ensure each actor is dedicating a reasonable amount of computer per validator as well.",
        "created_at": "2023-09-06T10:42:43.984000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "With these two things, it may make it so centralized validators will at least need to charge a fairly hefty fee (to cover hardware costs) while home shakers can just use their idle hardware.",
        "created_at": "2023-09-06T10:43:42.182000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The *idea* with proof of work was that individuals would utilize idle home hardware for mining.  It was unfortunate that ASICs ruined that dream.",
        "created_at": "2023-09-06T10:44:56.024000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "The reason why we decided to use Lighthouse's networking library is that it was a generic standalone (not coupled with Lighthouse) Ethereum networking library built on top of `rust-libp2p`, other clients also used it (https://github.com/paritytech/shasper/pull/179) back then. Only later it was coupled with Lighthouse types and eventually renamed to `lighthouse_network`. Grandine has its own implementation of the higher-level networking (i.e. sync manager) and we are thinking of rewriting that mid-level stack that overlaps with Lighthouse at some point when we will have a higher headcount. The main issue we see is that the innovation here is a bit limited because we do not think that rewriting the underlying `rust-libp2p` makes sense. Would be sad to burn a lot of hours debugging the same/similar networking bugs instead of innovating on some other components.",
        "created_at": "2023-09-06T10:52:20.243000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yeah definitely didn't mean to say that it was bad in any way of using someone's work (as long as it's acknowledged properly). In fact I'd be happy if Felix had replied \"here's a C++ implementation\". I'll ask the silkworm crowd in their Discord just in case. But in my case the head count= 1/10 so this is a very slow project",
        "created_at": "2023-09-06T10:55:32.499000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "Sure, just wanted to share the motivation in our case. 1/10 headcount is definitely quite low for the project ðŸ˜‚",
        "created_at": "2023-09-06T11:50:01.427000+00:00",
        "attachments": null
    }
]