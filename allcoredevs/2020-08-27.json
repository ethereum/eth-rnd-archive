[
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Can the core devs for various client implementations confirm that this change is in line with actual implementations in the wild?  https://github.com/ethereum/EIPs/pull/2911/files",
        "created_at": "2020-08-27T08:43:54.999000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "\u003e The 9 blocks including and after the activation block (so block 1,920,000 - 1,920,009) **MUST** have \"dao-hard-fork\" (`0x64616f2d686172642d666f726b`) in the `extraData` field of the block.",
        "created_at": "2020-08-27T08:44:18.164000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "**EIP-1559 Implementers' Call #4 tomorrow, Aug 28, at 15:00 UTC**\nAgenda: https://github.com/ethereum/pm/issues/197\nZoom: https://consensys.zoom.us/j/91866526216\n\nThe call won't be live streamed but will be uploaded to Youtube afterwards",
        "created_at": "2020-08-27T15:31:11.950000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "\u003e \u003c@!425279588009246720\u003e Is there a possibility to run kind of the same simulation for 768 bit modulus (swap the opcodes, operand sizes and run 10k multipicaitons on random data)? It may be 3x overhead for 384 bit modulus, but for 768 bit one it may happen to be tens of percents\n\u003c@!381789485777682434\u003e It would be relatively simple to benchmark wasmsnark generated mnt6/7 code with host functions, if you happen to have a native implementation to compare against.\n\nChanging the EVM opcodes would be more work in our opinion, but also doable.",
        "created_at": "2020-08-27T16:17:48.854000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "I’m more curious about the overhead on crossing the EVM \u003c-\u003e math boundary. Math itself should be equally performant in your implementation and eip1962 - both are for variable modulus plus-minus an approach that top bit is never filled in 1962. It’s not necessary to have full control flow of MNT4/6 pairing, but instead try  the most optimistic option of reading a continuous array of memory and e.g multiplying two sequential elements",
        "created_at": "2020-08-27T16:21:52.801000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "general",
        "parent": "",
        "content": "You want something like this?\n\n```\nmstore(0, \u003crandom\u003e)\nmstore(32, \u003crandom\u003e)\nmstore(64, \u003crandom\u003e)\nfor (1 … 10000) {\n  // read 96 bytes (768 bits) from 0 and multiplies it with the same value; stores it as the same offset\n  mulmodmont768(0, 0, 0, mod_offset, r_inv_offset)\n}\n```",
        "created_at": "2020-08-27T16:24:44.781000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "Yes, kind of. Ideally it would be to try both options: read 96 bytes from offer 0, multiply with the same value and store at the same location, then repeat, and read from offsets 0,96,192,... to check if memory access patterns matter",
        "created_at": "2020-08-27T18:30:49.382000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "general",
        "parent": "",
        "content": "\u003c@!381789485777682434\u003e \u003c@!425279588009246720\u003e Looking at this I  prefer a stack-based interface to a memory-based one even more.  Getting things in and out of memory still requires using the stack.  And I've long thought our stack is too small anyway.",
        "created_at": "2020-08-27T19:42:37.530000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "It’s not my area, but do you envision a stack specifically for 384 bit words or would you pack a 384 bit primitive into two 256 bit words?",
        "created_at": "2020-08-27T19:54:51.464000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "general",
        "parent": "",
        "content": "In https://notes.ethereum.org/@axic/evm384 optiion (a) is to use two stack items, \u003c@!381789485777682434\u003e  Am taking up the discussion on the Magicians https://ethereum-magicians.org/t/evm384-feedback-and-discussion/4533/5.",
        "created_at": "2020-08-27T22:22:14.520000+00:00",
        "attachments": null
    }
]