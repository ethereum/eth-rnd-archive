[
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think this communication channel would be a good opportunity for your team to push for gRPC.",
        "created_at": "2021-03-22T00:36:04.053000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It is a pretty specialized channel for inter-service communication, onlike the more general purpose APIs.",
        "created_at": "2021-03-22T00:36:30.142000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I would say that casual users would like to see a single piece of software that just works after the downloading. This is either gonna be a tool that glues two clients together or a monolithic client built on top of modern eth1 and eth2 clients or from scratch. IMO, there is a room for both approaches, namely multi-services for users with tech background and the thing that does everything for you for those who are not that experienced.",
        "created_at": "2021-03-22T08:51:09.271000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Sure, packages are cool and there are already services that provide that like dappnode.",
        "created_at": "2021-03-22T09:24:01.538000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "However, I don't think we should be building a situation where Teku only works with Nethermind, and Prysm only works with Geth.",
        "created_at": "2021-03-22T09:24:25.061000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I agree, it must not happen this way",
        "created_at": "2021-03-22T09:24:49.756000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "All 4 application clients should work with all 4 consensus clients and then anyone can package any two together, or anyone can run any 2 as services.",
        "created_at": "2021-03-22T09:24:51.167000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "In order to achieve this, we need a *standard* for application \u003c=\u003e consensus communication.",
        "created_at": "2021-03-22T09:25:05.846000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "When designing that standard we need to decide on security system (TLS vs JWS vs signed payloads), transport, and payload format.",
        "created_at": "2021-03-22T09:25:52.443000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'm weakly in favor of signed payloads still, but open to being convinced away from it.  For transport/payload I wouldn't strongly oppose gRPC because I don't know much about it, though I do like the benefits of REST in terms of ubiquitous support around the internet and the ease of implementation.",
        "created_at": "2021-03-22T09:26:36.175000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "In this case I'd be inclined to go for gRPC with mutual TLS.  With the amount of data and potential timeliness concerns a binary format is preferred for both transport and encoding/decoding purposes.  And for local configurations it's possible to create a local CA and certificates to make this transparent (or to relax the requirement for TLS when endpoints are local).",
        "created_at": "2021-03-22T09:31:31.937000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Would you want a long lived connection then rather than something like HTTP?",
        "created_at": "2021-03-22T09:42:51.198000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "(I don't know if gRPC specifies the transport as well or just the payload form)",
        "created_at": "2021-03-22T09:43:09.615000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "I think that transports are pluggable.  Default is HTTP/2",
        "created_at": "2021-03-22T10:36:28.093000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "We're hosting a community call to discuss EIP-3074 on Wednesday 15:00 UTC: https://github.com/ethereum/pm/issues/283\nPlease DM me your email if you'd like to be added to the calendar invite.",
        "created_at": "2021-03-22T14:17:00.130000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "That conflicts with EIPIP meeting.  ðŸ˜¢",
        "created_at": "2021-03-22T14:22:29.316000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "i saw ðŸ˜¦ unfortunately that time worked well for some teams who were planning to come",
        "created_at": "2021-03-22T14:24:18.670000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "gRPC/mTLS should be fine as well if certs are okay. The good thing with this is that it relieves the client teams from understanding anything with regards HTTP - since protoc automatically generates client/server stubs. Should be relatively easier to implement. The contract protobufs that binds the different clients will have to be written under the common understanding between the client teams by some entity.",
        "created_at": "2021-03-22T14:34:45.834000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "dependency on OpenSSL / other SSL libraries is a drawback from my point of view especially if these are dynamically linked in the host platform - But client teams can resolve that over time with forked minimalistic libraries statically linked in Eth devs control.",
        "created_at": "2021-03-22T14:39:11.692000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "As an example, we have separated, as \u003c@!329594653097721856\u003e suggestion, the `.proto` definitions (and then some docs hopefully) into a separate repo: https://github.com/ledgerwatch/interfaces We are not versioning yet, but the plan to start doing versioning scheme, once interfaces become more mature",
        "created_at": "2021-03-22T14:40:52.171000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "Looks good! will take a closer look post-work. Language support-wise I assume gRPC easily covers all eth client implements?",
        "created_at": "2021-03-22T14:43:59.560000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "We use it for Go, Rust, C++, and Python at the moment",
        "created_at": "2021-03-22T16:16:17.374000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "general",
        "parent": "",
        "content": "gRPC has widespread support in general across many languages, with some even having codegen",
        "created_at": "2021-03-22T19:08:49.758000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "general",
        "parent": "",
        "content": "For Rust we also provide a wrapper for even more convenience, but it's not strictly necessary",
        "created_at": "2021-03-22T19:09:39.929000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "For application-layer \u003c-\u003e consensus-layer comms, I would argue for restful http or jsonrpc\n\nThere are strong arguments for just having a restful http api across the stack and there is ubiquitous support across the board.\njsonrpc would  just be easy to plug into existing eth1/application-layer clients because they all have it already today.\n\nI'm 99% sure grpc does not exist for Nim\n\nI'm also pretty sure there were issues with certain types being support but not 100% sure on that.",
        "created_at": "2021-03-22T19:12:21.197000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Just saw this.. hmm",
        "created_at": "2021-03-22T19:13:17.172000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Id then argue defining these methods as restful http -- similar to the other beacon methods today https://github.com/ethereum/eth2.0-apis\nyou can then convert any of these definitions to protos (as prysm does on these methods)",
        "created_at": "2021-03-22T19:16:01.759000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "general",
        "parent": "",
        "content": "Quick Google tells me there's at least 2 protobuf implementations, and at least 1 HTTP/2\n\nMix the two and you get gRPC",
        "created_at": "2021-03-22T19:59:38.686000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "general",
        "parent": "",
        "content": "Didn't find dedicated gRPC lib, but those who need it might as well make one",
        "created_at": "2021-03-22T20:00:20.573000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Iâ€™d really like to avoid introducing grpc unless thereâ€™s a very clear need for it. Eth1 and 2 clients all support some form of json over http currently and eth2 clients quite deliberately decided against grpc for the beacon node to validator client apis. It seems crazy to add a whole new form of api for this.",
        "created_at": "2021-03-22T20:44:30.783000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "I would say that the use cases are very different.  One is for (ideally) low latency/overhead computer-to-computer transmission, the other has humans commonly at one end or the other (or in the middle) and so readability, tool support and existing middleware (caches etc.) were all significant factors in the decision to go with JSON (and REST).\n\nI do think that the best solution for this specific problem should be considered outside of the context of what we already have for a different problem.  Not saying that we would definitely come to a different answer, but I'd rather end up with the best solution on its own merits.",
        "created_at": "2021-03-22T21:06:19.116000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I'm really struggling to see how validator client to beacon node is so different to beacon node to application client, but some of that will depend on exactly what the API requirements of the merge wind up being.",
        "created_at": "2021-03-22T21:19:16.807000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "And I do think there should be a strong weighting towards not introducing new technologies unless they provide a lot of benefit.  It just adds more for everyone to understand and work with.",
        "created_at": "2021-03-22T21:20:17.573000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "If you really want to go down the design road, you should also consider that consensus component from the \"core\", if properly separated, will require duplex/async communication (at least this is what I concluded trying to support EtHash, Clique, and potentially AuRa while having decent validation performance), which for JSONRPC and Restful http might require mutual connections. Also, JSON conversions do matter as they are quite CPU intensive. Please note I am not \"pushing\" gRPC, but I am just pointing out that going with \"what we've got\" instead of what is best for the use case is going to lead to a lot of wasted effort. I suspect that running POS consensus on mutual JSON RPC connections is going to be slow-ish",
        "created_at": "2021-03-22T21:37:37.901000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "You want JSON when your client is Javascript in the browser. Otherwise it is a waste of CPU, to be honest",
        "created_at": "2021-03-22T21:38:34.885000+00:00",
        "attachments": null
    }
]