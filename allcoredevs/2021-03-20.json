[
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I would support REST if it we end up building some kind of authentication requirement in.",
        "created_at": "2021-03-20T04:23:23.380000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The consensus clients already have a private key they have to manage, maybe we just say that the block pushed to the node over REST needs to be signed and you boot your application node with a specific public key it accepts from?",
        "created_at": "2021-03-20T04:24:32.045000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Probably the simplest given the infrastructure we already have.",
        "created_at": "2021-03-20T04:24:43.382000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "The beacon chain node does not manage any private keys (well except the network key but thatâ€™s currently very replaceable). Validator keys are held either by the validator client or an external signer and the beacon node may have no way to ask it to sign anything and may have any number of validator keys being used with it, including none.",
        "created_at": "2021-03-20T04:28:58.897000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Hmm, I forgot about that...",
        "created_at": "2021-03-20T04:30:44.358000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "For most use cases it will just listen only on localhost with dns rebounding attack protection and that will be plenty. No doubt clients will also support authentication in various forms but I donâ€™t think itâ€™s a big issue.",
        "created_at": "2021-03-20T05:38:24.040000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Since we have 4 application clients and 4 consensus clients we need a standard mechanism for connecting the two of them securely.",
        "created_at": "2021-03-20T07:04:05.194000+00:00",
        "attachments": null
    },
    {
        "author": "dkdkdkdkdkdk",
        "category": "general",
        "parent": "",
        "content": "regarding WebSockets - are there actually any cases where the application client sends something to the beacon client unprompted?",
        "created_at": "2021-03-20T09:51:25.263000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I don't believe so, it is all consensus to application I think.",
        "created_at": "2021-03-20T10:10:34.584000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "However, WS lets us have the application connect to the beacon instead of the other way around which is nice for security.",
        "created_at": "2021-03-20T10:11:03.527000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I'm leaning toward REST with key exchange though.",
        "created_at": "2021-03-20T10:11:13.872000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "It was originally planned as a unidirectional communication with the beacon node as initiator",
        "created_at": "2021-03-20T10:11:33.332000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think that is reasonable, but we need auth is all.",
        "created_at": "2021-03-20T10:12:44.440000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "It could be secured with whatever techniques that modern web apps allows to. I don't know what security features does app's JSON-RPC implementations offer today",
        "created_at": "2021-03-20T10:13:02.778000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Could it be oauth? or is it too hard requirement for the application client?",
        "created_at": "2021-03-20T10:14:10.806000+00:00",
        "attachments": null
    },
    {
        "author": "agusx1211",
        "category": "general",
        "parent": "",
        "content": "imho it's not unreasonable to leave the auth and encryption job to an encrypted tunnel, it simplifies the implementation for all teams, it makes compatibility issues between clients less likely, and it gives flexibility for infra devs\n\nworse case scenario someone configures its node using an unsecured connection, that connection will most likely be local and an attacker could only use it to bring the node down (not stealing funds), and an attacker that has that kind of access probably can bring the node down in multiple other ways anyway",
        "created_at": "2021-03-20T10:27:16.985000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I see the value in moving the security part of the communication channel to separate piece of software. But it would increase setup complexity",
        "created_at": "2021-03-20T11:13:22.048000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Today there is basically no security because it is a mostly untrusted endpoint.",
        "created_at": "2021-03-20T11:14:41.835000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "OAuth with what?  That usually involves 3 servers?",
        "created_at": "2021-03-20T11:14:56.037000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think the *easiest* would probably be to just sign the payloads and throw the signature in an HTTP header.",
        "created_at": "2021-03-20T11:15:19.147000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Then the application client would recover the public key of the signer and make sure it matches the public key they are configured to accept.",
        "created_at": "2021-03-20T11:15:59.004000+00:00",
        "attachments": null
    },
    {
        "author": "dkdkdkdkdkdk",
        "category": "general",
        "parent": "",
        "content": "don't most stakers run both clients on the same machine? requiring a signature seems like overkill in that scenario",
        "created_at": "2021-03-20T11:16:40.953000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I don't think we want to *require* this setup.",
        "created_at": "2021-03-20T11:18:05.675000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "sounds like JWT (Json Web Tokens), right?",
        "created_at": "2021-03-20T11:39:38.594000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "JWTs would be different.",
        "created_at": "2021-03-20T11:44:15.457000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "JWTs don't sign the payload, which means you need a secure transport (like TLS).",
        "created_at": "2021-03-20T11:44:33.961000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "By signing the payload, you can operate with an insecure transport (like plain HTTP).",
        "created_at": "2021-03-20T11:44:46.973000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "You mean encrypting the payload? JWT seems to be signing it but does not require encryption. Anyway, it doesn't need to be discussed here",
        "created_at": "2021-03-20T11:48:52.239000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Not encrypting, just signing.",
        "created_at": "2021-03-20T11:48:58.578000+00:00",
        "attachments": null
    },
    {
        "author": "dkdkdkdkdkdk",
        "category": "general",
        "parent": "",
        "content": "do you think it's reasonable to require security regardless of the setup?",
        "created_at": "2021-03-20T11:49:07.082000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "```\ngeth --with-trusted-public-key ${my-public-key}\nteku --with-private-key ${my-private-key}\n```\nGeth would provide an unsecured REST endpoint that anyone can send new blocks to.  However, if the header of the request doesn't contain a signature over the payload that recovers to `${my-public-key}`, it will throw out the block.",
        "created_at": "2021-03-20T11:52:01.855000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Teku can then initiate a connection to geth via any routing/networking topology (including through any kind of edge servers, reverse proxies, forward proxies, VPNs, etc.) and since it is just REST over HTTP there is no almost zero complexity for any weird networking setups.",
        "created_at": "2021-03-20T11:52:55.233000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The entire security of the system is just that one signature in the HTTP header that signs over the block.",
        "created_at": "2021-03-20T11:53:16.835000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Part of the reason this is nice is because all of the involved clients already know how to sign things and recover signatures, so we don't have to bring in a bunch of new cryptography stuff.",
        "created_at": "2021-03-20T11:54:28.202000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Plus, the client developers all know how to sign and recover as well.",
        "created_at": "2021-03-20T11:54:50.873000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "who provisions teku's pub key in geth?  This is part of the deployment?",
        "created_at": "2021-03-20T16:31:35.459000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "Thats not true.. signed JWTs = JWS - sign over payload and the header : https://auth0.com/docs/tokens/json-web-tokens/json-web-token-structure",
        "created_at": "2021-03-20T16:33:43.288000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "although to add on JWT are typically useful if some contextual state information needs to be transferred between geth and teku.  An advantage would be the format standardization",
        "created_at": "2021-03-20T16:36:25.524000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Hmm, it doesn't feel like it is an appropriate use of a JWS since I believe they are really intended to sign over JSON structured data, particularly user info.",
        "created_at": "2021-03-20T16:53:26.469000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I can appreciate the benefits of standardized tooling, but that is kind of the exact reason I like using secp256k1 or BLS, because it is tooling that the clients already have for other reasons.",
        "created_at": "2021-03-20T16:53:59.978000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "It provides custom claims so that you can customize the token as need be.  This is essentially what you are suggesting - Sign send the signature over HTTP headers within the Auth field.  JWT would just impose formatting and provide more order if in future more contextual info. needs to be sent over.",
        "created_at": "2021-03-20T17:22:28.420000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "This is assuming that the communication/auth is uni-directional",
        "created_at": "2021-03-20T17:23:11.114000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "If no contextual info. needs to be sent - skip the JWTs",
        "created_at": "2021-03-20T17:24:24.388000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "As a client dev I would be against trying to invent some new form of authentication. SSL+basic auth would likely be my first approach as itâ€™s pretty simple, though even that would be optional since most setups would just be on localhost anyway. \nAuth via ssl certs would be the next option as itâ€™s already common between validator clients and signers. \nAnd I believe besu already supports jwt as an auth method for json rpc so that is probably a reasonable option as well. \n\nIâ€™m not particularly fussed about having this as a standard because different people want to do it different ways and thereâ€™s already plenty of standardisation on how to secure web endpoints.",
        "created_at": "2021-03-20T20:04:17.057000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "is there a valid reason to run these on different machines? If not, IPC and auth are an extremely solved problem. even if so, web auth is also very solved",
        "created_at": "2021-03-20T20:24:02.937000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "The only reason why the beacon and application nodes are separate is historical; if we were developing ethereum from scratch today the functionality would all be baked into one node",
        "created_at": "2021-03-20T20:24:50.598000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "as a side note, I've run ECC sigs in http headers before. seems attractive because it's familiar, but it's more trouble than it's worth",
        "created_at": "2021-03-20T20:24:54.425000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "So I would say making it possible to run them on different machines is \"an extra feature\", not a strict necessity",
        "created_at": "2021-03-20T20:25:17.216000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "Geth has an IPC solution already, btw",
        "created_at": "2021-03-20T20:25:27.907000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "with auth, I believe",
        "created_at": "2021-03-20T20:25:52.914000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Realistically I think any transport is fine; the only annoyance of plain old RPC is that the sender authenticates the receiver (because it's requesting to the receiver's URL) but the receiver doesn't authenticate the sender, so any use case where the sender needs to be authenticated (specifically `submitBlock`) requires polling",
        "created_at": "2021-03-20T20:26:50.862000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "rather than shoehorning in things we're familiar with (ECC, JWT, SSL), it should be pretty straightforward to ask a dev familiar with IPC options to recommend something",
        "created_at": "2021-03-20T20:29:14.335000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "I'd support that",
        "created_at": "2021-03-20T20:31:15.147000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "IIRC geth's existing IPC is built around named pipes on windows and unix sockets on other platforms",
        "created_at": "2021-03-20T20:31:27.556000+00:00",
        "attachments": null
    },
    {
        "author": "dkdkdkdkdkdk",
        "category": "general",
        "parent": "",
        "content": "you mean by turning it into `getBlock`?",
        "created_at": "2021-03-20T20:31:29.814000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Basically, the issue is that when a beacon block contains an application block, the beacon client needs to ask the application client to verify that it's correct, and the application client needs to ignore PoW checks in this case and it needs to save the block locally",
        "created_at": "2021-03-20T20:32:28.347000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "And so the beacon client submits the application block to the application client",
        "created_at": "2021-03-20T20:32:37.407000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "And this submission must be trusted, as you can't just have anyone submit a block with no PoW and have it be verified",
        "created_at": "2021-03-20T20:32:51.637000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "The polling solution would be for the application client to keep poking the beacon client and asking it if it has an application block to submit",
        "created_at": "2021-03-20T20:33:50.238000+00:00",
        "attachments": null
    },
    {
        "author": "dkdkdkdkdkdk",
        "category": "general",
        "parent": "",
        "content": "it seems the application client will need an extra config to identify the trusted beacon client either way",
        "created_at": "2021-03-20T20:35:50.024000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "right",
        "created_at": "2021-03-20T20:36:03.810000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "one common method for these things is to have the channel be inaccessible to unauthorzied people. e.g. localhost with protection against dns rebinding, or an IPC file with rw set for a specific usergroup",
        "created_at": "2021-03-20T20:36:28.309000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "or have a parent process set up stdin/stdout connections between children",
        "created_at": "2021-03-20T20:37:49.542000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "ok anyway this is a highly specialized discussion that obviously has an answer but we need to decide which one; we should just make a breakout chat and invite the right experts to give the answer",
        "created_at": "2021-03-20T20:38:44.257000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "general",
        "parent": "",
        "content": "I think the most important tradeoff to understand right now is that this is easier if we mandate that the nodes run on the same machine",
        "created_at": "2021-03-20T20:41:07.918000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "I would argue that making this restriction is actively good; it slightly reduces the chance that we'll see people pointing to infura or other centralized providers for application block validation",
        "created_at": "2021-03-20T20:42:12.708000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Obviously it's not a proper solution to that problem; for that there's proof of custody schemes, but it does stack on top of whatever solution we come up with",
        "created_at": "2021-03-20T20:42:48.031000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I suspect running on the same machine is more of a baseline because it avoids the need for authentication. Clients will support forms of authentication and encryption based on their user demands as well, just as besu supports various forms of authentication for json rpc today.",
        "created_at": "2021-03-20T20:51:09.922000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Also worth noting that exposing the current eth1 node json rpc publicly is a major dos vector because clients can just eth_call the node into oblivion. You need to add various rate limiting etc for it to be safe.",
        "created_at": "2021-03-20T20:52:09.569000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I am strongly against requiring same machine because that totally breaks all containerization solutions.",
        "created_at": "2021-03-20T22:55:03.899000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "why wouldn't a container just contain both nodes?",
        "created_at": "2021-03-20T22:55:28.637000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I currently run all of my clients (application and consensus) in containers.",
        "created_at": "2021-03-20T22:55:34.156000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Because this isn't how containers csgenerally work. ðŸ˜„",
        "created_at": "2021-03-20T22:55:50.123000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "They're not merged into a single node only for historical reasons anyway",
        "created_at": "2021-03-20T22:55:56.243000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It is considered an anti-pattern and bad practice to have multiple processes per container, and for good reason.",
        "created_at": "2021-03-20T22:56:11.116000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I disagree that them being one is a good thing.  I agree with \u003c@456226577798135808\u003e that we should be working on splitting clients up into *more* services rather than consolidating them into a single one.",
        "created_at": "2021-03-20T22:56:57.606000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "hmm",
        "created_at": "2021-03-20T22:57:12.608000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It allows more specialization and mixing and matching.  Nethermind may have better RPC stuff while Geth may do better at mempool management and OE has a better EVM.",
        "created_at": "2021-03-20T22:58:12.749000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "At the moment, I get all of one, but if it was a service oriented system with common APIs for communication between pieces of the system I could use different bits from different authors.",
        "created_at": "2021-03-20T22:59:17.630000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "right, I can see how that opens the door for more client diversity",
        "created_at": "2021-03-20T22:59:28.735000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "In this case though, my prime argument is just that these two pieces are *currently* separate and there are pretty well established practices for dealing with multi-service architectures and requiring them on the same machine breaks some of the most popular conventions.",
        "created_at": "2021-03-20T23:00:32.021000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "Along the same lines ... the solution for commuinication/ auth should work irrespective of whether the two are on the same node or different nodes i.e with both being separate containers",
        "created_at": "2021-03-20T23:04:08.527000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What challenges did you run into with ECC signatures in headers?",
        "created_at": "2021-03-20T23:04:49.807000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "So I do think we want to eventually require them to be on the same *physical machine* (or physically connected machines) because we want to have proof of custody on EVM validation",
        "created_at": "2021-03-20T23:05:30.779000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "My problem with TLS is that it is a pain to setup, especially with self signed certificates.  It *feels* (maybe naive) easier to do a signed payload to me.",
        "created_at": "2021-03-20T23:05:37.845000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "But that should not interfere with containerization solutions",
        "created_at": "2021-03-20T23:05:41.797000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "And that requirement would not exist for nodes that are not validators",
        "created_at": "2021-03-20T23:05:50.580000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Are you thinking that the JWT payload would just be a byte array which is an RLP or SSZ encoded block?",
        "created_at": "2021-03-20T23:06:15.366000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What do you mean by proof of custody?",
        "created_at": "2021-03-20T23:07:02.446000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "https://ethresear.ch/t/a-0-001-bit-proof-of-custody/7409",
        "created_at": "2021-03-20T23:07:11.897000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "But over either the ethereum state or some kind of execution trace, instead of just the block data",
        "created_at": "2021-03-20T23:07:36.464000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "Yes.. typically base64 encoded but if Eth uses separate serialization schemes that should be fine too.  Optionally parameters such as client id can be sent as well",
        "created_at": "2021-03-20T23:12:39.870000+00:00",
        "attachments": null
    },
    {
        "author": "carpediem_7",
        "category": "general",
        "parent": "",
        "content": "The signature is then sign algo( base64UrlEncode(header) +  base64UrlEncode(payload),  secret)",
        "created_at": "2021-03-20T23:14:18.778000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What does that have to do with single machine vs multi-machine?",
        "created_at": "2021-03-20T23:27:38.855000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "The point is that the only way to efficiently do the protocol in a multi-machine context is to send your key over to the other machine, which risks your security",
        "created_at": "2021-03-20T23:40:04.525000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Because otherwise you would have to send over too much data",
        "created_at": "2021-03-20T23:40:17.431000+00:00",
        "attachments": null
    }
]