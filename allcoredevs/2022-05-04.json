[
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "How do coredevs feel about the execution-specs project, and possibly using it to describe Core EIPs?",
        "created_at": "2022-05-04T14:49:41.503000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "https://ethereum.github.io/execution-specs/py-hardforks.html",
        "created_at": "2022-05-04T14:49:56.365000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "i think it is a nice goal to aim for -- are the specs complete yet? i don't see more recent forks on this page",
        "created_at": "2022-05-04T19:18:44.571000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e I am strongly in favour of it, but afaik they aren't complete yet",
        "created_at": "2022-05-04T20:01:11.890000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctimbeiko\u003e One thing that would be useful to know from client teams, if we do the switch once the specs are complete, is at what stage of the EIP process weâ€™d expect to see a PR to the executable specs? \n\nEIP authors have said that for some types of EIPs, it makes sense to have an initial prototype/implementation in a production client, so it seems reasonable to not expect this for, say, Drafts. \n\nThat said, if we do move to this as the canonical way to specify changes, it feels like somewhere around when we move an EIP to CFI, youâ€™d want to have a PR to the spec. Do people think thatâ€™s too soon/late?",
        "created_at": "2022-05-04T20:03:15.568000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e Interesting question is, isn't it easier to implement the changes in the spec than into a client?",
        "created_at": "2022-05-04T20:04:34.015000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e It almost feels like this step would come before having a prototype",
        "created_at": "2022-05-04T20:04:51.704000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctimbeiko\u003e Right, this step _could_ come before, but for some changes (or EIP champions with experience in a particular client), the spec may be more cumbersome than the prototype.",
        "created_at": "2022-05-04T20:05:25.123000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "\u003c@683653554631868440\u003e brought this up on the EIPIP call this morning and had some previous comments about it here: https://github.com/ethereum/pm/issues/492#issuecomment-1071196084",
        "created_at": "2022-05-04T20:06:20.617000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e I think if it is harder to implement something in the spec than in an actual client, we got something very wrong",
        "created_at": "2022-05-04T20:09:02.243000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e this definitely isn't true for the eth2 executable spec",
        "created_at": "2022-05-04T20:09:09.817000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "this is certainly true for any dev that has been working in a particular CL client in one language and does not know any python",
        "created_at": "2022-05-04T20:15:08.824000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "general",
        "parent": "",
        "content": "I really like it, although I have not used it yet. Having at least some programming language embedded in EIPs would be very helpful.",
        "created_at": "2022-05-04T20:15:46.051000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Yes, this was Greg's concern too, coming from a Geth/C++ background and knowing very little python. He gave the example of https://eips.ethereum.org/EIPS/eip-615 as one which would be harder to implement in an executable spec than in a client he was familiar with.",
        "created_at": "2022-05-04T20:17:31.916000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e a design goal in the consensus-layer specs is to not leverage almost any language specific capababilities. Itâ€™s as common denominator code as you can get",
        "created_at": "2022-05-04T20:18:42.347000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e We aim to keep the python very simple and not use  python-specific syntactic features. It is really much more like pseudocode. It does not contain any optimizations.",
        "created_at": "2022-05-04T20:18:42.557000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdankrad\u003e Of course it's possible that if someone is super deep in the code of one client, then they could find it easier than switching to thinking about the spec. However, that then lacks the power of having a common unambiguous language between all clients",
        "created_at": "2022-05-04T20:19:45.727000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "general",
        "parent": "",
        "content": "I bet if you have any client implementation someone can translate this to Python-powered spec. Especially if you can generate tests from the implementation and test the spec against these.",
        "created_at": "2022-05-04T20:23:04.677000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdannyryan\u003e on CL side, we do the opposite, we generate tests from the spec for the implementations",
        "created_at": "2022-05-04T20:23:42.647000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "This I think is one of the best features of the CL specs that it gives precise tests that all clients need to pass. This is particularly critical in consensus code",
        "created_at": "2022-05-04T20:25:30.898000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "the tesing of itself is also really nice. when adding a new feature, I know if I broke some prior test/assumption/functionality",
        "created_at": "2022-05-04T20:26:31.873000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "general",
        "parent": "",
        "content": "This is ideal, but my point is that one can start from a client implementation if really there is a need for it.",
        "created_at": "2022-05-04T20:27:20.568000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "yeah, fair",
        "created_at": "2022-05-04T20:27:34.086000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Not yet complete. Finishing Constantinople likely this week.",
        "created_at": "2022-05-04T20:29:36.673000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Having done both, I can say that implementing an EIP in the specs is _much_ easier than in a client, at least in my experience.",
        "created_at": "2022-05-04T20:30:22.924000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yeah I do believe the same holds true in the CL side, but I empathize with someone that has never had to dig deep in the spec and knows well the codebase of a particular client. Also, even if not intended, I believe that implementation details from the spec leak into the clients. It's no coincidence that many implementations are list-like based (as in Python) when perhaps other structures would have been more readable. In this regard I think the annotated specs that both Vitalik and Ben maintain are a huge favor to the community",
        "created_at": "2022-05-04T20:38:21.084000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "general",
        "parent": "",
        "content": "Interesting point about spec language leaking into client implementations.  Usually specs are written in such a way that the description, in English or pseudo-code or whatever, is self-contained and simple, and something that slips in that is an artefact of a particular implementation starts to look incoherent with that, and probably the spec will be cleaned up to remove the implementation-specific quirk.",
        "created_at": "2022-05-04T20:44:07.015000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "That's one of my biggest concerns.",
        "created_at": "2022-05-04T20:46:08.328000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "I don't want the structure of the `execution-specs` leaking into clients because it's easier to just straight port the code.",
        "created_at": "2022-05-04T20:46:37.289000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "general",
        "parent": "",
        "content": "For example, comparing the `snap/1` spec (Snap sync protocol) with the Geth implementation, there are some important differences, but the language of the spec defines something simpler than the language in the implementation, which are arguably bugs but snook in because they look simpler in the Geth implementation, and would look like odd anomalies when rephrased in the spec.",
        "created_at": "2022-05-04T20:47:21.959000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "general",
        "parent": "",
        "content": "That said, I found several instances of misleading or ambiguous language in EIPs, where the proper interpretation was only clear by looking at actual client implementations to see what they really did. This goes back to some of the oldest and simplest EIPs where \"everyone knows\" what the language means, but they read ambiguously to me. Thank goodness for Hive tests.",
        "created_at": "2022-05-04T20:54:24.954000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "general",
        "parent": "",
        "content": "The most recent spec error I know about is in EIP-1559.  (I really should write it up)  Working on Nimbus a significant mistake was found (not by me) in the pseudo-code in EIP-1559, by someone implementing what they read. I believe it's missing a line or two. All the client implementations do the right thing though, and checking those is how to confirm what the _real_ spec is. The EIP-1559 one is particularly interesting to this discussion, because the spec itself is Python pseudo-code.  I think if it had been written out in clear English like most EIPs, I think there would be no mistake and it would be possible to implement correctly without reading other client implementations.  In other words, I think writing that spec in pseudo-code _intending_ to make it precise, actually ended up obscuring a fault with it.",
        "created_at": "2022-05-04T21:03:40.349000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "There's a big difference between writing simple python in an EIP where it's never tested or executed and writing it in an executable spec where the code is tested but also the reference tests are built off of that code.  You can still have places where you missed writing a test obviously, but it becomes much less likely for the code to be wrong.",
        "created_at": "2022-05-04T21:29:30.397000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "general",
        "parent": "",
        "content": "I agree. But specs serve multiple purposes: One is to define, which tests and executable specs provide in machine-checkable form. The other is to explain the essence of the change, ideally making issues and mistakes stand out as clearly as possible, and being neutral with respect to different possible implementations. Having to explain the essence acts as a review/sanity check that it actually makes sense, and then at scale, to keep each layer of the tower of abstractions staying reasonable simple. I think the combination of Hive tests and English EIPs have done that well for EVM EIPs so far.",
        "created_at": "2022-05-04T22:05:17.246000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctimbeiko\u003e I think we would want to keep EIPs for their english sections",
        "created_at": "2022-05-04T22:05:55.280000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctimbeiko\u003e So, you have an EIP which explains the change, its rationale, perhaps even some non-obvious implementation gotchas, and then link to the executable spec(s) for the code.",
        "created_at": "2022-05-04T22:06:29.389000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctimbeiko\u003e This would have the added benefit of allowing a single EIP to point to sets of changes across the CL and EL, which is very awkward to do now for things like withdrawals and 4844",
        "created_at": "2022-05-04T22:06:54.038000+00:00",
        "attachments": null
    },
    {
        "author": "galaxybloom.",
        "category": "general",
        "parent": "",
        "content": "\u003c@552133098075193354\u003e is there a project/way to assist in translating EIPs into other languages, or is that already done?",
        "created_at": "2022-05-04T22:07:45.567000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctimbeiko\u003e Also, itâ€™s pretty bad (IMO) that CL changes donâ€™t have an EIP we can point to, so it would be nice for them to also require an EIP which is then much easier to discuss/debate, rather than random-ish issues like https://github.com/ethereum/consensus-specs/issues/2883",
        "created_at": "2022-05-04T22:07:58.750000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "I'm not sure I understand this question?",
        "created_at": "2022-05-04T22:08:16.471000+00:00",
        "attachments": null
    },
    {
        "author": "galaxybloom.",
        "category": "general",
        "parent": "",
        "content": "English to French, German etc.?",
        "created_at": "2022-05-04T22:08:29.775000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "ha, no! it would be nice, though ðŸ™‚",
        "created_at": "2022-05-04T22:08:39.507000+00:00",
        "attachments": null
    },
    {
        "author": "galaxybloom.",
        "category": "general",
        "parent": "",
        "content": "Iâ€™d be interested in looking into organizing this. I can do 4-5 languages, and could solicit help for others. Who would be a good point of contact for me?",
        "created_at": "2022-05-04T22:09:25.748000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "let's chat in \u003c#746566142700814426\u003e",
        "created_at": "2022-05-04T22:11:26.036000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "general",
        "parent": "",
        "content": "A risk is that the executable spec(s) contain accidental complexity (corner cases) that go unnoticed because the code looks natural in a particular implementation, but would stand out as weird corner cases if the exact same behaviour was spelled out in written form.  I'm only saying that process of making the written form acts as a kind of review/sanity check on real simplicity.  I guess having to encode it all in a tedious formal specification with no programming language pleasantries would have the same benefit ðŸ™‚",
        "created_at": "2022-05-04T22:12:05.279000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "This is something that itches me as well. I feel is not too off-topic (specially now that the merge is coming) that I'll put my rant here. The guys at sigma prime have been doing a lot of excellent protocol research, and this naturally results in that a bunch of the discussion happens in their GitHub, so by the time that the PR hits the Spec repo it's half cooked and us mortals could barely review it. I was (am) very against what happened with the Fee Recipient API for example, by the time the PR hit the repo, the link to the discussion in \u003chttps://github.com/sigp/lighthouse/issues/2715\u003e included a month of people's thinking and arguing. I envision something similar with this idea of forking late blocks \u003chttps://github.com/sigp/lighthouse/pull/2860\u003e to which this time I strongly agree, but would want to see it in the specifications and with a corresponding study of the security implications. Anyway I feel that if we had a centralized way like EIPs that point a link to Ethereum Magicians or something like this, then we could have less transient discussions on these topics rather than having to lurk in every client's repo to find out what's going on in the same protocol I'm working on.",
        "created_at": "2022-05-04T23:01:07.701000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "\u003c@755590043632140352\u003e suggest you come and chime in here: https://ethereum-magicians.org/t/core-eips-in-an-executable-spec-world/8640 ðŸ™‚",
        "created_at": "2022-05-04T23:14:12.224000+00:00",
        "attachments": null
    }
]