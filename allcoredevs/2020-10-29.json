[
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "**AllCoreDevs in ~23hrs (Oct 30, 14:00 UTC)**\nAgenda: https://github.com/ethereum/pm/issues/219\nStream: https://www.youtube.com/watch?v=GOWSrHtNZOQ\n\nMost important thing on the agenda currently is trying to get resolution on Hudson's messages from a few days ago (https://discord.com/channels/595666850260713488/745077610685661265/770736034946089010). TL;DR: what goes into YOLOv3 \u0026 Berlin?",
        "created_at": "2020-10-29T14:50:30.274000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "\u003e Also, on the call it was mentioned that because a lot of the flat DB work ties into new sync protocols, it would be good to have a second call dedicated to that in a few weeks. Would the same time (Wed 14:00 UTC) two weeks from now (Nov 11) work for most folks? \u003c@!213672586264051717\u003e \u003c@!403707149043105803\u003e \u003c@!489256758989029405\u003e \u003c@456226577798135808\u003e \u003c@!206016661470314496\u003e \u003c@!211091239112671234\u003e \u003c@!364458974906548225\u003e\nJust sent an invite for Tuesday Nov 10th for this. If you didn't get it and want to attend, please ping me.",
        "created_at": "2020-10-29T14:53:27.358000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "\u003c@!381789485777682434\u003e \u003c@!211091239112671234\u003e - for the BLS EIP (2537), I'm curious if you have any thoughts on the pros and cons of simplifying the EIP by removing the precompiles for G1 and G2 add and mul.\nBLS12_G1ADD can be done with G1 Multiexp with two points and both scalars set to 1\nBLS12_G1MUL can be done with G1 Multiexp where there is only one point and the scalar can be anything",
        "created_at": "2020-10-29T21:01:29.298000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "I know it wouldn't be the most gas efficient but maybe it would be worth it in the interest of simplicity?",
        "created_at": "2020-10-29T21:03:07.753000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "I need to re-check for BLS signature formula over different messages and over the same message, but it‚Äôs reasonable. I can not immediately recall anything else other than random oracle mapping to curve that requires only addition, not the multiexp or multiplication of some sort",
        "created_at": "2020-10-29T21:06:15.873000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "Well, if Eth2.0 scheme is one from here https://ethresear.ch/t/pragmatic-signature-aggregation-with-bls/2105 then it would benefit from plain additions",
        "created_at": "2020-10-29T21:28:50.722000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "So I guess the concern would be the performance difference of add vs going through the multiexp code path",
        "created_at": "2020-10-29T21:32:08.696000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "And it‚Äôs substantial for G2 (updated number are not yet merged, but here are the latest measurements): addition 800 gas, multiplication 45000 gas. Multiexp will give a discount, but not 50 times",
        "created_at": "2020-10-29T21:40:07.203000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "Let me run an estimate for eth2.0 shard signature verification (for a light client) to see what part of the signature it takes",
        "created_at": "2020-10-29T21:42:58.934000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "Well we should maybe separate out the gas cost from the actual performance, there is no reason we couldn't special case the gas cost for simple adds",
        "created_at": "2020-10-29T22:00:48.743000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "e.g. if all scalars = 1 use this pricing formula",
        "created_at": "2020-10-29T22:01:33.160000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "it would at least reduce complexity in terms of number of precompiles/interfaces and underlying code",
        "created_at": "2020-10-29T22:02:20.444000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "If we are going to special case out special variables for gas calculations we should keep the add and mul precompile methods then.",
        "created_at": "2020-10-29T22:04:05.372000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "These special cases are where consensus failures breed.",
        "created_at": "2020-10-29T22:04:53.443000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "\u003c@!403707149043105803\u003e fair enough. I personally haven't looked much into the gas pricing yet, but maybe there is a pricing formula that more accurately represents the computational complexity such that doing adds/muls with the multiexp precompile makes their pricing more representative",
        "created_at": "2020-10-29T22:06:20.182000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "The more complex the pricing formula the easier it is to abuse.  I would prefer to overcharge than to overfit.",
        "created_at": "2020-10-29T22:07:05.479000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "Also agree, but for instance the EIP mentions that implementations should use Pippenger's algorithm and perhaps prices according to that. But given the current gas limits Pippenger is probably not the correct algorithm given the number of points you'll actually be able to do",
        "created_at": "2020-10-29T22:08:07.129000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "we should not make assumptions about implementation.",
        "created_at": "2020-10-29T22:08:22.145000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "Agreed",
        "created_at": "2020-10-29T22:08:28.440000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "But sometimes it is implicit in the pricing",
        "created_at": "2020-10-29T22:08:43.926000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "For instance the ModExp precompile was priced by Vitalik to represent Karatsuba multiplication, but I don't think that is actually the underlying implementation in any of the clients",
        "created_at": "2020-10-29T22:09:15.379000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "Yeah, having separate addition is much better than special case of all scalars = 1",
        "created_at": "2020-10-29T22:12:01.459000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "Anyway, I don't have a dog in this fight, just thought I would throw out the suggestions since I'd heard concerns about the number of precompiles in the EIP and the complexity",
        "created_at": "2020-10-29T22:16:28.358000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "Implicit peppinger is indeed an optimization, but it allows too large savings. In principle we are on a quite late state for the 2537, so I would support to remove additions/multiplications if it would not hurt (but it hurts), but I would not add any extra implementation details into the spec other than price constants adjustments (1962 got faster, other libs were very fast with a margin to it)",
        "created_at": "2020-10-29T22:16:48.115000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "It may be good to keep this idea in mind for other similar cases where one would not aim for such a specific application for BLS signatures",
        "created_at": "2020-10-29T22:17:29.243000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "\u003c@!381789485777682434\u003e makes sense, I was hopeful that the gas pricing formula for modexp wouldn't penalize the simple add and mul cases too much",
        "created_at": "2020-10-29T22:18:11.180000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "By the way, did you find a reason why Rust‚Äôs default modexp is so slow?",
        "created_at": "2020-10-29T22:18:49.404000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "I don't recall precisely but I think it was a naive algorithm",
        "created_at": "2020-10-29T22:19:38.407000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "For example I think for large exponents it didnt use montgomery",
        "created_at": "2020-10-29T22:21:25.852000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "or something to that effect",
        "created_at": "2020-10-29T22:21:33.553000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "been too long üòÇ",
        "created_at": "2020-10-29T22:22:15.002000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "What part of the algo do you call ‚Äúnaive‚Äù? Last time I had a time to look it had windowed Montgomery modexp for odd modulus, so my intuition was that it either allocates a lot, or their FMA with carry approach was suboptimal",
        "created_at": "2020-10-29T22:23:25.946000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "Did you test before or after a commit mentioned here by the way? https://github.com/rust-num/num-bigint/issues/156",
        "created_at": "2020-10-29T22:23:43.678000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "It was my colleague who tested it but I can ask",
        "created_at": "2020-10-29T22:26:12.798000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "Looks like 0.2.6 was what we tested, so maybe that would improve it",
        "created_at": "2020-10-29T22:27:05.050000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "general",
        "parent": "",
        "content": "There are many PR pending to improve performance there, may be it can be easily become on par with Go, and I presume Java has a good bigint already. Not sure for C#",
        "created_at": "2020-10-29T22:28:58.794000+00:00",
        "attachments": null
    },
    {
        "author": "kelly06407",
        "category": "general",
        "parent": "",
        "content": "Unfortunately the standard C# library isn't great either",
        "created_at": "2020-10-29T22:30:17.567000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "I wonder how EIP-2200/EIP-1706 interacts with the `eth_estimateGas` RPC call. Consider a transaction that *actually* costs gas cost G. This value should be what's reported by `eth_estimateGas`. However, EIP-2200/EIP-1706 requires that we revert if gas left is less than 2300, if it meets a SSTORE opcode. This means that if someone uses `eth_estimateGas` to get the gas cost of a call that ends with a SSTORE on dirty slots, and then directly pass that gas cost to a transaction, the transaction would fail! The user must adds an additional 2300 gas to be safe on the estimate.\n\nIs this the expected behavior? How does Geth deal with this situation? cc \u003c@!211091239112671234\u003e \u003c@!206016661470314496\u003e",
        "created_at": "2020-10-29T23:08:32.605000+00:00",
        "attachments": null
    }
]