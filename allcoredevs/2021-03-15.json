[
    {
        "author": "chriseth8375",
        "category": "general",
        "parent": "",
        "content": "\u003c@!552133098075193354\u003e Unfortunately, I cannot join the allcoredevs meeting on Friday. This means that I cannot champion the BEGINDATA EIP. Furthermore, I think we should also dicuss if we want to have a more general and extensible solution like https://notes.ethereum.org/@axic/evm-object-format",
        "created_at": "2021-03-15T10:47:04.441000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "Something that I mentioned to \u003c@!683653554631868440\u003e but it I think it will be useful for general understanding, so I will post it here, also FIY \u003c@!273818081439121408\u003e . For EIPs like EIP-615 and EIP-2315 (new version) and such, those aim to introduce some restrictions to the EVM (meaning that some bytecode sequences that are considered \"valid\" today will be considered \"invalid\" in the future), absolutely require full cooperation with the compiler teams (in our case Solidity and Vyper). And this full cooperation cannot be limited to \"oh, they raised their concerns but I thought they were not appropriate, and therefore we went ahead with what we had\". Full cooperation here means EVM designers and compiler writers have a common strategy on how they will roll out the new restriction in lock step. For example: Firstly, restriction needs to be embedded into the compilers, so that they do not generate code that will be deemed \"invalid\". Only then the restriction can be applied to EVM, either with breaking backwards compatibility or with some kind of versioning. For some complex changes, more than one of such lock-step phases \"compiler -\u003e VM\" may be required. I hope this can be one of the lessons learnt from Berlin hard fork coordination. And this lesson can be understood not just on very technical level, but on the level of coordinators like \u003c@!552133098075193354\u003e \u003c@!191378736254287874\u003e \u003c@!187490121698770945\u003e . We can build in a simple test. Does this change introduce restrictions to EVM? If yes, what do compiler writers think about it? Do we have their full cooperation?",
        "created_at": "2021-03-15T12:16:05.713000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "general",
        "parent": "",
        "content": "\u003c@!273818081439121408\u003e is a coauthor of EIP-615, and as Solidity lead was aware and supportive of its restrictions.  I wrongly assumed he still supported his own proposal as it entered Last Call.  At least Last Call was an appropriate time for him to raise objections.  EIP-2315 was the result.\n\nEIP-2315 did not introduce _any_ restrictions - only a standard control-flow mechanism.  It imposed _no_ requirements on compilers.   But Christian and others believe that it needs to restrict that mechanism in some of the ways that EIP-615 did. \n\nIt wasn't that \"... they raised their concerns but I thought...\"  They made a proposal that we thoroughly discussed.  As author I mostly decided against incorporating their proposal into the EIP, precisely because I intended only to propose an unrestricted mechanism.\n\nThat was the EIP that the core devs accepted, and multiple client teams implemented and tested.  It was ready to go into the upgrade we are currently coordinating.  But Christian waited until this late date to raise his objections again and make them show-stoppers.  This was not an appropriate time, given how long-standing his objections were. I remain angered and disappointed by what went down.\n\nThe current version of EIP-2315 is back to Draft, and includes discussion and demonstration of how security guarantees (but not features) equivalent to EIP-615 can be provided by deprecating dynamic jumps.  I agree that whether and how to do so is now up for a discussion that the prior version had intentionally left for a later date.\n\nI have recommended we form a working group of interested parties -- and I hope that includes compiler authors -- to come to consensus and coordinate this and the other EVM improvements currently proposed.\n\nThis seems a more productive use of my disappointment than simply walking away from six years of work.",
        "created_at": "2021-03-15T13:27:22.802000+00:00",
        "attachments": null
    },
    {
        "author": "chriseth8375",
        "category": "general",
        "parent": "",
        "content": "\u003c@!683653554631868440\u003e I'm sorry that this impression came up, but me being an author of EIP-615 does in no way mean I support it. Many months ago, you started with such a proposal, and I agreed to work on it as an experiment of how it would speed up an interpreter. You wrote the interpreter and it did not provide a significant speedup, if I remember correctly. The main problem with the EIP is that it is fully unclear whether or not it is an improvement to the EVM. It does not even state the metric it wants to improve the EVM on. There was a lot of discussion on those EIP, but that does not mean that any objections were resolved. I was fooled by the EIP process since I thought the EIP would not be scheduled for Berlin until very late. Because of that, I specifically did not \"make [my objections] show-stoppers\". Instead, I asked the community to re-evaluate everything. But going back to a constructive way of working: Please, Greg, tell me why you want these EIPs to be implemented. What is their goal and why do you think it is worth making the EVM more complicated? Which problem do they solve? I would really appreciate keeping the EVM as simple as possible and at the same time make it flexible enough so that we can get proper scalability - not execution efficiency factors of 10-20%, but rather 100x scaling.",
        "created_at": "2021-03-15T13:40:10.519000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "We are basically coming to an understanding that changes related to static analysis and control flow that do not introduce restrictions are mostly not useful unless they are part of well-formed strategy, where benefits eventually come, but in the future. This is a conjecture, but it does make sense to me now. EVM is a bit too permissive on this front, and the only way to fix it is via introducing restrictions",
        "created_at": "2021-03-15T13:44:33.736000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "And from my side, I do feel that the topic of static analysis is something that we are gradually learning, and I am trying to turn this learning into some practical demonstrations, so that more people can learn and we can figure out what the real promises are (like, will it allow 10x or 100x improvement of anything?). We are where we are, and until we get some critical mass of collective learning and understanding, some things will be seen as premature",
        "created_at": "2021-03-15T13:50:27.837000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I wish I had a few people in my team who are both good programmers and static analysis experts, but unfortunately it is not the case ðŸ™‚ and getting there takes time and effort, so I have to be patient",
        "created_at": "2021-03-15T13:51:22.696000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "general",
        "parent": "",
        "content": "Unfortunately our static analysis experts left the project a while back.  I consulted with them a lot in writing these EIPs.",
        "created_at": "2021-03-15T14:42:28.041000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "general",
        "parent": "",
        "content": "The EIP-2315 RETURNSUB mechanism -- taken from EIP-615 -- is the bare minimum needed for more advanced VMs.  The basic 2-stack design is so old and accepted I didn't feel it needed much justification.",
        "created_at": "2021-03-15T14:44:46.845000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "general",
        "parent": "",
        "content": "The consensus then was that dynamic jumps are the single biggest obstacle to static analysis.  Deprecating them requires subroutines.  It's that simple in the end.",
        "created_at": "2021-03-15T14:51:38.881000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I am not sure if you appreciate the challenge of orchestrating this over many upgrades. When I was trying to design the changes for State Rent for example, there were designs with 3 hard forks, and with 4 hard forks. And people were encouraging me to start writing EIPs for the first hard fork, but I was very hesitant because I knew that unless the entire roll-out plan is solid, there is a big risk of doing the first change which will end up being useless at best or counter-productive. And then the roll-out plan did not materialise because I realise the project requires much more resources and support than I had. Did I get angry and frustrated? No. I moved on",
        "created_at": "2021-03-15T14:59:47.454000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "general",
        "parent": "",
        "content": "I do appreciate the difficulty.  I think that is one reason we offered EIP-615 as a single entity.  EIP-2315 is - again - a very small mechanism that is ready to go. I do not believe it causes any damage, and compilers can use it as they see fit.  The coordination issues arise if and when we decide to deprecate dynamic jumps -- then every user of the EVM must adapt.\n\nHad EIP-2315 not been accepted at all I would not have been angry.  Having it dropped so late in the game, after so much work (and on my birthday) --  yeah, I was angry.  As \u003c@!206016661470314496\u003e put it, it was a \"nasty\" thing to do.  That having passed I got back to work on the EIP, answering the criticisms I could, and suggesting a way forward.",
        "created_at": "2021-03-15T15:15:37.436000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "general",
        "parent": "",
        "content": "More importantly, this incident tells me that our \"process\", that is, our ability to reach and maintain consensus, is badly broken.  When EIPs can be rejected so very late there is less motivation to pursue improvements to Ethereum, less motivation to implement them, and less motivation to make plans to use them.  This hurts us.",
        "created_at": "2021-03-15T15:19:44.302000+00:00",
        "attachments": null
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "Got it. To be sure. I understand, are you withdrawing BEGINDATA from consideration for London? If so, is it just because you can't attend the call (in which case, we can discuss it next call), or because of the alternative proposal (in which case, delaying it makes sense)?",
        "created_at": "2021-03-15T15:44:19.060000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "general",
        "parent": "",
        "content": "I actually don't quite agree. The process is not broken because work was done in vain. In order for an EIP to go through, it requries\n\n- passing tests, \n- implementation(s)\n- fully fleshed out eip, \n- support from client devs (no inherent DoS etc)\n- a solid usecase / support\n\nThis it not a 1, 2, 3.. ladder, rather all of these must be done, and they typically tie into eachother. Client devs need to implement it, which feedbacks into the spec, and helps writing tests, which helps others who wants to implement it. 615 made it though almost all goalposts. For me, as more of an infrastructure builder than app-layer, my point was \"If people want this, I'm fine with it, the client can handle this\". So I didn't raise any objections. \n\nIt took way too long for it to finally be decided that proper support was lacking. And that's the process failure here. But the process failure was never \"a lot of people put in a lot of work for something that didn't come to anything\". I also put in a lot of work --- I also put in a lot of work on the version that had static guarantees, which was abandoned. A lot of what we do will land on the scrapheap. I'm fine with that.",
        "created_at": "2021-03-15T19:16:50.253000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "I've replied to some of the concerns regarding EIP-3074 over at https://ethereum-magicians.org/t/eip-3074-sponsored-transaction-precompile/4880\n\nI'd totally understand if EIP-3074 were to be dropped from London because it's been a bit unstable.",
        "created_at": "2021-03-15T20:26:43.501000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "anyone have a quick estimate on eth1 block processing times on standard consumer machines for average blocks",
        "created_at": "2021-03-15T22:27:43.508000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I seem to remember ~100ms but don't know where I picked that up",
        "created_at": "2021-03-15T22:27:51.019000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "My node currently needs ~200ms (geth, snapshot enabled, 5GB RAM), a bit less than what I would call \"standard consumer\" so yeah ~100-150 seems realistic",
        "created_at": "2021-03-15T22:32:12.811000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I have a MacBook pro from a few years ago running geth and it takes anywhere between 80ms to 270ms to import blocks (I'm guessing the 80ms is an empty block given timings).  Mostly around the 150-200ms mark.",
        "created_at": "2021-03-15T22:33:53.112000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "thank you!",
        "created_at": "2021-03-15T22:41:21.962000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I have looked at the current state of EIP-3074 and a bit about the history and discussion. It is now two new opcodes instead of a precompile. First opcode looks to me like a more restrictive version of `ecrecover` precompile with an extra function of setting a special \"context variable\" `authorizedAccount`. This context variable then allows the second opcode, `AUTHCALL` to \"trick\" the executed code by manipulating the value of `msg.sender` (or `CALLER` in EVM terms). So after some thinking about what is the actual limitation that this EIP seeks to overcome, I concluded that the limitation is the fact that `msg.sender` is commonly regarded and used as not just the caller, but also \"authorized caller\". For all contracts currently written, these two things are the same, regardless of which one (or both) they are actually using. This EIP assumes that `msg.sender` is only used as \"authorized caller\" (this assumption might be ok though), and proposes a mechanism to be able to swap it programmatically, but not in an arbitrary way. There have to exist a signature of `TYPE || sponsor || commit` which can be treated as a blanket permission for the sponsor to send as many transactions as they wish while impersonating the `msg.sender`. From the first sight, this can make the currently proposed mechanism unattractive. An alternative that I would suggest is to introduce a new transaction type that allows multiple signatures (and yes, all further transaction types can be an extension of that). In addition to that, an opcode that allows to read a signature with the given position. Signature with position 0, for example, would be the `tx.origin`, the account that pays for the gas. But there could be as many extra signatures as you want (perhaps with some limits). This is a very \"rushed\" on-top-of-my-head idea, but I do think the current proposal is flawed as I described above",
        "created_at": "2021-03-15T22:51:43.388000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I think there is no escaping from sponsee signing off just one call and not giving blanket approval. And I also don't think the argument of \"oh, but it does not work for existing contracts\" is a good one. Tricking the existing contracts by twisting the EVM semantics around them is not a good thing either ðŸ™‚",
        "created_at": "2021-03-15T22:55:53.007000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "If there is a good mechanism for performing sponsored transactions with the support from the callee, I believe the token contracts (mentioned in the motivation section) will get redeployed to take advantage of this",
        "created_at": "2021-03-15T22:57:27.937000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I don't think `BEGINDATA` EIP needs to be withdrawn from London consideration yet. We will discuss a potentially more general proposal, and a lot will depend on the complexity/benefits trade-offs. More general mechanism may potentially enable quite a few other things (including control flow/static analysis improvements), but we do not know yet how long it is likely to be prepared",
        "created_at": "2021-03-15T23:01:44.036000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "\u003c@456226577798135808\u003e I think a good way to think about `AUTHCALL` is it gives all EOAs smart contract wallet capabilities. Smart contract wallet users trust that code is safe to use. Invokers are like generic smart contract wallets than any EOA could use. There are ways to write an invoker that hurts users--just like one can do with a smart contract wallet. But there will be *safe* invokers that the community trusts that anyone can use. This is also strictly opt in. A user can't accidentally sign an AUTHCALL msg anymore than they can't accidentally sign a transaction that burns all their ether.\n\nMaybe I don't fully understand your criticism, do you see a major difference between `AUTHCALL` and using a smart contract wallet to secure your assets?",
        "created_at": "2021-03-15T23:10:48.521000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "if you use a smart contract wallet (like Gnosis Safe, for example, which I am familiar with), you need to produce signature (on-chain or off-chain) for every single transaction the contract executes. You do not normally do something like \"here is my signature that can be used to approve any transaction that this wallet contract can do on my behalf\"",
        "created_at": "2021-03-15T23:16:53.864000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "to be fair, this is a an implementation detail and an invoker can implement the same logic (1 signature per call)",
        "created_at": "2021-03-15T23:17:59.431000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "We did originally have restrictions on what you can do with a single signed package. As they say, something is done when there's nothing left to take away.\n\nReplay protection was in the precompile version, then got removed because precompiles with storage are weird.\n\nIf the invoker is responsible for replay protection, the user has to trust them for that, so... why not trust them for everything?",
        "created_at": "2021-03-15T23:18:52.389000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "The way I read the EIP, since the callee contract does not check `commit` or other things, once the sponsee produced a signature for a sponsor, the sponsor basically owns all the token balances of that sponsee, which I think is not the intent",
        "created_at": "2021-03-15T23:19:11.498000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "sure, this can be impemented, but this is unlikely to be very useful",
        "created_at": "2021-03-15T23:19:34.345000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "the invoker (a smart contract) should check `commit` - the sponsor (tx.origin) has no power over the user's tokens",
        "created_at": "2021-03-15T23:20:52.738000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "an EOA should only use an invoker they trust, the analog here being a user should only use a smart contract wallet they trust",
        "created_at": "2021-03-15T23:21:21.107000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "This is an equivalent of handing your private key to someone, provided you don't have any ETH on it (which is the assumption in the Motivation section).",
        "created_at": "2021-03-15T23:22:08.936000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Exactly",
        "created_at": "2021-03-15T23:22:20.610000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "So why do EIP, if you can just give sponsor your private key?",
        "created_at": "2021-03-15T23:22:24.511000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "You can't program a human.",
        "created_at": "2021-03-15T23:22:45.636000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "You can verify a smart contract",
        "created_at": "2021-03-15T23:22:57.488000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "Ok, I see your point now",
        "created_at": "2021-03-15T23:23:35.394000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "a robust invoker contract is like deploying a smart contract wallet for every EOA",
        "created_at": "2021-03-15T23:23:37.404000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "but I am still suspicious, need to think about it a bit more",
        "created_at": "2021-03-15T23:23:59.432000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "instead of enshrining certain things in a signature (e.g. one sig per call, nonce in sig, etc),  `AUTHCALL` provides the most flexible interface to developers",
        "created_at": "2021-03-15T23:25:33.939000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "it's up to developers to use it safely (in an invoker) and to convince the community it is safe (just like smart contract wallet development, minus the deployment cost for each user)",
        "created_at": "2021-03-15T23:26:30.897000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I think with this EIP there will still be a need for people to create a smart contract per EOA. Because \"safe invokers\", what are they going to look like and going to do? At the moment I can only think of one that basically allows anyone to sweep all your token balances once you've produced 1 signature. But I can write my own invoker, which will have some restrictions that are applicable to me. So please show me an example of a useful and safe invoker contract, because I cannot imagine one",
        "created_at": "2021-03-15T23:31:36.398000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "general",
        "parent": "",
        "content": "I think the important thing is to really stress the importance of the `commit` field. So an invoker contract could e.g. require `commit = keccak256(abi.encode(nonce, to, amount, calldata))` and then internally increase a per-signer nonce mapping after executing the tx once.",
        "created_at": "2021-03-15T23:33:05.357000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "general",
        "parent": "",
        "content": "Using `commit` instead of a specific choice of fields to sign over gives the invoker the ability to choose its own set of validity constraints. Including authenticated tx details, replay protection, expiry, pricing, ...",
        "created_at": "2021-03-15T23:34:23.807000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "```\nfunction sponsor(uint256 nonce, address callee, uint256 value, uint256 gas, bytes calldata, uint8 v, bytes32 r, bytes32 s) {\n    commit = keccak256(abi.encode(nonce, callee, value, gas, calldata));\n    address sponsee = authorize(commit, v, r, s);\n    require(nonces[sponsee] == nonce, \"bad nonce\");\n    nonces[sponsee] += 1;\n    authcall{value: value, gas: gas, calldata: calldata}(callee);\n}\n```",
        "created_at": "2021-03-15T23:34:49.120000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Loosely",
        "created_at": "2021-03-15T23:34:52.793000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "general",
        "parent": "",
        "content": "I think we can do a better job of explaining the role of `commit` in the EIP though - I will try to make it more clear.",
        "created_at": "2021-03-15T23:35:31.014000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "general",
        "parent": "",
        "content": "I know that EIP-3074 is relatively late for being included in London. So understand if people feel like it should be pushed to consideration for Shanghai, that's definitely a reasonable position. However, the specifics are now stable and well reasoned out. We have a reference implementation in geth and a prototype-implementation in solidity. There is a lot of interest by different groups (Infura's ITX, flashbots, ...). So I think we will at least try to make the case for inclusion in London on Friday and see how people feel about it. In the meantime, we will expand the rationale section of the EIP to optimally reflect all the design decisions that went into it.",
        "created_at": "2021-03-15T23:48:44.074000+00:00",
        "attachments": null
    }
]