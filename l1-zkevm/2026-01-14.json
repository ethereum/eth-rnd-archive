[
    {
        "author": "codygunton",
        "category": "Execution Layer",
        "parent": "",
        "content": "Hi all, I just published a blog post that breaks down the question of security of ZKEVMs into (many!) sub-issues. Excited to work with all of you on this in 2026 ðŸ™‚ \nhttps://zkevm.ethereum.foundation/blog/zkevm-security-overview",
        "created_at": "2026-01-14T14:59:25.561000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e Regarding unaligned accesses:\n\nThe RISC-V specification leaves unaligned memory access behavior \nEEI-dependent(https://docs.riscv.org/reference/isa/_attachments/riscv-unprivileged.pdf, page 54). Historically, possible behaviors used in practice in various hardware implementations include:\n1. Raise an exception/trap - requires the zkVM to implement an exception handling mechanism that transfers control from the faulting instruction to a registered handler. Most zkVMs have been reluctant to introduce such complexity.\n2. Support in hardware - handle unaligned accesses transparently, possibly without much a performance penalty if unaligned accesses are rare\n3. Undefined behavior - may return garbage data or silently perform an aligned access by masking the lower address bits (e.g., clearing the last two bits for word accesses, as seen in older ARMv7-M processors).\n\nFor zkVMs, I recommend one of two approaches:\n- Support unaligned accesses in hardware - handle them correctly \nand transparently within the VM.\n\n- Make unaligned accesses unprovable - ensure that execution traces involving unaligned accesses either fail to generate a proof or produce proofs that fail verification.\n\nAvoid undefined behavior (such as silently rounding addresses to \naligned boundaries), as this can introduce subtle security vulnerabilities. Programs may appear to work while actually accessing incorrect memory locations, leading to exploitable conditions that are difficult to detect and debug.",
        "created_at": "2026-01-14T15:33:40.333000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@marcinbugaj**\n\u003e Regarding unaligned accesses:\n\nThe RISC-V specification leaves unaligned memory access behavior \nEEI-dependent(https://docs.riscv.org/reference/isa/_attachments/riscv-unprivileged.pdf, page 54). Historically, possible behaviors used in practice in various hardware implementations include:\n1. Raise an exception/trap - requires the zkVM to implement an exception handling mechanism that transfers control from the faulting instruction to a registered handler. Most zkVMs have been reluctant to introduce such complexity.\n2. Support in hardware - handle unaligned accesses transparently, possibly without much a performance penalty if unaligned accesses are rare\n3. Undefined behavior - may return garbage data or silently perform an aligned access by masking the lower address bits (e.g., clearing the last two bits for word accesses, as seen in older ARMv7-M processors).\n\nFor zkVMs, I recommend one of two approaches:\n- Support unaligned accesses in hardware - handle them correctly \nand transparently within the VM.\n\n- Make unaligned accesses unprovable - ensure that execution traces involving unaligned accesses either fail to generate a proof or produce proofs that fail verification.\n\nAvoid undefined behavior (such as silently rounding addresses to \naligned boundaries), as this can introduce subtle security vulnerabilities. Programs may appear to work while actually accessing incorrect memory locations, leading to exploitable conditions that are difficult to detect and debug.\nI'd recommend:\n\n\u003e Support unaligned accesses in hardware - handle them correctly and transparently within the VM.\n\nOr will make push2-push32 opcodes very complicated and only for RiscV (as x64 and Arm happily are unaligned, and the code section that the push data comes from is not aligned for these opcodes)",
        "created_at": "2026-01-14T21:16:14.924000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Undefined behaviour would be bad :(",
        "created_at": "2026-01-14T21:21:53.800000+00:00",
        "attachments": null
    }
]