[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmoodlezoup\u003e re: **@jbruestle**\n\u003e Definitely excited on anything that makes cross zkVM interoperability easier for users.  As \u003c@427491045308235776\u003e mentioned, longer term I'd very much like to see more efforts on deeper standardization, as well as pushing precompile patches upstream.  That said given the disinterest by some upstream libs in providing  support for non Tier 1 platforms (which rules out even rv64gc, much less zkVM platforms), I think looking at doing something simpler near term is the right approach.  A way to allow users to use the same patches across zkVMs and have the patches then use feature flags or platform information to appropriately call the right acceleration on the zkVM side seems like a good intermediate step.  In general though, open to consideration of multiple approaches.\nI'd be fine with a universal patch per library, and a feature flag per zkVM (unless someone comes up with a more elegant solution)",
        "created_at": "2025-06-03T02:19:25.021000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjustindrake\u003e Has anyone tried to use non-deterministic hinting to speed up Ethereum precompiles such as pairings and modexp? For pairings this paper (https://eprint.iacr.org/2024/640) is relevant. Elliptic curve scalar multiplications have also been non-deterministically optimised here (https://eprint.iacr.org/2025/933).",
        "created_at": "2025-06-03T12:36:39.241000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cElMarroqui\u003e re: **@justindrake**\n\u003e Has anyone tried to use non-deterministic hinting to speed up Ethereum precompiles such as pairings and modexp? For pairings this paper is relevant. Elliptic curve scalar multiplications have also been non-deterministically optimised here.\nYes Linea uses both these papers",
        "created_at": "2025-06-03T12:37:35.470000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cenitrat\u003e re: **@justindrake**\n\u003e Has anyone tried to use non-deterministic hinting to speed up Ethereum precompiles such as pairings and modexp? For pairings this paper is relevant. Elliptic curve scalar multiplications have also been non-deterministically optimised here.\nYes, extensively through Garaga https://github.com/keep-starknet-strange/garaga for Keth",
        "created_at": "2025-06-03T12:38:54.539000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003civokub\u003e And to add on top of that, in Linea we use something called PLONK-in-Wizard. These optimised implementation are implemented as gnark circuits which we compile into PLONK and then verify in Linea zkEVM the correctness of PLONK traces",
        "created_at": "2025-06-03T12:38:54.713000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cNicolasCsgy\u003e re: **@justindrake**\n\u003e Has anyone tried to use non-deterministic hinting to speed up Ethereum precompiles such as pairings and modexp? For pairings this paper is relevant. Elliptic curve scalar multiplications have also been non-deterministically optimised here.\nIf teams are interested in using this and are looking for help feel free to reach out to @simonmasson, @RenoRen79  or myself",
        "created_at": "2025-06-03T12:39:48.084000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjustindrake\u003e re: **@ivokub**\n\u003e And to add on top of that, in Linea we use something called PLONK-in-Wizard. These optimised implementation are implemented as gnark circuits which we compile into PLONK and then verify in Linea zkEVM the correctness of PLONK traces\nDo you have a link (for my slides)? :)",
        "created_at": "2025-06-03T12:45:53.689000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cElMarroqui\u003e re: **@justindrake**\n\u003e Has anyone tried to use non-deterministic hinting to speed up Ethereum precompiles such as pairings and modexp? For pairings this paper is relevant. Elliptic curve scalar multiplications have also been non-deterministically optimised here.\nLinea also uses some ideas from this paper https://eprint.iacr.org/2022/1162.pdf for the pairing precompile",
        "created_at": "2025-06-03T12:48:33.824000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjustindrake\u003e What about modexp? It's currently by far the worst prover killer and it feels like we could do some non-deterministic magic with it.",
        "created_at": "2025-06-03T12:49:52.859000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003civokub\u003e re: **@justindrake**\n\u003e Do you have a link (for my slides)? :)\n* @alexandrebelling presentation from Devcon - https://drive.google.com/file/d/18BC5R9QvxaV67ChCL7bKhOa1dXXomtfA/view\n* gnark circuits for modexp and pairing - https://github.com/Consensys/gnark/blob/master/std/evmprecompiles/05-expmod.go - https://github.com/Consensys/gnark/blob/master/std/evmprecompiles/08-bnpairing.go\n* integration from gnark to Linea https://github.com/Consensys/linea-monorepo/tree/main/prover/zkevm/prover/modexp (modexp) and https://github.com/Consensys/linea-monorepo/tree/main/prover/zkevm/prover/ecpair (bn_pair)\n* Linea proof system description: https://eprint.iacr.org/2022/1633.pdf\n\nAnd hackmd about the field emulation techniques we use in gnark https://hackmd.io/dDJmqQiKRWSRzEiqUYTA0Q",
        "created_at": "2025-06-03T12:53:18.015000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003civokub\u003e re: **@justindrake**\n\u003e What about modexp? It's currently by far the worst prover killer and it feels like we could do some non-deterministic magic with it.\nFor modexp we only use non-determinism for emulated field arithmetic. We shortly thought about trying to use some ideas from VDFs, but it didn't work out in the end.",
        "created_at": "2025-06-03T12:54:07.333000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003civokub\u003e But for modexp I have a hunch that it should be nicely parallelizable - essentially we could flatten full modexp of n-bits into n instances of 1-bit modexpos and then assert that the inputs and outputs are consistent.",
        "created_at": "2025-06-03T12:57:00.368000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003civokub\u003e The problem with modexp is that the complexity depends really on the modulus and the computational time grows quadratically in the bitlen of the modulus. So 4k modexp is 256x as expensive as 256-bit modexp. In Linea we have \"small-modexp\" circuits for 256 bit modulus and \"large-modexp\" circuit and then choose the most optimal one.",
        "created_at": "2025-06-03T13:00:26.183000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003civokub\u003e re: **@ivokub**\n\u003e But for modexp I have a hunch that it should be nicely parallelizable - essentially we could flatten full modexp of n-bits into n instances of 1-bit modexpos and then assert that the inputs and outputs are consistent.\nAnd as it is that nicely parallelizable, then maybe sumcheck/gkr based approach dedicated for modexp may even be more suitable. To be honest, I don't recall anyone having implemented modexp using GKR. So a low-hanging fruit for someone to try it out :)",
        "created_at": "2025-06-03T13:03:19.043000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003civokub\u003e We didn't bother that much into optimizing too much as some historical data shows that most cases are with 256-bit modulus (https://docs.google.com/spreadsheets/d/1Q0jTsob5rmOkHXPmX4ITEV5WsgW41xBkxavyxgVsCG0/edit?usp=sharing) and as a L2 we weren't that much constrained with worst-case performance",
        "created_at": "2025-06-03T13:06:53.413000+00:00",
        "attachments": null
    }
]