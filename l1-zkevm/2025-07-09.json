[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csophiagold0\u003e re: **@jpwang**\n\u003e yes, our understanding is that if you grind right before the fiat-shamir challenge at any place using the random oracle model in the interactive protocol, the grinding makes specific attacks on the randomness harder to find\nI want to return to this discussion. Do other zkVM teams using 32 bit fields think this approach is reasonable to reach 128 bits of security without changing the extension?",
        "created_at": "2025-07-09T14:45:00.490000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmratsim\u003e re: **@kevaundray**\n\u003e I think this adds a bit of complexity to the API, so I'm trying to see why this is being done.\n\nDo you plan to support guest programs in other languages such as go/c# etc?\nIt's done because it allows hashing arbitrary sizes without holding everything in memory.\n\nFor example this is used to implement HMAC and HKDF as used in EIP-2333.\n\nAnd it's also used in hash-to-curve to implement BLS signatures in the \"expand-xmd\" primitive",
        "created_at": "2025-07-09T15:06:28.188000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmratsim\u003e See: https://github.com/mratsim/constantine/blob/master/constantine%2Fhash_to_curve%2Fh2c_hash_to_field.nim#L119\n\nSo zkvm will need the \"update\" for blob inputs and proving consensus / beam chain",
        "created_at": "2025-07-09T15:09:41.763000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmratsim\u003e re: **@amvlasov**\n\u003e If you are mainly talking about standarding interfaces for Reth/Revm, then why extern \"C\" at the first place? If you assume single e.g. Rust implementation for every language and C-header, then it's more about question if other languages codebases use or not use update approach on hashes\nI think only go doesn't use the update approach iirc.",
        "created_at": "2025-07-09T15:10:30.056000+00:00",
        "attachments": null
    }
]