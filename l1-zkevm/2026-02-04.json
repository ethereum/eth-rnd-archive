[
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "The VM would need to ensure this memory region is never modified? I think this does not come out of the box: even if you tell the memory allocator to never touch that region for allocation, you need some system level protection against writes to the region. After you call `read_input(&mut ptr, ..)`, I don't think you can statically guarantee even in a trusted program that the slice is never written to. I'm curious if the Zisk implementation protects against writes with the above semantics? \n\n<@1408119112743256134> I also left comments in the PR on `write_output`.",
    "created_at": "2026-02-04T00:56:46.917000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "Yeah the VM would need to ensure that its read-only -- for Zisk I believe they have a separate memory region just for the inputs vs memory that gets allocated during the duration of the program",
    "created_at": "2026-02-04T00:58:48.504000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "Reference here: https://github.com/0xPolygonHermez/zisk/blob/b3ca745b80423c8123dc24f19039865a5bc8b074/core/src/mem.rs#L30\n\nI think one downside I can see of this is approach is that the memory region for inputs is capped at 128MB(?), this should be configurable, though I'm not sure what the effect is on the ZisK prover",
    "created_at": "2026-02-04T01:00:15.593000+00:00",
    "attachments": []
  },
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "How is it kept separate though? If it becomes just a plain `ptr: *const u8`, then if I just call `unsafe { (ptr + 5).set(prank) }`, will the VM trap?",
    "created_at": "2026-02-04T01:01:59.306000+00:00",
    "attachments": []
  },
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "For example I think almost everyone links the program ROM as text into memory, but you can in fact unsafely mutate the text -- it's only ROM in VMs where the program is also _separately_ loaded into a read-only memory space that is not addressed using the same pointers as data memory (the address is distinguished by the fact that only `pc` can reference the ROM)",
    "created_at": "2026-02-04T01:06:40.270000+00:00",
    "attachments": []
  },
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "I guess the circuit needs to have a very lightweight MMU that routes addresses based on the range? The analog of the host code: https://github.com/0xPolygonHermez/zisk/blob/b3ca745b80423c8123dc24f19039865a5bc8b074/core/src/mem.rs#L316",
    "created_at": "2026-02-04T01:09:32.159000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "It seems there are three types of memory regions as noted here (ROM, RAM, free input memory): https://github.com/0xPolygonHermez/zisk/blob/b3ca745b80423c8123dc24f19039865a5bc8b074/state-machines/mem/pil/mem.pil#L17\n\nAnd the circuit constrains that the input memory cannot be written to",
    "created_at": "2026-02-04T01:20:51.544000+00:00",
    "attachments": []
  },
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "Ok, it seems the `zkvm_io` API is then making a pretty opinionated suggestion on the zkVM's underlying memory regions & management that is not dictated by pure RISC-V. Let me think about whether there's other ways to support the API as written besides the three memory region approach",
    "created_at": "2026-02-04T02:16:57.130000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "I think the point about writing into ROM was not brought up before â€” since it may require change in N-1 out of N zkVMs, then going with (1) and making a separate proposal for (2) that we explore later sounds more optimal unless we know now that (2) gives us non trivial performance gains",
    "created_at": "2026-02-04T02:40:57.862000+00:00",
    "attachments": []
  },
  {
    "author": "marcinbugaj_94168",
    "category": "Execution Layer",
    "parent": "",
    "content": "<@1072958679533498398> , <@427491045308235776> : https://github.com/eth-act/zkvm-standards/pull/8#issuecomment-3846898336, https://github.com/eth-act/zkvm-standards/pull/8#discussion_r2763463624",
    "created_at": "2026-02-04T11:30:28.812000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "If we assume that the application itself never manually frees that region of ROM memory, then I think it become a question of how to stop the memory allocator from freeing that memory, which for certain languages like C# and Go would mean stopping the GC from moving or reclaiming it?",
    "created_at": "2026-02-04T12:22:33.294000+00:00",
    "attachments": []
  },
  {
    "author": "marcinbugaj_94168",
    "category": "Execution Layer",
    "parent": "",
    "content": "`read_input` is supposed to return always the same address. An option of freeing is not provided because that memory is not \"managed\" in any sense. That's not a problem for C and Rust. There must be a way of expressing the fact that the memory is not managed in C# and Go as well.",
    "created_at": "2026-02-04T12:25:29.732000+00:00",
    "attachments": []
  },
  {
    "author": "marcinbugaj_94168",
    "category": "Execution Layer",
    "parent": "",
    "content": "Cranelift as alternative backend for WASM compilation",
    "created_at": "2026-02-04T14:53:41.008000+00:00",
    "attachments": []
  },
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "So the change in the doc means we impose this read-only at the code-level (e.g., by telling the memory allocator) but not machine level. This makes sense to me and is much easier to support.",
    "created_at": "2026-02-04T18:04:34.081000+00:00",
    "attachments": []
  }
]