[
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "The VM would need to ensure this memory region is never modified? I think this does not come out of the box: even if you tell the memory allocator to never touch that region for allocation, you need some system level protection against writes to the region. After you call `read_input(&mut ptr, ..)`, I don't think you can statically guarantee even in a trusted program that the slice is never written to. I'm curious if the Zisk implementation protects against writes with the above semantics? \n\n<@1408119112743256134> I also left comments in the PR on `write_output`.",
    "created_at": "2026-02-04T00:56:46.917000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "Yeah the VM would need to ensure that its read-only -- for Zisk I believe they have a separate memory region just for the inputs vs memory that gets allocated during the duration of the program",
    "created_at": "2026-02-04T00:58:48.504000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "Reference here: https://github.com/0xPolygonHermez/zisk/blob/b3ca745b80423c8123dc24f19039865a5bc8b074/core/src/mem.rs#L30\n\nI think one downside I can see of this is approach is that the memory region for inputs is capped at 128MB(?), this should be configurable, though I'm not sure what the effect is on the ZisK prover",
    "created_at": "2026-02-04T01:00:15.593000+00:00",
    "attachments": []
  },
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "How is it kept separate though? If it becomes just a plain `ptr: *const u8`, then if I just call `unsafe { (ptr + 5).set(prank) }`, will the VM trap?",
    "created_at": "2026-02-04T01:01:59.306000+00:00",
    "attachments": []
  },
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "For example I think almost everyone links the program ROM as text into memory, but you can in fact unsafely mutate the text -- it's only ROM in VMs where the program is also _separately_ loaded into a read-only memory space that is not addressed using the same pointers as data memory (the address is distinguished by the fact that only `pc` can reference the ROM)",
    "created_at": "2026-02-04T01:06:40.270000+00:00",
    "attachments": []
  },
  {
    "author": "jpw_axiom",
    "category": "Execution Layer",
    "parent": "",
    "content": "I guess the circuit needs to have a very lightweight MMU that routes addresses based on the range? The analog of the host code: https://github.com/0xPolygonHermez/zisk/blob/b3ca745b80423c8123dc24f19039865a5bc8b074/core/src/mem.rs#L316",
    "created_at": "2026-02-04T01:09:32.159000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "It seems there are three types of memory regions as noted here (ROM, RAM, free input memory): https://github.com/0xPolygonHermez/zisk/blob/b3ca745b80423c8123dc24f19039865a5bc8b074/state-machines/mem/pil/mem.pil#L17\n\nAnd the circuit constrains that the input memory cannot be written to",
    "created_at": "2026-02-04T01:20:51.544000+00:00",
    "attachments": []
  }
]