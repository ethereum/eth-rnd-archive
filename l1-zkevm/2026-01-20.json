[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e Here is an example of using casting that leads to generating potentially unaligned accesses. That is from the master branch of popular google flatbuffer library (serialization). https://github.com/google/flatbuffers/blob/8914d06ab7123167424438cf293bb349833bcb7d/include/flatbuffers/base.h#L428 . I found a few issues related to unaligned accesses in flatbuffers - for instance this (https://github.com/tensorflow/tensorflow/issues/39661). That's technically UB but this style of coding used to be popular in the past and such problems can be buried deep in dependencies.",
        "created_at": "2026-01-20T10:04:34.041000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmratsim\u003e re: **@marcinbugaj**\n\u003e Here is an example of using casting that leads to generating potentially unaligned accesses. That is from the master branch of popular google flatbuffer library (serialization). https://github.com/google/flatbuffers/blob/8914d06ab7123167424438cf293bb349833bcb7d/include/flatbuffers/base.h#L428 . I found a few issues related to unaligned accesses in flatbuffers - for instance this. That's technically UB but this style of coding used to be popular in the past and such problems can be buried deep in dependencies.\n\nCap'n proto Rust crate has a feature flag for controlling unaligned accesses: https://dwrensha.github.io/capnproto-rust/2020/01/19/new-feature-to-allow-unaligned-buffers.html\nBut many ISAs enforce alignment, x86 is a bit of the exception there.",
        "created_at": "2026-01-20T10:56:48.698000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e re: **@L1zkevm_bot**\n\u003e \u003ckevaundray\u003e +1 on performance, @shamatar for reference here; is there a significant/any performance degradation for air bender if the circuit only does aligned loads?\n\nFor the emitted code you linked, the compiler may or may not emit an unaligned load, even if the hardware says it is supported\nDid you mean to ask \"what is a performance degradation if circuit only does UNaligned loads\"? Because at the moment all loads are aligned and unaligned loads are unprovable traps",
        "created_at": "2026-01-20T11:23:14.827000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e Flatbuffs is special as it has/had internal alignment check on full buffers and writable positions, so if input buffer is validated, they could expect alignments to be ok. So with a good chance it may be sound, even though this particular line of code has suppressed sanitized reporting",
        "created_at": "2026-01-20T11:36:20.497000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e For Ethereum STF due to it's complexity and security requirements I'd only expect highly-restricted programs to be provable input, and for initial steps it doesn't has to be full product matrix of all programs X all provers to be needed for CL voting, but some majority/supermajority/another rule",
        "created_at": "2026-01-20T11:38:33.622000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e re: **@amvlasov**\n\u003e Flatbuffs is special as it has/had internal alignment check on full buffers and writable positions, so if input buffer is validated, they could expect alignments to be ok. So with a good chance it may be sound, even though this particular line of code has suppressed sanitized reporting\nThere has been reports for unaligned accesses problems on DSP processors and older ARM hardware when using official API. These kinds of problems are quite common in serialization frameworks or any libraries that deal with stream of data. The fact that this flatbuffers code remains unmodified shows that such vulnerabilities can persist even in popular and well-regarded codebases.",
        "created_at": "2026-01-20T13:58:54.677000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e I‚Äôm wondering what happens if you report/make an issue about this particular line",
        "created_at": "2026-01-20T14:00:04.925000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e But as you see automated sanitizers are good for such patters",
        "created_at": "2026-01-20T14:00:28.389000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e re: **@justindrake**\n\u003e Can you quantify this (e.g. in dollars or man hours)?\nUnfortunately I can't do that. As @alexanderlhicks mentioned we haven't agreed on the target capabilities yet and that is a prerequisite",
        "created_at": "2026-01-20T14:00:59.550000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003c@381789485777682434\u003e ah no I meant if the circuit only does aligned loads -- ie if the circuit were to support unaligned loads but the guest program did none of them. \n\nSo this is the performance degradation (if any) to normal Rust programs that do not use unaligned loads",
        "created_at": "2026-01-20T14:44:03.511000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "Someone will need to commit to fixing target specific issues in perpetuity, so it's not a one off funding issue, and there are other qualitative requirements that make it hard to make any reasonable estimation on man hours needed imo.",
        "created_at": "2026-01-20T14:53:36.705000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "Though everything will need to start off ar Tier 3, so we added Tier 3 support for RV64IM a few months ago: https://github.com/rust-lang/rust/pull/148790\n\nI don't think the conversation above changes this target since RISC-V doesn't specify what happens on unaligned loads",
        "created_at": "2026-01-20T14:57:02.579000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e It depends on the design (there is no such circuit). If it‚Äôs merged with less-than-word then it‚Äôs not too many such circuits per block, but I do not remember how many. Alternative is to make a separate circuit, that didn‚Äôt exist, and it‚Äôs more circuits in the system. But then it‚Äôs kind-of free circuit-side. But there are still complications with simulator.\n\nBut that is anyway unrelated on unwillingness to accept UB in STF anyway",
        "created_at": "2026-01-20T14:58:00.907000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e @alex_vlasoff , could you please provide input in https://github.com/eth-act/zkvm-standards/pull/8#issuecomment-3759140098",
        "created_at": "2026-01-20T15:12:45.948000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003calex_vlasoff\u003e re: **@marcinbugaj**\n\u003e @alex_vlasoff , could you please provide input in https://github.com/eth-act/zkvm-standards/pull/8#issuecomment-3759140098\nI believe you‚Äôve meant another Alex Vlasov\n @amvlasov",
        "created_at": "2026-01-20T15:28:43.983000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e re: **@alex_vlasoff**\n\u003e I believe you‚Äôve meant another Alex Vlasov\n @amvlasov\nSorry for the mistake üòÖ",
        "created_at": "2026-01-20T15:32:36.003000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003calex_vlasoff\u003e re: **@marcinbugaj**\n\u003e Sorry for the mistake üòÖ\nNo problem üòä",
        "created_at": "2026-01-20T15:32:59.909000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003c@381789485777682434\u003e \n\nFor Golang, I _think_ its not UB -- you can check the PR I made that tries to clarify the specs where they mention that its intentionally left in the gray area.\n\nFrom what I gather:\n\n- The compiler won't generate unaligned loads, if the hardware doesn't support it. RISC-V is specified to not support it. See here for the only relevant optimization: https://github.com/golang/go/blob/7251c9e0f00a6d7d37bb441f3e823c160131e9b5/src/cmd/compile/internal/ssa/memcombine.go#L19\n\n- If an unaligned load is written in user code, then this is not UB, but it can crash devices.\n\n- They have a `checkptr` tool that does check for unaligned loads, but only if its a struct and one of the inner fields is unaligned. This is because this could crash the GC when it chases those pointers. But if its an unaligned u64 for example, this check doesn't catch it.",
        "created_at": "2026-01-20T17:51:52.181000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "The behaviour not being specified explicitly is something I think they've been aware of for a few years. See for example, the diff here: https://go-review.googlesource.com/c/crypto/+/222855",
        "created_at": "2026-01-20T17:55:46.438000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "I think the above rationale has been confirmed in the last reply from Ian:\n\nGo doesn't really have undefined behavior in the C standard sense.\n\nSince Go doesn't have pointer arithmetic outside of the unsafe package, it's not possible to have a misaligned address in safe Go.\n\nAs Keith said above, the unsafe package is intentionally a grey area that is not fully specified. The language simply doesn't say what happens when you use the unsafe package to construct a misaligned pointer and then dereference that pointer.\n\nI personally think that in that case the compiler is free to generate code that faults at run time. If you don't want that to happen, don't generate misaligned pointers.\n\nThe unsafe package already provides all the facilities you need to copy the misaligned pointer into an aligned value and use that. Whether the compiler optimizes that case is a quality of implementation issue. \n\nThat issue is not affected by concerns about the language or about undefined behavior.",
        "created_at": "2026-01-20T18:10:24.692000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "I have a hard time to interpret it together with a response that we had in the opened issue ‚Äúthe pedantically correct way to phrase this is that the compiler assumes that for *p the compiler always assumes that p % unsafe.Alignof(*p) == 0‚Äù. I‚Äôm fine to say that alignment is not in spec, but implementation detail and can even change with compiler version. But AlignOf(*uint64) = 8",
        "created_at": "2026-01-20T19:33:30.930000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "This was the original addition to the spec and they said its too strict. \n\nI think what Ian is saying is that if it is not aligned, the compiler will just emit the unaligned load and it will not break your code(due to optimizations) but it may fault on hardware. Moreover, the only way to do this is in unsafe code, so its the user's responsibility",
        "created_at": "2026-01-20T19:39:04.623000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "For the *uint64 case, I think that if you do offset the address by say 2 bytes, then it would violate one of the rules of unsafe; you cannot read beyond the end of the container",
        "created_at": "2026-01-20T19:43:21.279000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "It‚Äôs enough to make 16 bytes and read uint64 at offset 2 to avoid length argument",
        "created_at": "2026-01-20T22:06:28.535000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "And I checked the codegen, they will generate load blindly (LD opcode) for *uint64 deref. So they were lazy and ‚Äúassume‚Äù/‚Äúrequire‚Äù supported unaligned ops here, while not generating it in other places like LE integer load or memcopy. What a shame language",
        "created_at": "2026-01-20T22:09:17.632000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "But then I have a question - they did have mips backend I think, and mips also has alignment requirements‚Ä¶",
        "created_at": "2026-01-20T22:16:23.518000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "In that case, the compiler would never emit unaligned loads -- but if someone were to write unsafe code, I think the hardware would fault and then assuming linux, it would be fixed up in software",
        "created_at": "2026-01-20T22:17:55.294000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "Well, they have it kind of covered in unsafe package - via\n‚Äú(1) Conversion of a *T1 to Pointer to *T2.\n\nProvided that T2 is no larger than T1 and that the two share an equivalent memory layout(?!), this conversion allows reinterpreting data of one type as data of another type‚Äù",
        "created_at": "2026-01-20T22:25:18.606000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "So there is no valid use of unsafe declared as ‚Äúconversion from Pointer‚Äù, there is only same time roundtrip conversion *T1 -\u003e Pointer -\u003e *T2",
        "created_at": "2026-01-20T22:27:08.869000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "However, ‚Äúequivalent memory layout‚Äù is not defined nearby",
        "created_at": "2026-01-20T22:27:32.557000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "So the comment about misuse of unsafe could be valid",
        "created_at": "2026-01-20T22:28:45.084000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "Do you have a link to latest GitHub conversation with Ian? I want to ask about this interpretation of proper use of unsafe package",
        "created_at": "2026-01-20T22:34:13.717000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "conversations happen on googles review system here: https://go-review.googlesource.com/c/go/+/737121",
        "created_at": "2026-01-20T22:34:53.684000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution Layer",
        "parent": "",
        "content": "I‚Äôll try to ask tomorrow",
        "created_at": "2026-01-20T22:35:25.829000+00:00",
        "attachments": null
    }
]