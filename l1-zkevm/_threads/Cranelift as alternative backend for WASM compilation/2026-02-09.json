[
  {
    "author": "marcinbugaj_94168",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "The `wasrisc` experiments measured **instruction counts** without precompiles. What really matters is **proving time**. Since precompiles are expected to have much higher proving time (cost) than normal RISC-V instructions, it would make sense to enhance the benchmark by:\n1. Using \"hardware\" implementations of precompiles in the stateless functions\n2. Measuring proving time instead of execution time\n3. Using zkVM providers' provers instead of qemu-riscv64\n\nIn that real-world scenario, I expect the overhead to be significantly less than 3x (though still >1x). The 3x penalty holds for general-purpose computation without precompiles. To get more accurate results for EF use cases, we'd need to improve the benchmarks by integrating accelerators and using zkVM tools for proving. For EF use cases, ~3x represents the upper bound on performance loss.",
    "created_at": "2026-02-09T13:45:19.670000+00:00",
    "attachments": []
  },
  {
    "author": "marcinbugaj_94168",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "> go’s backend is unique\nGo is known to produce 30% slower code than LLVM/gcc for equivalent logic: https://benchmarksgame-team.pages.debian.net/benchmarksgame/fastest/rust-go.html. By this token it may turn out that Go will lose “first N different proofs” game",
    "created_at": "2026-02-09T13:52:22.184000+00:00",
    "attachments": []
  },
  {
    "author": "marcinbugaj_94168",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "Given that there are many moving parts (in regards of STF languages and compilers) it could make sense to invest in WASM Cranelift RISCV bare metal code generation - as an experiment or as a research project",
    "created_at": "2026-02-09T13:53:57.555000+00:00",
    "attachments": []
  }
]