[
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "",
    "created_at": "2026-02-23T15:58:35.539000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "CC <@466102668138512394> who works on zkboost, <@577788234810130432> <@402080271563751435> for visibility",
    "created_at": "2026-02-23T15:58:36.457000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "<@838752311416193084> nice work! Out of interest why did you chose to roll your own distributed proving orchestration framework as opposed to using a pre-existing framework from traditional data industries.",
    "created_at": "2026-02-23T16:27:12.475000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "Have you made optimisations that wouldn't be possible in other frameworks?",
    "created_at": "2026-02-23T16:28:24.730000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "For example how does it compare to a framework like ray - https://github.com/ray-project/ray",
    "created_at": "2026-02-23T16:29:25.457000+00:00",
    "attachments": []
  },
  {
    "author": "orion3336",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "Fair question. We wanted a lightweight Rust-native orchestrator that can embed provers in-process, including intermediate parallel operations (think of optimisations we did to better distribute FFTs and MSMs) with minimal data copies when performance matters, or invoke them as opaque binaries when flexibility matters.",
    "created_at": "2026-02-23T18:50:34.739000+00:00",
    "attachments": []
  }
]