[
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "",
    "created_at": "2026-02-23T15:58:35.539000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "CC <@466102668138512394> who works on zkboost, <@577788234810130432> <@402080271563751435> for visibility",
    "created_at": "2026-02-23T15:58:36.457000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "<@838752311416193084> nice work! Out of interest why did you chose to roll your own distributed proving orchestration framework as opposed to using a pre-existing framework from traditional data industries.",
    "created_at": "2026-02-23T16:27:12.475000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "Have you made optimisations that wouldn't be possible in other frameworks?",
    "created_at": "2026-02-23T16:28:24.730000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "For example how does it compare to a framework like ray - https://github.com/ray-project/ray",
    "created_at": "2026-02-23T16:29:25.457000+00:00",
    "attachments": []
  },
  {
    "author": "orion3336",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "Fair question. We wanted a lightweight Rust-native orchestrator that can embed provers in-process, including intermediate parallel operations (think of optimisations we did to better distribute FFTs and MSMs) with minimal data copies when performance matters, or invoke them as opaque binaries when flexibility matters.",
    "created_at": "2026-02-23T18:50:34.739000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Execution Layer",
    "parent": "l1-zkevm",
    "content": "Do you have a sense of how much performance gain you achieve using rust-native orchestration with embedded provers / in-process optimisations. It would also be great to get a sense of reliability of push0. How has your experience been operating push0 in production?\n\nI'm trying to get a sense of what direction you think is most practical based on your experience:\n- Use an off the shelf orchestration solution like ray with compiled DAG's to match the proving workflow (this comes with off the shelf error handling, work distribution, etc)\n- Build a bespoke orchestration solution like push0 specifically for execution proving (probably harder to have feature parity with industry leading orchestration frameworks but possibly more opportunity for optimisation?)",
    "created_at": "2026-02-23T19:18:49.322000+00:00",
    "attachments": []
  }
]