[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csoispoke\u003e re: **@gakonst**\n\u003e IMO you possibly don't need FOCIL if you can make the MEV pipeline look like MEV Geth where bundles are the default, you allow bundles to be proven, remove the MEV Relay role, and the proposer runs an aggregation circuit which combines the bundles into a block?\n\nThe SNARK is costly to recompute so MEV stealing probably cannot happen in time, and the SNARK ensures the work the proposer needs to do is just run a greedy algo for the highest paying bundles vs re simulating everything.\nI think it assumes:\nâ€¢ End users being able to prove their own bundles/transactions.\nâ€¢ There can't be another party with access to very fast proving infrastructure that could see the content of a pending txn/bundle, prove it, and resubmit it as their own with slightly higher fees. In other words I think it would introduce latency-proving races.",
        "created_at": "2025-06-30T11:10:41.685000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e re: **@soispoke**\n\u003e I think it assumes:\nâ€¢ End users being able to prove their own bundles/transactions.\nâ€¢ There can't be another party with access to very fast proving infrastructure that could see the content of a pending txn/bundle, prove it, and resubmit it as their own with slightly higher fees. In other words I think it would introduce latency-proving races.\nYah I am operating in a MEV Boost style model where users send their orderflow for \"stamping\" by a provernet of their choice. And the proof latency race might be desired! That's good for the user. And I think you can do it in a way that doesn't devolve to monopolistic prover market structure.",
        "created_at": "2025-06-30T13:45:23.361000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e @jordibaylina , @pumatheuma , @yisun , @mratsim , @alexandrebelling , @jbruestle , @amvlasov and others that I may have missed:\n\n(Mostly just trying to get a temperature check)",
        "created_at": "2025-06-30T14:31:27.730000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjpwang\u003e ^ there is quite a strong distinction based on whether you allow use of conjectures or not",
        "created_at": "2025-06-30T14:33:04.960000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@jpwang**\n\u003e ^ there is quite a strong distinction based on whether you allow use of conjectures or not\n@mmaller what are your thoughts on use of conjectures?",
        "created_at": "2025-06-30T14:36:08.334000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e Also on the standardization of precompiles; this proposal by @jpwang https://hackmd.io/@axiom/H1zAF9wQle was better than what I had originally proposed.\n\nThis requires changes mostly on the EL side and not its dependencies -- @gakonst we spoke already, but can you give a general ACK for these changes here?",
        "created_at": "2025-06-30T14:38:49.321000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjpwang\u003e re: **@jpwang**\n\u003e ^ there is quite a strong distinction based on whether you allow use of conjectures or not\nto give some additional context, for \u003c32 bit fields, if you don't assume any conjectures there is a step change at ~120ish bits of security where you would need to change the extension field used (which I would put in the non-trivial camp). but you could get to 128 either by using some very strong conjectures or by grinding for the last ~10 bits",
        "created_at": "2025-06-30T14:40:56.669000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003calexandrebelling\u003e Trivial considering that the variables are well understood:\n* Arity of the field extension\n* Number of columns to open (regardless of the conjecture being used or not, the number of column require to achieve any security level is known)\n\nThere is also the concrete security impact of doing multiple layers of recursion which is not so trivial and the impact of being in a list decoding regime on the PIOP security",
        "created_at": "2025-06-30T14:41:47.415000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e Until there are better ideas on how proofs will be validated there is little value in 128 bits (for now most uses end up in wrapping anyway, that is 80-100 at most). Consensus is 100 bits too",
        "created_at": "2025-06-30T14:46:55.294000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e Sorry -- forgot to add \"show answers\" thanks Ladislaus.\n\n(This is also multiple choice)",
        "created_at": "2025-06-30T14:49:10.726000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@amvlasov**\n\u003e Until there are better ideas on how proofs will be validated there is little value in 128 bits (for now most uses end up in wrapping anyway, that is 80-100 at most). Consensus is 100 bits too\nI think this is a bit orthogonal right now since the question was not about whether we should do 128 bits, just gathering data on the effort needed\n\n(Not saying its not an important consideration)",
        "created_at": "2025-06-30T14:52:17.206000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e As for precompile interfaces:\n- pairing/ecrecover/p256 - are most likely `fn(input: \u0026[u8], output: \u0026mut impl NoStdWriter)`\n- for hashes - quite elaborated traits that would do something like `get_impl() -\u003e impl Digest`, otherwise it's hard to express if e.g. keccak/blake is fully unrolled/partially unrolled/decomposed",
        "created_at": "2025-06-30T14:54:07.682000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e Kev, how should I mark an answer like \"will be available in next version\"? It's not about trivial/not (as performance is affected anyway due to recursion), but it's clearly \"not right now\" (2-3 months)",
        "created_at": "2025-06-30T14:55:05.470000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@amvlasov**\n\u003e As for precompile interfaces:\n- pairing/ecrecover/p256 - are most likely fn(input: \u0026[u8], output: \u0026mut impl NoStdWriter)\n- for hashes - quite elaborated traits that would do something like get_impl() -\u003e impl Digest, otherwise it's hard to express if e.g. keccak/blake is fully unrolled/partially unrolled/decomposed\n\u003e As for precompile interfaces:\n\nYou're okay with the underlying proposal of using extern C?",
        "created_at": "2025-06-30T14:55:44.417000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003calexanderlhicks\u003e re: **@amvlasov**\n\u003e Until there are better ideas on how proofs will be validated there is little value in 128 bits (for now most uses end up in wrapping anyway, that is 80-100 at most). Consensus is 100 bits too\nFor the L1 we expect to target 300kB proofs with no wrapping.",
        "created_at": "2025-06-30T14:56:57.233000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e But the underlying statement is not 128 bits yet (for L2s there is a good example of deploying into same address two different bytecodes with `create2`, while people expect same address across different chains for some apps, but for L1 I think something like that can be made too. E.g. consensus layer related BLS12-381 staff). Not like it affects anything in the work, but problem is not too well defined from my view",
        "created_at": "2025-06-30T15:00:01.737000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e re: **@kevaundray**\n\u003e \u003e As for precompile interfaces:\n\nYou're okay with the underlying proposal of using extern C?\n`impl Digest` is crucial, and I would prefer alignment guarantees, and have no idea if `extern \"C\"` can do that (what c-bindgen would produce?)",
        "created_at": "2025-06-30T15:01:32.412000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@amvlasov**\n\u003e impl Digest is crucial, and I would prefer alignment guarantees, and have no idea if extern \"C\" can do that (what c-bindgen would produce?)\nWhy is impl Digest crucial?\n\nHere is a PR that is being used to be more concrete about the proposal: https://github.com/bluealloy/revm/pull/2675/files#diff-0c07183268be3158ccbf04e1bf6173dd6e490366cb7bdfa98f33797723a5a09aR17",
        "created_at": "2025-06-30T15:05:37.378000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e There multiple cases when making continuous input is painful, so stateful object (with alignment guarantees) would be move convenient",
        "created_at": "2025-06-30T15:09:34.458000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e for ecrecover input is small and easy to make continuous (and it's kind-of already such in most calls) - then stateless is fine. Only hashes themselves are more convoluted",
        "created_at": "2025-06-30T15:11:22.465000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csoispoke\u003e re: **@gakonst**\n\u003e Yah I am operating in a MEV Boost style model where users send their orderflow for \"stamping\" by a provernet of their choice. And the proof latency race might be desired! That's good for the user. And I think you can do it in a way that doesn't devolve to monopolistic prover market structure.\nI think MEV-boost style you lose public observability, and the prover network would have to be private/trusted not to leak MEV. So there would be no way to tell whether txns are censored in the first place\n\nPublic mempool style you get proof latency races/frontruning etc.. and there I think it would likely push the market towards hardware centralization. Also I struggle to see a world in which builders are not integrated with provers but that's a different discussion!",
        "created_at": "2025-06-30T15:13:00.947000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjpwang\u003e re: **@amvlasov**\n\u003e for ecrecover input is small and easy to make continuous (and it's kind-of already such in most calls) - then stateless is fine. Only hashes themselves are more convoluted\nhowever the actual use cases of the hash in `revm` are stateless, so the stateful implementation could be left as an internal implementation detail?",
        "created_at": "2025-06-30T15:16:29.334000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmmaller\u003e re: **@kevaundray**\n\u003e @mmaller what are your thoughts on use of conjectures?\nThis depends a lot on the conjecture.  If we could avoid conjectures and get 128 bits of security and be efficient enough then this would be best case scenario.  If we must use conjectures, then as a minimum, I would hope the conjecture can be clearly written in a standalone manner such that we could put some resources into its analysis.",
        "created_at": "2025-06-30T15:22:25.316000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003celiastzr\u003e re: **@kevaundray**\n\u003e \ncc @MayaDotan for",
        "created_at": "2025-06-30T15:34:14.743000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e re: **@jpwang**\n\u003e however the actual use cases of the hash in revm are stateless, so the stateful implementation could be left as an internal implementation detail?\nI didn't check the codebase, but at least I used stateful approach in no_std MPT implementation. Same we do for Ethereum TX transaction format parsing (L2 specific) and signature verification",
        "created_at": "2025-06-30T15:37:13.018000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@amvlasov**\n\u003e I didn't check the codebase, but at least I used stateful approach in no_std MPT implementation. Same we do for Ethereum TX transaction format parsing (L2 specific) and signature verification\nCould you link these cases, so I can check it out?",
        "created_at": "2025-06-30T15:38:59.826000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e Like that - accumulate from iterator https://github.com/matter-labs/zksync-os/blob/756ed34a1d91e62b69204b1ab9d59b7682015018/basic_system/src/system_implementation/flat_storage_model/mod.rs#L127 (`\u0026mut impl MiniDigest` usage)",
        "created_at": "2025-06-30T15:42:37.278000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e As I said - some code is potentially L2 specific, but in general accumulation interface is convenient",
        "created_at": "2025-06-30T15:43:34.114000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e technically you can do that via\n```\nextern \"C\" {\n    #[repr(C, align(..))]\n    struct Opaque {\n       _size: [u8; SIZE],\n       _marker: // consider PhantomPinned,\n    }\n\n    fn update(stateful_object: *mut Opaque, input: *const u8, size: usize);\n}```",
        "created_at": "2025-06-30T15:52:54.119000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@amvlasov**\n\u003e technically you can do that via\nextern \"C\" {\n    #[repr(C, align(..))]\n    struct Opaque {\n       _size: [u8; SIZE],\n       _marker: // consider PhantomPinned,\n    }\n\n    fn update(stateful_object: *mut Opaque, input: *const u8, size: usize);\n}\nI think this adds a bit of complexity to the API, so I'm trying to see why this is being done.\n\nDo you plan to support guest programs in other languages such as go/c# etc?",
        "created_at": "2025-06-30T16:03:44.729000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e If you are mainly talking about standarding interfaces for Reth/Revm, then why `extern \"C\"` at the first place? If you assume single e.g. Rust implementation for every language and C-header, then it's more about question if other languages codebases use or not use `update` approach on hashes",
        "created_at": "2025-06-30T16:07:38.279000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@amvlasov**\n\u003e If you are mainly talking about standarding interfaces for Reth/Revm, then why extern \"C\" at the first place? If you assume single e.g. Rust implementation for every language and C-header, then it's more about question if other languages codebases use or not use update approach on hashes\nItâ€™s for reth/revm now, but itâ€™s also forward looking for other languages that will have their own implementation of the execution layer state transition function",
        "created_at": "2025-06-30T16:13:27.571000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e So we canâ€™t assume that there will be one rust implementation that other languages will call into via ffi",
        "created_at": "2025-06-30T16:14:02.386000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjbruestle\u003e Re 128 bits: The overall security is the *lower* of two things:  1) Query phase soundness: this is where the conjecture matters, and where grinding can help you, and generally, just adding more queries (which is usually trivial) is sufficient, if somewhat expensive for recursion 2) Everything else, which usually uses some variant of the Schwartz-Zippel lemma to show that something is *highly improbable*.  Here the security is basically: Size of cryptographic field in bits  - log2(degree of polynomial).  As an example, for our proof system, we use the rank 4 extension of baby bear, so the field size is in bits is 123.6, and let's say we are doing a 1Mi row commitment, so degree of the polynomial is 1Mi, log2(1Mi) = 20, so we end up with 123.6 - 20 = 103.6 bits of security.  This aspect of security has nothing to do with any of the conjectures, and also can't be improved by grinding or any other tricks in most cases.  The only way to really improve it is to make the field used bigger.  We could move to the quintic (rank 5) extension, and while in theory this the 'trivial' (just a change to extension size), in practice we have lots of things like hand coded CUDA assembly to do BB^4 arithmetic that would need to be modified, so in practice it's probably non-trivial, although by no means terribly hard.  Impact on perf might be significant: rank 4 fields have nicer algebraic  structure for multiplication / inverse / etc than rank 5 fields, 4 is a po2 so alignment rules are much nicer in memory, etc, etc.  In general, I think other projects are in a fairly similar boat in terms of having some non-trivial attachment to their specific field choices.",
        "created_at": "2025-06-30T17:11:44.190000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjpwang\u003e I think you can also address commit phase security and other applications of schwartz-zippel via grinding?",
        "created_at": "2025-06-30T17:16:28.040000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cpgaf775\u003e re: **@jpwang**\n\u003e I think you can also address commit phase security and other applications of schwartz-zippel via grinding?\ngrinding reduces the number of queries required; i haven't seen an approach to grinding that targets the error term jeremy is describing above.",
        "created_at": "2025-06-30T17:43:34.955000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cpgaf775\u003e [might be possible, but it's not what is typically meant by \"grinding\" in the STARKish literature]",
        "created_at": "2025-06-30T17:44:11.184000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjpwang\u003e yes, our understanding is that if you grind right before the fiat-shamir challenge at any place using the random oracle model in the interactive protocol, the grinding makes specific attacks on the randomness harder to find",
        "created_at": "2025-06-30T17:49:15.988000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e re: **@kevaundray**\n\u003e Also on the standardization of precompiles; this proposal by @jpwang https://hackmd.io/@axiom/H1zAF9wQle was better than what I had originally proposed.\n\nThis requires changes mostly on the EL side and not its dependencies -- @gakonst we spoke already, but can you give a general ACK for these changes here?\nACK from our end, as you describe we are already familiar with and comfortable with the method from Arbitrum's original suggestion",
        "created_at": "2025-06-30T17:50:53.524000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e Again this series of projects is a key priority for the success of Ethereum and is top of my list. Please bump things to me @mattsse or @rkrasiuk and we will see they get done promptly to assist you all to the best of our ability on our libs, PRs, refactors, PoCs or otherwise.",
        "created_at": "2025-06-30T17:52:27.565000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cpgaf775\u003e re: **@jpwang**\n\u003e yes, our understanding is that if you grind right before the fiat-shamir challenge at any place using the random oracle model in the interactive protocol, the grinding makes specific attacks on the randomness harder to find\nya ok i guess this feels very natural now that you say it; haven't thought through the details but ya i guess i had overlooked the fact that grinding is more general than the usage in ethSTARK ðŸ™‚",
        "created_at": "2025-06-30T17:54:26.201000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@kevaundray**\n\u003e Itâ€™s for reth/revm now, but itâ€™s also forward looking for other languages that will have their own implementation of the execution layer state transition function\n@amvlasov To keep things moving, going to go with stateless functions and we can revisit if folks think we need a stateful API.\n\nI was looking into some of your system functions like bn254 ecadd and they seemed to be stateless apart from the resouce parameter for charging the equivalent of gas. Am I missing something here re how this would be used for an Ethereum L1 guest program?",
        "created_at": "2025-06-30T19:26:07.922000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e reference: https://github.com/matter-labs/zksync-os/blob/756ed34a1d91e62b69204b1ab9d59b7682015018/basic_system/src/system_functions/bn254_ecadd.rs#L11",
        "created_at": "2025-06-30T19:26:19.812000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e In the first message about ABIs I mentioned that pairing/ecrecover are fine to be pure ones and they are well encapsulated. Only hashes were questionable",
        "created_at": "2025-06-30T21:31:21.734000+00:00",
        "attachments": null
    }
]