[
    {
        "author": "jsign",
        "category": "Execution Layer",
        "parent": "",
        "content": "hey, we published part 2 of the repricing blog post series: https://zkevm.ethereum.foundation/blog/repricings-for-block-proving-part-2",
        "created_at": "2026-01-19T14:32:44.729000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e \u003c@427491045308235776\u003e , in hackmd you asked for an example of production code that is not UB and that leads to unaligned accesses. Here is a \"kind of\" instance of that:\n\nThe Linux kernel uses unaligned accesses deliberately for speed, especially in data-processing paths. It provides safe accessors which emit code leading to unaligned accesses (get_unaligned, put_unaligned) and conditionally enables fast paths when the CPU supports it efficiently (CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS). Examples (among many in the kernel):\n- https://github.com/torvalds/linux/blob/24d479d26b25bce5faea3ddd9fa8f3a6c3129ea7/include/crypto/utils.h#L18\n- https://github.com/torvalds/linux/blob/24d479d26b25bce5faea3ddd9fa8f3a6c3129ea7/lib/lzo/lzo1x_compress.c#L66\n\nThat code leverages the fact that some architectures (x86_64, aarch64, some RV64 platforms) support unaligned accesses. The provided links show C code that leads to unaligned accesses (despite the fact that language spec calls it UB).",
        "created_at": "2026-01-19T14:42:37.035000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e BTW Here is an unsolved Rust bug for RISCV64 that leads to unaligned accesses: https://github.com/rust-lang/rust/issues/145769",
        "created_at": "2026-01-19T14:43:27.406000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjustindrake\u003e re: **@marcinbugaj**\n\u003e BTW Here is an unsolved Rust bug for RISCV64 that leads to unaligned accesses: https://github.com/rust-lang/rust/issues/145769\nWhen do you think we'll have a flavour of RISC-V as a Rust tier 1?",
        "created_at": "2026-01-19T14:47:55.355000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e On the performance implications of not supporting unaligned accesses.\n\nhttps://rust.godbolt.org/z/6W7GcGvbd/ shows u64 deserialization from unaligned buffer (common in deserialization frameworks). A simple function that deserializes a u64 from a byte slice of unknown alignment explodes into many instructions (loads, shifts, ORs) when targeting a strict architecture. In contrast, on aarch64 https://rust.godbolt.org/z/8r4fxGTPr (which handles unaligned accesses), it often compiles to just one or two efficient load instructions. This directly impacts parsing performance and will impact EVM emulation.\n\nInteresting publication on unaligned accesses and performance: \"Misaligned memory loads penalties in RISC-V Microcontrollers\": https://reddi.unlam.edu.ar/index.php/ReDDi/article/download/177/332?inline=1 . That raises an important question what would be the cost of supporting unaligned accesses in zkVMs.",
        "created_at": "2026-01-19T14:48:31.345000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e re: **@justindrake**\n\u003e When do you think we'll have a flavour of RISC-V as a Rust tier 1?\nI think it's hard to tell unless the EF can devote some resources to work on Rust compiler for the desired platform.",
        "created_at": "2026-01-19T15:08:13.305000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003calexanderlhicks\u003e Yeah I wouldn't count on this in the short term, let alone having the target we are standardizing on (however that evolves) be the one that is made tier 1. I do think we can at least get a target we actually use to be tier 2 though. Beyond that is also depends on risc-v adoption more broadly (which is progressing...).",
        "created_at": "2026-01-19T16:43:34.247000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjustindrake\u003e re: **@marcinbugaj**\n\u003e I think it's hard to tell unless the EF can devote some resources to work on Rust compiler for the desired platform.\nCan you quantify this (e.g. in dollars or man hours)?",
        "created_at": "2026-01-19T17:11:27.533000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "Just to clarify, my main point is that we should be intentional as of why we want this, not that we shouldn't do it",
        "created_at": "2026-01-19T17:15:46.392000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "I don't think the linux code is a counter-example because from what I can see, the get_unaligned method may or may not emit unaligned loads, see:\n\n```\n#define __get_unaligned_t(type, ptr) ({                         \\\n    const struct { type x; } __packed * __pptr = (typeof(__pptr))(ptr); \\\n    __pptr-\u003ex;                                                  \\\n})\n```",
        "created_at": "2026-01-19T17:16:55.076000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "I think this falls into the same bucket as `memcpy` where the alignment is set to 1 and its on the compiler to decide whether it does it via byte-by-byte or via an unaligned load",
        "created_at": "2026-01-19T17:18:29.223000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "+1 on performance, \u003c@381789485777682434\u003e for reference here; is there a significant/any performance degradation for air bender if the circuit only does aligned loads?\n\nFor the emitted code you linked, the compiler may or may not emit an unaligned load, even if the hardware says it is supported",
        "created_at": "2026-01-19T17:22:39.954000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "The document for reference is https://hackmd.io/@kevaundray/SkUPg3LBWe\n\nI'm still unsure about the golang section.\n\nWas waiting for golang devs to explicitly modify the specs re unaligned loads, since it is ambiguous and confusing imo. PR for that is here: https://github.com/golang/go/pull/77215",
        "created_at": "2026-01-19T17:31:06.755000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e re: **@L1zkevm_bot**\n\u003e \u003ckevaundray\u003e I don't think the linux code is a counter-example because from what I can see, the get_unaligned method may or may not emit unaligned loads, see:\n\n```\n#define __get_unaligned_t(type, ptr) ({                         \\\n    const struct { type x; } __packed * __pptr = (typeof(__pptr))(ptr); \\\n    __pptr-\u003ex;                                                  \\\n})\n```\nIt was done with direct casting in older kernels. Here's an example: https://github.com/spotify/linux/blob/master/include/linux/unaligned/access_ok.h . Now indeed, they got rid of hardware specific stuff for unaligned accesses. Still, `get_unaligned()` function gets compiled in a way that \"big\" loads are emitted for unaligned addresses.",
        "created_at": "2026-01-19T18:22:49.413000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "For emitting big unaligned loads — this is only if the compiler wants to no? \n\nie the code above does not force the compiler to emit unaligned loads similar to memcpy",
        "created_at": "2026-01-19T18:28:23.431000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e re: **@L1zkevm_bot**\n\u003e \u003ckevaundray\u003e For emitting big unaligned loads — this is only if the compiler wants to no? \n\nie the code above does not force the compiler to emit unaligned loads similar to memcpy\nThe code above forces compiler to emit unaligned loads. Casting in C and C++ enables that although it’s technically UB. That approach was used in the past in the Linux kernel",
        "created_at": "2026-01-19T18:46:24.221000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "To clarify, get_unaligned would force an unaligned load? Seems like it’s using __packed which says there is an alignment of 1?",
        "created_at": "2026-01-19T18:54:05.316000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e The one with packed leaves the decision to the compiler. I was talking about the approach in older kernels which indeed forces unaligned accesses",
        "created_at": "2026-01-19T18:57:45.758000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "Ah right, I think if it's using UB to force the unaligned access, I would consider that a user bug irrespective of zk.\n\n-----------\n\nThe main overarching point that I'm validating is that ultimately, it is the compiler that decides whether an unaligned access is emitted in non-UB code. If code uses UB, then I think this would be a bug.\n\nFor bare metal RISC-V, we can check but I think the compiler would not emit an unaligned load (in non-UB code) since that _could_ crash the device if unaligned access is not supported and there is no OS like linux to catch the trap and fix it up in software.\n\nSo then imo the justification for adding unaligned access would be to guard against compiler bugs (that you noted have happened before) that hurt performance but do not affect correctness because everything else is a bug.\n\nThis is assuming it is UB in Golang (still waiting for them to review the spec PR)",
        "created_at": "2026-01-19T19:00:21.455000+00:00",
        "attachments": null
    }
]