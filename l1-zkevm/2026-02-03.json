[
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "<@1408119112743256134> on the IO PR, just thinking about Tamir's comment, a streaming like API would look closer to this I think:\n\n⁨```C\nssize_t read_input_stream(uint8_t* output, size_t count);\n```⁩",
    "created_at": "2026-02-03T13:34:26.280000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "Thinking possible usage would be something like:\n\n⁨```C\nuint8_t chunk[4096];\nssize_t n;\nwhile ((n = read_input(chunk, sizeof(chunk))) > 0) {\n    process(chunk);\n}\n```⁩",
    "created_at": "2026-02-03T13:38:02.165000+00:00",
    "attachments": []
  },
  {
    "author": "marcinbugaj_94168",
    "category": "Execution Layer",
    "parent": "",
    "content": "Yes. That's equivalent to libc API that was contested by Zisk. That API requires a copy from a (potentially) internal buffer to a buffer controlled by a client. I like libc API, I won't hide the fact that I like this idea",
    "created_at": "2026-02-03T13:38:10.324000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Execution Layer",
    "parent": "",
    "content": "Right because of the extra copying needed, if your input is already in memory",
    "created_at": "2026-02-03T13:39:26.056000+00:00",
    "attachments": []
  }
]