[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e However, even with proper feature flags set, developers can still write code that triggers unaligned accesses in all these languages, and the compiler can't do anything about it. For example:\n\n- Casting a char* or uint8_t* to a uint32_t* and dereferencing it (C/C++)\n- Using Unsafe.Read\u003cT\u003e() or pointer arithmetic in unsafe contexts (C#)\n- Using unsafe.Pointer conversions and dereferencing (Go)\n\nThese are perfectly valid operations in the language - the compiler has no way to know at compile time whether the resulting pointer will be aligned or not, as it depends on runtime values. Feature flags control whether the compiler _itself_ generates unaligned accesses for normal operations, but they can't prevent developers from writing code that causes them.",
        "created_at": "2026-01-16T09:43:51.033000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "Those unaligned accesses would be UB no?",
        "created_at": "2026-01-16T11:20:43.386000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@marcinbugaj**\n\u003e However, even with proper feature flags set, developers can still write code that triggers unaligned accesses in all these languages, and the compiler can't do anything about it. For example:\n\n- Casting a char* or uint8_t* to a uint32_t* and dereferencing it (C/C++)\n- Using Unsafe.Read\u003cT\u003e() or pointer arithmetic in unsafe contexts (C#)\n- Using unsafe.Pointer conversions and dereferencing (Go)\n\nThese are perfectly valid operations in the language - the compiler has no way to know at compile time whether the resulting pointer will be aligned or not, as it depends on runtime values. Feature flags control whether the compiler itself generates unaligned accesses for normal operations, but they can't prevent developers from writing code that causes them.\nWhich also applies if smart contracts are written in native Risc-V (i.e. we could maybe constrain the EVMs; but would need heavy testing, but if contracts are opened to native RISC-V in future then its a much larger eco-system and languages to try and constrain, audit etc)",
        "created_at": "2026-01-16T11:21:17.530000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "ie if you want to do unaligned accesses that’s not UB, you’d need to use safe APIs, like Unsafe.ReadUnaligned in C#",
        "created_at": "2026-01-16T11:22:11.392000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@L1zkevm_bot**\n\u003e \u003ckevaundray\u003e [reply]: Those unaligned accesses would be UB no?\nOnly undefined if cpu is undefined; so x64 and modern arm is defined and correct (as both support unaligned reads)",
        "created_at": "2026-01-16T11:22:54.509000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "I think UB is orthogonal to what the hardware can do, ie if it’s undefined then the compiler can apply optimizations that assume pointers are aligned which may break with misaligned pointers",
        "created_at": "2026-01-16T11:24:41.385000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "For x86-64, if Unsafe.ReadUnaligned is used or std::ptr::read_unaligned in rust, then the compiler will emit unaligned loads on x86 because it knows that the cpu supports i",
        "created_at": "2026-01-16T11:26:14.999000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@L1zkevm_bot**\n\u003e \u003ckevaundray\u003e I think UB is orthogonal to what the hardware can do, ie if it’s undefined then the compiler can apply optimizations that assume pointers are aligned which may break with misaligned pointers\nOk, but if say native riscv contracts are supported in future; do you want to also check and specify the language and compilers that can be used and are assured to \"do the right thing\"?",
        "created_at": "2026-01-16T11:26:17.962000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "I think all/most languages have the same approach for unaligned pointers, ie that you need to go through some sort of safe API for it to not be UB.\n\nOne thing to maybe note is that Zicclsm doesn’t force the compiler to emit unaligned loads, it’s mainly a hint to the compiler that the compiler can choose to ignore (though generally for x86 from godbolt, it always emits them)",
        "created_at": "2026-01-16T11:33:23.383000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "Generally I would probably not make decisions on the “replacing the evm” idea based on this since it’s so far out relatively speaking",
        "created_at": "2026-01-16T11:33:54.822000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e There is a huge difference between risc-v native smart contracts and their security model (and many other aspects). And in short - they have very little sense. For EVM being an isolation layer it just must not have UB inside of itself",
        "created_at": "2026-01-16T11:40:59.917000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@amvlasov**\n\u003e There is a huge difference between risc-v native smart contracts and their security model (and many other aspects). And in short - they have very little sense. For EVM being an isolation layer it just must not have UB inside of itself\nAm mostly highlighting are the zkVM only for the scope of Evm implementations (which can be constrained) or are they also for wider execution?",
        "created_at": "2026-01-16T11:43:16.960000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e Provers have assumptions about code and execution models. Running external dynamic untrusted bytecode just requires different prover implementation with different tradeoffs, and there is no such practical need at the moment. In any case native bytecode being the distribution format is not a good idea",
        "created_at": "2026-01-16T11:51:34.185000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@marcinbugaj**\n\u003e However, even with proper feature flags set, developers can still write code that triggers unaligned accesses in all these languages, and the compiler can't do anything about it. For example:\n\n- Casting a char* or uint8_t* to a uint32_t* and dereferencing it (C/C++)\n- Using Unsafe.Read\u003cT\u003e() or pointer arithmetic in unsafe contexts (C#)\n- Using unsafe.Pointer conversions and dereferencing (Go)\n\nThese are perfectly valid operations in the language - the compiler has no way to know at compile time whether the resulting pointer will be aligned or not, as it depends on runtime values. Feature flags control whether the compiler itself generates unaligned accesses for normal operations, but they can't prevent developers from writing code that causes them.\nThis is invalid C/C++ (although the syntax is valid). You will not fix unsafe language by making some pieces of the underlying architecture \"less undefined\".\n\nSimilarly, dereferencing invalid pointer is UB. riscv cannot fix this. If we wanted we had to choose \"safe\" architecture (e.g. wasm).",
        "created_at": "2026-01-16T11:54:30.442000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Ok, regardless of what is decided. I think its important to define outcome\n\nEither fault or read correctly; undefined or fill junk would be problematic (silent fail)",
        "created_at": "2026-01-16T11:54:36.280000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@ben_a_adams**\n\u003e Only undefined if cpu is undefined; so x64 and modern arm is defined and correct (as both support unaligned reads)\nThis is not how UB works on the language level. If something is UB on the language level it is strong signal to the compiler that some conditions cannot happen and it may modify the semantic of the program accordingly. Making it not UB in the architecture fixes nothing.",
        "created_at": "2026-01-16T11:56:40.488000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@chfast**\n\u003e This is not how UB works on the language level. If something is UB on the language level it is strong signal to the compiler that some conditions cannot happen and it may modify the semantic of the program accordingly. Making it not UB in the architecture fixes nothing.\nthen is defined behaviour :P",
        "created_at": "2026-01-16T11:58:29.588000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@ben_a_adams**\n\u003e then is defined behaviour :P\nDon't waste my time on jokes.",
        "created_at": "2026-01-16T12:00:18.806000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e Kev had a good phrasing that it's compiler's work to decide what instructions to emit. Dereferencing an unaligned pointer (and in some languages - even creating it) is UB already - so compiler can always assume that pointers are aligned and blindly emit instructions that require alignment. There are other code sequences where compiler will benefit from unaligned loads by themselves, without any pointers involved. E.g. one compiler can decide to copy (u32, u32) tuple (size 8, alignment 4) using single 64-bit load/store on x64/arm64, but will do two 32-bit load/stores on risc-v/mips/other",
        "created_at": "2026-01-16T12:01:00.146000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e But still, (u32, u32) copy is fully defined, and compiler may or may not benefit from hardware capabilities. Some compilers allow easier control of such behavior (LLVM based ones for risc-v usually have a flag), and other just do not",
        "created_at": "2026-01-16T12:02:29.454000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e On the practical side: it is easy to detect unaligned access in zkVM during execution?. They are interpreters in the end?",
        "created_at": "2026-01-16T12:04:15.261000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e So the only problem is code that is already(!) UB, but will by coincidence work on x86/arm/some QEMU with rich OS",
        "created_at": "2026-01-16T12:04:21.136000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e In our prover we prove that all accesses are aligned for corresponding instructions, so hitting e.g. unaligned u32 load is unprovable program, but it mainly indicated that program is invalid by itself, so relying on it is not a thing anyone wants",
        "created_at": "2026-01-16T12:05:32.096000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmratsim\u003e re: **@chfast**\n\u003e On the practical side: it is easy to detect unaligned access in zkVM during execution?. They are interpreters in the end?\nFor speed we'll likely want JIT",
        "created_at": "2026-01-16T12:05:33.094000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmratsim\u003e but during jitting it's just an `and` mask to check for alignment before emitting the instruction",
        "created_at": "2026-01-16T12:06:12.474000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@mratsim**\n\u003e For speed we'll likely want JIT\nDon't you need \"the trace\" anyway?",
        "created_at": "2026-01-16T12:07:06.214000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@amvlasov**\n\u003e In our prover we prove that all accesses are aligned for corresponding instructions, so hitting e.g. unaligned u32 load is unprovable program, but it mainly indicated that program is invalid by itself, so relying on it is not a thing anyone wants\nPUSH32 for example could degrade to 32 single byte reads as no alignment can be guaranteed? (i.e. not even int alignment as is from a random byte offset in the code data)",
        "created_at": "2026-01-16T12:10:19.132000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@ben_a_adams**\n\u003e PUSH32 for example could degrade to 32 single byte reads as no alignment can be guaranteed? (i.e. not even int alignment as is from a random byte offset in the code data)\nPotentially/likely. But riscv is for simplicity, not performance (now I'm joking, sorry).",
        "created_at": "2026-01-16T12:14:26.453000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Ok :)\n\nThough tbf bad example; would likely read to alignment then do aligned reads, but other PUSH opcodes more problematic",
        "created_at": "2026-01-16T12:14:50.182000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@amvlasov**\n\u003e In our prover we prove that all accesses are aligned for corresponding instructions, so hitting e.g. unaligned u32 load is unprovable program, but it mainly indicated that program is invalid by itself, so relying on it is not a thing anyone wants\nMy main concern would be seeming right at \"deployment\" and then failing at some point in future when live\n\nIf it would fail at deployment as unprovable that's all good vs a block being unprovable as it takes a new code path\n\nand maybe that's on the Evms to audit their code base; and their dependencies for any unaligned accesses (though that seems more human failable)",
        "created_at": "2026-01-16T12:25:20.053000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e PushX is memcopy + endianess swap (memcopy doesn’t require by bytes)",
        "created_at": "2026-01-16T12:29:05.065000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@amvlasov**\n\u003e PushX is memcopy + endianess swap (memcopy doesn’t require by bytes)\njust memcopy might be an assumption https://github.com/bluealloy/revm/blob/ecd3fc5a594eae6b0ace46ed4861f310c697361a/crates/interpreter/src/interpreter/stack.rs#L324-L390",
        "created_at": "2026-01-16T12:43:36.556000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcinbugaj\u003e Which brings me to the initial point: why don't we accept unaligned accesses if they're cheap to implement (definitely cheaper than some precompiles/accelerators) and can save us a lot of headache?",
        "created_at": "2026-01-16T13:28:21.905000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "@ben @marcin \n\nFailing at deployment was also my main concern, though I'm no longer completely convinced because there would be two ways to try and emit an unaligned load:\n\n1) Via UB ie `std::ptr::read` or `Unsafe.Read` in c#\n2) Via safe APIs like `std:ptr::read_unaligned` or `Unsafe.ReadUnaligned`\n\nFor (1), this would be UB so it's a bug in the code irrespective of whether the target is zkVMs or x86. It may just be luck that it works for that particular program version and that particular compiler or compiler version, but its not guaranteed that it should produce correct machine code.\n\nGiven that's the case, I'd lean towards this being something that ideally is caught by audits, UBSan or whatever tools are available.\n\nFor (2), this is valid user code and the compiler would decide whether it emits unaligned loads or not; so just because code has `std::ptr::read_unaligned` would not imply that the machine code being emitted would have unaligned loads. For x86, it seems to always be the case since the compiler knows that x86 supports (fast?) unaligned loads. For RISC-V, I don't think the compiler would ever opt to emit them unless there was a guarantee that it would be supported right?",
        "created_at": "2026-01-16T14:28:01.919000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "Just trying to understand and document the rationale for why we would want it, ie what case(or possibly lack thereof) we are protecting against",
        "created_at": "2026-01-16T14:30:12.199000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution Layer",
        "parent": "",
        "content": "On RISC-V in the EVM, offchain labs also published an article a while back where they nicely distinguish between the ISA being used for zkEVM proofs(pISA) and the ISA being used for the EVM (dISA) -- and the fact that they don't necessarily need to be the same.\n\nReference: https://ethresear.ch/t/why-risc-v-is-not-a-good-choice-for-an-l1-delivery-isa-and-why-wasm-is-a-better-one/23491",
        "created_at": "2026-01-16T14:33:05.542000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camvlasov\u003e re: **@ben_a_adams**\n\u003e just memcopy might be an assumption https://github.com/bluealloy/revm/blob/ecd3fc5a594eae6b0ace46ed4861f310c697361a/crates/interpreter/src/interpreter/stack.rs#L324-L390\nU64::from_be_bytes in memory, the rest is safe by itself",
        "created_at": "2026-01-16T15:42:01.479000+00:00",
        "attachments": null
    }
]