[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e @somnergy (https://t.me/somnergy) , does the STF implementation in C++ use the STL? I'm curious if that implementation must link to libstc++ and libc effectively",
        "created_at": "2025-12-08T15:56:04.266000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@Marcin**\n\u003e @somnergy , does the STF implementation in C++ use the STL? I'm curious if that implementation must link to libstc++ and libc effectively\nYeah, but there are caveats",
        "created_at": "2025-12-08T15:56:55.089000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e re: **@somnergy**\n\u003e Yeah, but there are caveats\ncould you please elaborate on that?",
        "created_at": "2025-12-08T16:03:33.511000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e more context: I'm wondering if https://github.com/eth-act/zkvm-standards should cover the subject of libc support. More specifically whether some minimal libc implementation should be supported by zkVMs and their toolchains",
        "created_at": "2025-12-08T16:05:02.162000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e On what, caveats? Careful with things that try to use OS calls. Provide an sbrk implementation, if necessary. Hook into the target host's memory allocator if available",
        "created_at": "2025-12-08T16:05:21.976000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@Marcin**\n\u003e more context: I'm wondering if https://github.com/eth-act/zkvm-standards should cover the subject of libc support. More specifically whether some minimal libc implementation should be supported by zkVMs and their toolchains\nWell, from my perspective it doesn't matter. More features = more bugs and security holes. It may be up to the prover SDK to provide if they want to. But it's a minor thing that one can adjust to - writing for thr baremetal",
        "created_at": "2025-12-08T16:07:45.038000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e \u003e But it's a minor thing that one can adjust to - writing for thr baremetal\n\nI think that the goal is that the code is portable without the need for any glue code",
        "created_at": "2025-12-08T16:08:59.405000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@Marcin**\n\u003e \u003e But it's a minor thing that one can adjust to - writing for thr baremetal\n\nI think that the goal is that the code is portable without the need for any glue code\nDo you consider libc to be a glue code?",
        "created_at": "2025-12-08T16:10:21.337000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e re: **@chfast**\n\u003e Do you consider libc to be a glue code?\nNot really. What I meant is if there is a STF implementation in C++ that uses STL then zkVM's vendor toolchain should provide a pretty standard implementation of libstdc++ and libc. Put it differently: there should be need for zkVM _specific code_",
        "created_at": "2025-12-08T16:12:44.005000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@Marcin**\n\u003e \u003e But it's a minor thing that one can adjust to - writing for thr baremetal\n\nI think that the goal is that the code is portable without the need for any glue code\nWriting targetted code is fairly common. And incompatibilities are due to various reasons. I think the prover SDK is upstream and I am trying to target that with my implementation of the Ethereum protocol? Is it easy? No!",
        "created_at": "2025-12-08T16:12:49.010000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@Marcin**\n\u003e Not really. What I meant is if there is a STF implementation in C++ that uses STL then zkVM's vendor toolchain should provide a pretty standard implementation of libstdc++ and libc. Put it differently: there should be need for zkVM specific code\nThere would always be target specific code when it's to be running at optimum speed, i think.",
        "created_at": "2025-12-08T16:16:17.177000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e But if libc is provided, it maybe makes my life 0.5% easier, but I would also want to go back in time and have the Prover SDK's document better, and not just stick to rust/reth/revm - not my call though",
        "created_at": "2025-12-08T16:16:34.764000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e (Sorry for the massacre of English language there)",
        "created_at": "2025-12-08T16:18:46.565000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e \u003e There would always be target specific code when it's to be running at optimum speed\n\nhttps://github.com/eth-act/zkvm-standards/tree/main/standards/c-interface-accelerators\n\nHere is a future standard for accelerator / precompiles to make things happen at optimal speed. zkVMs would implement these C function and clients would use them",
        "created_at": "2025-12-08T16:18:49.835000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@Marcin**\n\u003e Not really. What I meant is if there is a STF implementation in C++ that uses STL then zkVM's vendor toolchain should provide a pretty standard implementation of libstdc++ and libc. Put it differently: there should be need for zkVM specific code\nThey are already doing so by using the riscv toolchain for C/C++.\n\nThe versions and implementations of C++ and C standard libraries don't matter because you can always link them statically. What matters is if a zkVM diverges from the riscv embedded/baremetal standards.\n\nE.g. syscall for write on riscv is 64, but in some zkVMs it is 1. So the standard output doesn't work if you pick off-the-shelf libc implementation.",
        "created_at": "2025-12-08T16:18:55.796000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e \u003c@425274498732916736\u003e , the target would be `riscv64im-unknown-none-elf` according to https://github.com/eth-act/zkvm-standards/blob/main/standards/riscv-target/target.md. Syscalls won't be use to perform side effects I think",
        "created_at": "2025-12-08T16:21:36.711000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@Marcin**\n\u003e \u003e There would always be target specific code when it's to be running at optimum speed\n\nhttps://github.com/eth-act/zkvm-standards/tree/main/standards/c-interface-accelerators\n\nHere is a future standard for accelerator / precompiles to make things happen at optimal speed. zkVMs would implement these C function and clients would use them\nIt's not a necessity, but a good to have. Good haves go a long way tho.\nI also don't use the \"provided\" toolchain, for example - as it's outdated. I would want to reserve my choice of writing my own memory allocator for each of the provers I am interacting with - for every last drip of performance",
        "created_at": "2025-12-08T16:22:04.884000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@Marcin**\n\u003e \u003c@425274498732916736\u003e , the target would be riscv64im-unknown-none-elf according to https://github.com/eth-act/zkvm-standards/blob/main/standards/riscv-target/target.md. Syscalls won't be use to perform side effects I think\nI guess you have to convince zkVMs first...",
        "created_at": "2025-12-08T16:23:32.501000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e \u003e I would want to reserve my choice of writing my own memory allocator for each of the provers I am interacting with - for every last drip of performance\n\nThen you have to be aware of the memory layout for each zkVM you target. Is my understanding accurate?",
        "created_at": "2025-12-08T16:25:58.893000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@Marcin**\n\u003e \u003e I would want to reserve my choice of writing my own memory allocator for each of the provers I am interacting with - for every last drip of performance\n\nThen you have to be aware of the memory layout for each zkVM you target. Is my understanding accurate?\nYeah",
        "created_at": "2025-12-08T16:26:24.931000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e Well, then I'd say that one of the advantages of libc is that it abstracts over it. If you want to access heap you just use malloc that in combination with the vendor provided linker scripts abstracts over memory.",
        "created_at": "2025-12-08T16:27:23.049000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e That's why I'd stipulate that every toolchain should provide linker script and libc implementation that provides working malloc (even if that's vanilla gcc/clang) and put that into https://github.com/eth-act/zkvm-standards",
        "created_at": "2025-12-08T16:29:22.493000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e what's your take on that idea?",
        "created_at": "2025-12-08T16:29:41.284000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@Marcin**\n\u003e \u003e There would always be target specific code when it's to be running at optimum speed\n\nhttps://github.com/eth-act/zkvm-standards/tree/main/standards/c-interface-accelerators\n\nHere is a future standard for accelerator / precompiles to make things happen at optimal speed. zkVMs would implement these C function and clients would use them\nI've reviewed this previously and I don't think this design is good. It moves the burden of EVM precompiles from the EVM implementation to zkVM implementation. EVM implementations have a decade of experience dealing for badly specified precompiles. zkVM don't. From what I've seen so far, the current zkVM high-level accelerators are full of bugs and they usually work only in optimistic cases.",
        "created_at": "2025-12-08T16:31:07.172000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e So, the message is, yes zkvm's should provide something + a ton of documentation. A minimal libc can be put into standards. But if it's not good, we'll not care about it much. So a standard compliant implementation is something that nobody uses - what's the point then?\nSo, standards should be minimal. And libc API is higher level, so it should be optional. I would have the teams focus on stability and speed (which they already are)",
        "created_at": "2025-12-08T16:38:38.177000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e I think that precompile implementation must be on the side of zkVM because that's the only way to efficiently prove them. Otherwise precompiles would have to be emulated in \"software\".\n\n\u003e From what I've seen so far, the current zkVM high-level accelerators are full of bugs and they usually work only in optimistic cases.\n\nThat's why the standard is needed so that zkVMs conform to it :)",
        "created_at": "2025-12-08T16:38:52.576000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@Marcin**\n\u003e I think that precompile implementation must be on the side of zkVM because that's the only way to efficiently prove them. Otherwise precompiles would have to be emulated in \"software\".\n\n\u003e From what I've seen so far, the current zkVM high-level accelerators are full of bugs and they usually work only in optimistic cases.\n\nThat's why the standard is needed so that zkVMs conform to it :)\nHypothetically, there may be a way to JIT it, or use each client's implementation natively as the hook. Idk, it could go in many directions.",
        "created_at": "2025-12-08T16:40:49.942000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e AOT is usually faster than JIT that's why I couldn't justify JIT that happens as part of zkVM guest program.",
        "created_at": "2025-12-08T16:42:48.236000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e \u003e  each client's implementation natively as the hook\n\nExactly, the proposed C precompile interface is a kind of a hook",
        "created_at": "2025-12-08T16:43:18.046000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cMarcin\u003e that hook must be provided by a zkVM",
        "created_at": "2025-12-08T16:44:17.381000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@Marcin**\n\u003e \u003e  each client's implementation natively as the hook\n\nExactly, the proposed C precompile interface is a kind of a hook\nIt's an extern interface. And I agree if ZKVM's are providing custom circuits for cryptographic primitives there should be a standard (maybe even more minimal). \n\nAs \u003c@425274498732916736\u003e said, if it's buggy at a higher level, for some reason, then might as well not do it.\nBut let's say the difference when not using the provided hook for Zilkworm is 10%, and with say [xyz]_eth is 200% - that is wholly dependent, and it moves the compulsion to the zkvm team to test and maintain it - a huge and risky ask",
        "created_at": "2025-12-08T16:46:31.508000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e If there is something that goes grossly against the spirit of \"you shouldn't have to use glue code\" or \"write once, run everywhere\" - it's this set of syscalls c-header. If you use a hook that uses an alternative execution path, then you can no longer claim to be the same implementation, in principle. So, yeah, we compile well, we glue it, and we optimize it - that is a balanced way forward. My hunch : the c-header would evolve a lot.\nBut libc is welcome.",
        "created_at": "2025-12-08T16:50:18.521000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@chfast**\n\u003e I've reviewed this previously and I don't think this design is good. It moves the burden of EVM precompiles from the EVM implementation to zkVM implementation. EVM implementations have a decade of experience dealing for badly specified precompiles. zkVM don't. From what I've seen so far, the current zkVM high-level accelerators are full of bugs and they usually work only in optimistic cases.\nDo you have examples of bugs you've found and cases where they've only worked in optimistic cases?\n\nThe accelerators usually have two components:\n\n- The part written in pure Rust/C/C++ code\n- The part that calls the zkVM specific circuit\n\nI'd be interested in also knowing which of these you've found bugs in\n\n-------\n\nNot sure I understand the JIT approach -- how would this work concretely?",
        "created_at": "2025-12-08T19:51:49.793000+00:00",
        "attachments": null
    },
    {
        "author": "developeruche",
        "category": "Execution Layer",
        "parent": "",
        "content": "Optional Proofs Implementation Prysm",
        "created_at": "2025-12-08T20:23:36.404000+00:00",
        "attachments": null
    }
]