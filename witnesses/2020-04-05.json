[
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah, let's go and discuss that in the voice channel\none thing I've noticed is that you have a prefix notation there for nodes\n(like `branch_node child1 ... childN`) and we use suffix one `child1 ... childN branch_node`. That was done to simplify witness parsing with a pre-allocated stack of fixed amount (not taking into account the trie itself). You basically push `child` values to a stack (that can't be more than 16 elements in hex trie), and then replaces them with a single  `branch_node`. \nAs I see, in your implementation, I'll have a stack of variable size (or recursion) that will put more pressure on the garbage collector/other memory management system.",
        "created_at": "2020-04-05T06:53:57.667000+00:00",
        "attachments": []
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One more thing is I'm not sure we need to send number of tries in a forest. If there aren't enough of them, we will most probably know that when we will verify a witness (and we will need that to mitigate some attacks). I think there we can just read until EOF or rely on underlying network protocols to provide us the size.\nThat's a more open question and it will save us just 32 bits per witness, so maybe it isn't crucial",
        "created_at": "2020-04-05T06:57:14.204000+00:00",
        "attachments": []
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!682078300234973185\u003e \u003c@!364458974906548225\u003e \u003c@456226577798135808\u003e  and other interested people. I've created a calendar event so we don't mix up the timezones and DST stuff: https://calendar.google.com/event?action=TEMPLATE\u0026tmeid=Xzhnc2plY3BqOGtwM2liOXA2NTMzaWI5azY0cWo4YjlvNnNzM2NiYTQ2c3M0NmQ5ZzY1MmphY2k1OGcgaUBtYW5kcmlnaW4ucnU\u0026tmsrc=i%40mandrigin.ru",
        "created_at": "2020-04-05T07:00:13.077000+00:00",
        "attachments": []
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Slide 22 of the slides in http://web.cse.ohio-state.edu/~rountev.1/756/pdf/SyntaxAnalysis.pdf provide an explicit stack algorithm for analysing LL(1) grammar. Paul claims that it is a LL(1) grammar. I have not verified it. Proving it should be simple. If it is, then we get the proof of unambiguity for free, as it is well known that LL(1) grammars are unambiguous",
        "created_at": "2020-04-05T07:06:43.778000+00:00",
        "attachments": []
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is it a fixed-size (or capped from the top) stack of a reasonable size? Because that is one thing that allows efficient processing if we talk about allocation.",
        "created_at": "2020-04-05T16:44:58.617000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think that both prefix and postfix formats are ok. I currently favor a prefix format because it simplifies formalization and has some nice properties. But maybe postfix has advantages too.\n\nYes, the prefix format also has a stack-based parsing algorithm, using a table generated from the syntax. I don't know the max stack depth, but for a naive implementation it may be worst-case 128 kb, average case 16kb, and much less if you are clever about how you store merkle hashes. I am open to implementing such a table and stack-based parser. I think that YACC or Bison could generate such a parser for us too.",
        "created_at": "2020-04-05T20:24:43.532000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!520564582196969472\u003e I removed numtrees, which I agree is non-critical, and we can decide later if we want back.",
        "created_at": "2020-04-05T20:26:03.325000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!689635476826619924\u003e For theoretical purposes, it is LL(1). For practical purposes, many syntax rules are parameterized, since if all parameters were expanded, there may be thousands of syntax rules. I hope to show unambiguity by using methods in Aho's textbook chapter 4, which is what your slides are also based on.",
        "created_at": "2020-04-05T20:28:39.844000+00:00",
        "attachments": []
    }
]