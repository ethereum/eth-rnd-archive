[
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!682078300234973185\u003e  Regarding parameterisation of \u003cTree\u003e\nSuppose we have:\n\u003cBlock_Witness\u003e := v : \u003cVersion\u003e t1:\u003cTree\u003e t2:\u003cTree\u003e,\n\u003cTree\u003e := 0xbb c1: \u003cCustom\u003e n1:\u003cTree_Node(0)\u003e\n\u003cTree\u003e := 0xbb c2: \u003cCustom\u003e n2:\u003cTree_Node(0)\u003e\n\u003cTree_Node(0)\u003e := 0x03 h1:\u003cBytes32\u003e // First Tree\n\u003cTree_Node(0)\u003e := 0x03 h2:\u003cBytes32\u003e // Second Tree\nwith the plan to encode two separate trees, then this would give two choices to expand \u003cTree\u003e for t1 and t2, which makes it not correct. Hence I think parameterisation of \u003cTree\u003e is necessary. This would also mean that the production for \u003cTree\u003e should be in the form \u003cTree(d)\u003e := 0xbb c:\u003cCustom\u003e n:\u003cTree_Node(d)\u003e ... note the updated parameter of Tree_Node.\n\nMay be I am wrong. Let me know.",
        "created_at": "2020-04-08T01:20:33.850000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!682078300234973185\u003e On the similar lines, I see that \u003cTree_Node\u003e on the same level of the parse tree has the same parameter number. Should it not be different? In that case we need an encoding scheme for these parameters.",
        "created_at": "2020-04-08T01:34:28.455000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!689635476826619924\u003e I would encode the Block_Witness you describe as `0x01 0xbb 0x00 0x03 h1:\u003cBytes32\u003e 0xbb 0x00 0x03 h2:\u003cBytes32\u003e`, which is two trees with root nodes as hash nodes h1 and h2, respectively. I don't understand how you define non-terminals `\u003cTree\u003e` and `\u003cTree_Node(0)\u003e` multiple times. t1 and t2 are bound to two invocations of the same `\u003cTree\u003e` rule, not separate rules. I agree that it may be confusing because `\u003cTree\u003e^*` notation is another parameterization, so maybe there should be a syntax rule `\u003cBlock_Witness(n)\u003e` for each `n\u003e=0` corresponding to how many times we repeat `\u003cTree\u003e`, and a separate rule to parse `n` and call the specific `\u003cBlock_Witness(n)\u003e`.",
        "created_at": "2020-04-08T02:07:54.144000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But then there would be billions of syntax rules.",
        "created_at": "2020-04-08T02:09:17.865000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!682078300234973185\u003e For the binary example: 0x01 bb 00 03 h1 bb 00 03 h2, from your witness spec, we will have the instructions:\nBW := \u003cVersion\u003e \u003cTree\u003e \u003cTree\u003e\n\u003cVersion\u003e := 0x01\n\u003cTree\u003e := \u003cCustom\u003e \u003cTreeNode(0)\u003e\n\u003cCustom\u003e := 0x00\n\u003cTreeNode(0)\u003e := 0x03 \u003cBytes32\u003e\n\u003cBytes32\u003e := \u003cByte\u003e^32\n\u003cByte\u003e := h1 | h2\nRight? \n\nI believe for a similar but different example: 0x01 bb 00 03 h2 bb 00 03 h1, we will have the same set of instructions. \n\nIt does not look like a problem for this small example where a trie is just a single node. But when tries contain different nodes, it is possible for a node belonging to a second trie, to be put in the first trie, while reconstructing from the witness instructions. \n\nAm I missing anything?",
        "created_at": "2020-04-08T03:05:52.858000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e But then there would be billions of syntax rules.\n\u003c@!682078300234973185\u003e But can be templated with parameters",
        "created_at": "2020-04-08T03:10:28.030000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One solution for determining the parameters is to append the branch-label (nibble value in Hexary trie, and bit value in a binary trie) to the parameter. I think we  need to update only the rule for \u003cBranch_Node(d)\u003e:\n\n\u003cBranch_Node(d)\u003e := …. c[i]\u003cTree_Node(di)\u003e … \n\nWhere di is just plain concatenation of d and i. An example parse tree for binary tries:\nTreeNode(1)\n       |\nBranchNode(1)\n   /                     \\ \nTreeNode(10)   TreeNode(11)\n |\nBranchNode(10)\n  /                        \\\nTreeNode(100)   TreeNode(101)",
        "created_at": "2020-04-08T04:48:34.073000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Looks correct except I'm not sure what `\u003cByte\u003e := h1 | h2` means. I think that `h1` and `h2` are variables bound to whatever is parsed by different invocations of `\u003cBytes\u003e^32`.",
        "created_at": "2020-04-08T04:51:22.709000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There is no syntactic restriction on data (leaves, hashes, etc) is put in each tree. The syntax just restricts the structure.",
        "created_at": "2020-04-08T04:52:15.134000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But finally we would need to bind it to one specific value. I read h1 and h2 to be concrete root hashes of tries",
        "created_at": "2020-04-08T04:52:44.902000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't think that `\u003cTree_Node(d)\u003e` needs any more parameters. It is a recursive definition. \u003cTree_Node(5)\u003e represents all possible tree nodes at nibble-depth 5.",
        "created_at": "2020-04-08T04:54:05.267000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Supporting multiple trees is for breaking a witness into chunks. But that is not specified yet, the syntax will change to accommodate it.",
        "created_at": "2020-04-08T04:56:44.988000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Okay. I didn't realize that. Then why does the rule for BlockWitness contain a list of trees?",
        "created_at": "2020-04-08T04:58:00.760000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Each witness chunk will be a `Tree` in the list. Maybe `Tree` is not a good name for a witness chunk.",
        "created_at": "2020-04-08T05:03:02.919000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't quite get it. You say witness chunks are not supported, but they are in the rule for Block_Witness. For this concrete example, can you describe what your encoding looks like?\nRoot1          Root2\n  /    \\              /       \\\nh1    h2         h3     h4\nIf you think I am wasting this channel's thought space, I am happy for a zoom call. Let me know",
        "created_at": "2020-04-08T05:07:22.886000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The encoding for your concrete example is: `0x01 0xbb 0x00 0x00 bitmask1:0x0003 0x03 h1:\u003cBytes32\u003e 0x03 h2:\u003cBytes32\u003e 0xbb 0x00 0x00 bitmask2:0x0003 0x03 h3:\u003cBytes32\u003e 0x03 h4:\u003cBytes32\u003e` where I chose the bitmasks to say that the last two children are present.",
        "created_at": "2020-04-08T05:16:16.714000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The set of instructions?",
        "created_at": "2020-04-08T05:16:40.388000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Each witness chunk will be a `\u003cTree\u003e`. Also, `\u003cTree\u003e` may correspond to things for syncing and other p2p stuff. Maybe the name `Tree` is not a good one.",
        "created_at": "2020-04-08T05:19:10.334000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I agree. My bad.",
        "created_at": "2020-04-08T05:21:33.500000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not sure what instructions are. I will annotate the encoding the best I can. `version:0x01 tree1:0xbb custom1:0x00 branchnode1:0x00 bitmask1:0x0003 hashnode1:0x03 h1:\u003cBytes32\u003e hashnode2:0x03 h2:\u003cBytes32\u003e tree2:0xbb custom2:0x00 branchnode2:0x00 bitmask2:0x0003 hashnode3:0x03 h3:\u003cBytes32\u003e hashnode4:0x03 h4:\u003cBytes32\u003e`.",
        "created_at": "2020-04-08T05:23:31.017000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sorry, i understood. We convert the tries to instructions and parse it back to tries. I got confused between parse trees and the tries.",
        "created_at": "2020-04-08T05:25:34.963000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Anyways, how exactly would you extend for accomodating witness chunks?",
        "created_at": "2020-04-08T05:26:28.909000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We have not yet defined what \"witness chunk\" means. Maybe each witness chunk will be a subtree, so we would specify a prefix path with each subtree. This subtree prefix path may go in the \u003cCustom\u003e data section, or we may change the syntax.",
        "created_at": "2020-04-08T05:32:15.661000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But \u003c@!520564582196969472\u003e and \u003c@456226577798135808\u003e have no obligation to use my spec, and they are evaluating options now.",
        "created_at": "2020-04-08T05:34:40.956000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Now, I don't get the rationale for parameters in non-terminals at all. What is the problem in using Tree_Node(d) in place of Tree_Node(d+1)? Can you give me an example?",
        "created_at": "2020-04-08T05:35:25.384000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In our vision it has to be a subtree",
        "created_at": "2020-04-08T05:40:05.392000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Because then you get root hash checks for free",
        "created_at": "2020-04-08T05:40:18.124000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If you build the trie from the chunks from top to bottom",
        "created_at": "2020-04-08T05:40:40.004000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The first chunk will be matched against the block root hash",
        "created_at": "2020-04-08T05:41:04.723000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The next sub tries will be attached to hash nodes in this trie",
        "created_at": "2020-04-08T05:41:20.820000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So you know their root hashes",
        "created_at": "2020-04-08T05:41:26.273000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Etc",
        "created_at": "2020-04-08T05:41:28.293000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It’s not that it is impossible to validate in some other way, but we already have this mechanism",
        "created_at": "2020-04-08T05:42:06.550000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Parameter `d` represents nibble-depth. `\u003cBranch_Node(5)\u003e` has children `\u003cTree_Node(6)\u003e`. The reason for parameterizing depth is to limit tree depth in the syntax. For example, we can't have `\u003cTree_Node(100)\u003e`   because this would exceed the maximum nibble-depth.",
        "created_at": "2020-04-08T05:43:02.217000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!520564582196969472\u003e I agree that your way of chunking is a good way to do it.",
        "created_at": "2020-04-08T05:44:08.171000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!520564582196969472\u003e Subtree chunking sounds good",
        "created_at": "2020-04-08T05:44:58.577000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One side effect of that is that then the same witness can be used for semi stateless sync that I did. When you need to just update the existing trie paths often multiples times per block",
        "created_at": "2020-04-08T05:47:11.644000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(semi-stateless is when you are keeping the trie between block executions instead of rebuilding from scratch)",
        "created_at": "2020-04-08T05:47:50.377000+00:00",
        "attachments": null
    },
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!682078300234973185\u003e Proving your grammar is LL(1) is very easy. From the rules, it is clear that the parsing table will have at most 1 rule. Hence it is unambiguous as well.",
        "created_at": "2020-04-08T05:51:53.448000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Thank you \u003c@!689635476826619924\u003e. It was designed to be unambiguous. I still think that it needs a written proof of unambiguity, especially if we add optimizations.",
        "created_at": "2020-04-08T05:58:35.537000+00:00",
        "attachments": null
    }
]