[
    {
        "author": "80raghavendra",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!682078300234973185\u003e Â Comment / Input 1: May a few sentences clarifying the notion of parameterised non-terminals will help? Something along the following lines. \n\nA \u003cNonTerminal(d\u003c64)\u003e means that there exist different non terminals of the form NonTerminal(0), NonTerminal(1), up to NonTerminal(63). However all the productions for these non-terminals take the same form. Hence they are described in a single production with parameterised non-terminals.\n\nAm happy to add if I have the rights.\n\nQ1. Should the non-terminal \u003cTree\u003e also be parameterised? \n\nComment 2: One advantage over \u003c@!520564582196969472\u003e  approach here is that there is no need for a separate set of substitution rules.\n\nQ2. Is a merge with Block Witness specification GitHub repo planned?",
        "created_at": "2020-04-07T05:00:14.947000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!689635476826619924\u003e  thank you for your review!\n\nComment 1 response. Makes sense. Updated the 11th notation bullet point like you suggested.\n\nQ1 response. I thought about it. I think that \u003cTree\u003e should remain as a high-level entry-point to start the witness, no parameterization is needed for this. Parameterization can start within \u003cTree\u003e or later. Of course, this is a subjective decision and I am willing to change it.\n\nComment 2 response. Yes, the prefix notation allows stating semantics rules alongside syntax rules. Syntax-directed translation is nice. Not sure whether \u003c@!520564582196969472\u003e 's postfix notation allows this.\n\nQ2 response. I chatted with \u003c@!520564582196969472\u003e  and \u003c@456226577798135808\u003e  yesterday. We agreed that the formats are almost identical, except mine is in prefix notation and \u003c@!520564582196969472\u003e 's is in postfix notation. We don't know which is better. I didn't make a PR yet because I don't want to put any pressure on \u003c@!520564582196969472\u003e . So mine will remain in a notes doc for another week to give \u003c@!520564582196969472\u003e  and \u003c@456226577798135808\u003e a chance to evaluate prefix notation, and give me a chance to evaluate getting guarantees from postfix notation.",
        "created_at": "2020-04-07T12:57:51.127000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!682078300234973185\u003e I am just reviewing the doc. I think the production `Branch_Node(d\u003c64)` should have `Tree_Node(d+1)` in its children",
        "created_at": "2020-04-07T20:20:51.342000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, typo, good catch.",
        "created_at": "2020-04-07T20:22:47.861000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Now I have seen what you've done. I think you have described formal syntax",
        "created_at": "2020-04-07T20:22:49.625000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but not formal semantics. So your document is complementary to Igor's",
        "created_at": "2020-04-07T20:23:13.754000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "and there needs to be the 3rd document too, of course",
        "created_at": "2020-04-07T20:23:29.424000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hah, yes.",
        "created_at": "2020-04-07T20:23:41.126000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We need to define \"block witness\". Then we can formalize semantics.",
        "created_at": "2020-04-07T20:24:15.427000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "the 3rd document would describe how to construct root hash of the structure. Currently it is in the Yellow Paper, but in a non-compatible notation to ours",
        "created_at": "2020-04-07T20:25:08.516000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but let me think about it a bit more",
        "created_at": "2020-04-07T20:25:17.861000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "perhaps you have already packed most of our semantics in your syntax",
        "created_at": "2020-04-07T20:25:32.774000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Syntax describes the language of admissible binary strings that could be parsed. It is expressed as a grammar currently. What we were trying to do with the our \"semantics\" I guess, is to describe how to transform that binary string into the root hash (or a structure which can be accessed and modified during block execution)",
        "created_at": "2020-04-07T20:28:02.022000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "so proper definition of semantics would also need to specify how, given the structure of the witness, to do things like GetAccountByAddrHash, InsertAccount, DeleteAccount, etc. for the storage items too",
        "created_at": "2020-04-07T20:29:07.722000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "After some thought, what you said is ineresting. Functions like `GetAccountByAddrHash()` can map witnesses to parts of witnesses. And functions `Insert/DeleteAccount()` can rewrite witnesses. And `Merkleize()` can map a witness to 32-bytes. So much of ethereum is defined recursively as operations on byte arrays.\n\nI was thinking that we would instead extend the yellowpaper's definitions in section 4.1 and appendix D to define \"block witness\". And the witness syntax would translate byte arrays to abstract \"block witnesses\" which each client can handle their own way.\n\nNot sure which is better. Maybe we can eventually have both of these definitions and show that they are characterizations of each other.",
        "created_at": "2020-04-07T21:14:22.471000+00:00",
        "attachments": []
    }
]