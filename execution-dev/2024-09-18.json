[
    {
        "author": "pipermerriam",
        "category": "general",
        "parent": "",
        "content": "Are there formalized or requirements anywhere for what constitutes an execution client in the context of ACD?",
        "created_at": "2024-09-18T13:39:34.242000+00:00",
        "attachments": []
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "In short, no. In practice, it's more of a gradual process, where new teams (EL or CL) generally get integrated across more things like test suites, devnets, etc. as they mature. \n\nReth is the most recent example on the EL side. During the Dencun fork it gradually got included across everything and was slightly caveated in the [upgrade announcement](https://blog.ethereum.org/2024/02/27/dencun-mainnet-announcement). On the CL side, Grandine has been added to \"the stack\" as part of this fork, but is slightly different because they had the client \"ready\" already but only recently open-sourced it.",
        "created_at": "2024-09-18T14:13:24.134000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "My (subjective) view was that in order to be considered a mainnet client one should\n- pass all the execution spec tests / ethereum/tests\n- be  able to produce blocks (have a miner)\n- be able to verify mainnet\n- have one or more audits from a reputable auditing company\n- be open source\n- regularly engage in the discussions around hardforks, specs, etc. \nAs always these are not hard requirements in order to not be gamed and some clients have been grandfathered in (like geth which hadn't had an audit since frontier afaik).",
        "created_at": "2024-09-18T14:57:34.925000+00:00",
        "attachments": []
    },
    {
        "author": "suburbandad_",
        "category": "general",
        "parent": "",
        "content": "does 1.14.8 have then non-concurrent version of g1 and g2 msm, or is that in a branch somewhere?",
        "created_at": "2024-09-18T17:58:47.824000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "That's in a branch still (https://github.com/ethereum/go-ethereum/pull/30358) \u003c@524738020033691659\u003e",
        "created_at": "2024-09-18T18:30:34.977000+00:00",
        "attachments": []
    },
    {
        "author": "francis.li",
        "category": "general",
        "parent": "",
        "content": "Hi \u003c@206016661470314496\u003e , nice to meet you. This is Francis from Base team, and I'm curious on your thoughts on deterministic witness generation in your Execution Layer Cross Validation Proposal (https://gist.github.com/karalabe/47c906f0ab4fdc5b8b791b74f084e5f9#witness-gathering)\n\nTo provide a little more context, currently we're working with op and reth team to add a debug_execution_witness API into both op-reth and op-geth to generate execution witness for a certain block. This API would be very beneficial for fault proofs and ZK team to gather necessary states instead of relying on specific APIs like debug_dbGet that only geth provides. \n\nCurrently there is one blocker, the witness generated from geth \u0026 reth are non compatible due to reth applies account / storage deletions with sorted keys while geth does not (https://github.com/ethereum-optimism/op-geth/blob/79fc6fe5d134621644dedbe62f7b35468ee76000/core/state/statedb.go#L1002-L1005). \n\nWe'd love your thoughts on making geth sort the deletion keys before applying deletions? This way, we could have deterministic witness generation (apply updates first, then deletions sorted by keys) and have compatible API across different EL clients.",
        "created_at": "2024-09-18T22:03:08.528000+00:00",
        "attachments": []
    }
]