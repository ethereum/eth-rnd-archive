[
    {
        "author": "nerdynaman",
        "category": "general",
        "parent": "",
        "content": "We want to check what all information is revealed from ethereum traffic to ensure if a state sponsored network level adversary can throttle ethereum traffic",
        "created_at": "2024-04-04T06:23:20.442000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "general",
        "parent": "",
        "content": "I'll be presenting some small updates on EIP-7623 (Increase Calldata Cost by setting a floor price) on the next call and wanted to share this analysis with you:\nhttps://ethresear.ch/t/eip-7623-post-4844-analysis/19199\n\nThe tldr is:\n* 4844 decreased the median EL payload size\n* max block size remained the same\n* the gap between avg and max increased\n* including blobs, blocks can now have a max size of 3.51 MiB\n* EIP-7623 decreases it to 1.9 MiB (incl. 6 blobs)\n* 3% of transactios are affected by the new floor price (pay 12/48 instead of 4/16 for calldata) \n    -\u003e among those significantly affected are DA users (majority) and, less drastical, users attaching messages to ETH transfers\n* those 3% of transactions are executed by 1.4% of all senders\n\nThe latest update on the EIP included lowering the token floor from 16 to 12 as it looked like a better compromise between not affecting many while still achieving a big reduction in max possible block size.\nThere's a draft implementation by Marius here:\nhttps://github.com/ethereum/go-ethereum/pull/29040\nAnd in the execution-specs here:\nhttps://github.com/ethereum/execution-specs/pull/897\n\nHappy to hear what everyone thinks about it, and especially shipping it in Pectra.",
        "created_at": "2024-04-04T13:46:25.168000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Author here. The experiment is just to compare the state heal stage, i.e., synchronizing two giant KV tables.",
        "created_at": "2024-04-04T18:58:52.070000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "The number of coded symbols to store depends on how outdated a peer's state one plans to support. The more outdated a state one plans to synchronize with, the more symbols one needs to store. I did some measurements on how costly it will be to update the stored/cached symbols (which can support peers that are weeks outdated) and it is not a issue---it takes maybe 1 CPU core to keep up with the state changes on Ethereum mainnet.",
        "created_at": "2024-04-04T19:00:04.876000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Anyway happy to answer more questions! A team also just did a Rust implementation.",
        "created_at": "2024-04-04T19:01:57.663000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I think it's a very interesting protocol!",
        "created_at": "2024-04-04T19:26:08.775000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "We are most concerned about the *storage size* of the symbols",
        "created_at": "2024-04-04T19:26:52.415000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "thanks!\n\nAs mentioned earlier, the storage size of the symbols depends on how outdated peers one plans to heal. For example, to be able to heal a peer that has been offline for 24 hours, one needs to store about 500 MB of symbols. It increases about linearly as the staleness increases. So to heal a peer that has been offline for a month it's about 15GB of extra storage. Not too much imo compared to the amount of space nodes already need to use.",
        "created_at": "2024-04-04T20:47:58.648000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "FYI a symbol is as large as a state KV pair + about 10 bytes of metadata, so about 100 bytes. It takes ~2.72 coded symbols to heal one state KV.",
        "created_at": "2024-04-04T20:51:55.226000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Hmm, wait, so given a historical base state S it basically needs all state updates made to S as coded symbols?",
        "created_at": "2024-04-04T21:33:27.707000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Now would probably be a good time for me to actually understand the algorithm from the paper...",
        "created_at": "2024-04-04T21:34:45.840000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I'll be back with questions about it later",
        "created_at": "2024-04-04T21:35:03.140000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Yeah, so to go from state S to S', the number of coded symbols needed is the number of KV pairs that differ between S and S', times 2.72. What matters is the number of KV pairs that differ, not the updates. For example if a storage slot is rewritten 100 times between S and S' it still only counts as 1 diff.",
        "created_at": "2024-04-04T21:38:41.350000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Notice that the coded symbols are _not_ the actual diffs. You can think of them as _encoding_ of S' which allows someone holding S to figure out the difference between S and S'. The coded symbols are not tailored for S. The same stream of symbols also works to heal someone holding some other state S'' (though depending on the number of differences between S'' and S' we may need more or fewer symbols)",
        "created_at": "2024-04-04T21:39:10.751000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I get it. That does make it a bit harder to actually know how many symbols are needed for real world sync though. The problem we face with state synchronization, is that nodes only want to store the most recent state. And since sync takes time, the algorithm needs to handle the state constantly going out of date. I don't know if this progression to newer states *on the server side* is something you simulated in your experiment.",
        "created_at": "2024-04-04T22:36:09.332000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Anyway, we do know that state turnover is kind of high. And in the worst case, the nodes will have to store all state updates, since we can't count specific state entries being overwritten many times.",
        "created_at": "2024-04-04T22:37:06.346000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "The current snap sync scheme only requires storing the most recent state. It can be seen as a trade off where the communication overhead is a bit higher than it could be but there is no extra storage requirement beyond what the node already needs to process blocks and verify the root hash.",
        "created_at": "2024-04-04T22:39:08.089000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "general",
        "parent": "",
        "content": "\u003e I don't know if this progression to newer states on the server side is something you simulated in your experiment. \n\nI was playing with the code yesterday and had trouble getting the examples to continue to work if I modified the Encoder's state while the decoder was receiving symbols, so I'm also curious about this.",
        "created_at": "2024-04-04T22:40:20.953000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "The encoder and the decoder must work on static sets. It's okay to update the sets when synchronization is not happening though.",
        "created_at": "2024-04-04T22:47:28.529000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "The nice thing of ratelessness is that you do not need to estimate precisely how many symbols you will need. You can just parameterize it generously (say 15 GB as mentioned above) such that it covers the vast majority of peers that you will help heal.",
        "created_at": "2024-04-04T22:48:57.178000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Yeah that is indeed a great benefit of the current design. As you mentioned it is a tradeoff though. For example IO and CPU cost during state heal is also much higher (which I observed but did not have space to report in the paper). Imho the storage overhead is not significant. A full node already stores hundreds of gigabytes and it's probably not too outerageous to let them store another 10 GB to save bandwidth, compute, and IO during healing.",
        "created_at": "2024-04-04T22:51:11.770000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "I do think the fact that current state heal requires only the latest state is a major benefit. It handles the moving target very elegantly. Sadly Rateless IBLTs do not provide that feature.",
        "created_at": "2024-04-04T22:51:49.540000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "One might need to store the symbol sequences for multiple recent blocks, or just retain the symbols if it is being used",
        "created_at": "2024-04-04T22:52:28.132000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Once everyone stops using the symbols for a particular block height, it can be safely dropped and new peers will use the latest symbol sequence.",
        "created_at": "2024-04-04T22:52:56.348000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "(Notice that you do not need to literally store two entire sequences of symbols for two block heights. You can do copy-on-write and allocate new symbols only when its written)",
        "created_at": "2024-04-04T22:56:04.645000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Just to give you an intuition, our thinking with the snap sync design was:\n\nEvery 12s, a new block is produced, containing some amount of state updates. The server (geth) stores the state of the last 128 blocks. So this means, a syncing node will start with a pivot state, and can keep requesting nodes from that state for 128 * 12s = ~25min. Then it has to switch to a new state. At the moment, it switches more often than that though.",
        "created_at": "2024-04-04T22:57:49.059000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Yup I get that part. The fact that a state snapshot is stored only for a limited time is the main reason that one needs to do state heal.",
        "created_at": "2024-04-04T22:58:59.329000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "This idea you are developing right now, where it prepares the sequences for multiple blocks, sounds like a good direction. We don't know which block the client will be targeting (in fact it must be chosen kind of randomly to prevent some attacks). So it would have to store the sequences for all recent blocks. I'm curious what you think the overhead will be.",
        "created_at": "2024-04-04T22:59:36.282000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Just to clarify, the scheme is targeted at improving state heal, not snap sync as a whole.",
        "created_at": "2024-04-04T23:00:10.402000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Yes I get that.",
        "created_at": "2024-04-04T23:00:18.105000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Another problem you might not be aware of, is that at the moment where healing begins, the client state does not correspond with any previous valid state.",
        "created_at": "2024-04-04T23:01:27.795000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "This happens because the pivot is also moving while it downloads the KV pairs during the earlier phase",
        "created_at": "2024-04-04T23:01:56.170000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "I see. If the final target of snap sync (i.e., the target of state heal) is randomized within a range, we do have to store the sequences for all of them. As mentioned above, one should do copy-on-write so there is no redundancy.",
        "created_at": "2024-04-04T23:02:13.530000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Yup I'm fully aware of that problem. (which I wrote too little about in the paper ; )",
        "created_at": "2024-04-04T23:02:30.468000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "i.e. the initial state during healing is arbitrary KV pairs mixed from several states",
        "created_at": "2024-04-04T23:02:38.780000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Yes that's why I think the state heal problem is interesting. Otherwise one can just use the block height to ID the current state and request a diff.",
        "created_at": "2024-04-04T23:03:07.076000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "the way we do it actually isn't super great right now, since we have to build a complete merkle tree from KV pairs in client before starting the heal",
        "created_at": "2024-04-04T23:04:09.952000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "snap -\u003e trie is kind of expensive",
        "created_at": "2024-04-04T23:04:24.548000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "I see. Yeah I kind of experienced that when running the experiments.",
        "created_at": "2024-04-04T23:04:44.577000+00:00",
        "attachments": null
    },
    {
        "author": "megaethbunny",
        "category": "general",
        "parent": "",
        "content": "Needed to build a trie from a flat snapshot and it did take long.",
        "created_at": "2024-04-04T23:05:01.946000+00:00",
        "attachments": null
    }
]