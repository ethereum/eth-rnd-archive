[
    {
        "author": "__flcl",
        "category": "general",
        "parent": "",
        "content": "\u003c@194432762315407360\u003e  considering that spam countering measure of declining blob transactions with priority fee less than 1 gwei, do you guys mind we adjust rpc/devp2p tests a bit and make blob txs sent in tests to have at least 1 gwei priority fee? Or this constraint does not seem helpful anymore?",
        "created_at": "2025-10-17T16:49:06.616000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Yes, sure!",
        "created_at": "2025-10-17T17:40:15.076000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "general",
        "parent": "",
        "content": "I think we should consider it, although I know that by default, everyone will lean towards the Geth format. However, enabling certain EIPs would improve modularity for the broader ecosystem, and we should seriously take that into account.\n\n\u003c@226589605816696832\u003e wdyt?",
        "created_at": "2025-10-17T18:29:06.074000+00:00",
        "attachments": null
    },
    {
        "author": "smartprogrammer",
        "category": "general",
        "parent": "",
        "content": "agree 100%. I would argue that allowing granular control over enabling EIPs also greatly benefit L2s that would like to keep up with the latest spec from L1. the EIPs related to blobs and beacon chain can easily be not enabled while enabling EIPs related to execution.",
        "created_at": "2025-10-17T18:31:44.690000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "general",
        "parent": "",
        "content": "Iâ€™m not against standardizing, but we should have a discussion about what the format should look like. I know that the current geth-like format can sometimes be problematic. Imagine a chain that wants to be EVM-compatible but uses a different consensus mechanism.",
        "created_at": "2025-10-17T18:32:44.530000+00:00",
        "attachments": null
    },
    {
        "author": "smartprogrammer",
        "category": "general",
        "parent": "",
        "content": "We also benefit from this granularity greatly during early days of testing a fork. where sometimes we want to enable specific EIPs for a specific devnet configuration",
        "created_at": "2025-10-17T18:33:55.306000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "general",
        "parent": "",
        "content": "Happy to hear your thoughts \u003c@194432762315407360\u003e \u003c@412614104222531604\u003e \u003c@199561711278227457\u003e",
        "created_at": "2025-10-17T18:39:07.626000+00:00",
        "attachments": null
    },
    {
        "author": "barnabasbusa",
        "category": "general",
        "parent": "",
        "content": "Iâ€™m happy if everyone is happy.",
        "created_at": "2025-10-17T18:40:16.046000+00:00",
        "attachments": null
    },
    {
        "author": "lukaszrozmej",
        "category": "general",
        "parent": "",
        "content": "granurality is powerful and useful especially for partial testnets but it is a configuration nightmare",
        "created_at": "2025-10-17T18:57:53.807000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "^ Yeah basically this, also a lot of the features we do now are EL+CL related and often touch the engineAPI in some way or the other. I'm like the idea of per EIP activation, but I'm not sold its going to be trivial on all clients to implement (I know nethermind does per EIP already, but none of the others do). \n\nI'm assuming we're talking about L2s enabling/disabling certain EIPs, but in that case we'd need to make sure that tooling like solidity/libraries/etc all support this approach too. Otherwise we risk leaving the eth ecosystem even more fractured even if we start with a good intention.",
        "created_at": "2025-10-17T19:02:26.524000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "general",
        "parent": "",
        "content": "\" I'm not sold its going to be trivial on all clients to implement \"\n\nTrue for sure, but if we want to standardize it, we can create the format that we think is the best (doesn't have to be geth, doesn't have to be Nethermind) but IMO, we should do it right instead of what is the fastest to achieve",
        "created_at": "2025-10-17T19:08:24.182000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "isnt that what this EIP aims to achieve? \nhttps://eips.ethereum.org/EIPS/eip-7949",
        "created_at": "2025-10-17T19:09:42.347000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "^ would be great to get eyes on it and improve it if we find things to improve on",
        "created_at": "2025-10-17T19:10:10.876000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "general",
        "parent": "",
        "content": "Does it have some granularity for EIPs? It looks to me like geth format\n\nThe good examples when it doesn't work are EIPs 6110, 7002 in the context of EVM L2s",
        "created_at": "2025-10-17T19:12:54.013000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "general",
        "parent": "",
        "content": "toss it in the agenda for ACDT? happy to discuss it sync",
        "created_at": "2025-10-17T19:14:09.598000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "There is no granularity for configuring individual EIPs in the proposed format",
        "created_at": "2025-10-17T19:36:51.990000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I have worked a lot on the fork configuration system in geth recently, and I can tell you that it is not going to be possible to retrofit activation of individual EIPs in any reasonable time frame.",
        "created_at": "2025-10-17T19:38:13.096000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Also, when it comes to configuring L2 chains, I have surveyed their codebases, and they use a similar system of enabling named forks",
        "created_at": "2025-10-17T19:38:59.614000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "IMHO configuring named fork activations is the best approach. In any given fork, there are interdependencies of EIPs (i.e. one EIP requires another, or overrides an EIP from a previous fork, etc.) We don't necessarily want to model these dependencies in the code. The named forks are a close enough approximation of the features introduced by EIPs.",
        "created_at": "2025-10-17T19:41:25.814000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Another advantage to configuring named forks is that it matches the 'versioning' that we use for the specs and the mainnet.",
        "created_at": "2025-10-17T19:42:12.903000+00:00",
        "attachments": null
    },
    {
        "author": "barnabasbusa",
        "category": "general",
        "parent": "",
        "content": "what about future forks?",
        "created_at": "2025-10-17T19:50:10.810000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "general",
        "parent": "",
        "content": "Thinking about it more and we might not need \"EIP granularity,\" but what is actually desired is disabling beacon-chain-specific things (EIP-6110,EIP-7002 and so on), so the ideal format can be something close to geth, but with the way of:\n-disabling beacon-chain features\n-disabling blobs\n-need to think about other things",
        "created_at": "2025-10-17T19:53:27.917000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "The way I see it, we agree on two things in the ACD process:\n\n- the EIPs contained in named forks\n- scheduling of said forks on various networks\n\nThe genesis config file is really only about the latter part. It says when the fork is enabled.",
        "created_at": "2025-10-17T19:57:33.939000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "We don't have a machine-readable file that configures which EIPs are in the fork, because it's not something that can easily be changed anyway.",
        "created_at": "2025-10-17T19:58:46.529000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I was trying to say, we don't want to make it configurable like that. The upgrades are defined like a version, which gives the implementation some freedom on how it can be structured. For example, you can look at execution-specs, which works by copying and adapting the entire state transition implementation for every fork. They do it like this to avoid all the `if forkX then ... else ...` stuff that complicates the clients",
        "created_at": "2025-10-17T20:01:40.763000+00:00",
        "attachments": null
    },
    {
        "author": "smartprogrammer",
        "category": "general",
        "parent": "",
        "content": "We believe we can follow the suggested standard while keeping our unique granularity. We will potentially have a suplementary file that specifies which EIPs to enable with each named fork. this way,  other clients can stick with this desired format for the genesis while we keep our granular control",
        "created_at": "2025-10-17T20:05:47.922000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Yeah that's totally fine! The whole idea with standard genesis file is just to be able to codify the output of ACD decisions for all the clients in the same way. It simplifies the spec testing and also makes it easier to just run the clients on a testnet/devnet, etc.",
        "created_at": "2025-10-17T20:07:51.532000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "general",
        "parent": "",
        "content": "Yeah, it makes sense. \n\n\u003c@194432762315407360\u003e up to you guys, but I would consider this in your case as well ðŸ™‚",
        "created_at": "2025-10-17T20:14:51.628000+00:00",
        "attachments": null
    }
]