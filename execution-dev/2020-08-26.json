[
    {
        "author": "__lithp__",
        "category": "general",
        "parent": "",
        "content": "I think \u003c@!425615769280315392\u003e was one of the first people to point out CREATE2 had this problem, \"Wild Magic\"; eventually the community decided not to delay Constantinople over it. I don't remember the rationale, but I think there was some relatively easy workaround that Jason might remember?\n\nIf all you want is immutable data storage, then by verifying that there is no SELFDESTRUCT opcode (or DELEGATECALL, I think?) in the contract code you can convince yourself that the data will always be there (modulo some future version of state rent / state eviction)",
        "created_at": "2020-08-26T01:10:24.864000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I have been thinking more about conditional transactions, which are transactions that are only valid under certain conditions.  For example, a transaction that is only valid before/after a certain point in time, or a transaction that is only valid if it is included before or after a specific other transaction, or if a transaction is valid only if it is first or last in a block, or first block after a certain time, etc.",
        "created_at": "2020-08-26T01:25:07.669000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The problem with these historically has been that they introduce an attack vector because you have transactions that need to be broadcast, but may never end up in the chain (thus never cost the attacker anything to submit).",
        "created_at": "2020-08-26T01:25:35.264000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What are people's thoughts about something like hashcash on these transactions for spam protection?",
        "created_at": "2020-08-26T01:25:54.153000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The idea here being that conditional transactions will require an attached proof of work so that we can be sure the submitter had to spend some reasonable amount of money in order to submit the transaction so it isn't a DoS vector.",
        "created_at": "2020-08-26T01:27:14.999000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "One downside of the hashcash solution is that very often conditional transactions are *incredibly* time sensitive, meaning you need to get into the pending queue within a block.  Perhaps there are other options for proof of burn that don't require on-chain transactions?  Ideally, we want a proof of burn that doesn't require adding bloat to the blockchain, so we *don't* want to just require the user to submit a transaction that burns ETH.",
        "created_at": "2020-08-26T01:30:33.189000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Part of my desire for conditional transactions is to get all of the transactions out of the chain that no one actually wants there (e.g., any transaction that was effectively a no-op and only incremented a nonce and paid gas).",
        "created_at": "2020-08-26T01:31:08.578000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cjasoncarver\u003e Yeah the simpler thing to check is whether it's possible for the contract to disappear, as you mentioned. Otherwise, you can try to prove it's not a create2 contract, though that's not as easy as it sounds, because you have to track down the series of transactions that created it, back to an externally owned account that started the series, making sure that none of those are create2. (re @eth1x_bridge_bot: \u003clithp\u003e I think \u003c@425615769280315392\u003e was one of the first people to point out CREATE2 had this problem, \"Wild Magic\"; eventually the community decided not to delay Constantinople over it. I don't remember the rationale, but I think there was some relatively easy workaround that Jason might remember?\nIf all you want is immutable data storage, then by verifying that there is no SELFDESTRUCT opcode (or DELEGATECALL, I think?) in the contract code you can convince yourself that the data will always be there (modulo some future version of state rent / state eviction))",
        "created_at": "2020-08-26T01:37:51.485000+00:00",
        "attachments": null
    },
    {
        "author": "afdudley",
        "category": "general",
        "parent": "",
        "content": "Yeah, the constraint has to work the other way too... I mean, we don't just want to asset that the code is immutable, want to also stop people from DoSing the chain (or services like etherscan) by changing a lot of contract code.",
        "created_at": "2020-08-26T03:06:24.867000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I thought CREATE2 was OK, but the combination of SELF-DESTRUCT with CREATE2 - wasn't. Unfortunately, it seems rather infeasible to remove SELF-DESTRUCT. But for now, I got over my problems with SELF-DESTRUCT+CREATE2, they do introduce complexities in the implementation, but with some extra work, they can be managed. And I don't currently have energy to work on CREATE3 I am afraid ðŸ™‚",
        "created_at": "2020-08-26T06:14:12.113000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e Why is it infeasible to remove selfdestruct?",
        "created_at": "2020-08-26T06:17:21.424000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "I concluded this after suggesting to remove it (https://ethereum-magicians.org/t/eip-for-disabling-selfdestruct-opcode/4382) and by doing so discovering some usage modes that seem to be quite popular",
        "created_at": "2020-08-26T06:21:41.618000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "perhaps it is doable, but not by me ðŸ™‚ and I did not see much interest in anyone else doing it ðŸ™‚",
        "created_at": "2020-08-26T06:22:12.620000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "that is why I am assuming it is currently infeasible",
        "created_at": "2020-08-26T06:22:31.694000+00:00",
        "attachments": null
    }
]