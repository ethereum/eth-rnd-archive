[
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "For the record, we've previously seen cases where running geth (in the form of op-program specifically, but it's the geth EVM and world state trie code) would access different world state nodes when executing the same set of blocks when run in two different processes. This turned up in the ongoing compatibility testing we run. We believed this was due to golang hash maps having a random access order and have not seen the problem since running the \"online\" mode which fetches and saves the required preimages and the offline mode that checks they are actually sufficient to reexecute in the same process so that the random seed for hash map ordering is the same. But it sounds like we haven't understood the exact details of what happened.\n\nSadly, the blocks we saw the problem on were from op-goerli which was shut down quite a while back so not simple to try and extract exact traces from it (I have the block number and trie node hash that was missing though...)",
        "created_at": "2024-09-25T00:05:47.995000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "general",
        "parent": "",
        "content": "[EOF] Can someone in the working group comment on the rationale for banning EXTCODE operations in EOF? https://ethereum-magicians.org/t/eip-7761-hascode-formerly-iscontract-instruction/20936/6?u=wjmelements",
        "created_at": "2024-09-25T20:57:21.451000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "general",
        "parent": "",
        "content": "Ideally the rationale is in the EIP but it is not mentioned",
        "created_at": "2024-09-25T20:57:42.880000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "Looks like we need to add it to the 3540 EIP.  The goal is to get rid of code introspection, where the code that is being executed can never become data on the stack, and vice versa. One example of the places this is needed is ZK execution.  Allowing CREATE to take arbitrary memory (potentially from an external call) and convert it into a fully functional contract requires a fully functional EVM in the ZK circuit or ZK evaluation methodology.  By requireing code to come in via a separate channel that is not calldata it becomes more feasable for closes ZK systems to never need to re-compile their ZK circuits again. There are other places this is nice, but the future impact in validity proofs is one of the bigger ones.",
        "created_at": "2024-09-25T22:00:28.977000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "While we could keep it in (and there is the possibility we could restore it as an operation) keeping the \"read\" part out keeps the notion of introspection out of the EVM.",
        "created_at": "2024-09-25T22:01:23.231000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "(And this is presuming within only EOF code, migration to that state is another topic)",
        "created_at": "2024-09-25T22:02:00.332000+00:00",
        "attachments": []
    }
]