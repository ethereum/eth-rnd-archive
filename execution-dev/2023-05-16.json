[
    {
        "author": "wjmelements",
        "category": "general",
        "parent": "",
        "content": "We have working parallel execution for the EVM but it requires preprocessing each transaction to calculate a read/write access list. If the access list provided in the raw transaction distinguished read vs write for (code, storage, balance), and also was strict such that reading or writing outside of the list caused a reverting fault, we wouldn't need to preprocess the transactions. Such a transaction type would also benefit its users by avoiding unintended state changes.",
        "created_at": "2023-05-16T20:41:08.620000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "general",
        "parent": "",
        "content": "It could even go stricter by declaring what it expects prior state to be.",
        "created_at": "2023-05-16T20:45:42.360000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "There was a devcon talk on parallel EVMs - https://archive.devcon.org/archive/watch/6/challenges-of-parallelizability-under-ethereums-execution-model/?playlist=Layer%201%20Protocol\u0026tab=YouTube\nThis sounds like OCC.\nBut the real blocker is state growth, not EVM processing time.  Can the current client architectures handle a 4x increase?\nThen there is the question of TX size if every slot read needs to be enumerated.",
        "created_at": "2023-05-16T21:59:25.803000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "general",
        "parent": "",
        "content": "I think the more interesting and impactful space is in unorderd transaction sets (adjacent to parallel) and then how that impacts light client validation.",
        "created_at": "2023-05-16T22:00:51.125000+00:00",
        "attachments": null
    }
]