[
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "I should have been more clear as I didn't realize that this spec also allows me to put the same uncle twice (it seems) in the uncles list of the current block I'm validating. My main point was that the spec does not seem to prevent that if you have the following situation:",
        "created_at": "2020-10-31T00:25:18.858000+00:00",
        "attachments": [
            {
                "type": "",
                "origin_name": "AVCM9aNrURPyAAAAAElFTkSuQmCC.png",
                "content": "16d5451751d880e306e2e3a80113e4af5cc6ed338e255ea77b2c66f4f60886f4"
            }
        ]
    },
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "Here the arrows are where the `parentHash` points to, and `n`, `n+1` etc. are block numbers; `u` thus also has `n+1` as block number. The dotted lines imply that we have listed `u` as uncle in that block.",
        "created_at": "2020-10-31T00:25:49.832000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "The spec does not seem to disallow me to put `u` as uncle in `n+2` and `n+3`?",
        "created_at": "2020-10-31T00:26:09.500000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "Because if I check P(H(n+2)) == P(U) this is false, so we don't have to check anything else here in this sibling function",
        "created_at": "2020-10-31T00:26:52.062000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "But then I check P(H(n+1)) == P(U): we also have U != H(n+1) and also not U \\in B(H(n+1))_U",
        "created_at": "2020-10-31T00:27:45.471000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "Same holds if I do the same thing for `n+3`, and possibly even `n+4`..?",
        "created_at": "2020-10-31T00:28:01.885000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "I am assuming that the intended constraints are as following:\n\nThere are no more than 2 uncles in a block header.\nThe uncle header is a valid header.\nThe uncle cannot consist more than once in the uncle list of the current header.\nIn the past 6 parent blocks of the current header which we are verifying: \n-\u003e None of these checked blocks is the uncle (this is point (2))\n-\u003e The uncle does not already consist in any of these blocks as uncle (this is what point (3) intends to do (?))\n-\u003e For one of these headers, the uncle has listed this header as the parentHeader ( this is point(1), i.e. it is parentHeader of the canonical chain)",
        "created_at": "2020-10-31T00:31:06.867000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "\u003e The spec does not seem to disallow me to put u as uncle in n+2 and n+3?\n\nAha, correct, another bug.\n\n\u003e Same holds if I do the same thing for n+3, and possibly even n+4..?\n\nCorrect.\n\n\u003e I am assuming that the intended constraints are as following:\n\nYes, your constraints seems complete.     \n\n\u003e This is what point (3) intends to do (?)\n\nYes, perhaps that was the intention. But it is ineffective.",
        "created_at": "2020-10-31T01:13:41.745000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "Great, thanks a lot \u003c@!682078300234973185\u003e :D\n\nFinal question: since I only have to validate the header of the uncle, it is thus possible that I can create a bogus block and add this as uncle? I have produced a valid header so I have done the PoW, but the some values (e.g. `stateRoot`) are wrong. There is of course zero incentive to do that but just checking, because if you'd have to validate every uncle (also running each uncle block... and their uncles... and their uncles....) that could get nasty ðŸ˜…",
        "created_at": "2020-10-31T01:29:35.948000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "\u003c@!508125616940515329\u003e You're welcome. Nice catch.\n\n\u003e it is thus possible that I can create a bogus block and add this as uncle?\n\nYes, uncles are loose.",
        "created_at": "2020-10-31T01:34:33.546000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "general",
        "parent": "",
        "content": "Thanks! ðŸ˜„",
        "created_at": "2020-10-31T01:35:47.283000+00:00",
        "attachments": null
    }
]