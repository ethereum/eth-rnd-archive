[
    {
        "author": "shanefontaine",
        "category": "general",
        "parent": "",
        "content": "One thing I don't see in that thread is that technically `selfdestruct` is the only way to truly destroy ETH right now (pre 1559) (`selfdestruct(address(this));`). With that said, I don't see _any_ use at all for that action.",
        "created_at": "2020-08-27T04:31:03.535000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "One downside of the hashcash solution is that very often conditional transactions are *incredibly* time sensitive, meaning you need to get into the pending queue within a block.  Perhaps there are other options for proof of burn that don't require on-chain transactions?  Ideally, we want a proof of burn that doesn't require you submit some useless transaction to the chain (we are trying to reduce the volume of such things).",
        "created_at": "2020-08-27T04:34:42.042000+00:00",
        "attachments": []
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e \u003e \u003cShane Fontaine\u003e One thing I don't see in that thread is that technically selfdestruct is the only way to truly destroy ETH right now (pre 1559) (selfdestruct(address(this));). With that said, I don't see _any_ use at all for that action.",
        "created_at": "2020-08-27T04:52:09.471000+00:00",
        "attachments": []
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e Yeah, it's a dumb invariant-breaking edgecase and should ideally be removed",
        "created_at": "2020-08-27T04:52:19.159000+00:00",
        "attachments": []
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvbuterin\u003e Actually technically you can also call a bunch of addresses, have them all self-destruct, then send them ETH; that ETH gets burned when the self-destructs process *at the end of the transaction*",
        "created_at": "2020-08-27T04:53:00.541000+00:00",
        "attachments": []
    },
    {
        "author": "shanefontaine",
        "category": "general",
        "parent": "",
        "content": "Interestingâ€”I didn't realize it happens at the end. Could make for some nice attempts at obfuscating txs. It looks like raw traces (and by extension naive explorers) only show the `selfdestruct` call as the opcode is called in order of execution, but have no explicit concept of what happens to the ETH transferred to the contract at the conclusion of the tx _after_ the `selfdestruct` + any other calls or transfers.\n\nSo the tx below calls `selfdestruct` and then transfers the ETH to the `selfdestruct`ed contract, but AFAICT there is no way to know that the ETH is destroyed with the data available on Etherscan or traces. In fact, I think that the data provided here could mislead you to believe the `selfdestrcut`ed contract will have the ETH at the conclusion of the tx.\n\nhttps://kovan.etherscan.io/tx/0xd85fe45a4819d4b947e8f7752d276190cc736762a70a6bfd870930f6009e88e8",
        "created_at": "2020-08-27T06:12:49.172000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "ðŸ¤”  If we wanted to do something about frontrunning/backrunning (I don't know that we do) we could make it so that the clients track receipt timestamp for every transaction they see.  They would then do the normal transaction selection algorithm (sort by price, pick first 12.5M gas worth).  They would then sort the selected transactions by receipt timestamp and execute.  If, after execution, there is space in the block fill it with some ETH transfers.",
        "created_at": "2020-08-27T12:01:38.722000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The idea here is that you *cannot* frontrun against a miner using default selection unless you can see the transaction *before* the miner sees the transaction and get a transaction on the wire and into the hands of the miner fast enough.",
        "created_at": "2020-08-27T12:02:12.764000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Of course, the big problem here is that miners can simply use their own transaction selection strategy (not the default) where they encourage front-runners.",
        "created_at": "2020-08-27T12:02:46.885000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I am mildly curious how many miners would build/run their own custom transaction selection library.  Interestingly, if few enough do so then the incentive to frontrun goes away and it is no longer meaningfully beneficial to run your own sorting library.",
        "created_at": "2020-08-27T12:03:34.423000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I can imagine one of the larger pools perhaps doing it first, I wonder if that is enough on its own?",
        "created_at": "2020-08-27T12:03:50.990000+00:00",
        "attachments": []
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "**EIP-1559 Implementers' Call #4 tomorrow, Aug 28, at 15:00 UTC**\nAgenda: https://github.com/ethereum/pm/issues/197\nZoom: https://consensys.zoom.us/j/91866526216\n\nThe call won't be live streamed but will be uploaded to Youtube afterwards",
        "created_at": "2020-08-27T15:30:59.037000+00:00",
        "attachments": []
    }
]