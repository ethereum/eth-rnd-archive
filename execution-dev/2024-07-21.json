[
    {
        "author": "joeaa_",
        "category": "general",
        "parent": "",
        "content": "is it ever possible that a a reorg changes the block.timestamp to a block.timestamp less than block n - 1, with block n being the reorged block. or does the invariant block.timestamp(n) \u003c block.timestamp(n+1) always hold. i know it differs a bit accross the different non-evem blockchains",
        "created_at": "2024-07-21T15:15:32.030000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "`block.timestamp \u003e block.parent.timstamp` is a hard requirement in every chain I know of.  Some have more constraints, like Ethereum *at the moment* is `\u003e +12` (but this could change in the future).",
        "created_at": "2024-07-21T15:42:18.748000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Note that this doesn't have anything to do with reorgs.  Just block validity logic.",
        "created_at": "2024-07-21T15:43:47.550000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "This can happen depending on what do you mean by block n and n-1. The important thing is that there may be many different valid **block n** and to make things more complicated, there is a difference between block n and slot n. In the current mainnet of Ethereum a situation that more or less resembles what you suggest is the following: \n\nThere is a chain That looks like this with k a possibly large number. But these are **block numbers**\n```\nn-k \u003c-.... \u003c- n-2 \u003c-- n-1 \u003c-- n\n```\nIf you look at slot numbers, these are very different with a bunch of them missing, for example it could look like \n```\n(n-k, N-l) \u003c- ... \u003c- (n-2, N-5) \u003c-- (n-1, N-1) \u003c--- (n, N)\n```\nThe second number is the slot number and the first is the block number. The requirement that Ethereum makes and that is alluded by \u003c@301186049323958275\u003e is that the timestamp of `n` has to be the exact timestamp of `N` that currently means `12 * N` seconds since genesis in December 1 2020. \n\nSuddenly you can see a different chain that becomes the head of the chain, and this chain is actually fuller than the one you had before as head: your reorg would look like:\n\n```\n(n-k, N-l) \u003c- ... \u003c- (n-2, N-5) \u003c----------------------------------------- (n-1, N-1) \u003c--- (n, N)\n   \\\n    ------------------------(n-2. N-4) \u003c---- (n-1, N-3) \u003c---- (n, N-2) \n```\nIf this chain becomes head, the timestamp of the block at blockheight `n` will be below that of the timestamp of block height `n-1` in the previous head chain. \n\nHere I've played with the different between block and slot, but you can have nastier things if you start playing with k large enough so that there are two different blocks, of different heights **in the same slot** that are valid for the protocol. I'll leave that as a curious exercise, but probably Ben Edington already wrote an example in his book.",
        "created_at": "2024-07-21T20:18:30.467000+00:00",
        "attachments": null
    }
]