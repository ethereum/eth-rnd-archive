[
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I am not sure about that. In case if a fork requires changes on CL/EL to be coordinated (like withdrawals) a block number won't be possible to be used because of empty slots. It opens up a question of using block numbers in the forks after the merge.\n\nOne of the options is to use `timestamp` as a fork trigger post-Merge. CL uses epoch numbers as a fork trigger, a certain epoch number is easily convertible to `timestamp` which EL has access to.",
        "created_at": "2022-07-01T09:50:59.967000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "We could also schedule them by slot number though?",
        "created_at": "2022-07-01T09:52:10.549000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "EL could get access to the slot number",
        "created_at": "2022-07-01T09:52:29.285000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "(Or epoch number)",
        "created_at": "2022-07-01T09:54:21.238000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yes, and probably it will have a `slot` embedded into block header at some point in time, e.g. if it would be exposed by EVM. But this would require adding a `slot` field first.",
        "created_at": "2022-07-01T09:54:38.701000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Anyway, the forkID system only works if we can pre agree on a number or other identifier which is different between chains.",
        "created_at": "2022-07-01T09:55:09.550000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Btw, could timestamp replace block number in the fork id? What are the implications?",
        "created_at": "2022-07-01T09:55:31.626000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I think it would work just as well TBH",
        "created_at": "2022-07-01T09:55:44.780000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I am a huge fan of doing forks based on timestamp post merge.  However, I'm curious to better understand why we can't use block number?  It seems like we could say that block X is the fist time the new rules take effect, so an empty slot prior to block X just means the new rules haven't taken effect yet.",
        "created_at": "2022-07-01T10:18:01.398000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Re: Timestamps:  \"Any slot/block with a timestamp \u003e= X is under the new rules, any with a timestamp \u003c X is executed under the old rules.\"",
        "created_at": "2022-07-01T10:18:52.574000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "No need for epochs, slots, or blocks.  Timestamps are *super* easy for humans to understand, compared to epochs and the like.  Though perhaps there is an issue with a fork happening out of phase with epochs (e.g., in the middle of an epoch)?",
        "created_at": "2022-07-01T10:19:45.510000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "If a slot was missed the block number would be reached *later* than epoch number inducing a race condition between the layers",
        "created_at": "2022-07-01T10:20:56.830000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I definitely don't think we should have two measurements for one fork!",
        "created_at": "2022-07-01T10:21:34.929000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Either we fork on block number, or we fork on epoch.  We definitely shouldn't have CL fork on epoch and EL fork on block.",
        "created_at": "2022-07-01T10:21:51.391000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The CL knows what the block number was for the last EL block included in the chain, so it can fork on block number easily enough.  Same with timestamp.",
        "created_at": "2022-07-01T10:22:13.273000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "CL fork on epoch, EL fork on timestamp sounds fine with me as `compute_timestamp_at_epoch_number(epoch)` should be an easy one",
        "created_at": "2022-07-01T10:22:59.535000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I do not like that.  I strongly prefer both fork on the same value.",
        "created_at": "2022-07-01T10:23:20.384000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It just feels so incredibly error prone to have the two clients have different values they fork on.",
        "created_at": "2022-07-01T10:23:31.837000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Any of these would be preferable to a mixed strategy: both on slot number, both on block number, both on timestamp, both on epoch.  I like both on timestamp the best, because humans understand it trivially so there is less confusion for users and less room for human misunderstanding (assuming we use unix timestamps, which are well defined).",
        "created_at": "2022-07-01T10:23:58.563000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I hold this position even if one value can be derived from the other (like epoch \u003c=\u003e timestamp).",
        "created_at": "2022-07-01T10:26:01.291000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "I believe it is important for CL to fork on epoch number because of the epoch processing part of the state transition. I am not sure that leaking epoch number to EL is the right thing to do",
        "created_at": "2022-07-01T10:26:26.821000+00:00",
        "attachments": []
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "pick an epoch and timestamp =compute_timestamp_at_epoch_number(epoch) are same values so this shouldn't cause confusion",
        "created_at": "2022-07-01T10:27:00.491000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I don't mind picking a timestamp that aligns with a particular epoch boundary, but the fork should \"happen at a timestamp\" ultimately.  That is to say, if we get the calculation wrong it is the timestamp that matters and any client that forked at the timestamp is correct over one that forked at the epoch.",
        "created_at": "2022-07-01T10:28:33.258000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Either that or we do inform the EL of the current epoch and have it fork on epoch.",
        "created_at": "2022-07-01T10:28:49.496000+00:00",
        "attachments": []
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "epoch is very stickly aligned to timestamp",
        "created_at": "2022-07-01T10:29:51.872000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Imagine we do the math and determine that timestamp X is equal to epoch Y.  CLs all code to fork at epoch X and ELs all code to fork at timestamp Y.  Y rolls around and it turns out we mathed wrong and X != Y.  EL and CL now desync.",
        "created_at": "2022-07-01T10:29:52.700000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "While we can certainly take measures to minimize the chance of this happening, I think the safe solution here is to say \"timestamp is what both EL and CL fork on\" because it is a piece of information they share.  We can aim for an epoch boundary, but ultimately what matters is the timestamp if there is any disagreement or error in calculation.",
        "created_at": "2022-07-01T10:30:48.401000+00:00",
        "attachments": []
    },
    {
        "author": "g11tech",
        "category": "general",
        "parent": "",
        "content": "i am not sure epochs can shift on time",
        "created_at": "2022-07-01T10:30:49.561000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Could be as simple as a clerical error.",
        "created_at": "2022-07-01T10:30:59.758000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Or an off by one error in the function used to convert or something stupid like a typographical error when drafting the specification.",
        "created_at": "2022-07-01T10:31:20.448000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "One caveat with using epoch on CL and timestamp on EL. If `SLOTS_PER_EPOCH` (unlikely but still) or `SECONDS_PER_SLOT` (like in PBS proposal) changes then `compute_timestamp_at_epoch_number(epoch)` becomes a more complicated function than it is today",
        "created_at": "2022-07-01T10:31:27.893000+00:00",
        "attachments": []
    },
    {
        "author": "vorot93",
        "category": "general",
        "parent": "",
        "content": "circling back to forkid, I think it should be scrapped at this point given two P2P networks and the external fork choice for EL\ncomplexity that is no longer justified",
        "created_at": "2022-07-01T10:31:30.225000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Heh, I feel the opposite.  I wish we would go much further with hard forks *actually* forking the entire ecosystem every time.",
        "created_at": "2022-07-01T10:32:10.346000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I *personally* think that the ETC/ETH split should have left ETC with chain ID 1, ETH symbol, Ethereum name, etc.  It is us that wanted to change the rules after the fact, they are the ones that followed the original ruleset.",
        "created_at": "2022-07-01T10:33:06.737000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "In general, I think \"no change\" should be preferred over \"change\".  Any change should be important/big enough to make people *want* to move, we shouldn't be using defaults, trademarks, etc. to force people to move.",
        "created_at": "2022-07-01T10:33:38.174000+00:00",
        "attachments": []
    },
    {
        "author": "vorot93",
        "category": "general",
        "parent": "",
        "content": "and then there's difficulty bomb as chain and leash",
        "created_at": "2022-07-01T10:53:01.125000+00:00",
        "attachments": []
    },
    {
        "author": "vorot93",
        "category": "general",
        "parent": "",
        "content": "hopefully gone once and for all post-merge",
        "created_at": "2022-07-01T10:53:15.901000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "We created the fork ID for discovery purposes, because we needed a small integer value to identify each chain. IMHO this requirement still exists.",
        "created_at": "2022-07-01T11:28:47.588000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "We could remove it from the eth wire protocol if everyone feels strongly that it is not needed.",
        "created_at": "2022-07-01T11:29:19.541000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "However, it is a pretty nice optimization for avoiding wrong peer connections.",
        "created_at": "2022-07-01T11:29:46.126000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Can't epoch be derived from slot number? If we have slot in EL header, we also know epoch.",
        "created_at": "2022-07-01T11:31:01.757000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "Hmm, but this would mean EL needs to duplicate logic including SLOTS_PER_EPOCH",
        "created_at": "2022-07-01T11:32:11.903000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "I stand by my suggestion to fork on slot number",
        "created_at": "2022-07-01T11:32:26.853000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "`SLOTS_PER_EPOCH` is unlikely to be changed thus more stable than timestamp \u003c-\u003e epoch relation. If we want to have a slot as a fork trigger post-Merge that we'd need to coordinate a fork to include `slot` into block header in the first place",
        "created_at": "2022-07-01T11:35:00.831000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I find the discussion about timestamp, epoch, slot number to be completely mind-bogging. The three of them are equivalent and they continue being so even after changing the function `compute_timestamp_at_epoch_number` as long as we change by an invertible function. So It does not matter how you call them, all of them will be *time based forks*. Block number on the other hand is not a time-based fork trigger, but from the comments of \u003c@194432762315407360\u003e above, it would be fine for the EL to use timestamp.",
        "created_at": "2022-07-01T11:37:05.600000+00:00",
        "attachments": []
    },
    {
        "author": "lukaszrozmej",
        "category": "general",
        "parent": "",
        "content": "I agree! We don't want useless peers",
        "created_at": "2022-07-01T11:37:55.763000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "The question is just, how much logic do we need to pull into EL to make the scheduling work? If timestamp is available now, and is always supplied by CL, we could use it as fork trigger without knowing how it is computed.",
        "created_at": "2022-07-01T11:40:01.965000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "My general argument is that all clients should be forking on the same constant so it is clear who is correct in any scenario where there was a coordination/communication/calculation failure by humans.",
        "created_at": "2022-07-01T11:40:46.205000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "timestamp is available on both layers, and is an invariant, and either layer can decide how to translate to whatever internal type is useful.",
        "created_at": "2022-07-01T11:41:01.578000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "By asserting that \"we are forking on timestamp\", it makes it blindly clear which chain is correct when it turns out that our `timestamp_to_epoch_calculator` had a bug.",
        "created_at": "2022-07-01T11:41:14.435000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Certainly an unlikely bug, but it feels like there is little benefit here to using a different constant between the layers and if such a bug does happen it is incredibly high impact.",
        "created_at": "2022-07-01T11:43:05.897000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Currently we have `CAPELLA_FORK_EPOCH` in CL configuration. If we want both layers to be forked upon timestamp we will have to replace this parameter with `CAPELLA_FORK_TIMESTAMP`. I don't know how big of a change on CL side it is, probably, it's straightforward. CL may enforce `XXX_FORK_TIMESTAMP` to strictly point to epoch boundary",
        "created_at": "2022-07-01T11:50:52.884000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "CL / EL forks are independent though",
        "created_at": "2022-07-01T11:51:41.178000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I think we have the separate repos still so this is not strictly necessary, the CL can have any trigger as long as it's in bijection with timestamp. in particular CAPELLA_FORK_EPOCH works",
        "created_at": "2022-07-01T11:51:46.970000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "As long as we keep the two systems separated, we can decide independently how forks on the respective system are scheduled.",
        "created_at": "2022-07-01T11:52:11.748000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "general",
        "parent": "",
        "content": "However, if CL wants to be aware of an EL change, the CL too must know when the fork activates.",
        "created_at": "2022-07-01T11:52:41.991000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I definitely advocate for designing our systems such that one of the two systems can fork before the other.",
        "created_at": "2022-07-01T13:30:57.240000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "For example, we could for EL with withdraws first, and then fork CL to support them second.  We don't actually need them to go live at the same time, and I think from a risk reduction standpoint we should try to *avoid* having them go live at the same time.",
        "created_at": "2022-07-01T13:31:23.392000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "This doesn't mean they have to go live a year apart, but having a few days between the EL and the CL fork could prove valuable.  Having CL not even schedule their fork until after the EL fork is live may significantly reduce the coordination challenges around fork timing.",
        "created_at": "2022-07-01T13:32:37.740000+00:00",
        "attachments": []
    },
    {
        "author": "pawandhananjay",
        "category": "general",
        "parent": "",
        "content": "do ELs have a json rpc method for returning the latest finalized block post merge?",
        "created_at": "2022-07-01T17:32:45.910000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "eth_getBlockByNumber(\"finalized\")",
        "created_at": "2022-07-01T17:33:41.040000+00:00",
        "attachments": []
    },
    {
        "author": "pawandhananjay",
        "category": "general",
        "parent": "",
        "content": "perfect! thank you",
        "created_at": "2022-07-01T17:34:02.598000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "This opens up the possibility for the CL to fork outside of an epoch transition.  That's not possible and would require a massive reworking of the specs and all client implementations.\n\nThe CL will be forking based on epoch. It's just not viable to do the fork any other way. If there's a discrepancy between timestamp and epoch, it's the epoch that will win because all implementations are going to fork based on epoch.",
        "created_at": "2022-07-01T22:24:22.262000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "So the question is whether we pass the epoch value to the EL when the forks have to be in sync or if we can assume that having gone through the much more complex process of defining how the fork works we can manage to convert the epoch to a timestamp accurately.",
        "created_at": "2022-07-01T22:25:15.661000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "A test for the conversion seems trivial enough and would give us confidence we got this right. So I think we can be pragmatic here instead of making a massive rod for our own back.",
        "created_at": "2022-07-01T22:26:10.126000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Where it's possible to have forks decoupled between EL and CL so they don't have to fork at the same time that's clearly a good idea.",
        "created_at": "2022-07-01T22:27:15.324000+00:00",
        "attachments": []
    }
]