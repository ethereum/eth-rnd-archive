[
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Is it possible to identify whether a given contract function is constant-gas?",
        "created_at": "2020-07-09T01:32:48.687000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "In the general case, no.",
        "created_at": "2020-07-09T01:33:13.837000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "It is undecidable, in fact.",
        "created_at": "2020-07-09T01:33:29.406000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Is there a subset of cases where it is reasonably possible?",
        "created_at": "2020-07-09T01:33:43.962000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Yes, you can do a static analysis. But this analysis may need to be upper-bounded somehow. So you can decide: this code stops within this amount of gas, or we have no idea.",
        "created_at": "2020-07-09T01:35:39.362000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Pretty sure the answer is yes, since a function with no conditionals would be constant gas.",
        "created_at": "2020-07-09T01:35:59.145000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "You are correct, without turing completeness, the problem is may be decidable with a fast decision procedure.",
        "created_at": "2020-07-09T01:36:35.343000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I wonder if there is an opportunity to allow users to sort of create their own precompiles (merely brainstorming).",
        "created_at": "2020-07-09T01:37:23.660000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "For some bit of code that does some operation in constant time, you could (in theory) remove the gas-accaunting-as-you-go from it and compile the code down to native.",
        "created_at": "2020-07-09T01:38:37.831000+00:00",
        "attachments": []
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cjadler\u003e https://twitter.com/jadler0/status/1174859441377828865 (re @eth1x_bridge_bot: \u003cMicah\u003e For some bit of code that does some operation in constant time, you could (in theory) remove the gas-accaunting-as-you-go from it and compile the code down to native.)",
        "created_at": "2020-07-09T01:39:58.731000+00:00",
        "attachments": []
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cjadler\u003e Compiling the bytecode to native can be done using jets.",
        "created_at": "2020-07-09T01:40:25.827000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Initially, maybe this could be something done during forks, where there is a process by which anyone can submit a function to an automated prover, along with a little ETH (to cover costs of running the prover and adding the code permanently to the clients) and if the prover validates that it is in fact bounded gas, it could charge less for certain opcode's since they can be compiled down to native.",
        "created_at": "2020-07-09T01:42:20.246000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "This could be particularly useful for pure code like hashing algorithms and such, which are often debated a bunch for inclusion.",
        "created_at": "2020-07-09T01:43:22.283000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "You have independently rediscovered the idea for auto-metered precompiles for constant-time crypto bottlenecks.",
        "created_at": "2020-07-09T01:43:30.228000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If this is already a discussed things then I'll bow out.  :)",
        "created_at": "2020-07-09T01:43:57.940000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "No, I am happy that you are mentioning it.",
        "created_at": "2020-07-09T01:44:25.445000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "There is an inactive proposal to auto-meter precompiles for crypto bottlenecks, along with precise and accurate metering. This metering is done by counting cycles on open hardware.",
        "created_at": "2020-07-09T01:45:21.515000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Brief writeup is here https://notes.ethereum.org/2HLNNOo2TPS5T0Pel5_zqw .",
        "created_at": "2020-07-09T01:45:49.493000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Some examples of counting cycles here https://github.com/poemm/assembles .",
        "created_at": "2020-07-09T01:46:08.117000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Do you run against all major clients and take worst?",
        "created_at": "2020-07-09T01:46:13.361000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "No. It is not EVM. It is a universal assembly language with 16 registers (limited by x86). So it avoids the compiler correctnes+performance problem. It is metered on an open hardware description which has reasonably competitive instructions/cycle. CPU cycles are counted.",
        "created_at": "2020-07-09T01:48:56.145000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "There is a linear map from cycle count to gas.",
        "created_at": "2020-07-09T01:50:20.383000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Useful for constant-time crypto bottlenecks like hash kernels and bigint arithmetic.",
        "created_at": "2020-07-09T01:51:17.402000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Which are the major (like 95%) bottlenecks for much of crypto.",
        "created_at": "2020-07-09T01:51:44.994000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I wonder if a constant time bigint square root would end up being cheaper than on-chain variable time square root?",
        "created_at": "2020-07-09T01:52:16.996000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Probably, since I believe constant time square root is 1 iteration per bit, so not that many.",
        "created_at": "2020-07-09T01:52:43.955000+00:00",
        "attachments": []
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "I don't know, I have never implemented bigint square root.",
        "created_at": "2020-07-09T01:52:53.518000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "(that one in particular is used all over the ecosystem)",
        "created_at": "2020-07-09T01:53:01.628000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "why is everyone using the square root, by the way?",
        "created_at": "2020-07-09T06:00:42.435000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I think it is just one of the most common operations in math that isn't trivial.",
        "created_at": "2020-07-09T06:27:04.259000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Logarithms are probably next?",
        "created_at": "2020-07-09T06:27:09.523000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "but you mean square root on finite fields, right?",
        "created_at": "2020-07-09T06:27:49.303000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I don't think so?  Just like `sqrt(some_big_number)`.",
        "created_at": "2020-07-09T06:28:13.774000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "general",
        "parent": "",
        "content": "why would anyone want to compute that in DeFi? ðŸ™‚",
        "created_at": "2020-07-09T06:28:32.352000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The simplest case that is not uncommon is with Uniswap.",
        "created_at": "2020-07-09T06:40:39.941000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "`(x + added_x) * (y - removed_y) = constant` ends up as a quadratic equation when `added_x` and `removed_y` can be expressed as a function of the other.",
        "created_at": "2020-07-09T06:41:45.586000+00:00",
        "attachments": []
    },
    {
        "author": "80raghavendra",
        "category": "general",
        "parent": "",
        "content": "I talked about polynomial  commitments for witness compression. It is a beginner to intermediate level deep dive. Feedback invited. https://youtu.be/1Iaxr6FP3VU",
        "created_at": "2020-07-09T10:46:28.894000+00:00",
        "attachments": []
    }
]