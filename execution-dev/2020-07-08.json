[
    {
        "author": "phabc",
        "category": "general",
        "parent": "",
        "content": "How easily accessible to smart contracts will state proofs become once we have somesort of statelessish Ethereum? Would be nice for contracts to be easily able to verify a witness such that they could use data of past blocks more easily. Thinking of things like Uniswap moving average over n blocks, etc. Would open up to some interesting applications and could reduce state bloat. Might want to expose more than 256 blockashes for it to be even more useful too.",
        "created_at": "2020-07-08T18:44:15.955000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cjadler\u003e Statelessness is orthogonal to that. The real blocker is forwards-compatible FFI functions for verifying proofs. See this twitter thread, which is unfortunately sparse since Johnson is currently banned from Twitter: https://twitter.com/jadler0/status/1260243252780904450. (re @eth1x_bridge_bot: \u003cPhABC\u003e How easily accessible to smart contracts will state proofs become once we have somesort of statelessish Ethereum? Would be nice for contracts to be easily able to verify a witness such that they could use data of past blocks more easily. Thinking of things like Uniswap moving average over n blocks, etc. Would open up to some interesting applications and could reduce state bloat. Might want to expose more than 256 blockashes for it to be even more useful too.)",
        "created_at": "2020-07-08T18:55:25.593000+00:00",
        "attachments": null
    },
    {
        "author": "phabc",
        "category": "general",
        "parent": "",
        "content": "Quite sparse indeed. Are there already state proof validation functions in geth and other clients?",
        "created_at": "2020-07-08T18:58:17.553000+00:00",
        "attachments": null
    },
    {
        "author": "phabc",
        "category": "general",
        "parent": "",
        "content": "Rationale for mentionning statelessness is that state proofs would now be a first class citizen of any Ethereum clients, which hopefully would make it easier to convince the community of the benefits of exposing such verification to contracts as well.",
        "created_at": "2020-07-08T19:00:30.509000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cjadler\u003e Yes, it's part of the LES spec: https://github.com/ethereum/devp2p/blob/master/caps/les.md#getproofs-0x08. (That's for generating proofs, but presumably any client that can act as a light node can also verify proofs.) It's also a requirement for fast sync and beam sync. It really is just a trivial change to expose this functionality as an FFI function. (re @eth1x_bridge_bot: \u003cPhABC\u003e Quite sparse indeed. Are there already state proof validation functions in geth and other clients?)",
        "created_at": "2020-07-08T19:03:57.332000+00:00",
        "attachments": null
    },
    {
        "author": "phabc",
        "category": "general",
        "parent": "",
        "content": "Makse sense, so what is the main thing holding such an FFI function as a pre-compile then? Lack of champion and EIP?",
        "created_at": "2020-07-08T19:18:58.806000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cjadler\u003e Money don't grow on trees\nI got bills to pay, I got mouths to feed\nThere ain't nothing in this world for free\nhttps://youtube.com/watch?v=e2Z0sON2UPc (re @eth1x_bridge_bot: \u003cPhABC\u003e Makse sense, so what is the main thing holding such an FFI function as a pre-compile then? Lack of champion and EIP?)",
        "created_at": "2020-07-08T19:27:44.596000+00:00",
        "attachments": null
    },
    {
        "author": "phabc",
        "category": "general",
        "parent": "",
        "content": "Money grows on merkle trees though",
        "created_at": "2020-07-08T19:58:15.398000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cchriseth\u003e Why was the wasm-for-precompiles never adopted?",
        "created_at": "2020-07-08T21:16:51.381000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cjadler\u003e Because of this ðŸ‘†",
        "created_at": "2020-07-08T21:23:48.080000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Some technical reasons follow. Perhaps there are other reasons.",
        "created_at": "2020-07-08T22:59:23.682000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "1) The Wasm spec was only finalized recently by W3C, which delayed everyone. Now there are many useful Wasm features coming (interface types, reference types, multimem, bulkmem) which would be wise to wait for because they will allow a better design.",
        "created_at": "2020-07-08T23:00:29.136000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "2) Wasm-for-precompiles does not directly address the state growth problem. Wasm-for-precompiles may indirectly address the state growth by helping stateless dapps with (i) compression algorithms to reduce calldata size, and (ii) persistent linear memories which are more flexible than 32-bytes storage chunks. This direction has open questions.",
        "created_at": "2020-07-08T23:02:13.453000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "3) \u003c@!425274498732916736\u003e 's evmone innovations (fast bigint, checks at basic-block level, etc) give enough performance for everything but the most expensive cryptography (pairings). Although Wasm is faster, it is not orders-of-magnitude faster. It would be pragmatic to first push evm to its limits, then identify whether there is need for more performance.",
        "created_at": "2020-07-08T23:03:57.458000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "4) Fear of correctness and attacks. Until a few months ago, we didn't even have a Wasm engine which we consider reasonable for consensus.",
        "created_at": "2020-07-08T23:04:27.163000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "5) Hardware variance prevents accurate and precise metering. I have examples of code with 140x slowdowns for the same gas because of hardware cliffs. So even with Wasm, we must still have conservative metering. If we have conservative metering, then there remains a performance gap. If there is a performance gap, then there is a reasonable case for native precompiles for the most expensive crypto (pairings). But \u003c@!425274498732916736\u003e 's vision for evm may be fast enough for everything but the most expensive cryptography.",
        "created_at": "2020-07-08T23:08:04.676000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "6) Eth2 is around the corner. Any added complexity to Eth1 may hinder the merging of Eth1 and Eth2.",
        "created_at": "2020-07-08T23:08:59.555000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "Those reasons address Wasm-for-precompiles. A separate topic is Wasm-for-general-blockchain-computation -- with guarantees, ecosystem, and performance, Wasm is difficult to beat as a general VM for blockchain.",
        "created_at": "2020-07-08T23:16:04.089000+00:00",
        "attachments": null
    },
    {
        "author": "pauld.9606",
        "category": "general",
        "parent": "",
        "content": "These are just my opinions.",
        "created_at": "2020-07-08T23:16:48.354000+00:00",
        "attachments": null
    }
]