[
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "\u003c@628018527470616606\u003e ‚òùÔ∏è",
        "created_at": "2022-06-22T06:13:32.106000+00:00",
        "attachments": null
    },
    {
        "author": "lukaszrozmej",
        "category": "Testing",
        "parent": "",
        "content": "Yes thx for the links, we are actively investigating Ropsten issues, we have some regressions from recent changes too.",
        "created_at": "2022-06-22T08:12:50.953000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "\u003c@360491619402776577\u003e I was doing some of the Nimbus\u003c-\u003eGeth testing. Afaik Nimbus have now made a change that allows them to sync with Geth - but from a non-dev perspective, this change looks oddly specific. Instead of giving Geth a post-TTD fcU, they now give Geth an fcU closer to wherever its head is at, at the time. With the post-TTD fcU, Geth doesn't get state and can't complete sync to TTD. With the \"close to head of Geth\" fcU, it can.\nThat can't be as designed, can it?",
        "created_at": "2022-06-22T11:27:26.721000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "\u003c@654267572107083777\u003e can explain what was done, and how the interop behaves, better than I can. I'm happy to run tests and provide debug logs.",
        "created_at": "2022-06-22T11:29:58.647000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "Yes it is, nodes only maintain the snapshots (that we use to snap sync from) for the last 128 blocks. So to finish the sync we need to get a fcu within 128 blocks of the head",
        "created_at": "2022-06-22T11:47:51.525000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "It seems unclear how to trigger even a state sync on the blocks it already claims to have block header-synced though",
        "created_at": "2022-06-22T11:51:04.692000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "So in practical terms: I was syncing CL and EL from scratch, and CL hits TTD first. Geth is somewhere in the 11mil, so still a bit away from TTD. It now gets a post-TTD fcU and it can't complete sync: Instead, I am hearing, it needs an fcU within 128 blocks of where its head is at so it can complete the sync. This behavior then seems to depend on where Geth's pre-TTD sync is at, when the CL hits TTD, and possibly even as to which sync mode Geth uses.\n\nDoes this require a spec adjustment, or is that requirement to send an fcU close to head already covered by spec?",
        "created_at": "2022-06-22T11:55:56.245000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "No it needs a head withing 128 blocks of the current head of other nodes not of its own. It's not dependent on where we are in our sync pre-TTD. It is dependent on snap sync mode yes",
        "created_at": "2022-06-22T11:57:33.290000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "This is already a requirement in the spec",
        "created_at": "2022-06-22T11:57:47.130000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "That the CL continuously gives us their best head",
        "created_at": "2022-06-22T11:58:06.600000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "Okay. So then maybe the current behavior isn't as designed after all? Afaik, and please keep me honest here tersec:\n- When CL gives Geth their best head, Geth cannot sync to TTD\n- When CL gives Geth a head closer to Geth's current head, Geth can sync to TTD",
        "created_at": "2022-06-22T11:58:44.886000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "There are doubtless nuances to this behavior that I am not understanding or recounting correctly",
        "created_at": "2022-06-22T11:59:29.350000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "It should be exactly the opposite",
        "created_at": "2022-06-22T11:59:58.787000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "- When CL gives Geth their best head, Geth should be able to sync\n- When CL gives Geth a head closer to Geth's current head, Geth might not be able to sync",
        "created_at": "2022-06-22T12:00:27.926000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "\"their best head\" doesn't imply the rest of what you wrote",
        "created_at": "2022-06-22T12:00:50.982000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "I have debug logs of that behavior where CL hits TTD first, gives Geth an fcU of their best head, and Geth can't sync. Happy to share.",
        "created_at": "2022-06-22T12:00:59.602000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "https://github.com/ethereum/consensus-specs/blob/dev/sync/optimistic.md\n\u003e Optimistic sync is designed to be opt-in and backwards compatible (i.e., non-optimistic nodes can tolerate optimistic nodes on the network and vice versa). Optimistic sync is not a fundamental requirement for consensus nodes. Rather, it's a stop-gap measure to allow execution nodes to sync via established methods until future Ethereum roadmap items are implemented (e.g., statelessness).",
        "created_at": "2022-06-22T12:01:42.328000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "Even if it turns out Geth is behaving as designed after all in that case, and the fcU needed to be somehow different, additional eyes on this would be immensely useful",
        "created_at": "2022-06-22T12:01:46.826000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "Yeah logs would be great",
        "created_at": "2022-06-22T12:02:44.574000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "Sorry I meant best optimistic head, otherwise snap sync does not work",
        "created_at": "2022-06-22T12:03:16.117000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "Debug logs are here: \u003chttps://www.dropbox.com/s/7iyl1n2x6g8jt7g/nimbus-pr3773-geth-latest-beaconheader-syncissue.tgz?dl=0\u003e",
        "created_at": "2022-06-22T12:03:32.481000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "You can still full sync without optimistic heads",
        "created_at": "2022-06-22T12:03:32.689000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "\" When CL gives Geth a head closer to Geth's current head, Geth might not be able to sync\" -- right so that makes me think that maybe, the current workaround Nimbus put in place is not optimal, as now sure Geth syncs, but now it's in undefined territory where it \"might not be able to\".",
        "created_at": "2022-06-22T12:04:57.643000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "I guess you meant full sync w/o optimistic heads pre-TTD, but post-TTD EL would need to know the head from CL to continue syncing",
        "created_at": "2022-06-22T12:06:14.186000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "And thank you for digging into this, Marius. Hugely appreciate the time. I just want to get to my happy place, and that's where I can sync any client combo from scratch and feel secure that it's all happening per-spec and in a well-defined manner üôÇ",
        "created_at": "2022-06-22T12:06:33.983000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "One concern I have is that this creates an ad-hoc, unwritten effective set of conditions for successful sync not listed anywhere in the engine API or CL specs.",
        "created_at": "2022-06-22T12:14:24.095000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "This kind of thing creates a \"folk-knowledge protocol\" where one has to effectively target specific implementations, not a spec, and that's suboptimal for the health of a spec.",
        "created_at": "2022-06-22T12:15:09.105000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "All snap sync implementations (and fast sync for that matter, just with more leeway) work like this",
        "created_at": "2022-06-22T12:39:40.316000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "So judging from the logs we get a bunch of NewPayloads for `12,350,713` at `DEBUG[06-18|13:31:32.906`. According to etherscan this block was mined `Jun-08-2022` so 10 days earlier https://ropsten.etherscan.io/block/12350713\nThis means that all nodes have lost this state for now and can not serve the snap sync",
        "created_at": "2022-06-22T12:42:04.086000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "It can and should be written somewhere. It is the case for ALL EL implementations",
        "created_at": "2022-06-22T12:43:17.276000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "They all need crypto economically validated heads to sync",
        "created_at": "2022-06-22T12:43:38.742000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "No matter the sync strategy",
        "created_at": "2022-06-22T12:43:44.898000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Erigon who block transitions from genesis also needs good heads to reverse header sync and forward block sync",
        "created_at": "2022-06-22T12:45:17.547000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "Well, cryptoeconomically validated heads aren't equivalent to heads within 128 blocks of EL chain tip though",
        "created_at": "2022-06-22T12:46:17.210000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "The optimistic sync is \"opti-in\" in two manners\n\n1. If you have another way to send cryptoeconomic heads, great, do it\n2. If you have a lockstep, Genesis sync with some special implementation, that could work too",
        "created_at": "2022-06-22T12:46:22.412000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "(or whatever other small threshold block count; 128 is slightly arbitrary)",
        "created_at": "2022-06-22T12:46:46.594000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Continuously sending what you get from network would give you that except in extreme conditions at which some nodes might have trouble until you do",
        "created_at": "2022-06-22T12:46:57.848000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Also, engine api has been written with SYNCING in such a way as to imply that CL continues to send heads even if not fully validated. If that is not clear enough, we can and should clear it up",
        "created_at": "2022-06-22T12:47:37.305000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "The invariant for all ELs is \" if CL continues to send recent cryptoeconomic heads, EL will be able to eventually sync\"",
        "created_at": "2022-06-22T12:50:50.564000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "And \"head\" is important part of that statement. Not just random blocks somewhere in the tree",
        "created_at": "2022-06-22T12:52:18.207000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "So optimistic sync as specified is \n1. Not related to consensus rules (thus optional)\n2. Not the only way to send heads (thus optional)\n\nBut engine api assumes (and should be written more explicitly) that heads are sent",
        "created_at": "2022-06-22T12:54:57.095000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "Agreed it should be more explicit, it clearly caused confusion.",
        "created_at": "2022-06-22T13:12:00.997000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "In a practical manner, this makes optimistic sync not entirely opt-in: Users will want to use EL snap sync, for example, and this requires optimistic sync from the CL, if I am following this discussion.\nI am not sure that having this requirement is desirable from a protocol standpoint. And I wonder how it interacts with checkpoint sync on the CL side, which is fast becoming a recommendation.",
        "created_at": "2022-06-22T13:13:21.711000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "If EL expects to receive blocks that are near to its current head from CL to be able to sync then something is definitely wrong on EL side. EL should expect to see the head of canonical chain, and further receiving follow-up updates of the head. If CL follows the Optimistic Sync spec its behaviour must meet EL's expectations",
        "created_at": "2022-06-22T13:40:26.913000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "\"If EL expects to receive blocks that are near to its current head from CL to be able to sync then something is definitely wrong on EL side.\" certainly seems to be happening. State sync does not seem to trigger, even on existing pre-TTD blocks with some (non-Erigon, which has its own approach) near-current... not even head, exactly, but known-about-blocks. Geth still says its `latest` block (see also the EIP155 discussion) is the genesis block",
        "created_at": "2022-06-22T13:42:54.923000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "I guess geth will keep saying that genesis is the `latest` until snap sync is finished",
        "created_at": "2022-06-22T13:44:26.419000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "The ELs I've tested (in the last few days, Erigon, Geth, and Nethermind) all claim to stop syncing at [or near, for Nethermind -- they choose a slightly different pivot] TTD, so certainly for Erigon \u0026 Geth, providing the TTD + 1 block should be ahead of their local chains",
        "created_at": "2022-06-22T13:44:55.114000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "And a CL isn't in a position to provide any pre-TTD EL blocks",
        "created_at": "2022-06-22T13:45:22.045000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "even now for Geth\n```\n\u003e eth.getBlockByNumber('latest').number\n\"0x0\"\n```\n\nit's synced to very near tip",
        "created_at": "2022-06-22T13:46:36.701000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "and still\n```\nError: chain not synced beyond EIP-155 replay-protection fork block\n        at web3.js:6365:9(45)\n        at send (web3.js:5099:62(34))\n        at \u003ceval\u003e:1:12(3)\n```",
        "created_at": "2022-06-22T13:46:54.826000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "If state isn't available in the network (which I guess is the case for TTD + 1 block) then EL won't be able to finish state sync. If it would be a block sync then I see no obstacle for it to be accomplished",
        "created_at": "2022-06-22T13:47:19.429000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Is it state or block synced?",
        "created_at": "2022-06-22T13:47:38.395000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "state, or at least enough to be CL-finalized with `VALID` blocks through very recent epochs",
        "created_at": "2022-06-22T13:48:08.294000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "e.g.\n```\n{\"lvl\":\"DBG\",\"ts\":\"2022-06-22 13:41:46.038+00:00\",\"msg\":\"newPayload: inserting block into execution engine\",\"parentHash\":\"8af305f0\",\"blockHash\":\"eb363f3d\",\"stateRoot\":\"c7f6315c\",\"receiptsRoot\":\"a13f0470\",\"prevRandao\":\"b4690313\",\"blockNumber\":12446479,\"gasLimit\":30000000,\"gasUsed\":5410637,\"timestamp\":1655901540,\"extraDataLen\":0,\"baseFeePerGas\":{\"data\":{\"lo\":{\"lo\":14,\"hi\":0},\"hi\":{\"lo\":0,\"hi\":0}}},\"numTransactions\":20}\n{\"lvl\":\"DBG\",\"ts\":\"2022-06-22 13:41:46.051+00:00\",\"msg\":\"runForkChoiceUpdated: running forkchoiceUpdated\",\"headBlockRoot\":\"eb363f3d\",\"finalizedBlockRoot\":\"8ffb17e5\",\"payloadStatus\":\"VALID\",\"latestValidHash\":\"Some(0xeb363f3dd47fbde2c08395f9ff52468b802dff14eb01f15787a26f38e88b8ae5)\",\"validationError\":\"None[TaintedString]\"}\n```\ni.e. https://ropsten.etherscan.io/block/12446480",
        "created_at": "2022-06-22T13:53:41.198000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "```\n{\"lvl\":\"DBG\",\"ts\":\"2022-06-22 13:54:49.757+00:00\",\"msg\":\"runForkChoiceUpdated: running forkchoiceUpdated\",\"headBlockRoot\":\"d9c1462b\",\"finalizedBlockRoot\":\"8ffb17e5\",\"payloadStatus\":\"VALID\",\"latestValidHash\":\"Some(0xd9c1462b076808a3034c2d6653df5b5e64c704d2bba6febbb0e14f90cbc039db)\",\"validationError\":\"None[TaintedString]\"}\n```\nhttps://ropsten.etherscan.io/block/12446509 etc",
        "created_at": "2022-06-22T13:58:13.448000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "I am interpreting `VALID` in the response to `fcU` as a signal that EL sync has converged and it now has a state to lock-step forward",
        "created_at": "2022-06-22T13:59:30.749000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "that seems to be what Geth does, at least (well, for `newPayload` anyway): https://github.com/ethereum/go-ethereum/blob/7c7cd410d178df851bd86528e5acc29e5e70eafd/eth/catalyst/api.go#L315-L333",
        "created_at": "2022-06-22T14:01:27.034000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "This is something that I don't understand. If `chainId` is defined in `genesis.json`, why `eth_chainId` can't return its value from the config cc \u003c@360491619402776577\u003e",
        "created_at": "2022-06-22T14:04:04.176000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "well, and even if that weren't possible somehow, so, the chain is synced well past EIP-155, to appearances",
        "created_at": "2022-06-22T14:06:11.139000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Any state sync algorithm requires EL to know a canonical chain block that the network has a state for. A block with available post-state is a moving target because of state trie pruning. This is why we have optimistic sync as the only practical way of supplying EL with the right target for state sync. The state is available for a span of blocks close to the head which is constantly updating\n\nBlock sync post-Merge may be done in the following way (as an alternative to optimistic sync):\n1) CL starts up from a checkpoint, sends the checkpoint payload to EL and waits for EL to get synced to this block\n2) CL lock-steps onwards after EL finishes the first part of the sync\nIn this case no block is required to be imported optimistically.",
        "created_at": "2022-06-22T14:49:04.765000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "But the latter can also be done with optimistic sync which makes it a generic sync approach which makes CL agnostic to a specific sync algorithm used by EL",
        "created_at": "2022-06-22T14:53:06.441000+00:00",
        "attachments": null
    },
    {
        "author": "yorickdowne",
        "category": "Testing",
        "parent": "",
        "content": "Right. That agnostic approach really is required from a practical UX standpoint. A CL that tells its users \"works only with EL full sync\" is going to have a lot of support requests. Fair enough that this is how it works.\nNot sure what can be done in the spec to clarify how it works. Since this wasn't entirely clear the way it's written, some form of clarification seems desirable.",
        "created_at": "2022-06-22T15:05:39.124000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "The way the optimistic sync work is written in its spec. What we have recently discussed sounds more like a rationale behind supporting optimistic sync by client implementations, and I think we may add this rationale to avoid further confusion to the Optimistic Sync spec rationale section. I'll make it a try",
        "created_at": "2022-06-22T15:31:47.290000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "The core part for me is that ELs require only certain blocks to initiate the required state sync, so one can follow the engine API as written and still end up with nonresponsive ELs.",
        "created_at": "2022-06-22T15:58:14.260000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "This `eth_getBlockByNumber('latest')`/`eth_chainId` thing might be separate, because it's happening regardless, apparently of sync status, and it seems probably (?) specific to Geth",
        "created_at": "2022-06-22T15:59:39.464000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "There is an Optimistic Sync spec that CL should follow aside to Engine API, if CL client chooses to support optimistic sync",
        "created_at": "2022-06-22T16:00:35.621000+00:00",
        "attachments": null
    }
]