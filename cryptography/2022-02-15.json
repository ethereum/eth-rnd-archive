[
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Apple has no solution for GPGPU since they dropped OpenCL.\n\nAlso ARM hardware has a 2x inherent slwdown compared to x86 for bigint arithmetic due to lacking 64x64 -\u003e 128 multiplication.",
        "created_at": "2022-02-15T09:54:13.996000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I recently read something comparing pairings on ARM and x86 with timings (was it? https://uwspace.uwaterloo.ca/bitstream/handle/10012/6722/Grewal_Gurleen.pdf) but it was a paper from over a decade ago.\nBut even then current ARM needs 2 instruction for extended multiprecision multiplication (MU and UMULH: http://arith24.arithsymposium.org/slides/s2-liu.pdf)\n\nPretty sure there were some website with OpenSSL benchmarks somewhere at the release of M1.",
        "created_at": "2022-02-15T10:01:08.984000+00:00",
        "attachments": [
            {
                "type": "image/png",
                "origin_name": "unknown.png",
                "content": "88a136873c1bb5e246a997f8c4a488130af443ebb16a7266c618ba8bf995b19d"
            }
        ]
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Now ARM CPU have the very big advantage of not being starved for registers.\nRe: GPU, it's likely powerful enough. One way to be portable across Apple/Intel/AMD/Nvidia would be to target LLVM IR, and have LLVM JIT the GPU code, it can also target DX12 or OpenGL shaders.\n\nThat would require bundling LLVM but it would avoid having to bundle Cuda kernels on Windows (ethminer style) and installing OpenCL isn't straightforward as well (especially in CI).",
        "created_at": "2022-02-15T10:04:51.042000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also Apple is expensive as well.",
        "created_at": "2022-02-15T10:05:41.978000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What are the target processors for such comparison, if I remember correctly something like the A72 of a raspberry pi 4 could do both MUL and UMULH in parallel with a latency of 1 clock tick, the cost of having to use different registers to store the result and thus being able to pipeline them in parallel is minimal if you have 32 X registers",
        "created_at": "2022-02-15T12:09:13.216000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "oh interesting. That was a paper from 2010~2012. I don't remember a recent paper with pairings on ARM unfortunately. And I didn't get to add ARM assembly to my library yet.",
        "created_at": "2022-02-15T14:25:05.138000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "pipelining for A64 is quite interesting, specially in the situation you're describing. I'm talking out of my butt, but I imagine you can perform a bunch of vector additions for example but are forced to do these multiplications in the scalar unit. So you can alternate NEON instructions at a latency/throughput of 3/2 with the scalar ones at a latency/throughput of 1/2  and be able to run them all in parallel since they use different units.",
        "created_at": "2022-02-15T14:28:54.601000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "at least that's the situation when you do SHA256 with several buffers at a time",
        "created_at": "2022-02-15T14:30:24.672000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "you can also do this with SSE or AVX on x86 (but  not mixing both there are penalties).\n\nBut you need to change the representation of bigints to avoid carries",
        "created_at": "2022-02-15T14:35:38.950000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'll have to play with this https://github.com/MariusVanDerWijden/gpusnarks",
        "created_at": "2022-02-15T14:36:56.361000+00:00",
        "attachments": null
    }
]