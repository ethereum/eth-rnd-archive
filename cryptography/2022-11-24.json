[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Couldn't you just encrypt the hash of the message?",
        "created_at": "2022-11-24T15:46:34.501000+00:00",
        "attachments": null
    },
    {
        "author": "frozenfire.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If an adversary knows the set of possible messages (as one does in this case), then `encrypt(pk, H(message))` can be computed for every possible message and then compared to ones which are otherwise published. This would reveal which message is being encrypted without having to know the private key.",
        "created_at": "2022-11-24T21:09:11.328000+00:00",
        "attachments": null
    },
    {
        "author": "frozenfire.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This would similarly be the case if one just includes entropy in the encryption process (`encrypt(pk, H(r + message))`), because the private key holder would need to know the entropy in order to know what message was encrypted.\n\nThe person publishing that encrypted message would have to publish both the entropy and the encrypted message, and so an adversary can just check every message with that entropy.",
        "created_at": "2022-11-24T21:11:56.322000+00:00",
        "attachments": null
    },
    {
        "author": "frozenfire.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I suppose maybe I could do `encrypt(pk, r + H(message))` where len(r) + len(H(message)) is constant. Then the output can be decrypted, r can be discarded, and H(message) can be used.",
        "created_at": "2022-11-24T21:19:18.489000+00:00",
        "attachments": null
    }
]