[
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes indeed characteristic 2 would be perfect for me. If they're fast that'd be great. I'll look into the ones you mentioned for implementation. Even if they're not secure it would be nice to know the attack surface here. The attack vector for Ethereum would be to produce two different blocks with the same commitments and signature but different root, so it is two fold. In the one hand it will be a way for a proposer to avoid a slashing but in a perfectly identifiable way. So doesn't seem to be so bad. The other attack is the bad one: it is a way for a malicious operator to DOS the system with garbage blocks that pass signature verification or even worse to send his own blocks. But this has to be done very fast and only after having seen the original block. After all for what I want this is only for gossip so any collision needs to be found in a manner of milliseconds. Perhaps these curves are more than secure under these restrictions?",
        "created_at": "2025-01-26T00:15:15.382000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Just to be precise on the problem. If we split the block/blob in N chunks. Then we need to send N scalars, N points and a signature with each chunk. This is the extra data that's added to the current gossip mechanism. So these are in total N^2 scalars and points and N signatures that need to fly. The signatures are contstants and unavoidable. The points I hardly think we can make less than 32 bytes. But the scalars is where we can gain by having 1 byte instead of 32, it saves 3KB per block which is not negligible and it also makes decoding faster",
        "created_at": "2025-01-26T00:20:28.065000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Difference in CPU performance among these is huge",
        "created_at": "2025-01-26T00:21:20.668000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh interesting, I think that if the group elements being used in the pedersen commitment do not change and the size of the pedersen commitment is not too large, then you could trade off memory to potentially get a faster pedersen commitment. \n\nThis would apply for Ristretto and secp256k1",
        "created_at": "2025-01-26T00:36:25.458000+00:00",
        "attachments": null
    }
]