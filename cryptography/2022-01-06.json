[
    {
        "author": "justindrake",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e There's a super simple and elegant scheme that allows anyone to encrypt arbitrary messages to future values of a threshold BLS randomness beacon like Drand (https://drand.love). Basically, anyone can encrypt a message to the `n`th  round of Drand, and as soon as the beacon produces the `n`th random output (scheduled to happen at a well-defined point in time) anyone can immediately decrypt the corresponding encrypted messages. Encryption and decryption are cheap and don't require special hardware like VDF evaluators. The main downside is the threshold assumption: you're trusting a `t`-of-`n` committee (`n` is roughly 20 for Drand). If the threshold assumption is not acceptable then I'm happy to expand on time-based cryptographic primitives (like delay encryption https://eprint.iacr.org/2020/638.pdf and homomorphic timelock puzzles https://eprint.iacr.org/2019/635.pdf).",
        "created_at": "2022-01-06T07:55:15.139000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Can something similar be done with the Beacon chain RANDAO, or does the thing need to be designed specifically for this use case?",
        "created_at": "2022-01-06T08:33:05.873000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I do like the idea of drand, and it *may* work for my specific use case.  However, I do not like the assumption of 20-person trust if it can be avoided.",
        "created_at": "2022-01-06T08:33:38.108000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Do the other two you mentioned require everyone who wants to know the result do the full VDF, or can one person complete the VDF and then share their result with everyone (who can trustlessly verify it)?",
        "created_at": "2022-01-06T08:34:42.737000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I guess the `V` in VDF implies you can skip to the last step once anyone has shared the result, but I want to make sure the encryption mechanism doesn't require all of the steps in-between.",
        "created_at": "2022-01-06T08:35:10.320000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For the first paper, they answer it in the paper:\n\u003e When the auction key associated with the auction identifier is known, anyone in possession of it can decrypt all bids and determine the winner",
        "created_at": "2022-01-06T08:37:23.718000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So I think that one would work for me.  Not a fan of trusted setups, but I think in this case that is quite reasonable.",
        "created_at": "2022-01-06T08:37:38.534000+00:00",
        "attachments": null
    },
    {
        "author": "justindrake",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Can something similar be done with the Beacon chain RANDAO\n\nNot without very fancy cryptography (too fancy to be practical today) like witness encryption.\n\n\u003e Do the other two you mentioned require everyone who wants to know the result do the full VDF, or can one person complete the VDF and then share their result with everyone (who can trustlessly verify it)?\n\nDelay encryption and homomorphic timelock puzzles only require one person to evaluate the VDF and then share the output and proof with everyone.",
        "created_at": "2022-01-06T08:50:51.396000+00:00",
        "attachments": null
    },
    {
        "author": "justindrake",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "**background on threshold BLS beacons**: You have `n` secret shares `s_i` held by `n` committee members where any `t` shares are sufficient to recover the master secret `s` by interpolation. The master secret is hidden in a public parameter `P = s * G_1`. In round `r` committee members are invited to release `s_i * hash_to_G2(r)` and the random output is `Q = s * hash_to_G2(r)` obtained by interpolation.\n\n**key idea**: As the encrypter I'm going to hide a random 256-bit `nonce` that can be recovered by anyone once `Q` is public. Specifically, I'll publish `A = nonce * G1` and `B = nonce XOR sha256(nonce * e(P, hash_to_G2(r)))`. Notice that when `Q` is public `nonce` can be recovered as `B XOR sha256(e(A, Q))`. For actual encryption of a message `M` is suffices to encrypt against `nonce` (e.g. as `M XOR nonce`).",
        "created_at": "2022-01-06T09:10:53.405000+00:00",
        "attachments": null
    },
    {
        "author": "justindrake",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Here's a more detailed writeup https://protocollabs.notion.site/protocollabs/Timelock-Encryption-drand-f5df65a54a6641dfa77f9b8168c9b90b",
        "created_at": "2022-01-06T10:07:12.448000+00:00",
        "attachments": null
    }
]