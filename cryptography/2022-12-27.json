[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Optimizing for size, what is the best accumulator for an ever growing (never shrinking or mutating) set of values that will allow you to prove that a particular value is in the set, without needing knowledge of the full set (only knowledge of the accumulated value)?",
        "created_at": "2022-12-27T07:45:29.637000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One could imagine the most naive implementation which is the full set of values are just appended to the accumulator.  You could take this a step further by \"compressing\" the accumulator in some way.  But I'm hopeful there is some sort of fancy-math way to store a single value or two that one can use to check to see if the value is part of the set.",
        "created_at": "2022-12-27T07:47:32.539000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Do you care about non-membership ,can two different users prove membership of the same value and do you know in what context these values are added to the accumulator?",
        "created_at": "2022-12-27T10:16:02.874000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I care about being able to *definitively* say that X was part of the accumulation (so a bloom filter won't work), which I think implies that I must necessarily be able to infer non-membership?  However, if there is some situation where I can get certainty about inclusion without certainty about non-inclusion that is fine (but weird).",
        "created_at": "2022-12-27T10:18:06.068000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If you can present a value that was part of the accumulation, then the function should return true.  Doesn't matter how many users call it, or when, or anything like that.",
        "created_at": "2022-12-27T10:18:48.431000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Just a simple `isInSet(data): boolean`",
        "created_at": "2022-12-27T10:19:11.520000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Wouldnâ€™t an append-only merkle tree work?",
        "created_at": "2022-12-27T10:19:46.879000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, but proving you are in the tree requires knowing the whole tree I believe?",
        "created_at": "2022-12-27T10:20:02.792000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or at least, knowing enough to generate a proof.",
        "created_at": "2022-12-27T10:20:08.471000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And since the merkle tree changes with every addition, it means to generate a proof you need everything after your item was appended as well.",
        "created_at": "2022-12-27T10:21:10.568000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is there a timeframe in which one will generate proofs?",
        "created_at": "2022-12-27T10:23:03.189000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or is it feasible that I prove membership for a value that is 100 years old for example",
        "created_at": "2022-12-27T10:23:42.052000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No time constraint.",
        "created_at": "2022-12-27T10:25:15.095000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You may need to prove something was included a long time ago.",
        "created_at": "2022-12-27T10:25:22.295000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One algorithm that comes to mind is utreexo, but Iâ€™d need to re-read it when I get on my laptop as itâ€™s been a while",
        "created_at": "2022-12-27T10:25:41.015000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You need both the prover and the verifier to have constant storage? Ie the person who is calling IsInSet also does not have knowledge of the full state \n\nIf the verifier can grow unbounded, they can store all of the historical merkle roots",
        "created_at": "2022-12-27T10:29:47.826000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "or well they can store a tree which holds all of the merkle roots\n\nProving then requires you to prove that the merkle root you have is a part of the historical roots, then you show that your value is a part of that merkle root",
        "created_at": "2022-12-27T10:29:53.165000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Both the prover and the verifier need to be similarly small.",
        "created_at": "2022-12-27T10:35:21.091000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Merkle roots is how this problem has historically been solved.  It is just unfortunate that the prover needs to have access to the latest version of the tree to prove inclusion.",
        "created_at": "2022-12-27T10:36:44.292000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For an unbounded accumulator, this becomes problematic.",
        "created_at": "2022-12-27T10:37:04.782000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You could do a *little* better by having trees *eventually* stop accumulating and roll over to another tree and have the `isInSet` function take an array of merkle roots and it proves that your item is in at least one of the trees.",
        "created_at": "2022-12-27T10:37:43.661000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not if they can prove membership of their historical root ðŸ¤”",
        "created_at": "2022-12-27T10:38:11.384000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Then at least there is a constrained window of time that you need to track tree changes before you can stop, but it still requires you track tree changes *after* your item is included, and if you don't know *which* tree your item was included in you need to have all of the trees to find it.",
        "created_at": "2022-12-27T10:38:39.208000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Isn't that the same problem still, just recursive?",
        "created_at": "2022-12-27T10:39:43.838000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh right, the prover would need to ask the verifier for the merkle path for their historical root or the verifier would need to have a lookup table for historical roots (which would mean they are no longer succinct)\n\nNaively, Iâ€™d say you can achieve this if there is some relationship between the values that can be exploited or if you are okay with using stronger assumptions, then instead of a merkle tree accumulator, you can use a pairing based accumulator or an rsa accumulator",
        "created_at": "2022-12-27T10:50:18.390000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I believe this is the state of the art for dynamic accumulators based on pairings: https://eprint.iacr.org/2008/539.pdf or https://www.cs.yale.edu/homes/cpap/published/accumEUROSP2017.pdf",
        "created_at": "2022-12-27T10:50:59.999000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Iâ€™m not sure what it is for rsa unfortunately, Iâ€™d have to search a bit more",
        "created_at": "2022-12-27T10:56:17.849000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Looked a little bit and several people have asked the same question to some degree, and they are always led to direct mapped cashes, eg. \u003chttps://cstheory.stackexchange.com/questions/6596/a-probabilistic-set-with-no-false-positives\u003e",
        "created_at": "2022-12-27T10:58:00.290000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "With this, if you are replacing elements, then I think you canâ€™t say for sure if a value was in the multiset",
        "created_at": "2022-12-27T11:02:43.825000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, that is unfortunate.  ðŸ˜¢",
        "created_at": "2022-12-27T11:21:53.233000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I *think* I have looked into RSA accumulators before and they didn't fit my needs for some reason, but I don't remember why... I think it was that the prover still needs to know the full set at some point in time?",
        "created_at": "2022-12-27T11:23:50.910000+00:00",
        "attachments": null
    }
]