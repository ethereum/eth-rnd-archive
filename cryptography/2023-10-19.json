[
    {
        "author": "pcaversaccio",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "hey guys, happy to announce our initiative about helping support the NIST ECC Bug Bounty: https://twitter.com/pcaversaccio/status/1715021011576320011. TL;DR: For `secp256r1`, the seed is `c49d360886e704936a6678e1139d26b7819f7e90` and we donâ€™t know how it has been exactly calculated. That is what this bounty essentially seeks to change. Apparently, it's something close to \"SHA1(\"Jerry deserves a raise\")\". Would appreciate spreading this initiative \u0026 any donations are ofc welcome ðŸ˜ƒ",
        "created_at": "2023-10-19T15:27:26.374000+00:00",
        "attachments": null
    },
    {
        "author": "elliottdehn",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So if we're talking about \"login\" on the blockchain, we need to use ZK Proofs so that the password doesn't leak. However, can't someone sniff the ZK proof you use to login and use it themselves ahead of you? How do we make ZK proofs such that we provide an expected salt (address of prover) to an unknown password? Can anyone tell me how something like login could be made to work without front-running? Thanks.",
        "created_at": "2023-10-19T17:55:37.603000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ERC-4361 / Sing-in with Ethereum is likely the system you want instead of ZKP.  Comparing it to a traditional password login system instead of hashing the password and storing the hash the password creates a public/private key pair and the public key is stored where a hash would be stored.  The \"salt\" is the challenge login message used by login with ethereum (which has a nonce to serve as salt anyway).",
        "created_at": "2023-10-19T20:41:42.765000+00:00",
        "attachments": null
    }
]