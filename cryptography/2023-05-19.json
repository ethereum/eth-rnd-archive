[
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not much, my library is the fastest of the libraries I'm aware of.\n\nHere are the libraries I know: https://github.com/guild-of-zk/pairing-bench/tree/master/vendor\n\nThere are key low-level algortihm where you need a variable time for speed like inversion.\n\nFor MSM too, but for pairings you don't really need it. Even compared with Gnark or MCL I'm faster.",
        "created_at": "2023-05-19T05:48:33.978000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "4096 for KZG.\n\nI didn't optimize this one yet though. Focused on \u003c512 and \u003e16384 so far",
        "created_at": "2023-05-19T05:50:28.781000+00:00",
        "attachments": null
    },
    {
        "author": "paulmillr",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So thatâ€™s 40 ms per kzg batch single-threaded with the fastest library. \n\nFeels like JS impl perf would be too slow ðŸ¥¶",
        "created_at": "2023-05-19T05:52:20.446000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'll have to bench the wasm zprize single threaded. But wasm doesn't have \"add-with-carry\" and neither do MIPS or Risc, so they are really hindered for bigints.",
        "created_at": "2023-05-19T05:53:59.424000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I plan to create a JIT compiler for targets like Nvidia/Intel/AMD GPUs and Wasm.\n\nUnfortunately using raw uint256 even when the compiler provides the intrinsics is too slow, see https://forum.nim-lang.org/t/10187#67460\n\nI don't think the IR for zk I've seen so far (zkLLVM from Nil foundation, Zirgen from Riszc Zero, VampIR from Anoma) go so deep.\n\nI think there is 30% or so extra perf to get on GPUs or RiscZero VM or Optimism VM (cc \u003c@203220829473996800\u003e https://github.com/ethereum-optimism/cannon/wiki/Cannon-High-Level-Overview)\n\nAnd for an ISA to emulate I'm curious about the choice of RISC/MIPS vs the restricted ARM Thumbs-2 ISA.",
        "created_at": "2023-05-19T06:04:32.866000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The Cannon wiki is outdated, see notice on wiki home page. Iâ€™ve been working on updating it to work on top of our next upgrade, and itâ€™s getting faster too :). Also have been working on a RISC-V fault proof. That said, performance is less of an issue than ZK, since proof generation is already very viable on any machine, and onchain we bisect the work before doing a small proof of whatâ€™s left",
        "created_at": "2023-05-19T10:42:17.174000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Fault proofs are different from fraud proof?",
        "created_at": "2023-05-19T13:37:19.120000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Itâ€™s the same thing, but we donâ€™t like calling it fraud proof, since it implies malicious behavior, whereas bugs can also cause differences in truth",
        "created_at": "2023-05-19T15:26:46.264000+00:00",
        "attachments": null
    }
]