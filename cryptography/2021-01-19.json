[
    {
        "author": "m.kalinin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Speaking of concrete use case, BLS12-384 precompile is required for eth2 light client contract which would make e.g. withdrawals to eth1 technically possible before the merge happens.",
        "created_at": "2021-01-19T03:10:41.699000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Another such case may be to use Eth2.0 data availability in Eth1.0",
        "created_at": "2021-01-19T13:23:40.529000+00:00",
        "attachments": null
    },
    {
        "author": "alita85",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I worked on this for a bit (and am still working on it for fun üòÄ ), my 2 cents is that EVM384 is a functional / long-term solution and the precompile is a shot-term one. Elliptic curve in general stands to change the way that we do proof generation and is a big component for the future of cryptocurrency. It makes the most sense to me to deploy both the precompile and EVM384.",
        "created_at": "2021-01-19T16:00:53.607000+00:00",
        "attachments": null
    },
    {
        "author": "alita85",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "also in regards to auditing the EVM384 based BLS, it makes the most sense to me to build a new actually optimized compiler that's readable and designed around close to hardware implementations. Neither Huff or Yull offer this.",
        "created_at": "2021-01-19T16:03:42.103000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think the opposite is true.  IIUC, BLS **MUST** eventually be implement in each client because it is used in PoS.  If every client has a native implementation, it seems quite wasteful to *not* include it as a precompile.",
        "created_at": "2021-01-19T16:03:50.923000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So while EVM-384 may get us BLS on Ethereum *sooner*, we still will need to have native consensus compatible implementations on every client.",
        "created_at": "2021-01-19T16:04:30.888000+00:00",
        "attachments": null
    },
    {
        "author": "alita85",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Why would EVM-384 be sooner than a precompile?",
        "created_at": "2021-01-19T16:06:03.426000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For the reasons discussed in the call the other day and discussed at the top of this channel.  Core devs are worried about maintainability and risk of BLS, and that may be mitigated with enough time.",
        "created_at": "2021-01-19T16:07:04.265000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For example, after The Merge there will be more ETH2 devs working more directly with ETH1 devs (since it is all just one big Ethereum at that point), so skills to audit and fix BLS issues may become more readily available.",
        "created_at": "2021-01-19T16:07:46.895000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not suggesting that 384 **will** be available sooner.  Only that regardless of the timeline of 384, we still must eventually have native BLS on Ethereum, and thus a BLS precompile makes sense regardless of whether we have 384 or not by then.",
        "created_at": "2021-01-19T16:08:31.556000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That is to say, I feel like there are two questions:\n1. When native BLS on Ethereum? (The Merge at latest)\n2. Can we land 384 *before* ‚òùÔ∏è?",
        "created_at": "2021-01-19T16:09:04.394000+00:00",
        "attachments": null
    },
    {
        "author": "alita85",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah, I see what you mean. 384 itself (not including auditing the subsequent BLS implementations) is very straightforward and well-defined. It seems a lot easier to champion, anyway.",
        "created_at": "2021-01-19T16:10:53.241000+00:00",
        "attachments": null
    },
    {
        "author": "alita85",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But that's why I'm saying we do both",
        "created_at": "2021-01-19T16:11:08.813000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not against doing both.  I just want to make sure that it is clear to everyone that 384 doesn't mean we no longer have to implement native BLS.  It just means we are kicking the can down the road.  This may be beneficial, but we need to make sure that is fully recognized.",
        "created_at": "2021-01-19T16:12:15.436000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In many of the conversations I have seen on this topic, it wasn't clear to me that everyone realized that BLS is definitely landing on Ethereum in the medium future, regardless of what we decide today.",
        "created_at": "2021-01-19T16:12:45.888000+00:00",
        "attachments": null
    },
    {
        "author": "alita85",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also I just wanted to clarify one thing because I'm not certain that it's clear. EVM-384 (unless it has changed since I last saw it) is purely a math library that has a pretty standard byte-wise optimization for addition and multiplication. So it's just a library that would be used to make an actual BLS implementation run faster (the need was investigated and described by \u003c@!425279588009246720\u003e ). EVM-384 is not a BLS implementation in and of itself. I think this is known, but just making sure it's clear!",
        "created_at": "2021-01-19T16:28:16.713000+00:00",
        "attachments": null
    },
    {
        "author": "alita85",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "the whole point of the initial implementation of the BLS curve stuff using EVM-384 was a proof of concept for the on-chain performance. If it was like 10x slower than a native precompile it wouldn't make sense to add that math library to the EVM because it'd be useless. Basically, I think that EVM-384 and a native precompile are being considered as the same thing, but they are actually quite different in terms of the problem they're solving and they are not mutually exclusive.",
        "created_at": "2021-01-19T16:44:49.162000+00:00",
        "attachments": null
    },
    {
        "author": "s1na",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I want to raise the distinction between having BLS in the clients after the merge and exposing it to EVM",
        "created_at": "2021-01-19T16:57:30.853000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What is the argument for *not* exposing it to the EVM once it is part of consensus?",
        "created_at": "2021-01-19T16:58:04.511000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Good point. BLS in EVM *pre-merge* is valuable to allow applications to learn about eth2 prior to native integration\n\nBLS in EVM *post-merge* might just be easy, but isn't a requirement to leverage sharded data in eth2",
        "created_at": "2021-01-19T16:58:43.007000+00:00",
        "attachments": null
    },
    {
        "author": "s1na",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not sure which parts of the eth2 stack BLS is used (apart from signatures) but I feel like they might be more well-defined and have narrower attack surfaces than 9 precompiles which take arbitrary input",
        "created_at": "2021-01-19T16:59:11.127000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "all precompiles take arbitrary input",
        "created_at": "2021-01-19T17:07:33.592000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(in fact, all the call opcodes do)\n(in fact, the chain takes arbitrary input)",
        "created_at": "2021-01-19T17:08:08.438000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "there's a lot of understandable caution about adding functionality to the consensus process. but we're focusing a lot on concerns about specific changes rather than methods for gaining confidence in changes",
        "created_at": "2021-01-19T17:10:12.898000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "clearly we have a sufficiently high degree of confidence in enough cryptography to build two entire consensus systems. how can we reach the same degree of confidence in new cryptography/cryptographic APIs?",
        "created_at": "2021-01-19T17:10:52.012000+00:00",
        "attachments": null
    },
    {
        "author": "s1na",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "arbitrary input in comparison to say attesting to a block in eth2 which doesn't take user input, it's all client code",
        "created_at": "2021-01-19T17:12:43.731000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "a pubkey is user input",
        "created_at": "2021-01-19T17:13:08.110000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "so are signatures ü§î",
        "created_at": "2021-01-19T17:13:21.451000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "so are the serialized forms of each transmitted over the wire ü§î",
        "created_at": "2021-01-19T17:13:36.547000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I suspect that we have confidence that eth2 handles invalid inputs appropriately. I suspect that we can build the same confidence about a precompile",
        "created_at": "2021-01-19T17:14:16.234000+00:00",
        "attachments": null
    },
    {
        "author": "prestwich",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "what testing/verification processes helped us build confidence in eth1 \u0026 2s handling of invalid inputs, and how can we build the same confidence in new changes?",
        "created_at": "2021-01-19T17:15:33.154000+00:00",
        "attachments": null
    }
]