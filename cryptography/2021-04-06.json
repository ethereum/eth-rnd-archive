[
    {
        "author": "nicolas.alhaddad",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I agree with you about the niceness of having shares be valid BIP-39s. Therefore, I agree that you need to secret share the first 128 bit and not the full 132 bits. However, I would go for GF(2^128) instead of GF(256). There is a chance where some people would want verifiable secret sharing (computational hardness). In that scenario, you wonâ€™t be able to use GF(256) the Field is small and discrete log is not hard. However, Discrete log is hard in GF(2^128) and GF(2^256). Verifiable secret sharing is needed where share holders want to verify that they got good consistent shares. A private key holder can distribute shares to individuals and each individual can check that his share is correct against a commitment to the polynomial holding the initial secret. Another place where having valid secret shares (GF(2^128) and GF(2^256)) is nice is with threshold signatures (Falls under MPC as i previously stated). Share holder can sign together a transaction (especially with schnorr (tap root is coming to bitcoin maybe to ethereum?). (The only reason why working using 128 bit numbers and 256 numbers is not efficient is probably because you don't have 128 bit and 256 registers but it's okay. There are many libraries that will take care of this for you. In python integers have infinite precision....  Here is code that works in 2^128 with valid shares. https://replit.com/@nicolas3355/BIP-39-secret-sharing#main.py). That being said, the second argument I made about threshold signatures is weird: together they hold a seed (not the private key) so if they want to sign (they need an MPC version of the deterministic key generation) I take back my argument about signing being easy.",
        "created_at": "2021-04-06T14:31:43.689000+00:00",
        "attachments": null
    }
]