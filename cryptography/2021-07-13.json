[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Are there any cryptographic primitives where you can start with a 256-bit number, apply a transformation that results in a new evenly distributed 256-bit number (like a hashing algorithm would output), but where you can identify that the resulting number was the result of that transformation?",
        "created_at": "2021-07-13T03:43:07.877000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It doesn't have to be reversible (though that is also acceptable), I just need the ability to make one of the following two statements about a well distributed 256-bit number:\n\u003e * this number was generated by running some value through the \u003cwhatever\u003e algorithm\n\u003e * this number was not generated by running some value through the \u003cwhatever\u003e algorithm\"",
        "created_at": "2021-07-13T03:44:24.870000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is \"some value\" known here? If so, I think a fixed bitmap to be xor'ed with the number fits all these requirements. If not, I'm not sure it's feasible since any number could be the image of any other (or if you restrict the image domain to a subset of the 256-bit space, you end up with a huge probability of false positive)",
        "created_at": "2021-07-13T09:31:40.238000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, the person trying to identify whether the value they are given was run through the algorithm doesn't know the original value.",
        "created_at": "2021-07-13T11:39:19.462000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think I want something like a hash function where all output hashes are internally CRC checked or something.",
        "created_at": "2021-07-13T11:39:54.874000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ideally without sacrificing any bits solely for CRC checking.",
        "created_at": "2021-07-13T11:40:19.100000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nuint160 hash = algorithm(preimage)\n```elsewhere```\n// preimage not available here, but also not a secret\nif (isAlgorithmOutput(hash)) { ... }\nelse { ... }\n```",
        "created_at": "2021-07-13T11:41:43.218000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e the way I read your question is: *Let `k = F_{2^256}`, is there a function `f: k -\u003e k` such that given `a \\in k` we can discern wether there exists `b \\in k` such that `f(b) = a`?*.  I think this is is an ill-posed problem. For `f = 0`  then the question becomes is `is a = 0?`. Now to make `f` increasingly interesting as a hashing function you'd want to have a smaller kernel. But then in the extreme, when `f` is injective youÂ´d  get that the answer is always 'yes' for any value of `a`. So unless you specify what's a reasonable size for the image of this function there's no way anyone can really reply as far as I can see here.",
        "created_at": "2021-07-13T11:56:09.369000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I only understood about half of what you said here, can you dumb it down for me a bit?",
        "created_at": "2021-07-13T11:57:15.023000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The actual use case is address space extension.  We have 32-byte addresses that we \"compress\" into 20 byte addresses for backward compatibility.  Tentative plan is to just hash the 32 byte address and truncate the high bits.",
        "created_at": "2021-07-13T11:58:32.088000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "However, there would be significant value if we can differentiate at runtime whether an address we are given is a compressed long address or not.",
        "created_at": "2021-07-13T11:58:49.458000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So I'm trying to figure out a way to differentiate compressed addresses from regular addresses, and my thinking was maybe there was some clever cryptographic primitive that has properties similar to hashing (collision resistance), but is watermarked.",
        "created_at": "2021-07-13T11:59:50.890000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Then we can differentiate by looking for the watermark.",
        "created_at": "2021-07-13T11:59:56.980000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One proposed solution is to find some unused sequence of bits in Ethereum's current address space and set all compressed addresses to use those bits, but that reduces the bits of entropy in compressed addresses a lot, and it risks regular addresses colliding with it.",
        "created_at": "2021-07-13T12:01:13.622000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ok, so clearly you will have many 32-byte addresses that will map into the same 20-byte address by whatever algorithm you choose, it does not matter what algorithm you choose. Having accepted that, then you need to decide if it's important to reduce the image of this algorithm or not. If you want an algorithm that does not lose entropy besides the obvious already lost one by shrinking from 32 bytes to 20 bytes, then the answer will be no: for any 20 byte address there will exist a 32 that maps to it. If you are willing to reduce further down the size of the image then you may find addresses that are not in the preimage, an extrreme case is when the algorithm takes any 32 byte address and returns the 20 bytes 0x00.  So it is a matter of how much you want to reduce further your address space. You cannot avoid doing something which will end up being mathematically equivalent to using some unused bits.",
        "created_at": "2021-07-13T12:05:52.979000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm.  ðŸ¤”  And I suppose that in order to prevent legacy addresses from \"looking like\" compressed addresses, we would need to sacrifice quite a bit of entropy on the compressed addresses.",
        "created_at": "2021-07-13T12:12:38.050000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One could introduce some kind of checksum for example at the expense of too much entropy.",
        "created_at": "2021-07-13T12:14:51.144000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I am not following what's going on on address space extension, but if the plan is to have 32 byte addresses to simply have more addresses but at the same time allowing old code to interact with these addresses using a 20 byte compression of those, then there's something clearly wrong at least in my mind: you can only have as much security as the size of your address space, so by providing this functionality to old applications you will effectively be shrinking back the 32 byte address space, so why extend it in the first place.",
        "created_at": "2021-07-13T12:16:22.495000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We want a path to a future where we do have security.",
        "created_at": "2021-07-13T12:16:58.949000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "160 bits is *probably* enough entropy for today, but it *probably* won't be enough in 5 years.",
        "created_at": "2021-07-13T12:17:08.020000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The compressed address stuff is an attempt at backward compatibility during the transition.",
        "created_at": "2021-07-13T12:17:48.300000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\"during transition\" which will last years ðŸ™‚",
        "created_at": "2021-07-13T12:18:03.787000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What does \"entropy\" refer to here?",
        "created_at": "2021-07-13T12:19:45.651000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's probably impossible to prevent the compressed addresses from colliding with legacy addresses right?",
        "created_at": "2021-07-13T12:20:24.695000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "you can prevent this happening if legacy addresses do not use the entire 160bits",
        "created_at": "2021-07-13T12:21:34.538000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but what you cannot prevent for sure is two 32 bytes addresses colliding in their shrinked form",
        "created_at": "2021-07-13T12:21:55.294000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Going back to the original formulation, if you map 32 bytes numbers to 32 bytes number, but the valid pool of images is only say `2^(20*8)` items, then your `is_mapped(uint32B)`  predicate returns a false positive with probability `1/(2^(12*8))`",
        "created_at": "2021-07-13T12:22:29.862000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So even \"not using the entire 160 bits\" is not enough if you don't tolerate false positives.",
        "created_at": "2021-07-13T12:22:54.280000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Of course, that probability is fairly small...",
        "created_at": "2021-07-13T12:25:09.148000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Do you mean:\n\n- Let K = Sha256(Address32)\n- Remove first 12 bytes from K to make TK (TK is now 20 bytes)\n- Let K' = Sha256(TK)\n- Let NewAddress = First 12 bytes of K' || TK\n\n?",
        "created_at": "2021-07-13T12:29:15.089000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I mean to make some bytes of the 20-byte address a checksum. Potentially the checksum has to refer to the rest of the publicly visible bits, otherwise it is not possible to distinguish them without knowing the long form.\n\ni.e. `compressed = C || TK` where `TK` is 17 bytes and zero padded on the left, and `C` is the \"checksum\" of `TK`, shrunk to 3 bytes.\n\n(In this I use the vague checksum word, but can be part of a hash, etc. And use the arbitrary 3-bytes prefix, but have no claim whether that is adequate or not.)",
        "created_at": "2021-07-13T13:10:40.359000+00:00",
        "attachments": null
    }
]