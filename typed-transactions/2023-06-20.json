[
    {
        "author": "timbeiko",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Interesting ðŸ¤” !",
        "created_at": "2023-06-20T14:30:36.056000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I had an idea that would allow to reap benefits of _both_ normalized and union TX formats, and could also allow introduction of SSZ transaction types without conversion step.\n\nâ€“ Forget how `Optional` and `Union` work in SSZ for now, they are not used in production yet.\n\nâ€“ Add new SSZ type, `PartialContainer` (or whatever name).\n   1. Serialization: \n       â€“ `BitVector`/`BitList` at start, indicating what fields are defined. e.g., 8 bytes, or 16, or variable.\n       â€“ For each 0, simply skip the field, do not emit anything.\n       â€“ For each 1, encode the field normally. With the usual varlen vs fixedlen shenanigans.\n       â€“ Entire `PartialContainer` is always treated varlen, if embedded in outer structures.\n   2. Merkleization: \n       â€“ At the top, mix that `BitVector`/`BitList` in, similar to `List` `__len__`.\n       â€“ For each 0, merkleize as a 0. This way, if fields are added in the future, existing hash_tree_roots remain same!!\n       â€“ For each 1, merkleize regularly. Note that each field is always merkleized at the exact same location in the tree, regardless of presence/absence of others.\n   \nâ€“ `Transaction` would be a `PartialContainer`, with the `BitVector`/`BitList` indicating what fields are present.\nâ€“ During consensus/payload validation, enforce that only certain combinations are allowed, and unknown bits are rejected.\nâ€“ A smart contract can become futureproof! If it only cares about from/to/value, it will magically be compatible with all future tx types.\n\nTo avoid conversion on newPayload/getPayload, we would have to add two fields:\nâ€“ `from` â€” 20 bytes `ExecutionAddress`. This way, legacy RLP based transactions can be processed by smart contracts / light clients the same way as SSZ based transactions. During newPayload, add a check that `from` matches `ecrecover`. \nâ€“ `contract_destination` â€” 20 bytes `ExecutionAddress` for CREATE transactions. This way, clients do not require `from` + RLP + keccak to compute it.\n\nIf this sounds good, will spec it out.",
        "created_at": "2023-06-20T22:09:39.471000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Regarding the last point, in SSZ transaction formats, we would essentially include `from` and `contract_destination` and sign over them. While the two fields would be computed for RLP transactions on `engine_getPayload` , and verified on `engine_newPayload`",
        "created_at": "2023-06-20T22:11:57.547000+00:00",
        "attachments": []
    }
]