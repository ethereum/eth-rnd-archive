[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "At the All Core Devs call we decided on no SSZ for Berlin.  This means we can narrow down to one of these two options for the encoding of 2930 transactions (see above for advantages/disadvantages):\n```py\n// RLP multi-pass\n1 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, access_list, sendrV, senderR, senderS])\n// RLP single-pass\n1 || rlp([[senderV, senderR, senderS], rlp([1, chainId, nonce, gasPrice, gasLimit, to, value, data, access_list])])\n```\ncc \u003c@!211091239112671234\u003e",
        "created_at": "2020-11-27T15:43:28.777000+00:00",
        "attachments": []
    },
    {
        "author": "holiman",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Cc \u003c@194432762315407360\u003e",
        "created_at": "2020-11-27T15:52:41.954000+00:00",
        "attachments": []
    },
    {
        "author": "holiman",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm slightly in favour of multipass personally",
        "created_at": "2020-11-27T15:53:32.590000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e Multipass is the first one.  I call it that because in order to validate the transaction, you first have to deserialize it, then extract some pieces, then serialize it, then validate the signature.",
        "created_at": "2020-11-27T15:58:27.265000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The second option has the signed_data already serialized in the proper format while on the wire.",
        "created_at": "2020-11-27T15:58:42.990000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, my ‚ùì was intended to ask for the reason behind that preference from \u003c@!211091239112671234\u003e",
        "created_at": "2020-11-27T15:58:54.530000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!211091239112671234\u003e Oops, those samples don't include ChainID.  I'll fix that but it doesn't change much.",
        "created_at": "2020-11-27T15:59:01.162000+00:00",
        "attachments": []
    },
    {
        "author": "holiman",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Because it's what we already use, more or less. I suspect the gain from rlp singlepass is not that great compared to sig verification. Plus one would probably decode/encode anyway to ensure its canonicalized",
        "created_at": "2020-11-27T16:09:36.079000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, a non-canonical transaction is valid in a block or over the wire?",
        "created_at": "2020-11-27T16:12:06.534000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or are you saying they *aren't* valid, and you need to check that as part of your validation logic?",
        "created_at": "2020-11-27T16:12:26.881000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think he's saying that you would still need to actually decode the *other* part to do the additional pieces of validation logic like checking the nonce (or even just checking that it is actually well formed)",
        "created_at": "2020-11-27T16:18:34.673000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But I don't see that as a reason to prefer multi-pass.  Since we're going to have to change the logic anyways, I think the \"single-pass\" approach is a more intuitive API/structure. (assuming I interpreted your (martin) reasoning correctly)",
        "created_at": "2020-11-27T16:20:40.581000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Are secp256k1 signatures more expensive to generate than validate?",
        "created_at": "2020-11-27T16:21:27.977000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One argument for single pass is that it minimizes the amount of work you do before validating that a potential attacker did *more* work.  I think the counterargument here is that RLP encoding/decoding has epsilon cost so this won't have any real impact.",
        "created_at": "2020-11-27T16:22:39.590000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That argument assumes that secp256k1 signature generation is more costly than signature validation, but I don't know if that is true.",
        "created_at": "2020-11-27T16:23:08.162000+00:00",
        "attachments": []
    }
]