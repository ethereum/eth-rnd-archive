[
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A new aswesome feature, a new awesome channel",
        "created_at": "2020-11-22T04:13:36.792000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://eips.ethereum.org/EIPS/eip-2718",
        "created_at": "2020-11-22T04:13:42.618000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://eips.ethereum.org/EIPS/eip-2976",
        "created_at": "2020-11-22T04:13:49.368000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "",
        "created_at": "2020-11-22T04:13:59.675000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "",
        "created_at": "2020-11-22T04:14:05.200000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "**IF** all of the major SSZ libraries support unions, then we still have the problem of legacy transactions.",
        "created_at": "2020-11-22T04:14:30.928000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The current top suggestion for handling legacy transactions (in my mind) is to use the already leading byte as the transaction type (of which there are 3 possible values).  This is totally not compatible with an SSZ Union.",
        "created_at": "2020-11-22T04:15:45.394000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If we are willing to eat the problem of transaction hashes changing around the fork block, things become much simpler because we can simply define legacy transactions as some new SSZ payload (no RLP in it at all) and just define the signing scheme to RLP encode first.",
        "created_at": "2020-11-22T04:16:39.709000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The latter would let us have SSZ for everything as of Berlin, and we could even have the transactions root and receipts root be `ssz.hash_tree_root`s.",
        "created_at": "2020-11-22T04:17:33.313000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We wouldn't even need to worry much about deprecating legacy transactions long term, though that will happen naturally with 1559 I suspect.",
        "created_at": "2020-11-22T04:18:20.340000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If we can't get union support in all major SSZ libraries soon enough, then things look much more bleak.",
        "created_at": "2020-11-22T04:18:53.782000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I would like to explore how to handle the tx hash change at the time of the hard fork",
        "created_at": "2020-11-22T04:19:18.602000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My thinking is that clients could maintain two mappings in-memory of hash to transaction, one for each hashing mechanism.  That way someone doing a lookup of pre-fork hash can find the transaction after the fork, and vice versa.",
        "created_at": "2020-11-22T04:20:02.391000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "They would do this for maybe a week or two around the fork block and then could delete the code for handling that.",
        "created_at": "2020-11-22T04:20:13.528000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Making the roots a `hash_tree_root` would be nice w.r.t. merkle proofs: each leaf would be `H(HTR(value), type_index)`, and the tree would be a simple binary tree, with length mixed with the contents root for the final list HTR.",
        "created_at": "2020-11-22T04:20:33.126000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, \u003c@!364458974906548225\u003e managed to sell me on the virtues of recursive merkle proofs, allowing us to prove individual bits of data within a transaction within a block somewhere in history without having to fetch the whole thing.",
        "created_at": "2020-11-22T04:21:20.031000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Which is why I would really like to eventually got to a place where we have SSZ everywhere in the block.",
        "created_at": "2020-11-22T04:21:38.692000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One worry I have is the hashing costs (computational costs) of full merklization of the transaction and receipt though.",
        "created_at": "2020-11-22T04:22:30.851000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yea, it's great if it's done in a complete way. You can navigate merkle trees through the full eth2 state and transitions history. And with some clever shortcuts too, to make proofs short",
        "created_at": "2020-11-22T04:22:57.552000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, I just realized there is no complete SSZ library for C#.  \u003c@!489256758989029405\u003e does Nethermind just have its own SSZ library?",
        "created_at": "2020-11-22T04:33:20.322000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm guessing \u003chttps://github.com/NethermindEth/cortex-ssz\u003e is it, but the readme says:\n\u003e Does not yet support uint128, uint256, or union types. Does not yet support deserialization.",
        "created_at": "2020-11-22T04:33:47.887000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003chttps://github.com/sgryphon/cortex-ssz\u003e in the implementations list appears to just be a fork of the Nethermind one that is older than the Nethermind `cortex-ssz` library.",
        "created_at": "2020-11-22T04:36:10.167000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So let's say a transactions list would look like the naive ssz representation:\n```\nMAX_TRANSACTIONS = 2**15  # Not sure, each 2 means one deeper layer in list tree for every proof\nTransactionList = List[Transaction, MAX_TRANSACTIONS]\nTransaction = Union[LegacyTransaction, FooBar, Example, ManyMore, FutureOptions, JustAppendThem]\n```\nThe serialization wouldn't be pretty: A SSZ Union (as currently defined) is dynamic length (can't know the length with selecting between different types), and has a 4 byte selector.\nThis means that each element in `TransactionList` will have an offset (4 bytes at the start of the list), and a selector (right before the actual element).\nThe merkleization would be quite nice: a binary tree of transactions, of fixed depth. Wrapped with the length like `H(contents_root, uint256(length))`, and each leaf is `H(HTR(value), uint256(selector))`. So you can make nice binary proofs for any index, proof which type, and proof only a few contents of the value, if the value is SSZ typed. If the value is not SSZ typed, it would just be a `List[Byte, MAX_VALUE_LENGTH]`, and get encoded just as a flat bytes slice, and merkleized as a binary tree of 32 byte slices of it.\n\nThe merkleization looks better than a patricia tree IMHO, thanks to nice proofs and faster speed (easy to optimize logic for hashing a small binary tree).\nThe serialization needs work. The Union type was never used in Eth2, so we can change its definition to be more efficient. However, offsets are here to stay, focused at faster lookup speeds (See https://gist.github.com/karalabe/3a25832b1413ee98daad9f0c47be3632 for its origin, quick data lookups are neat)",
        "created_at": "2020-11-22T04:37:43.265000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That link is from when SSZ was still a proposal, haha. It even used transaction lists as example:\n\u003e A previous proposal called Simple Serialization (SSZ) achieved many of the simplicity requirements for primitive data types, but it incurs O(N) access time for complex dynamic types (e.g. list of transactions). This spec defines an alternative that guarantees O(log N) access times for arbitrary nested data.",
        "created_at": "2020-11-22T04:40:05.774000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "SSZ then adopted the offset feature of SOS",
        "created_at": "2020-11-22T04:40:17.346000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My only complaint about the offsets is that they are from the start of the object rather than the offset itself.",
        "created_at": "2020-11-22T04:40:24.935000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You mean that offsets can encode numbers that point back to the offsets? Yea, that's a little ugly. It has some weird nice side effects, but it is what it is.",
        "created_at": "2020-11-22T04:41:20.554000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Such offsets would be invalid fyi",
        "created_at": "2020-11-22T04:41:48.537000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nContainer[uint8, List[uint8, 0xff], uint16]\n// encodes as\n0xaa06000000bbbbcccccc\n// where `aa` is the first uint8`, `bbbb` is the uint16, and `cccccc` is the list\n\n// would rather it encode as\n0xaa02000000bbbbcccccc\n```",
        "created_at": "2020-11-22T04:44:11.467000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Only dynamic-length fields and elements would have an offset",
        "created_at": "2020-11-22T04:44:54.609000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, notice the `06` vs `02` in the two examples.",
        "created_at": "2020-11-22T04:45:10.503000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I want the offset to be \"offset from here\" rather than \"offset from back there\".",
        "created_at": "2020-11-22T04:45:22.544000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A `Vector[uint8, 0xff]` doesn't have an offset",
        "created_at": "2020-11-22T04:45:45.026000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "it's fixed length",
        "created_at": "2020-11-22T04:45:49.805000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh, sorry.  I meant the other one... `List` is it?",
        "created_at": "2020-11-22T04:45:59.678000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yep",
        "created_at": "2020-11-22T04:46:04.406000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Fixed.  ðŸ™‚",
        "created_at": "2020-11-22T04:46:11.484000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sorry for nitpicking, just making sure we get this right. Nice pun, fixed the to make it dynamic",
        "created_at": "2020-11-22T04:46:56.418000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\"offset from here\" has two nice properties:\n1. You don't have to remember history, you are always moving forward while decoding.\n2. You can prepend things on the stream without breaking the offsets.",
        "created_at": "2020-11-22T04:47:22.228000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This came up with typed transactions where it would be nice if `ssz(type, payload)` was the same as `type || ssz(payload)` (which would be true if we used \"offset from here\").",
        "created_at": "2020-11-22T04:47:55.868000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I know it is too late now to change these things, I'm just lamenting.",
        "created_at": "2020-11-22T04:48:31.527000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "explain point 2 please? If you are prepending things, then are you not breaking direct lookups (compared to O(n) searches), what offsets are for, completely?",
        "created_at": "2020-11-22T04:48:39.574000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It allows for enveloping with fixed length prefixes where all you need to change is the schema, not the serialized bytes.",
        "created_at": "2020-11-22T04:50:06.953000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```py\nContainerA = Container[uint8, List[uint8, 0xff]]\nContainerB = Container[uint8, uint8, List[uint8, 0xff]]\nmyBytes = 0xaabb00000000cccccc\ndecodedA = decode(myBytes.slice(1), ContainerA)\ndecodedB = decode(myBytes.slice(0), ContainerB)\nassert decodedA[1] == decodedB[2]\n```",
        "created_at": "2020-11-22T04:52:21.022000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The same byte stream can be decoded with two different schemas starting from different points in the stream, as long as the only difference between the schemas is additional fixed length items on the front.",
        "created_at": "2020-11-22T04:52:52.206000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This is convenient when you have layers of envelopes, like typed transactions.",
        "created_at": "2020-11-22T04:53:06.713000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah that makes sense, thanks",
        "created_at": "2020-11-22T04:53:50.097000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Another example would be if you had a byte array containing a signed transaction, where the signature came first.  You could choose to skip over the signature and deserialize only the signed data (since the signature is fixed length).",
        "created_at": "2020-11-22T04:54:51.471000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, in SSZ you can just define it as an envelope then though: `ContainerB = Container[uint8, ContainerA]`, and it doesn't cost you much ~~anything~~ (another offset, ha)",
        "created_at": "2020-11-22T04:55:09.234000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, but that assumes you are keeping the envelope around.",
        "created_at": "2020-11-22T04:55:30.962000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```py\ntype = transaction.slice(0,1)\npayload = transaction.slice(1)\ndelete transaction\nswitch(type) {\n    case 5: return processType5(payload)\n}\n```",
        "created_at": "2020-11-22T04:56:41.815000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Very trivial example meant to illustrate the point.  ðŸ™‚",
        "created_at": "2020-11-22T04:56:49.582000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Inside `processType5` we no longer have the outer layer, we only have the inner layer.",
        "created_at": "2020-11-22T04:57:09.049000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh, actually I think I see what you are saying.",
        "created_at": "2020-11-22T04:57:27.063000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I guess you are saying that you can achieve what I describe above by just throwing a Container around your variable width portion...",
        "created_at": "2020-11-22T04:58:24.087000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nTransaction = Container[v, r, s, nonce, gasPrice, gasLimit, value, to, Container[data]]\n```",
        "created_at": "2020-11-22T04:58:56.752000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yea, pretty naive solution, but it works I guess. Let's try optimize the real thing though, not a weird example, and we may find something more useful",
        "created_at": "2020-11-22T04:59:18.085000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I should use the new reply function. Above was intended for the throwing comment, not the Transaction def",
        "created_at": "2020-11-22T05:00:03.205000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The real example is typed transactions.  Because legacy transactions exist, we want the leading type byte to be separate from the following payload, because the following payload may not always be SSZ.",
        "created_at": "2020-11-22T05:00:19.109000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Though, I think at this point I no longer need to solve that particular problem, because there are other worse problems to deal with.  ðŸ˜¬",
        "created_at": "2020-11-22T05:01:18.195000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And my lamenting above isn't particularly productive anymore due to that, just me whining a bit.",
        "created_at": "2020-11-22T05:01:36.944000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Such is life",
        "created_at": "2020-11-22T05:01:45.585000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I am going to keep that \"wrap the dynamic data in a Container\" trick in my pocket though.  I kind of suspect it is going to come up at some point...",
        "created_at": "2020-11-22T05:02:14.149000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And in fact, I kind of want to just *always* do that.",
        "created_at": "2020-11-22T05:02:24.516000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "~~Hmm, but isn't the container itself dynamic sized, so you have the same problem?~~ Don't answer this, it is way too into the weeds.",
        "created_at": "2020-11-22T05:02:47.619000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ok, so TLDR: something with SSZ merkleization, but encoding that is so efficient, that offsets are cheap and selectors negligible?",
        "created_at": "2020-11-22T05:03:48.273000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In that case, sticking to some existing RLP encoding logic may be best, but just do the merkleization as if it were SSZ.",
        "created_at": "2020-11-22T05:05:32.845000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or we come up with something clever, and update the SSZ spec",
        "created_at": "2020-11-22T05:06:02.435000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My current dream world of unicorns and rainbows for typed transactions:\n1. All libraries implement Unions.\n2. We deal with the transient dual-hashing problem separately.\n3. All transactions are SSZ.\n4. Legacy transaction signatures are over `keccak256(rlp(legacy_tx))`, while all others are over `ssz_tree_root(tx)` where `tx` is `Union[Container[...], Container[...], ...]` and `legacy_tx` is derived from `tx`.",
        "created_at": "2020-11-22T05:07:37.901000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "5. Optional: Unions are limited to 255 items rather than 2^32 items.",
        "created_at": "2020-11-22T05:08:11.481000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In eth2 we wrap the hash_tree_root output with some signing data SSZ container, to then construct the \"signing root\". Can still do SSZ proof etc. on signature target, but with fork data. You might want to do something similar",
        "created_at": "2020-11-22T05:09:07.145000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I only understand half of those words.  ðŸ˜¬",
        "created_at": "2020-11-22T05:09:28.309000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "see https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/beacon-chain.md#compute_signing_root",
        "created_at": "2020-11-22T05:09:51.899000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e but with fork data\nThis is the half I don't understand.",
        "created_at": "2020-11-22T05:09:53.489000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Basically: compute the root, add some data to make the signature purposes clear, then sign it",
        "created_at": "2020-11-22T05:10:18.506000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What is an example of a domain?",
        "created_at": "2020-11-22T05:10:38.017000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh, scroll up 4 lines.",
        "created_at": "2020-11-22T05:10:53.980000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "E.g. we have an attestation domain, so that any signatures in other domains can not be a valid signature for some fabricated attestation. This way you can't accidentally sign two conflicting attestations, and never get slashed for no good reason",
        "created_at": "2020-11-22T05:11:35.666000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Would this, perhaps, be where chainID would live, rather than inside the transaction?",
        "created_at": "2020-11-22T05:12:05.784000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Currently, `chainId` is part of the transaction, but its only purpose is to limit signature validity to a particular chain.  It isn't actually part of the transaction for any other reason.",
        "created_at": "2020-11-22T05:12:35.209000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Maybe. It's omitted from the data, and assumed that the verifying context can guess it from configuration, then checks the signature, and then fails/passes",
        "created_at": "2020-11-22T05:13:12.685000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "See `compute_domain` definition right above that function I linked, that's what we do in eth2",
        "created_at": "2020-11-22T05:13:34.918000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sounds like a perfect fit for chain ID.",
        "created_at": "2020-11-22T05:13:36.317000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Would even save us some bytes on the wire.",
        "created_at": "2020-11-22T05:13:49.843000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yea, we put the eth2 fork version there",
        "created_at": "2020-11-22T05:13:53.213000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is the plan with ETH2 to have each hard fork be a new fork version?",
        "created_at": "2020-11-22T05:14:10.020000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(I'm hoping you say yes)",
        "created_at": "2020-11-22T05:14:13.891000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "As well as the \"genesis validators root\", so if some chain with different origin is similar enough to use the same fork version, they are still different",
        "created_at": "2020-11-22T05:14:37.458000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes",
        "created_at": "2020-11-22T05:14:50.527000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And things like deposits use a zeroed genesis validators root, and genesis fork version, to always be valid",
        "created_at": "2020-11-22T05:15:08.658000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Now you are thinking with merkles!",
        "created_at": "2020-11-22T05:15:26.642000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Someone should create a Portal derived meme for \"Now you're thinking with Merkles\".",
        "created_at": "2020-11-22T05:16:30.113000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Anyway, hope this helped, just think we want some better encoding strategy, but hashing/signing should be clear enough for some progress. Will think about it, but have to go now",
        "created_at": "2020-11-22T05:16:36.119000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Thanks!",
        "created_at": "2020-11-22T05:16:48.127000+00:00",
        "attachments": null
    }
]