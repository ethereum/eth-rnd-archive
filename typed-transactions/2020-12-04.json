[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "IIUC, you are proposing the following?\n```\nrlp([Type0, Payload0, Type1, Payload1, ..., TypeN, PayloadN])\n```",
        "created_at": "2020-12-04T01:50:54.136000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, that‚Äôs it",
        "created_at": "2020-12-04T01:55:05.339000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not personally a fan.  Heterogeneous lists are more complex to process than homogeneous lists, and the type and the payloads are tightly coupled tuples which I dislike splitting (again, because it slightly complicates processing).",
        "created_at": "2020-12-04T02:07:05.373000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In both cases, the lists are heterogeneous",
        "created_at": "2020-12-04T02:07:49.551000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "~~I don't believe this is true?~~",
        "created_at": "2020-12-04T02:08:57.396000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah, it depends on how you handle legacy internally.",
        "created_at": "2020-12-04T02:09:18.942000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "1) we have tx items and byte arrays\n2) we have tx items, type bytes",
        "created_at": "2020-12-04T02:09:36.857000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If you treat legacy transactions as typed transactions with types `0xf8-0xfa` then it is heterogeneous.",
        "created_at": "2020-12-04T02:10:00.432000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I‚Äôm not sure how they can be homogeneous? Unless you wrap legacy txs in a byte array?",
        "created_at": "2020-12-04T02:13:55.136000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "At the list chunking stage of processing, treat them all as Typed Transactions.",
        "created_at": "2020-12-04T02:21:25.217000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Which means switch on the first byte, dispatch to appropriate transaction processor based on that byte.",
        "created_at": "2020-12-04T02:21:55.796000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But that means we‚Äôd have to wrap legacy txs in byte arrays?",
        "created_at": "2020-12-04T02:23:55.635000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If we wanted them homogeneous, I think the only ways is to byte array wrap each tx - otherwise txs with types will always be different. Switching on the length byte of legacy txs is different than a type byte because after the type byte is the length prefix of the payload.",
        "created_at": "2020-12-04T02:25:42.372000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, you can just treat the first byte of legacy transactions as a type byte.  There are only 3 possible (in reality) leading bytes.",
        "created_at": "2020-12-04T02:28:51.645000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So there would be 3 legacy transaction types in this model.",
        "created_at": "2020-12-04T02:29:17.502000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But that is different than a typed tx - the typed tx goes `type || payload len || payload` and the legacy tx goes `type (also length) || payload`",
        "created_at": "2020-12-04T02:30:42.361000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Correct.  It really depends on how you architect things internally.\n```py\nfor (transactionBytes in transactionList):\n  switch (transactionBytes[0]):\n    case 1:\n      process2930(transactionBytes.slice(1))\n      break\n    case 0xf8:\n    case 0xf9:\n    case 0xfa:\n      processLegacy(transactionBytes)\n      break\n    default:\n      throw\n```",
        "created_at": "2020-12-04T02:35:37.912000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There are some other designs of course, that is just one that is made possible and is nice and simple if you have a homogeneous list.",
        "created_at": "2020-12-04T02:36:12.073000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```py\ntype = txBytes[0]\npayload = txBytes.slice(1)\nswitch (type)\n  case 1: process2930(payload)\n  case 0xf8:\n  case 0xf9:\n  case 0xfa:\n    processLegacy([type, ...payload])\n``` is another similar and possible design.",
        "created_at": "2020-12-04T02:38:01.336000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Back to the original point though, to get to the two designs you‚Äôve shown, we‚Äôd need to first parse out those bytes of an RLP byte array",
        "created_at": "2020-12-04T03:05:42.392000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It‚Äôs more optimal to not do that. I‚Äôm not sure if there is a downside I‚Äôm missing to approach 2?",
        "created_at": "2020-12-04T03:11:55.809000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, why is it optimal to not parse the RLP array?",
        "created_at": "2020-12-04T03:43:19.412000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I believe have to parse the full array to check the bounds, then parse to get out the actual tx",
        "created_at": "2020-12-04T03:44:06.610000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```py\ntxList = rlp_decode(messageBytes)\nfor (txBytes in txList):\n  type = txBytes[0]\n  payload = txBytes.slice(1)\n  switch (type):\n    case 1:\n      process2930(payload)\n      break\n    case 0xf8:\n    case 0xf9:\n    case 0xfa:\n      processLegacy([type, ...payload])\n      break\n ```",
        "created_at": "2020-12-04T03:45:02.432000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, can you type up some pseudocode to show what you mean?  I don't think I'm following.",
        "created_at": "2020-12-04T03:45:29.708000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah, you are using a streaming RLP decoder perhaps?",
        "created_at": "2020-12-04T03:46:03.352000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes it‚Äôs a streaming decoder",
        "created_at": "2020-12-04T03:46:47.091000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You *should* still be able to stream process I think?",
        "created_at": "2020-12-04T03:49:36.867000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In your example, it seems like you‚Äôre assuming that every txs is a byte array, but 2718 only defines typed txs to be a byte array - legacy are RLP elements",
        "created_at": "2020-12-04T03:49:51.269000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The first bytes of an RLP list item are its length IIRC.",
        "created_at": "2020-12-04T03:49:53.668000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It is a byte array from the perspective of the outer RLP list.",
        "created_at": "2020-12-04T03:50:13.019000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A byte array is prefixed by b8-bf, this is slightly different than an RLP element",
        "created_at": "2020-12-04T03:51:09.968000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nrlp([\n  rlp([nonce, gasPrice, gasLimit, to, value, data, v, r, s]),\n  1 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, r, s])\n  ...,\n])\n```",
        "created_at": "2020-12-04T03:52:05.387000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Both of those list items are byte arrays according to the outer `rlp` list.",
        "created_at": "2020-12-04T03:52:24.663000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So really it is the following in terms of rlp types:\n```\nrlp([bytes, bytes])\n```",
        "created_at": "2020-12-04T03:52:39.694000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, though perhaps people don't realize this and don't agree with it.",
        "created_at": "2020-12-04T03:53:55.367000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```py\nfor (el in rlpStream):\n  switch el.type():\n    case rlp.List:\n      processLegacy(el)\n      break\n    case rlp.String:\n      payload = el.toString()\n      type = payload[0]\n      process2718(type, payload)\n      break\n```\nthis is what it would currently look like from my perspective",
        "created_at": "2020-12-04T03:54:16.961000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Maybe everyone is assuming that legacy transactions are just lists in the outer array...",
        "created_at": "2020-12-04T03:54:17.385000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "that's what i've been assuming",
        "created_at": "2020-12-04T03:54:49.854000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That isn't how the spec is written, but I am worried now that other people have the same misunderstanding as you do.",
        "created_at": "2020-12-04T03:54:51.652000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://eips.ethereum.org/EIPS/eip-2976 is explicit on this subject, but I can see how it would be easy to overlook.",
        "created_at": "2020-12-04T03:55:24.458000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "so 2718 is supposed to wrap all txs in an RLP byte array?",
        "created_at": "2020-12-04T03:55:45.645000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "2718 doesn't.  2976 does.",
        "created_at": "2020-12-04T03:55:55.993000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "2718 doesn't define how transactions are gossiped.",
        "created_at": "2020-12-04T03:56:07.897000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "2718 only defines how they are prepared for merklization.",
        "created_at": "2020-12-04T03:56:24.164000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ah okay, there are no lists of transaction in the consensus mechanism",
        "created_at": "2020-12-04T03:56:39.369000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```py\nTransactionPayload = Bytes # dependent on TransactionType\nLegacyTransaction = Bytes # rlp([...])\nTransaction = (TransactionType | TransactionPayload) || LegacyTransaction\n\ntransactionRoot = patriciaTrie(rlp(Index) =\u003e Transaction)\n```",
        "created_at": "2020-12-04T03:58:16.257000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "hmm 2976 says that legacy txs are an RLP encoded array of the form [nonce, ...] - this would be different then saying they are the rlpByteArray(rlp(tx)), no?",
        "created_at": "2020-12-04T03:58:49.707000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The return type of `rlp_encode(x)` is a byte array.",
        "created_at": "2020-12-04T03:59:15.655000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes, but that array starts with `f8|f9|fa` were an RLP byte array starts with `b8|...|bf`",
        "created_at": "2020-12-04T04:00:13.162000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nrlp([rlp([...])]) != rlp([[...]])\n```",
        "created_at": "2020-12-04T04:01:34.097000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This isn't SSZ.  üòâ",
        "created_at": "2020-12-04T04:01:37.739000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i guess i'm confused - if i want to encode raw opaque bytes in RLP, that is an RLP byte array starting with `b8|...|bf` no?",
        "created_at": "2020-12-04T04:02:59.194000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "According to 2976 as currently written, a legacy transaction is RLP encoded, which returns a byte array (we can ignore what bytes are in that array for now).  That byte array is then an item in the transaction list which is then RLP encoded.",
        "created_at": "2020-12-04T04:04:19.237000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```py\ntransaction1 = rlp_encode([nonce1, ...])\ntransaction2 = rlp_encode([nonce2, ...])\ntransaction3 = Bytes.concat(1, rlp_encode([chainId3, ...]))\ntransaction4 = Bytes.concat(1, rlp_encode([chainId4, ...]))\ntransactionList = rlp_encode([transaction1, transaction2, transaction3, transaction4])\n```",
        "created_at": "2020-12-04T04:05:48.464000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm talking about the RLP type \"byte array\" not the bytes that represent some RLP structure",
        "created_at": "2020-12-04T04:06:15.059000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "To make sure we are on the same page, this is the type of the parameter to `rlp_encode` and the type of the return value of `rlp_decode`:\n```ts\n// | is the union operator\ntype RlpItem = ByteArray | RlpItem[]\n```",
        "created_at": "2020-12-04T04:07:43.262000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "okay got it, RlpItem is either a byte array or a list of other rlp items",
        "created_at": "2020-12-04T04:09:04.725000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In the case of the `transactionList` for devp2p, it is an RLP encoded array of ByteArrays.  There are no nested `RLPItem[]` in this particular data structure.",
        "created_at": "2020-12-04T04:09:53.616000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "okay, this means that on the wire a single tx list would start something like `f8 XX b9 XX f8 XX ...payload`",
        "created_at": "2020-12-04T04:11:01.100000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "the outer length is the length of the whole list, the inner `b9 XX` is denoting how long the tx's bytes are then we have the legacy tx bytes starting with `f8`",
        "created_at": "2020-12-04T04:12:27.402000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sec, let me crack open my RLP encoder...",
        "created_at": "2020-12-04T04:12:47.036000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "you don't just always have it open? ü§î",
        "created_at": "2020-12-04T04:13:01.838000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What you have looks right at a glance, yes.",
        "created_at": "2020-12-04T04:15:16.042000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The outer transaction list is a list of rlp items, which means it starts with `f8-ff` (almost always `f8` though in our case).  Every item in this particular list is a byte array, so it is length prefixed with something between `00-bf`.  In our case this will always be more than 55 bytes so we'll need length bytes which means `b8-bf` (pragmatically, always `b8 or b9` in our case) followed by one or two length bytes and then the bytes themselves.\n\nThose bytes are themselves an RLP encoded list in the case of legacy transactions, or it will be a `concat(type, payload)` for a 2718 transaction.  In your example it is a single legacy transaction, which means the first byte is going to be `f8-fa`.  If it was 2930, it would start with `1`.",
        "created_at": "2020-12-04T04:20:10.160000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So yeah, I think your thing is correct.",
        "created_at": "2020-12-04T04:20:51.201000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "alright got it, on the same page now",
        "created_at": "2020-12-04T04:20:52.233000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Soo.... this makes me wonder if this is compatible with Peter's plan for `eth/xx`.  üòñ",
        "created_at": "2020-12-04T04:21:08.173000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think it is only compatible with the version of his plan (which I can't seem to find in Discord) where Berlin+ only supports `eth/xx` or higher.",
        "created_at": "2020-12-04T04:21:39.057000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Found it: https://discordapp.com/channels/595666850260713488/745077610685661265/778217548893126666",
        "created_at": "2020-12-04T04:22:07.770000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah i'm really not sure",
        "created_at": "2020-12-04T04:22:11.198000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So either we need to agree to follow \u003c@!206016661470314496\u003e's plan A, or we need to change the spec for 2976.",
        "created_at": "2020-12-04T04:22:47.830000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "okay sounds like something we should try to discuss before next friday ACD",
        "created_at": "2020-12-04T04:23:13.572000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The temperature of the room from the last call makes me suspect that \"change the spec\" is going to be where we land, though that does make me sad.",
        "created_at": "2020-12-04T04:23:39.249000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It is going to complicate transaction processing a bit, as you described originally, I think.",
        "created_at": "2020-12-04T04:23:57.386000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "is it too late to goto SSZ?",
        "created_at": "2020-12-04T04:24:10.059000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Proposed example with spec changed:\n```py\nrlp([\n  [nonce1, ...],\n  Bytes.concat([1], rlp([chainId2, nonce2, ...])),\n  [nonce3, ...],\n  Bytes.concat([1], rlp([chainId4, nonce4, ...])),\n])\n```",
        "created_at": "2020-12-04T04:26:21.847000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "IIUC, this is how you originally thought we were doing things \u003c@!543900561460822016\u003e?",
        "created_at": "2020-12-04T04:26:49.485000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yep, that's what i originally thought (erroneously)",
        "created_at": "2020-12-04T04:27:18.254000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Bleh.  Decoding that is ugly, I agree with your original sentiment.",
        "created_at": "2020-12-04T04:28:24.963000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Rereading your original suggestion now that I understand, and since it is possible we may end up doing ‚òùÔ∏è",
        "created_at": "2020-12-04T04:28:48.391000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```py\nrlp([\n  [nonce1, ...],\n  1,\n  rlp([chainId2, nonce2, ...]),\n  [nonce3, ...],\n  1,\n  rlp([chainId4, nonce4, ...]),\n)]\n```\n\u003c@!543900561460822016\u003e is this what you had in mind then?",
        "created_at": "2020-12-04T04:30:41.356000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "would `Bytes.concat` convert to an RLP byte string starting with ~`b8`?",
        "created_at": "2020-12-04T04:31:54.406000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "because I believe i was thinking the spec was actually the latter one",
        "created_at": "2020-12-04T04:32:12.015000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "`Bytes.concat` just does what it says on the tin.  üôÇ  Concatenates bytes and byte arrays and spits out a new byte array.  üòÑ",
        "created_at": "2020-12-04T04:32:58.589000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "got it üôÇ",
        "created_at": "2020-12-04T04:33:19.426000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "alright i actually need to hop off now, but will continue thinking about this",
        "created_at": "2020-12-04T04:33:56.865000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "thanks \u003c@!301186049323958275\u003e for helping me get on the same page",
        "created_at": "2020-12-04T04:34:33.514000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think I still prefer https://discord.com/channels/595666850260713488/779922457631916064/784274373883985950 over https://discord.com/channels/595666850260713488/779922457631916064/784274373883985950",
        "created_at": "2020-12-04T04:38:41.973000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "hm for option two, splitting type and then encoding payload in RLP seems like we separating things that should be together. I am proposing option three where we are looking at typed transaction as byte array:\n```\nrlp([\n  [nonce1, ...],\n  rlp(1 || payload1),\n  [nonce3, ...],\n  rlp(1 || payload2),\n)]\n```",
        "created_at": "2020-12-04T09:15:28.918000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This is how it is currently implemented in OE.",
        "created_at": "2020-12-04T09:15:41.861000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@429719902363058177\u003e Why the extra rlp in there?",
        "created_at": "2020-12-04T09:37:40.576000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "As i understood option 1 just concatenates new transaction and with that breaks outer list, `rlp` is there to express that this need to be encoded.",
        "created_at": "2020-12-04T09:39:52.155000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, I'm not following.  RLP can encode ByteArrays (in fact, that and lists are the *only* things RLP can encode).",
        "created_at": "2020-12-04T09:41:58.706000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Taking a byte array and RLP encoding it (which just returns a slightly longer byte array) just to then put it into an RLP list seems wasteful.",
        "created_at": "2020-12-04T09:42:26.160000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I thought that option 1 is this: https://gist.github.com/lightclient/af944a74f6e8debcbb1232ac007df3cc\nFor clarification: does option 1 breaks outer list, if it does not, that option1 and option3 are same.",
        "created_at": "2020-12-04T09:46:11.163000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A. https://discord.com/channels/595666850260713488/779922457631916064/784269200700473356 is current spec.\n\nB. https://discord.com/channels/595666850260713488/779922457631916064/784274373883985950 is my proposed alternative spec.",
        "created_at": "2020-12-04T09:47:29.170000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "C. https://discord.com/channels/595666850260713488/779922457631916064/784275462343229540 is lightclient's proposed alternative spec.",
        "created_at": "2020-12-04T09:47:51.251000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "got it",
        "created_at": "2020-12-04T09:48:05.265000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I like option1 more üôÇ",
        "created_at": "2020-12-04T09:48:34.842000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Which one is option 1?  You mean the current spec?",
        "created_at": "2020-12-04T09:49:55.333000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or my proposed alternative?",
        "created_at": "2020-12-04T09:50:07.186000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://discord.com/channels/595666850260713488/779922457631916064/784274373883985950 this",
        "created_at": "2020-12-04T09:50:17.003000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I proposed same as you did, or thought that it is proposed that üôÇ",
        "created_at": "2020-12-04T09:50:51.242000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(I labeled them A, B, C, the one you pointed at is B)",
        "created_at": "2020-12-04T09:50:56.924000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I prefer A, but I suspect I'll lose that battle since it would require all clients implementing a new protocol and releasing those changes before Berlin and everyone dropping support for old protocols as of Berlin.",
        "created_at": "2020-12-04T09:51:58.886000+00:00",
        "attachments": []
    },
    {
        "author": "0xraino",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If I follow, I think I implemented it as B",
        "created_at": "2020-12-04T13:44:59.977000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It seems that everyone did.  üòñ",
        "created_at": "2020-12-04T15:27:06.388000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Which further increases the chances that B is what we'll end up going with I suppose.",
        "created_at": "2020-12-04T15:27:18.092000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "FWIW I implemented C!",
        "created_at": "2020-12-04T16:27:44.497000+00:00",
        "attachments": []
    },
    {
        "author": "0xraino",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So your outer rlp list is of length `num_legacy_txs + 2*(num_typed_txs)`?",
        "created_at": "2020-12-04T16:30:04.415000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!213672586264051717\u003e no it would just be the number of bytes of the inner elements",
        "created_at": "2020-12-04T16:31:22.917000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "this is an example: https://gist.github.com/lightclient/af944a74f6e8debcbb1232ac007df3cc",
        "created_at": "2020-12-04T16:31:47.213000+00:00",
        "attachments": []
    },
    {
        "author": "0xraino",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Wait so how do B and C differ? The encoding of the tx type will always be itself doesn't it collapse into byte concatenation?",
        "created_at": "2020-12-04T16:39:39.170000+00:00",
        "attachments": []
    },
    {
        "author": "0xraino",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, this message was just a misunderstanding of rlp list lengths, disregard.",
        "created_at": "2020-12-04T16:40:40.405000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, maybe you are right and B and C are the same because transaction type is \u003e55?",
        "created_at": "2020-12-04T17:03:39.206000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I‚Äôm pretty certain B and C aren‚Äôt the same. As you see in my example for C, there is no RLP item wrapping the tx type - it stands alone in the outer list. In B, it would be wrapped with an RLP length prefix",
        "created_at": "2020-12-04T19:04:09.147000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "whats the expected response to `eth_getTransactionByHash` for an EIP-2718 tx?  Or more specifically an EIP-2930 tx?  Would the `access_list` be included in the response for example?  Same goes for `eth_getBlockByNumber(..., true)` for a block that includes an EIP-2930 tx.  Do we need to prevent \"collisions\" between EIP-2930 \"access list\" and some other tx type that _also_ defines a different \"access list\" in the JSONRPC responses?  Will the tx type be returned as well?",
        "created_at": "2020-12-04T20:09:16.765000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!388751025789468672\u003e it should be the same json object you'd get with legacy txs + `chainId`, `type`, and `accessList`: https://github.com/ethereum/go-ethereum/blob/7a22d848c851b1dcc89344049e5be9833fde1e97/core/types/gen_tx_json.go#L15",
        "created_at": "2020-12-04T20:24:22.188000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Do we need to prevent \"collisions\" between EIP-2930 \"access list\" and some other tx type that also defines a different \"access list\" in the JSONRPC responses?\nhmm i don't believe so - the tx hash should be collision resistant  and you'll have the type of the tx",
        "created_at": "2020-12-04T20:25:05.617000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Thanks, is there an EIP describing these new fields?   Something like EIP-3041 and friends?\n\n\u003e the tx hash should be collision resistant  and you'll have the type of the tx\n\nI meant more a collision in the \"schema\" of the JSONRPC response, for example it could get complicated to build proper JSON parsing if in EIP-2930 txs `\"accessList\"` is an object but in EIP-XXXX (some future EIP) `\"accessList\"` is an array, for example.  I agree that having the `\"type\"` makes parsing _possible_ but it doesn't mean it'll be elegant.",
        "created_at": "2020-12-04T21:07:12.188000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There isn't an EIP for these new fields yet unfortunately.\n\nIt's definitely possible to have another transaction type in the future also have an `accessList`. Is it an issue to check the `type` before converting the json object into a native object?",
        "created_at": "2020-12-04T21:18:36.456000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Is it an issue to check the type before converting the json object into a native object?\n\nIt's definitely doable but potentially more error prone depending on the language doing the parsing.  I could also see the repeat of a lot of small DX bugs we've seen in the past like clients returning a `{ ... \"accessList\": null }` on a non-EIP-2930 tx.\n\nI'm also worried about someone trying to retrofit some sort of schema on the JSON ala OpenAPI, I don't believe it'd be easy to make the schema for different fields depend on the value of another field.  In which case putting all \"non-standard\" fields in their own object keyed by the tx type might be easier to validate, something like:\n\n```\n{\n   \"type\": \"0x1\",\n   \"typeDependentFields\": {\n      \"0x1\": {\n         \"accessList\": \"...\"\n      }\n   }\n}\n```\n\nI'm not happy with that exact schema but the key feature is that the path `.typeDependentFields[\"0x1\"].accessList` is unique to EIP-2930 txs.  One could still create an invalid tx JSON where type's value isn't the only key in typeDependentFields but the goal IMO is to make valid txs easy to parse.\n\nMy goal isn't to bike shed just to make sure that a) there's a decent chance that all the clients return the same JSON and b) wallets and frameworks like web3.js and ethers.js have an easy time handling the new tx types.",
        "created_at": "2020-12-04T21:42:05.144000+00:00",
        "attachments": []
    },
    {
        "author": "0xraino",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah yes, you're right. But this would be the same as yours:\n```\nrlp([\n  [nonce1, ...],\n  Bytes.concat(1, rlp([chainId2, nonce2, ...])),\n  [nonce3, ...],\n  Bytes.concat(1, rlp([chainId4, nonce4, ...])),\n])\n```\nright?",
        "created_at": "2020-12-04T23:08:40.870000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!213672586264051717\u003e not quite, the `Bytes.concat(..)` would be wrapped in a RLP length prefix as well",
        "created_at": "2020-12-04T23:09:36.568000+00:00",
        "attachments": []
    },
    {
        "author": "0xraino",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah right, because then it would be an opaque byte stream. That means Option C is the only one that has keeps rlp list initiators only at the beginning of txs",
        "created_at": "2020-12-04T23:11:56.797000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes exactly",
        "created_at": "2020-12-04T23:12:07.425000+00:00",
        "attachments": []
    },
    {
        "author": "0xraino",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In that case, I implemented Option C",
        "created_at": "2020-12-04T23:12:13.376000+00:00",
        "attachments": []
    }
]