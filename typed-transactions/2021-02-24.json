[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There are a number of EIPs that propose adding precompiles that are not pure, so a generalized solution would be valuable.",
        "created_at": "2021-02-24T03:26:17.608000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If I RLP decode these transactions, then I get a Buffer, which starts with 0x01. I do not think this is correct.",
        "created_at": "2021-02-24T15:18:26.969000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "*grumble*",
        "created_at": "2021-02-24T15:46:20.543000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't understand why everyone wants to RLP encode transactions everywhere...",
        "created_at": "2021-02-24T15:46:35.599000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@508125616940515329\u003e Is the keccak hash for each the hash of the bytes before decoding, or the hash of the bytes after RLP decoding?",
        "created_at": "2021-02-24T15:56:02.165000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I suppose I can answer this myself pretty easily...",
        "created_at": "2021-02-24T15:56:28.746000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Looking around at other clients, I see besu has implementations of two \"non pure\" precompiles related to private transactions: \n\nhttps://github.com/hyperledger/besu/blob/master/ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java#L103\n\nThey are passing the message frame to even the \"pure\" precompiles so maybe just adding an `evm` method param to `PrecompiledContract.Run` is acceptable as well.\n\nAnd I guess in the case of 3074 the `RequiredGas` would just return the \"fixed\" gas cost (the cost of the ECRecover on the signature and \"normal\" call costs as outlined in the EIP) and `Run` would deduct that actual gas of the called contract method.",
        "created_at": "2021-02-24T15:58:17.388000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What is the hash of?",
        "created_at": "2021-02-24T16:00:50.932000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I haven't checked, but I suppose that this is the hash of the RLP data (which should be hashed). I am correct that the serialized tx starts with 0x01 right? So we hash over ( `0x01 | payload` ).",
        "created_at": "2021-02-24T16:00:52.161000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I will just check now what happens if I hash the raw rlp",
        "created_at": "2021-02-24T16:01:05.509000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes.  A TypedTransaction is `0x01 | payload`.",
        "created_at": "2021-02-24T16:01:11.204000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And the hash of that transaction is a hash of `0x01 | payload`.",
        "created_at": "2021-02-24T16:01:23.953000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\n\u003e const rlpdata = Buffer.from('b8a701f8a486796f6c6f763380843b9aca008262d4948a8eafb1cf62bfbeb1741769dae1a9dd479961928080f838f7940000000000000000000000000000000000001337e1a0000000000000000000000000000000000000000000000000000000000000000080a0775101f92dcca278a56bfe4d613428624a1ebfc3cd9e0bcc1de80c41455b9021a06c9deac205afe7b124907d4ba54a9f46161498bd3990b90d175aac12c9a40ee9', 'hex')\nundefined\n\u003e keccak256(rlpdata)\n\u003cBuffer 44 43 a2 7a 9b 95 50 5b 85 22 30 79 37 be 52 a6 be 5b 53 0d 62 67 de 0e b3 97 17 a4 fd 30 6c e4\u003e\n\u003e keccak256(Buffer.concat([Buffer.from('01', 'hex'), rlpdata])\n... )\n\u003cBuffer 37 5b 62 c5 1d f0 29 e0 e8 6d bc 28 b9 31 1c 14 32 64 75 13 20 b8 18 f3 cd 57 7b 59 f8 ab 3c b5\u003e\n\u003e keccak256(Buffer.concat([Buffer.from('01', 'hex'), rlpdata]))\n\u003cBuffer 37 5b 62 c5 1d f0 29 e0 e8 6d bc 28 b9 31 1c 14 32 64 75 13 20 b8 18 f3 cd 57 7b 59 f8 ab 3c b5\u003e\n```",
        "created_at": "2021-02-24T16:02:20.197000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hash should be 0x8d6c458a40d2b06f56310eb1e1322138ee4fb2d78a1dc35e96ac166600529ce6",
        "created_at": "2021-02-24T16:02:28.726000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No idea how this works",
        "created_at": "2021-02-24T16:02:34.152000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Just tested myself, I have no idea where those hashes are coming from.",
        "created_at": "2021-02-24T16:04:47.782000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It would be great if someone can create a simple test case where we have an access list transaction, together with what the serialized transaction should be, and what the hash should be. (In serialized we verify that signed data is correct since we need the correct v/r/s values)",
        "created_at": "2021-02-24T16:04:50.165000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I took a test case from ethereum/tests, the signed data is correct but I cannot generate the correct transactions trie",
        "created_at": "2021-02-24T16:05:09.273000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\n\u003e const rlpDecoded = rlp.decode(rlpdata)\nundefined\n\u003e rlpDecoded\n\u003cBuffer 01 f8 a4 86 79 6f 6c 6f 76 33 80 84 3b 9a ca 00 82 62 d4 94 8a 8e af b1 cf 62 bf be b1 74 17 69 da e1 a9 dd 47 99 61 92 80 80 f8 38 f7 94 00 00 00 00 ... 117 more bytes\u003e\n\u003e keccak256(rlpDecoded)\n\u003cBuffer 21 2a 85 be 42 8a 85 d0 0f b5 33 5b 01 3b c8 d3 cf 75 11 ff dd 89 38 de 76 8f 4c a8 bf 1c af 50\u003e\n```\n\nAlso not ok ðŸ˜¦",
        "created_at": "2021-02-24T16:05:54.778000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Your results match mine.",
        "created_at": "2021-02-24T16:06:46.865000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I actually added a test like that to my code yesterday: https://github.com/INFURA/go-ethlibs/blob/master/eth/transaction_signing_test.go#L87",
        "created_at": "2021-02-24T16:07:57.771000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "hah oops wrong link ðŸ™‚ (editted to correct one)",
        "created_at": "2021-02-24T16:08:07.248000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Great ðŸ˜„",
        "created_at": "2021-02-24T16:08:58.383000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Okay this is really great, thanks ðŸ˜„",
        "created_at": "2021-02-24T16:09:37.212000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, \"raw\" unsigned transaction is weird to me.  Is that actually used anywhere?",
        "created_at": "2021-02-24T16:25:53.719000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Do you mean the \"raw\" output from `eth.fillTransaction`?  I don't use it in my code anywhere, I only call .RawRepresentation on already signed txs (mainly because my code doesn't generally handle unsigned txs yet).  As for geth I don't think it's used anywhere either, in that `eth.signTransaction` takes a tx object not a raw, and I don't see a `eth.signRawTransaction` or such anywhere.  What looks weird to you?",
        "created_at": "2021-02-24T16:58:18.738000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I find it odd/weird to have an endpoint/function that returns a value that no one wants.  ðŸ™‚",
        "created_at": "2021-02-24T16:59:24.088000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Looks like `fillTransaction` was added for external signers (so maybe clef?): https://github.com/ethereum/go-ethereum/pull/19915  I guess if someone wants to use that value they need to decode the raw tx, then sign it and update the R,S,V values?  (Presumably first showing the decoded tx to the user for confirmation)",
        "created_at": "2021-02-24T17:06:44.575000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I feel like it should have just returned JSON....",
        "created_at": "2021-02-24T17:07:21.621000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Rather than returning an encoded thing, and then making the recipient decode it for user presentation, and then re-encode it.",
        "created_at": "2021-02-24T17:07:38.927000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "it returns the JSON as well, it returns an object w/ two fields (`raw` and `tx`, tx is the transaction as JSON)",
        "created_at": "2021-02-24T17:08:27.130000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "*grumble*",
        "created_at": "2021-02-24T17:09:18.071000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Had a great talk with the ITX people, and 3074 has some sweet changes coming!",
        "created_at": "2021-02-24T17:52:11.273000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(IMO ðŸ˜‰ )",
        "created_at": "2021-02-24T17:52:18.515000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Soon enough to stand a chance for London?",
        "created_at": "2021-02-24T17:52:38.611000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Doesn't the identity precompile consume a variable amount of gas?",
        "created_at": "2021-02-24T17:53:55.857000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hopefully. Going to try and get a new revision out today.",
        "created_at": "2021-02-24T17:54:15.728000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "True it does, but the gas consumed is still just a function of the input size so it can be calculated before actually calling the precompile (which is what geth currently does).  For EIP-3074 to work in geth my _hunch_ is that breaking up the gas into a \"fixed\" portion and the gas consumed by the called contract will still be the easiest way to implement it.",
        "created_at": "2021-02-24T18:58:36.881000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah, okay. Since `CALL_PRECOMPILE` calls back out, it really does have variable gas usage.",
        "created_at": "2021-02-24T19:01:28.140000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e one outstanding question is whether to set `tx.origin`. I'm partial to doing it.",
        "created_at": "2021-02-24T20:37:20.695000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah this thing is indeed weird, because this raw one sets the /v/r/s/ values to empty buffers, but this structure is used nowhere (like in the serialized tx (data to be put in block), or the hash, or the message to sign...)",
        "created_at": "2021-02-24T21:27:14.340000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Wait, never mind",
        "created_at": "2021-02-24T21:27:48.650000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm confusing things, it's indeed probably for signing stuff",
        "created_at": "2021-02-24T21:27:57.092000+00:00",
        "attachments": []
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ya legacy EIP-155 txs require the RLP list that's signed to contain placeholder `r` and `s` zero-values when signing, EIP-2930 signs a more straight-forward list w/o the placeholder r and s values.  Come to think of it, I should update my code to make RawRepresentation private and instead just check `.SigningHash()` in the unit test since that's really the item that needs to be correct, and maybe export and verify `.SigningPreimage` as well.",
        "created_at": "2021-02-24T21:49:18.664000+00:00",
        "attachments": []
    }
]