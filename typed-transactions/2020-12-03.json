[
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Aren't hash for wire transmission and merklization same, just asking if I need to check that?",
        "created_at": "2020-12-03T09:26:32.654000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hash for signed data i first implemented hash on `1 || rlp([...])`  but will change to be as specified `rlp([1,...])`",
        "created_at": "2020-12-03T09:27:23.334000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "They should be.",
        "created_at": "2020-12-03T09:28:00.097000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!429719902363058177\u003e Does this seem reasonable to you?\n```\nkeccak256(1 || rlp([chainId, nonce, gasPrice, gasLimit, to, value, data, access_list, yParity, senderR, senderS]))\n```",
        "created_at": "2020-12-03T09:30:07.224000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I am fine with both but like more that one.",
        "created_at": "2020-12-03T09:31:51.861000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "`rlp([status, cumulativeGasUsed, logsBloom, logs])` for receipt?",
        "created_at": "2020-12-03T09:32:25.462000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "seems okay",
        "created_at": "2020-12-03T09:33:11.575000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, I don't think we actually hash transactions in consensus, only in the networking and interface layers?",
        "created_at": "2020-12-03T09:34:47.417000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I just realized that all of this stuff is defined in EIP-2718 and EIP-2976, so there is no need to redefine it in 2730.",
        "created_at": "2020-12-03T09:42:32.613000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's seems like there are two possible interpretations of EIP-2718 transaction list encodings.\n\n1. Wrap the EIP-2718 transaction in an RLP bytes wrapper.\n2. Use the EIP-2718 transaction serialization directly.\n\nI believe this only affects devp2p as the transaction root is generated without wrapping typed txs (correct me if I'm wrong).\n\nOriginally, I thought that following 2) would lead to an invalid RLP encoding, however after looking at it more I think that is false. In RLP terms, the stream should look something like: `list length || legacy tx bytes || uint(1) || typed tx bytes`. \n\nI believe this is a valid RLP list - it would just have the type byte scoped to the outer list and that list would be heterogeneous. In the case of 1), the list is also heterogeneous (elements are either a legacy tx or a byte string) so there isn't a major discrepancy there.\n\nOne slight advantage of 2) is that it is not necessary to pass over typed txs multiple times. If we're decoding a tx list, and we're beginning to decode a new item, we can check whether that item is a list or a single byte. If it is a list, it's a legacy tx and we can decode. If it is a byte, it's a typed tx and we can decode. Following 1), to decode a typed tx, we'd encounter a string length byte (`[0xb8, 0xbf]`) and then we'd have to read that string to a buffer before proceeding to decode it.\n\nI don't have a strong preference. I've reread the EIP-2718 eth magicians thread and Micah does clearly state that the correct approach is 1). I slightly prefer 2), but could be convinced of 1) rather easily - so let me know if I'm missing anything\n\ncc: \u003c@!301186049323958275\u003e \u003c@!429719902363058177\u003e \u003c@!213672586264051717\u003e",
        "created_at": "2020-12-03T23:43:35.199000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "if it helps, here is gist detailing the rlp encoding of a block following 2): https://gist.github.com/lightclient/af944a74f6e8debcbb1232ac007df3cc",
        "created_at": "2020-12-03T23:44:33.097000+00:00",
        "attachments": []
    }
]