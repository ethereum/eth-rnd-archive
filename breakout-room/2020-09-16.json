[
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003e we can solve DOS problem without EIP-2929, but I can accept it as a temporary solution\n\nI started on `penalties`, pivoted to `karma/oil`, and pivoted again to accesslists. I think 2929 ended up being a very nice solution, with all the properties I desired: \n\n- Solves immediate problem, \n- Doesn't bork contract flows, \n- Can be scaled up in the future, if needed, \n- Provides a good base for charging for witness data, as in, pay for what you declare, but pay a LOT for what you haven't declared. Plus solves the problem of canonicalizing a witness (de-bloat a malicious witness)",
        "created_at": "2020-09-16T13:10:34.735000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution Layer",
        "parent": "",
        "content": "what EIPs like 2929 and 2200 continue to do is to widen the semantic gap between the EVM instruction set and the gas calculation rules. Ideally, each instruction would have a constant cost. With occasional exceptions. When more and more exceptions and rules are introduced for the gas calculation cost, it makes me think that we almost need some kind of \"micro-code\" for EVM, something a bit lower-level so that in the micro-code you would have no or minimal semantic gap",
        "created_at": "2020-09-16T13:18:29.443000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution Layer",
        "parent": "",
        "content": "because what these EIPs are effectively doing is the enshrining a specific approach of implementing the affected opcodes",
        "created_at": "2020-09-16T13:19:48.976000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution Layer",
        "parent": "",
        "content": "and introducing something like transient storage is kind of micro-code approach. You then split the operations like SLOAD and SSTORE into bunch of micro code that has branching in it, and it uses transient storage or memory",
        "created_at": "2020-09-16T13:22:20.271000+00:00",
        "attachments": []
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "If execution and state is totally split, then yes, ops can have constant cost, and you'd pay for witness separately. So the total cost for accessing an item twice is lower than accessing two separate items, because the witness is smaller. \n\nThis proposal does not have such separation. Which leads to certain upsides, such as it can make these payments \"optional\", which is IMO very nice. \n\nI don't see how it enshrines any specific approaches though..?",
        "created_at": "2020-09-16T13:22:25.453000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003e I don't see how it enshrines any specific approaches though..?\n\u003c@!211091239112671234\u003e Well, it does introduce the structures like \"accessed_addresses\" and so on that are implied during the execution, but not formally part of EVM semantics",
        "created_at": "2020-09-16T13:24:43.025000+00:00",
        "attachments": []
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "Ah, ok",
        "created_at": "2020-09-16T13:25:23.142000+00:00",
        "attachments": []
    }
]