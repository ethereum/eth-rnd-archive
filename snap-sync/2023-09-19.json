[
    {
        "author": "suburbandad_",
        "category": "Execution Layer",
        "parent": "",
        "content": "moving question to the right channel - do we have any test coverage for snap protocol outside of geth?",
        "created_at": "2023-09-19T02:30:27.509000+00:00",
        "attachments": null
    },
    {
        "author": "suburbandad_",
        "category": "Execution Layer",
        "parent": "",
        "content": "I am implementing the remaining bits of the snap server protocol in besu from the snap.md protocol doc.  The thread from last year hits on pretty much exactly (some of) the questions I have\n\nquestions:\n * if there is nothing at start hash, limit hash, or any intervening accounts, what do we need to provide proofs for?  absence of start, limit, and presence of first account past the limit?\n* if we have start hash but not limit hash, I would assume we provide proof of absence of limit hash, but the thread above seems to contradict that?  when exactly should we provide proof of absence?\n* on the FF..FF range, do we just omit the first account past the limit in the response and expect the client to know there isn't anything left to download?",
        "created_at": "2023-09-19T03:03:17.612000+00:00",
        "attachments": null
    },
    {
        "author": "suburbandad_",
        "category": "Execution Layer",
        "parent": "",
        "content": "is the presence of the first account past the limit just a convenience for the client so they know where to start the next range from... so no proof necessary for it ?  (and similarly not having it at the end of the FF..FF range can be forgiven since the client should know the keyspace is exhausted and not care about the next range)",
        "created_at": "2023-09-19T03:10:53.174000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "I'll go through the questions, gimme some time.. Re testing, there is a tester implemented in geth, in `cmd/devp2p`. It is used by the hive-tests (`./devp2p rlpx snap-test`: https://github.com/ethereum/go-ethereum/blob/master/cmd/devp2p/rlpxcmd.go#L57). In order to test it, you need to feed the CUT with a chain of your choosing, and then the `devp2p` verifies that it can obtain it from the CUT.",
        "created_at": "2023-09-19T07:42:12.055000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "For the questions, here is the relevant part in geth: https://github.com/ethereum/go-ethereum/blob/master/eth/protocols/snap/handler.go#L323",
        "created_at": "2023-09-19T07:44:53.258000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "1. For question one, we add a proof for `req.Origin`, that is, the start hash. In this case, it will be a absence-proof. Then at L329, we detect that `last` is unset (no accounts added), and do _not_add another exclusion-proof for that. So afaict, there's only the exclusion-proof for the start-hash.",
        "created_at": "2023-09-19T07:47:52.058000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "2. \"we have start hash but not limit hash\" -- not sure I follow. What do you mean by \"have limit hash\" -- we do not expect to ever land on _exactly_ the limit hash. You provide a proof of the last element that you saw fit to inlude. Ideally, that last element exceeded the `limit hash`.",
        "created_at": "2023-09-19T07:50:16.764000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "3. Not sure I understand the question. Please clarify the ranges",
        "created_at": "2023-09-19T07:51:54.763000+00:00",
        "attachments": null
    },
    {
        "author": "suburbandad_",
        "category": "Execution Layer",
        "parent": "",
        "content": "After talking with \u003c@680337202521440470\u003e a bit this morning, I have a better understanding and expectation about when and for what we are providing proofs.  \n\nI wasn't sure if we should consider the out-of-range accountHash as the right side and provide a proof for it.  Just to be sure I am interpreting it correctly, it sounds like we do not provide proofs for accounts that are outside the requested range.  They are just there to signify an empty range and provide a shortcut to the next non-empty range.\n\nAnother bit of clarification, regarding storage range requests, am I reading this correctly that should we ignore start and limit hash when a storage range request has multiple account hashes?  Or should we honor start hash for the first account? \n\nhttps://github.com/ethereum/devp2p/blob/master/caps/snap.md?plain=1#L247-L250",
        "created_at": "2023-09-19T18:41:11.170000+00:00",
        "attachments": null
    },
    {
        "author": "suburbandad_",
        "category": "Execution Layer",
        "parent": "",
        "content": "this is great, thanks.  geth noob question - can I supply an empty chain.rlp file or does it need to at least have the genesis block ?",
        "created_at": "2023-09-19T18:55:48.795000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "Needs a genesis. I can give you a better usage example tomorrow",
        "created_at": "2023-09-19T19:00:19.127000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "You are not interpreting correctly. If we deliver a range of accounts, [a,b,c,d], then we provide proof for d, even if it is outside of the range you requested. \n\nReason is: we already dug it up from db, and you want it, so better to deliver it than throw away, only to serve some useless exclusion proof on the right-hand side",
        "created_at": "2023-09-19T19:03:30.380000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "The proofs need to affix the left side, and the right side, of the slice of data. All internal nodes must be created by filling the trie with leafs.",
        "created_at": "2023-09-19T19:05:42.229000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "(So you need to remove the right-side proofs of the left-hand proof and vice versa)",
        "created_at": "2023-09-19T19:06:31.084000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution Layer",
        "parent": "",
        "content": "For the question about storage handling, I'll answer tomorrow when I'm by my laptop",
        "created_at": "2023-09-19T19:10:21.259000+00:00",
        "attachments": null
    },
    {
        "author": "suburbandad_",
        "category": "Execution Layer",
        "parent": "",
        "content": "gotcha~~,  excepting the case you mentioned above when the range is empty where all we need is the left proof (of exclusion).~~",
        "created_at": "2023-09-19T20:22:50.336000+00:00",
        "attachments": null
    }
]