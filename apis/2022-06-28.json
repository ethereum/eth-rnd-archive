[
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Lighthouse does this too, because of a limitation of our checkpoint sync (we require a finalized block that isnâ€™t from a skipped slot). We have plans on the backburner to remove this limitation",
        "created_at": "2022-06-28T02:18:48.769000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "we download the `finalized` block, then the corresponding state via slot number - the only time it will not be the finalized state is when the sync starts right at the slot boundary",
        "created_at": "2022-06-28T06:01:27.854000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yeah that generally should work unless the nodes are struggling from sending huge /validators responses.  If you swapped that around to download the finalized state then get the block for that slot you'll be making life easier for the server even at epoch boundaries.",
        "created_at": "2022-06-28T06:04:28.283000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "thanks, will keep that in mind - we do it this way for similar reasons as LH - ie we don't want an empty slot - it's a limitation that could be removed but .. ðŸ˜‰",
        "created_at": "2022-06-28T06:19:53.661000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Allow me to gently encourage you to remove that restriction please. ðŸ™‚ I get the challenges and prioritisation fun but it would be great if state providers didnâ€™t have to run the whole rest api - thatâ€™s actually quite hard to do.",
        "created_at": "2022-06-28T06:23:00.498000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "do I understand it right that it's not a problem as long as we don't run into said timing issue? ie requesting via the `finalized` or slot number is the same, as long as `slot \u003e= finalized`?",
        "created_at": "2022-06-28T06:24:27.407000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yes correct.",
        "created_at": "2022-06-28T06:25:19.942000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "and yeah - there are things happening here - in particular, with era files, we don't ever have to request states from the api - instead, we'd be downloading a static file which can be served by a normal web server (or whatever)",
        "created_at": "2022-06-28T06:25:49.522000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yep. Ability to use a static Web-server and http caching  is a huge win.",
        "created_at": "2022-06-28T06:26:41.124000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I do wonder if we need to specify a file format for state (maybe block if people need it) and deposit merkle tree snapshot at some point. Then we could use that for the initial state and not have to pull old deposits either. A single file preserved the nice caching properties.",
        "created_at": "2022-06-28T06:27:52.202000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "we have a (de-facto) format for the contents of the deposit merkle tree at least, as seen in the client network repo, so that part is easy - era files are really trivial type-lengh-value files with snappy-ssz in them so recycling the base format for deposit merkle trees + state + block as well would be trivial",
        "created_at": "2022-06-28T06:33:22.807000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yeah I've added an implementation of the snapshot supporting merkle tree in Teku, but haven't updated all the PoW integration code to actually be able to start from a snapshot yet. I'd kind of like to drop support for generating genesis from the PoW chain when I do that as it would make life a lot easier.",
        "created_at": "2022-06-28T06:46:15.130000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "yeah, we wanted to do that as well, but then for some reason gnosis needed it",
        "created_at": "2022-06-28T06:49:38.121000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Ugh.",
        "created_at": "2022-06-28T06:56:18.073000+00:00",
        "attachments": []
    },
    {
        "author": "__kasey__",
        "category": "Consensus Layer",
        "parent": "",
        "content": "tar?",
        "created_at": "2022-06-28T19:28:35.320000+00:00",
        "attachments": []
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "+1",
        "created_at": "2022-06-28T19:28:52.638000+00:00",
        "attachments": []
    },
    {
        "author": "__kasey__",
        "category": "Consensus Layer",
        "parent": "",
        "content": "for state and block we could organize the paths in the tarball to reflect where the values could from in a beacon api request, ie the block at slot 23 in a tarball would have the path `/eth/v2/beacon/blocks/23/block.ssz`",
        "created_at": "2022-06-28T19:32:57.350000+00:00",
        "attachments": []
    },
    {
        "author": "__kasey__",
        "category": "Consensus Layer",
        "parent": "",
        "content": "*would come from in a beacon api request",
        "created_at": "2022-06-28T19:33:15.831000+00:00",
        "attachments": []
    },
    {
        "author": "__kasey__",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I wonder if this could be solved with cache control headers, like `ETag` and `If-None-Match`? Could you give an example where caching is tricky? I assume endpoints that take `head` and `finalized` as block or state ids are part of your thinking.",
        "created_at": "2022-06-28T19:39:56.504000+00:00",
        "attachments": []
    },
    {
        "author": "__kasey__",
        "category": "Consensus Layer",
        "parent": "",
        "content": "this is what prysm does",
        "created_at": "2022-06-28T19:46:20.220000+00:00",
        "attachments": []
    },
    {
        "author": "__kasey__",
        "category": "Consensus Layer",
        "parent": "",
        "content": "ideally your static webserver could serve a synthetic `Last-Modified` header based on the timestamp of the slot the state/block is from. This would allow you to specify `If-Unnmodified-Since` without the wonky semantics of states and blocks sharing the same `ETag`.",
        "created_at": "2022-06-28T19:52:02.430000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I like the idea of using tar, but I don't think we'd want any complex paths.  It would just be `state.ssz` and `block.ssz` (and probably also `deposit-snapshot.ssz` or something).  The contents of the tar should be self-consistent so the state and block should go together etc and you could just read them to see which slot they're from etc.",
        "created_at": "2022-06-28T21:47:56.876000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "That's the kind of thing I mean when I say it gets complex.  You *can* configure it to at least not always download the full content (`If-None-Match` would still require checking for updates on each request but they aren't that common).  With a single file you can just configure a cache time which things like apache generally make easy.\n\nJust as importantly though with a single file you don't have any race conditions.  With multiple files I might request the state and get slot X, then request the block but an update happened in the mean time and now I get block X+1. With the full rest api you can obviously request the block at a specific slot to solve that but then you can't use a static webserver.  A single file gets rid of all this complexity.",
        "created_at": "2022-06-28T21:51:43.861000+00:00",
        "attachments": []
    }
]