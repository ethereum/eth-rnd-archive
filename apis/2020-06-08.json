[
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "looking at `/v1/node/identity`\n - Is it the listening addresses or the advertised addresses being reported?\n - How do we convert a discv5 ENR to a multiaddr to report the discovery address?",
        "created_at": "2020-06-08T03:47:27.488000+00:00",
        "attachments": null
    },
    {
        "author": "nishant0",
        "category": "Consensus Layer",
        "parent": "",
        "content": "1) I would assume it would be both for reporting purposes\n2) assuming it would be something like\n```\nip4/xx.xx.xx.xx/udp/x/p2p/xxxx\n```\nfor a discv5 enr in the multiaddr format",
        "created_at": "2020-06-08T05:53:40.876000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The big question is what exactly the xxxx is after the p2p. To be useful it probably has to be the public key but I think there‚Äôs also two different ways of hashing the public key to get a node I‚Äôd (one from discovery and one from libp2p).",
        "created_at": "2020-06-08T06:02:46.975000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "And if it‚Äôs not the same node id encoding as libp2p would use is /p2p/ still the right component type to use? (It might be I‚Äôm not sure how generic they‚Äôre meant to be)",
        "created_at": "2020-06-08T06:03:49.678000+00:00",
        "attachments": null
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "its peerId",
        "created_at": "2020-06-08T06:04:45.895000+00:00",
        "attachments": null
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "https://docs.libp2p.io/concepts/peer-id/#peerids-in-multiaddrs",
        "created_at": "2020-06-08T06:04:46.522000+00:00",
        "attachments": null
    },
    {
        "author": "nishant0",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Unless I am missing something won't it be the same ? Assuming both discv5 and libp2p use the same secp256k1 key for identity",
        "created_at": "2020-06-08T06:05:27.149000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "That‚Äôs the question - it‚Äôs the same public key to start with but a libp2p peerid is a hash of the public key and discv5 has a different way of hashing to get to a node id (unless I‚Äôm remembering wrong).",
        "created_at": "2020-06-08T06:07:28.426000+00:00",
        "attachments": null
    },
    {
        "author": "nishant0",
        "category": "Consensus Layer",
        "parent": "",
        "content": "So in go-libp2p peer ids are a unique case, where there is no hashing with an actual hash function happening. The identity hash function basically just takes the raw bytes of the pubkey and appends a few varint bytes to it. This allows us to extract the pubkey from the peer id. I am guessing this is not the same in java ?",
        "created_at": "2020-06-08T06:29:40.964000+00:00",
        "attachments": null
    },
    {
        "author": "nishant0",
        "category": "Consensus Layer",
        "parent": "",
        "content": "if this helps:\nhttps://github.com/libp2p/specs/blob/master/peer-ids/peer-ids.md#peer-ids",
        "created_at": "2020-06-08T06:42:59.574000+00:00",
        "attachments": null
    },
    {
        "author": "nishant0",
        "category": "Consensus Layer",
        "parent": "",
        "content": "```\nIf the length of the serialized bytes is less than or equal to 42, compute the \"identity\" multihash of the serialized bytes. In other words, no hashing is performed, but the multihash format is still followed (byte plus varint plus serialized bytes). The idea here is that if the serialized byte array is short enough, we can fit it in a multihash verbatim without having to condense it using a hash function.\n```",
        "created_at": "2020-06-08T06:43:15.357000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "https://github.com/libp2p/jvm-libp2p/blob/626765e312fdacdbb2bbc49eb269c126b18d14db/src/main/kotlin/io/libp2p/core/PeerId.kt#L69 is the code. It‚Äôs not my most familiar area so@will dig into it some more. But as long as we expect it to be the same that will all work out.",
        "created_at": "2020-06-08T06:48:56.321000+00:00",
        "attachments": null
    },
    {
        "author": "nishant0",
        "category": "Consensus Layer",
        "parent": "",
        "content": "sounds good üëç",
        "created_at": "2020-06-08T06:50:43.043000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Ah that does help and explains why the code looks like it‚Äôs hashing and produces something different to what went in.",
        "created_at": "2020-06-08T06:52:56.230000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Thanks for the help.",
        "created_at": "2020-06-08T06:53:16.262000+00:00",
        "attachments": null
    }
]