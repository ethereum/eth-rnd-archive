[
    {
        "author": "perama",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Thanks for your thoughts. The strange use case more broadly is \"what objective statements can I make from the subjective state of a synced local node\". Goal is sovereign user empowerment.\n\nIf we only consider finalised epochs, two finalised chains seems only possible if both chains have lost one third (at a historical snapshot). \n\nIf your node has followed abnormal transition rules, and has finalised, this doesn't seem to necessitate a second finalised chain (bug in Geth bug w 67% geth users). But if you see (by parsing validator set) that validators were exiting and that 15 days ago the real-time exited proportion was 33%, then you know there could be another finalised chain (geth bug fix chain). If that 33% wasn't reached (say 25% max before those no-bug validators switched to bug-accepted clients, and % drops down to 10%), then AFAICT no bug-free finalised chain could exist.\n\nDoes that sound like a good way to think about it?",
        "created_at": "2022-07-11T01:55:32.031000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "But your node didn't follow abnormal transition rules - it just didn't apply the transition at all because it started from close to chain head and had to reason to go back and execute all the blocks. I can simply give you a checkpoint state that has all my own validators and none of the original ones and create a couple of blocks with invalid state transition (that you'll never execute) which connect back to the real chain so the block parent roots still lead back to genesis.  If you're prepared to wait for a full sync from genesis to perform this verification then yes you could detect this but I'm not sure that's a particularly realistic use case. \n\nEven if you do verify the full chain, given enough time it will undoubtably be true that enough validators have exited to create an alternative chain and once that happens an alternative chain can always exist. You may as well just assume an alternative chain can exist.  And you could still query validators via multiple requests to establish exit epochs or just request the full state (which is actually a smaller response than the current validators endpoint).",
        "created_at": "2022-07-11T02:06:03.227000+00:00",
        "attachments": []
    },
    {
        "author": "perama",
        "category": "Consensus Layer",
        "parent": "",
        "content": "In the case of the former, checkpoint sync involved backfilling blocks, where block hashes are checked. This would check the genesis state, which includes the hash of all the validators. That hash is baked into the client, so spoofing new validators cannot happen unless you have downloaded a malicious client.",
        "created_at": "2022-07-11T02:33:32.750000+00:00",
        "attachments": []
    },
    {
        "author": "perama",
        "category": "Consensus Layer",
        "parent": "",
        "content": "In all cases I don't dispute that checkpoint sync is the safest way to sync. Just that some scenarios could be of interest to the user. E.g. your node could alert you to a recent possible chain split, encouraging an extra check of the checkpoint.",
        "created_at": "2022-07-11T02:37:49.610000+00:00",
        "attachments": []
    },
    {
        "author": "perama",
        "category": "Consensus Layer",
        "parent": "",
        "content": "In the case of the latter, the slow trickle of validators finally crossing 33% is related to scenarios of mischievous long range attacks. As you say, best assume this to be the case always.\n\nThis is different to an event where validators are being ejected at a great pace, culminating in 33% of the active validator set being removed. This might be a time where client bugs have created network a partition that might require some thought by the user. It would obviously be a check-twitter scenario. Being able to inspect the validators set locally to make such an assessment seems valuable. E.g. a beacon node right now can assure the user that there definitely has not been a client bug scenario leading to another finalised chain.",
        "created_at": "2022-07-11T02:45:10.959000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "This is incorrect.  I can put any parent block root I like in a block if you aren't executing the state transition anyway.",
        "created_at": "2022-07-11T02:45:14.930000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "A beacon node can assure the user that now yes, *if* it has executed every state transition from genesis.  But once that statement ever isn't true, then it will never be true again. So this isn't a very useful way to try and validate the chain.",
        "created_at": "2022-07-11T02:46:46.096000+00:00",
        "attachments": []
    },
    {
        "author": "perama",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Okay, thanks for the tips and corrections :)",
        "created_at": "2022-07-11T02:52:42.861000+00:00",
        "attachments": []
    }
]