[
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Random throwaway thought: It's funny how you can do *everything* on Swagger, except easily highlight and copy the path of the endpoint üòÖ",
        "created_at": "2020-09-08T06:37:36.268000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e On an unrelated note, I was playing around with the API over the weekend and think that we have a bit of a hole.  At current, we use the state root as a primary identifier in a lot of the endpoints, but we have no way of going from a state root to a slot or block root.  I'm wondering if we either change `/v1/beacon/states/{stateId}/root` to be more generic in terms of what it returns (state root, block root, slot) or add some more endpoints.  Any thoughts? \u003c@!545555441518772225\u003e in particular.\n\u003c@!144468805697929216\u003e Going from a state root to a block root is a bit tricky since the state doesn't natively point back to the block. I suspect LH would need to add a new DB index to support this. On the other hand, `/v1/beacon/states/{stateId}/slot` would be very easy.",
        "created_at": "2020-09-08T07:10:29.207000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Well, when I say \"easy\" I dont necessarily mean efficient. It just works well with the current DB assumptions.",
        "created_at": "2020-09-08T07:11:24.971000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I wish we'd all just ignore state root and identify states by block root and slot like the spec does, but I don't seem to be winning that battle. üôÇ",
        "created_at": "2020-09-08T07:26:47.801000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e I wish we'd all just ignore state root and identify states by block root and slot like the spec does, but I don't seem to be winning that battle. üôÇ\n\u003c@!340345049063882753\u003e I also like the sound of that but we'd miss out on skip slot states (unless they are on a justified/finalized boundary).",
        "created_at": "2020-09-08T07:45:03.624000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!361447803194441738\u003e You can still reference them though it may not match how your database works.  ie if you load the state for blockRoot and then process_slots until you reach the specified slot you have the same state back.  Of course, you could store a look up of `(blockRoot, slot) -\u003e stateRoot` to avoid having to actually process_slots again.",
        "created_at": "2020-09-08T07:52:32.723000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I guess they can query skip slots in the canonical chain, but not outside it.",
        "created_at": "2020-09-08T07:55:20.593000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I don't think it matters.  From any blockRoot, canonical or not you can get the state matching that block, then from there process_slots to the requested state.",
        "created_at": "2020-09-08T07:59:52.893000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "But there's not one block for each state",
        "created_at": "2020-09-08T08:00:12.257000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Some states have zero blocks",
        "created_at": "2020-09-08T08:00:25.162000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "(or some blocks have multiple states, depending how you look at it)",
        "created_at": "2020-09-08T08:00:40.507000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I know how you can do it in the database",
        "created_at": "2020-09-08T08:01:45.352000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "But how does the API consumer address it?",
        "created_at": "2020-09-08T08:01:52.621000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The URL would have to be something like `/v1/beacon/states/{blockRoot}/{slot}/` so there are two params required to specify a state explicitly. The state for `blockRoot` would always be the state for the slot that block actually occurred in (same as the `Store` in fork choice spec stores states) but then knowing the `slot` you know how many further empty slots you have to process on top of that state.",
        "created_at": "2020-09-08T08:04:23.877000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "oh yeah ok, add new query parameters",
        "created_at": "2020-09-08T08:04:54.491000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yes, the need for two params is one of the reasons I feel I'm losing this battle. üôÇ",
        "created_at": "2020-09-08T08:05:49.684000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "it's forwards iteration as well",
        "created_at": "2020-09-08T08:05:53.724000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Either forwards iteration or have a (blockRoot, slot)-\u003estateRoot index in the db.",
        "created_at": "2020-09-08T08:06:37.157000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Funnily enough I think Teku has stateRoot -\u003e (blockRoot, slot) because we always index states by blockRoot \u0026 slot to match what the spec uses.",
        "created_at": "2020-09-08T08:07:05.169000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e \u003c@!144468805697929216\u003e Going from a state root to a block root is a bit tricky since the state doesn't natively point back to the block. I suspect LH would need to add a new DB index to support this. On the other hand, `/v1/beacon/states/{stateId}/slot` would be very easy.\n\u003c@!361447803194441738\u003e Yeah was thinking more about this yesterday, I can see that block root would be harder in some situations.  I suspect that `slot` would be enough, in most situations (and if we have `slot` we can fetch the block root in those situations where we need it).",
        "created_at": "2020-09-08T08:11:31.953000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e The URL would have to be something like `/v1/beacon/states/{blockRoot}/{slot}/` so there are two params required to specify a state explicitly. The state for `blockRoot` would always be the state for the slot that block actually occurred in (same as the `Store` in fork choice spec stores states) but then knowing the `slot` you know how many further empty slots you have to process on top of that state.\n\u003c@!340345049063882753\u003e Is there any situation in the current API where using the block root/slot would give end users something they can't get with state root (or slot, or state root plus epoch as per some of the endpoints)?  If we've missed something then worth updating sooner rather than later.\n\nThat said ,I'd be wary of using the two fields for a couple of reasons.  First, we lose our shorthand `head`/`finalized`/_etc._ states that I think we'll find a lot of people will end up using.  Second, there is some ambiguity over what this format should do.  For example, if we had `b/x` for a given block root and slot, and asked for `b/x+1` what happens if slot `x+1` is populated with a block?  Do you apply the block, ignore the block, reject the request?  What happens if you want `x+10` and there are forks?  It feels like it could be a moving target to know what you are getting back from a given block root/slot combo, whereas a single state root should be well-defined in all situations.",
        "created_at": "2020-09-08T08:29:02.630000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!144468805697929216\u003e I can understand the desire to have a single param though I'm still a little in two minds about what's easier to use in practice. As you discovered with blockRoot and stateRoot you need to be able to map between them whereas blockRoot+slot makes that simpler. On the other hand while you could still have `/v1/beacon/states/head` and `/v1/beacon/states/\u003cblockRoot\u003e/\u003cslot\u003e` in the same API it's not as neat and if you're trying to follow the canonical chain you wind up needing to know when the next block is so you can get it's blockRoot so there's some mapping between block and state anyway.\n\nIn terms of blockRoot+slot being ambiguous, I don't believe it is regardless of what happens with forks.  The state is always defined to be the one with the stateRoot as included in the block identified by blockRoot followed by empty slots until you reach the specified slots.  Slots prior to the block identified by blockRoot would be invalid (or possibly just defined as non-existent).",
        "created_at": "2020-09-08T09:23:08.008000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I haven't pushed this hard because it ultimately works out ok either way but I was quite surprised to see the API using stateRoot when the beacon chain spec so consistently uses blockRoot+slot.  Later discovered we'd misinterpreted Lighthouse's APIs which include \"root\" - Teku interprets it as blockRoot, lighthouse as stateRoot.",
        "created_at": "2020-09-08T09:24:26.064000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e with the `/eth/v1/node/peers` endpoints, teku keeps a lot of its network stuff separate from discovery, and its actually non trivial to get the ENR when in the context of the rest of the network details. For now we're going to go with not providing the ENR in that response object, but the rest we can work with... hopefully this isn't going to cause too many problems for anyone.\n\u003c@!680234424037670912\u003e yeah agree, let's keep enr field \"nullable\". Would you mind opening Pr and adding \"nullable\": true to that field?\n\n\u003e On an unrelated note, I was playing around with the API over the weekend and think that we have a bit of a hole.  At current, we use the state root as a primary identifier in a lot of the endpoints, but we have no way of going from a state root to a slot or block root.  I'm wondering if we either change /v1/beacon/states/{stateId}/root to be more generic in terms of what it returns (state root, block root, slot) or add some more endpoints.\n\u003c@!144468805697929216\u003e I think if was left out, as Paul already mentioned, because a lot of us doesn't have index connecting state to block. Curious what's your usecase for that?",
        "created_at": "2020-09-08T10:40:03.573000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!545555441518772225\u003e I was after the block that related to a state.",
        "created_at": "2020-09-08T10:56:12.142000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Also, thinking that we should have a `/v1/beacon/states/{stateId}/validators/balances` endpoint underneath `/v1/beacon/states/{stateId}/validators`.  Fetching balances for different states is going to be a common request (anything that wants to do reporting or accounting) but fetching the entire validator state at different times is much less important (you can fetch the current state and obtain all of the data that you require in most situations from that one response).\n\nI'd be inclined for it to return an array of `validator_index,balance,effective_balance`.  Any comments on this before I write it up?",
        "created_at": "2020-09-08T11:06:38.398000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "/v1/beacon/states/{stateId}/validators/balances  would be a request for validator with id \"balances\". Something like /v1/beacon/states/{stateId}/validator_balances would make more sense I guess",
        "created_at": "2020-09-08T12:34:06.055000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Good point",
        "created_at": "2020-09-08T12:49:36.919000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "regarding \"older\" slots, one way to interpret them actually is to follow the history of that dag - this way one can use the head block root and select \"any\" slot",
        "created_at": "2020-09-08T15:10:03.912000+00:00",
        "attachments": []
    },
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e \u003c@!680234424037670912\u003e yeah agree, let's keep enr field \"nullable\". Would you mind opening Pr and adding \"nullable\": true to that field?\n\u003c@!545555441518772225\u003e https://github.com/ethereum/eth2.0-APIs/pull/80",
        "created_at": "2020-09-08T20:57:10.233000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e regarding \"older\" slots, one way to interpret them actually is to follow the history of that dag - this way one can use the head block root and select \"any\" slot\n\u003c@!449019668296892420\u003e That would be convenient but would then be very confusing that going backwards pays attention to blocks on that chain and going forward always processes empty slots.  It's potentially quite expensive to walk backwards from an arbitrary block as well.",
        "created_at": "2020-09-08T21:11:25.630000+00:00",
        "attachments": []
    },
    {
        "author": "terence0083",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Should we define an end point for weak subjectivity checkpoint? Based on this formula: https://notes.ethereum.org/@adiasg/weak-subjectvity-eth2#Updating-Weak-Subjectivity-Checkpoint-States",
        "created_at": "2020-09-08T23:46:58.073000+00:00",
        "attachments": []
    },
    {
        "author": "terence0083",
        "category": "Consensus Layer",
        "parent": "",
        "content": "LH has started on this already https://github.com/sigp/lighthouse/blob/ac3c75463e191f785a99552dab33a10961c5460e/book/src/become-a-validator.md#optional-resuming-a-node-after-an-extended-period-of-downtime üëè",
        "created_at": "2020-09-08T23:47:30.668000+00:00",
        "attachments": []
    }
]