[
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "As a validator, I would like the ability to point my tooling at Geth + OpenEthereum + Nethermind + Besu and only sign if all 4 clients agree.",
        "created_at": "2020-07-18T05:15:40.826000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "If there is disagreement, I would rather \"bow out\" than sign stuff during a consensus failure.",
        "created_at": "2020-07-18T05:15:59.769000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e If there is disagreement, I would rather \"bow out\" than sign stuff during a consensus failure.\n\u003c@301186049323958275\u003e When producing attestations there’s a 4s window between when you will first accept the block and when you need to attest to it. It seems reasonable to me that sometimes a client might be 4s behind on processing a block, so this might get a bit hairy.",
        "created_at": "2020-07-18T07:19:55.441000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Hmm, I think we may be talking past each other (probably my fault, something said above just made me think about this and maybe I'm not in the right place).",
        "created_at": "2020-07-18T07:21:27.635000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The Ethereum network is made up of different client implementations, each of which may have a bug.  If I validate a given block with Geth and sign an attestation saying \"this block is valid\", I'm implicitly trusting that there are no bugs in the Geth implementation, and I'm even staking on that belief.",
        "created_at": "2020-07-18T07:22:40.285000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "What I would like is a way to not implicitly trust Geth, but instead validate that other clients all think the block is valid before proceeding to sign an attestation.",
        "created_at": "2020-07-18T07:23:05.834000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I am making the assumption that one will get slashed for signing an invalid block.  Perhaps this is not the case?",
        "created_at": "2020-07-18T07:23:34.737000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I agree that getting the opinion of multiple clients is good, but I think we’d have liveness issues if validators will just halt when they detect a difference between clients heads (which can be caused by very valid things, such a a temporary network fault). My approach would be to pick at least one client and produce the block from it (choosing with the majority is probably smart).",
        "created_at": "2020-07-18T07:25:41.863000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e I am making the assumption that one will get slashed for signing an invalid block.  Perhaps this is not the case?\n\u003c@301186049323958275\u003e  You won’t get slashed for an invalid block, only conflicting blocks. So there’s no in-protocol penalty for signing a single, invalid block.",
        "created_at": "2020-07-18T07:26:25.279000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "A pluggable strategy would be interesting here.  Actually, there are lots of places where a pluggable strategy would be interesting.",
        "created_at": "2020-07-18T07:26:37.803000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Presumably, someone operating in this mode would have all clients running on the same machine, or at the same internal network, so network faults I don't think are a big concern.  Are there other valid reasons why one may not be able to reach hyper-local consensus fast enough?",
        "created_at": "2020-07-18T07:27:02.105000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e You won’t get slashed for an invalid block, only conflicting blocks. So there’s no in-protocol penalty for signing a single, invalid block.\nAh, so if I am using Geth and it has a consensus bug, I'll produce/validate invalid blocks, but I won't be punished for anything other than for being a no-show from the consensus failure until it is resolved (e.g., time until Geth publishes a fix and I start running it)?",
        "created_at": "2020-07-18T07:28:43.244000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "So if it takes 2 days for Geth to publish a fix and me to upgrade to it, I'll be *effectively* a no-show for those two days while I wait for a fix, since during those two days I'll be producing/validating on a fork rather than what will eventually resolve to \"mainnet\".",
        "created_at": "2020-07-18T07:29:38.213000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Even if they’re on the same machine it doesn’t necessarily mean they’re getting the same view of the network. If they’re directly peered, it’s more likely. But message propagation involves some entropy so there’s no guarantee they’re always sharing blocks between each other. You could make it happen if you tried hard and thought about it, but I don’t think you can rely on it out of the box.",
        "created_at": "2020-07-18T07:30:18.823000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e So if it takes 2 days for Geth to publish a fix and me to upgrade to it, I'll be *effectively* a no-show for those two days while I wait for a fix, since during those two days I'll be producing/validating on a fork rather than what will eventually resolve to \"mainnet\".\n\u003c@301186049323958275\u003e  Yep!",
        "created_at": "2020-07-18T07:31:55.989000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e I don’t think you can rely on it out of the box.\nThis is the part I think *may* be valuable to bake into the protocol.",
        "created_at": "2020-07-18T07:33:31.742000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "That being said, after your explanation of what will happen in this case I'm less worried about it.",
        "created_at": "2020-07-18T07:33:42.618000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It *would* be nice if I could create a trusted peer list between my own nodes such that they *always* sent new data to each other and generally trusted each other (they don't rate limit each other and whatnot).",
        "created_at": "2020-07-18T07:34:40.110000+00:00",
        "attachments": null
    }
]