[
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "In the BeaconState debug endpoint for Altair, are we encoding the participation-registry bit-flags list as one big hex string (since each validator is a byte), or as a list of N numbers (not strings)? I think the hex-string makes more sense",
        "created_at": "2021-06-17T00:50:19.573000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Implementing it as hex-string in my tooling for now, It's easy to get a specific byte still, more efficient, and more similar to bitlists/bitvectors than a list of integers really.",
        "created_at": "2021-06-17T00:54:46.394000+00:00",
        "attachments": []
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "We have it as a list of integers currently, but can change to a hex-encoded string easily enough.\n\nI mostly use the JSON debug endpoints for manual mucking around, and munging with `jq`, etc, and would prefer a list for these purposes. I think any \"more serious\" tooling should use the SSZ endpoint",
        "created_at": "2021-06-17T01:35:22.853000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!602753420033785856\u003e good point about `jq`. Still feels inefficient to change every byte to an int though. The BeaconState debug endpoint as a whole is too heavy for most serious applications. However, the participation-flags are super useful for performance-tracking / explorers still. Maybe we should even have an endpoint that just returns that.",
        "created_at": "2021-06-17T02:22:05.763000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "if we're creating a separate endpoint for it, it would be nice if the encoding is the same",
        "created_at": "2021-06-17T02:24:29.019000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "And I know \u003c@!514429265001971732\u003e is waiting for the Altair participation-flag registry. It makes attestation performance tracking easy",
        "created_at": "2021-06-17T02:25:35.989000+00:00",
        "attachments": []
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "For the separate endpoint it might be nice to have optional validator IDs? Like: _give me the participation bits for validators x, y, z_",
        "created_at": "2021-06-17T02:29:14.993000+00:00",
        "attachments": []
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Although explorers will likely want bits for all validators",
        "created_at": "2021-06-17T02:29:34.429000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "At 400K validators, the response is still under 1 MB, pretty good to track large amounts of participation data",
        "created_at": "2021-06-17T02:30:11.876000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "So don't think we need pagination, especially since it's likely just a copy from the head state anyway",
        "created_at": "2021-06-17T02:31:06.271000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Filtering is nice for small users though, hmm",
        "created_at": "2021-06-17T02:31:35.672000+00:00",
        "attachments": []
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Maybe the bulk endpoint is sufficient for now, and we can add a separate filtering option later",
        "created_at": "2021-06-17T02:32:49.077000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Another interesting thing is that we use only 3 bits per byte really",
        "created_at": "2021-06-17T02:34:14.007000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "so in hex encoding, half of the output nibbles are `0`",
        "created_at": "2021-06-17T02:34:42.351000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "And with the integer option we get `,` instead",
        "created_at": "2021-06-17T02:35:05.073000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Hmm, Go by default json-encodes a `[]uint8` as base64, so it has to explicitly implement  one or the other option. Encoding to hex at least gives you fixed output length, whereas `[]int` does not (if we have more than 4 bits per byte).",
        "created_at": "2021-06-17T02:39:24.345000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Idk, probably overthinking it",
        "created_at": "2021-06-17T02:39:31.845000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "So Teku implements it as a `MutableList\u003cSSZByte\u003e`, Nimbus as a `HashList[ParticipationFlags, Limit VALIDATOR_REGISTRY_LIMIT]`, and Prysm as a `[]byte` (protobuf `bytes` really). \u003c@!311971895828283393\u003e would prysm be able to encode it (the participation flags in Altair BeaconState) as json-list of numbers?",
        "created_at": "2021-06-17T02:57:20.104000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Or we can change the other clients to hex-encoding of the list. As long as we can agree on something",
        "created_at": "2021-06-17T02:59:56.626000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Given that it is a list of `uint8` it seems like the canonical representation should indeed be a list of numbers.",
        "created_at": "2021-06-17T06:35:27.914000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "this is what nimbus will encode it as, if we do \"nothing\"",
        "created_at": "2021-06-17T09:56:30.308000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "anectdotally and separately, we have a tool that extracts similar bits for mainnet up to now (for performance tracking) - an sqlite database that collects all _misses_ of any form (anything that is not a perfect attestation) right now lands at 5.5gb for all validators and epochs of mainnet",
        "created_at": "2021-06-17T09:58:45.882000+00:00",
        "attachments": []
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I think this is something we could do with type aliases, and now we have strong typing for the specific-eth2 types. We also have a custom way of transcoding these types into JSON responses for the API in any way we want, so we should be OK I believe. Thanks for letting us know early!",
        "created_at": "2021-06-17T14:26:15.497000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Ok, then we'll encode the current and previous epoch participation fields of the BeaconState as a list of numbers, and not a hex-encoded byte string.",
        "created_at": "2021-06-17T14:32:55.164000+00:00",
        "attachments": []
    },
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "ok so basically this would be reflected in the rest api as a change to `BeaconStateAltair` so that participation is a list of numbers, rather than the current bytes definition...",
        "created_at": "2021-06-17T23:56:32.719000+00:00",
        "attachments": []
    }
]