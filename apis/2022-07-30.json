[
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I‚Äôd go the other way and only support finalized if anything. Then you just force cache it for a period. For checkpoint sync you don‚Äôt need it to be the very latest finalized but closer is better. Also a reason why defining a separate api makes sense so it doesn‚Äôt have the implication that the user is specifying the state to return - it should be up to the provider",
        "created_at": "2022-07-30T00:47:40.527000+00:00",
        "attachments": []
    },
    {
        "author": "samcm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yeah thats an interesting thought. I suspect theres probably a few devils in the details with all the clients currently implementing checkpoint sync slightly differently (I've roughly documented the routes here: https://notes.ethereum.org/@samcm/HJVJBRE3q). But if we're standardising how the process should happen then yeah I agree that's a simpler way to go üëç",
        "created_at": "2022-07-30T01:09:48.643000+00:00",
        "attachments": []
    },
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "if we set the cache header appropriately on the state route we can still make life fairly easy for caching... even if we set it to an epoch duration it'd be helpful i would expect",
        "created_at": "2022-07-30T01:13:59.294000+00:00",
        "attachments": []
    },
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "it sounds like we could potentially just add `\"finalized\": true` to the `blocks/{id}/root` response... probably just at the same level as execution_optimiistic is and include if the block requested is finalized?",
        "created_at": "2022-07-30T01:28:19.822000+00:00",
        "attachments": []
    },
    {
        "author": "samcm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Just to consolidate the discussion in the linked thread and \u003c#745077610685661265\u003e - Is the idea that clients would implement something like this?\n\nCLI args:\n```\n--checkpoint-sync-state-urls=https://untrusted.com\n--checkpoint-sync-trust-urls=http://trusted1.com,https://trusted2.com\n```\n\nOn startup:\n- Fetch the state from a random `state-url` via `GET /eth/v2/debug/beacon/states/finalized` (which could be moved to the `/eth/v1/checkpoint` namespace)\n- Verify the retrieved state by checking all `trust-urls` via `GET /eth/v1/beacon/finalized_blocks/{slot}/root` \n  - abort if a certain amount don't agree (maybe configurable?)\n  - abort if the state is outside of the weak subjectivity period",
        "created_at": "2022-07-30T02:20:53.691000+00:00",
        "attachments": []
    },
    {
        "author": "samcm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Obviously we want as many people/entities to run these endpoints as possible so I think it's worthwhile to look ahead and see how it'd look in practice. I don't think we will see as much uptake for either of these providers if it's unsafe to use a \"production\" beacon node as the source node - especially for home stakers. We can get away with only a handful of state providers, but the more trust providers the better.\n\nThe safest way would be to handle both of these routes with a web server and return data from a directory that is updated by a cron on an interval. But potentially even that is too manual/finicky to see a large amount of uptake.\n\nAs an FYI I've been experimenting with a standalone app with the current checkpoint sync implementation but if we are separating the providers by `state` and `trust` it's probably way more viable and would likely solve those problems and hopefully improve uptake.\n- Runs a webserver with configurable upstream nodes\n- Ensures the upstream nodes don't get DOS'd\n- Configurable to be a `state` provider or `trust` provider\n- Sets `cache-control` headers depending on the content \n- Fetches `finalized` state on a configurable interval and caches it internally\n- Stops serving the state if its outside the WS period\n- Fetches slot block roots and serves if `n%` upstreams agree\n- Upstream nodes could actually just be other instances of this app (!)",
        "created_at": "2022-07-30T03:29:26.614000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "We want these apis to be standalone though. The aim here is to define something very minimal that allows getting a state and then verifying it from a separate source. We don‚Äôt want it to be entwined in the standard rest api because that means needing to support a bunch more functionality than is required and makes it harder to provide those endpoints publicly.",
        "created_at": "2022-07-30T04:54:47.437000+00:00",
        "attachments": []
    },
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Ok fair‚Ä¶ so separate base path and maybe able to just serve those specific trust endpoints‚Ä¶",
        "created_at": "2022-07-30T23:02:38.921000+00:00",
        "attachments": []
    }
]