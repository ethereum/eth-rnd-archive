[
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "well, the SSZ spec explicitly considers `byte` and `uint8` to be the same, _and_ the beacon api encodes `List[byte]` as a string in `ExtraData` - ditto for `Vector[byte]` - so for the purposes of json and encoding it as string, it's right now \"mostly\", _except_ `ParticipationFlags`",
        "created_at": "2022-05-24T10:21:02.440000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@340345049063882753\u003e you mention \"reference tests\" - do we have those for BeaconState as well? Can't remember seeing that, but then again, I couldn't find the spec either üôÇ https://github.com/ethereum/beacon-APIs/issues/219#issuecomment-1135201133",
        "created_at": "2022-05-24T10:22:50.899000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Not at my computer to check but I think the SSZ ref tests (ssz_static in particular) have the SSZ file and along side it a yaml file with the ‚Äúcorrect‚Äù answer so you can check you got the same thing. We can use our json schema to parse the yaml which confirms it handles the format properly and has all the right field names etc. not sure it‚Äôs 100% guarantee we got it all right as it‚Äôs not what the yaml was really designed for but it did work as a good test when I was developing the new json approach.",
        "created_at": "2022-05-24T10:26:38.814000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "aahh, clever - thanks (though we have separate yaml and json parsers :/ )",
        "created_at": "2022-05-24T10:36:08.274000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yep for SSZ it makes no difference, a `byte` is a `uint8`.\n\nI would be inclined to keep the `List[uint8]` encoding as `[\"1\",\"2\",\"3\"]`.  It isn't the most efficient encoding, but then nothing in JSON is.  And it fits more closely with the existing \"integers are encoded as quoted strings\" part of the spec.",
        "created_at": "2022-05-24T11:04:57.370000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "per this argument we should encode hashes as lists of 8-bit integers as well - as it stands, participationflags is really the only exception (which is what triggered the bug report: we go by type and the participation flag needs a special exception in the code to _not_ encode it as a string",
        "created_at": "2022-05-24T17:32:38.053000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "But JSON and SSZ are different encoding systems, and for JSON we already state that lists of bytes are encoded as hex strings, and uint8s (being numbers) are encoded as integer strings.\n\nIt sounds like nimbus isn't differentiating between `List[uint8]` and `List[byte]`, which is where there is a requirement for an exception.  Is this correct?",
        "created_at": "2022-05-24T17:37:00.602000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "well - the json spec is based on the ssz spec and the ssz spec specifically says that there's no such thing as a `byte` except as an alias for `uint8`",
        "created_at": "2022-05-24T17:38:44.529000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "ergo, the beacon api spec is in this case going out of its way to make it less convenient to implement (by inventing its own types)",
        "created_at": "2022-05-24T17:39:29.616000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "basically, the language for describing eth2 is SSZ - on top of that, we have a \"canonical\" json mapping - but that json mapping makes up its own types that have no backing in eth2",
        "created_at": "2022-05-24T17:40:55.009000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "it also means that the SSZ:JSON relationship, instead of being a trivial symmetric 1:1 becomes m:n that can't be roundtripped",
        "created_at": "2022-05-24T17:42:22.390000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I don't remember that being the basis of defining the JSON encodings.\n\nI'm not sure that there is any JSON encoding that allows you to go back to a more canonical format without knowing the types of the elements already, if I understand correctly.",
        "created_at": "2022-05-24T17:53:37.810000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I mean, what else would it be? the objects we're sending back and forth are defined in the consensus spec (`BeaconState` and so on) - only types from SSZ will ever appear in these - similar to how protobuf has a well-defined way of mapping each protobuf type to json, the same could / should happen for SSZ - this way, the process of generating JSON specs can fully be automated, instead of like now, be random for onee field",
        "created_at": "2022-05-24T18:18:31.186000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "put another way: it's not the beacon api that leads the definition of what data we're putting on the chain - it's clearly the consensus spec that is the canonical source of truth here - the beacon api is a convenience layer on top, and we can make that as easy or complicated as we want",
        "created_at": "2022-05-24T18:20:11.510000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "the good news is that it's only one debug api that is irregular this way (so far) - one could argue that debug api:s should not be beholden to the same backwards compat standards, make it regular and leave it there as a lesson for the future",
        "created_at": "2022-05-24T18:22:25.211000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "All true, but we do have `byte` and `uint8` as separate types in the consensus spec, and they're there to differentiate the data held by them.  I don't see the requirement to encode them the same way just because they are the same size.\n\nAt the moment it seems pretty clear:\n  - `List[byte]` is a hex string\n  - `List[uint8]` is a list of quoted integers\n  - `List[uint64]` is a list of quoted integers\n\nIf you changed the second one to \"is a hex string\" it seems less consistent, not more.",
        "created_at": "2022-05-24T18:24:46.612000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e but we do have byte and uint8 as separate types\nwell, this is the core of the issue indeed - where does `byte` come from? it was made up without being backed by the actual source data we're encoding (`byte` does not exist as a type in any beacon chain client) - it leaves the designer of every beacon api endpoint in the future to have to arbitrarily pick a type, where no distinction actually exists",
        "created_at": "2022-05-24T18:29:49.918000+00:00",
        "attachments": null
    }
]