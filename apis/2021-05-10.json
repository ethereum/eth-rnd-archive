[
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I'll work through these today.",
        "created_at": "2021-05-10T08:56:43.026000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "awesome thanks. I'm happy to take guidance on the POST, I don't have strong opinions, just figured we were keeping consistent",
        "created_at": "2021-05-10T10:17:14.145000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "General question for some of the new endpoints: should these be /v1 or /v2?  I can see arguments for either, but am thinking that v2 makes more sense as we're versioning the API rather than the individual endpoints, with v1 already a tagged release.",
        "created_at": "2021-05-10T10:45:43.338000+00:00",
        "attachments": null
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "if interface is changed (block payload for example) it should be v2 imo",
        "created_at": "2021-05-10T11:35:25.492000+00:00",
        "attachments": null
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I'm planning on putting deprecated notice and tags on \"replaced\" endpoints",
        "created_at": "2021-05-10T11:35:54.200000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Totally agree with that, but the question is more about what the v represents?  If there is a /v2/foo it could mean \"this is the second version of the 'foo' endpoint\" or it could mean \"this is the 'foo' endpoint in the second version of the API\".\n\nThe former is going to be slightly easier for developers, but a lot harder for users as they will have to know which version of each endpoint they need to use for a given release of the API, or indeed which endpoints apply to a given fork.  Given that, I'm inclined to shift the burden to the producers of the endpoints as they know what they are doing, and away from users who may come to the API cold.",
        "created_at": "2021-05-10T13:02:31.215000+00:00",
        "attachments": null
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I would rather not tie api release with each endpoint release as it would prevent us from releasing api v2.1 to fix some descriptions",
        "created_at": "2021-05-10T13:10:19.175000+00:00",
        "attachments": null
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I see api versions more like api stability indicator",
        "created_at": "2021-05-10T13:11:01.701000+00:00",
        "attachments": null
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "but love to hear more opinions",
        "created_at": "2021-05-10T13:11:08.081000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "i've raised https://github.com/ethereum/eth2.0-APIs/pull/142 to demonstrate what i mean by the blocks post. Because its an extension, I'm leading towards leaving it on V1, as it is literally the same endpoint, i'd be loading the same controller on v2 and v1 if we had 2 definitions",
        "created_at": "2021-05-10T20:32:38.264000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I think there are three options:\n1. Only changed apis move to v2, new apis start at v1\n2. Changed and new apis are v2 but existing apis stay at v1\n3. All apis get a v2 version (v1 preserved for existing apis for compatibility)\n\nTalking about the whole api being versioned makes me think of option 3 and that feels like a lot of busy work in code but does mean users can always just use the latest vX instead of knowing what version that api is up to. \nYou don’t get that benefit with either of the other options. The main advantage of option 2 is that users know the api first became available in version 2 but I’m not sure there’s a real need for that and it could easily just be noted in the docs. There’s no real downside though. \nPersonally I’d prefer one of option 1 or 2 and don’t really care which. But I don’t have a strong opinions.",
        "created_at": "2021-05-10T20:34:50.073000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "Consensus Layer",
        "parent": "",
        "content": "My preference would probably be only change the version when there's an incompatible change to a v1 interface, and what you're indicating to devs is they need to stop consuming the previous version (good point on the deprecation flag, I should have been adding those).\nsome interfaces may end up further down the vX route if they have problems, though we've been pretty lucky in keeping everything as v1 until the fork.\n Changes to an interface that will continue to accept the old data can stay as v1, as they're totally compatible, it also has the upside of people not needing to update their apps...",
        "created_at": "2021-05-10T20:40:22.686000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "There is also a fourth option, which is to have a 'latest' pseudo-version identifier that maps to the latest version of each endpoint.  Sort of an option 2 but with additional ease-of-use feature for users.\n\nMy concern is us being three versions down the line, and the endpoints being at what will appear at that point in time to be arbitrarily v1, v2, v3 or v4.  Requiring the user to know about the history of the chain (e.g. to understand why v1 of the sync committees doesn't work for epoch 0) seems like something we would want to avoid placing as a burden on them if we can.",
        "created_at": "2021-05-10T21:44:35.176000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I think 'latest' is basically just not having the version number in the URL anyway so winds up with those compatibility drawbacks.\nTo my mind, users don't necessarily need to understand the history of why the version numbers are the way they are, they just need to know the URL to use - so to get a block the URL is `/eth/v61/beacon/blocks/29` - doesn't matter why there's a v61 in there just like it doesn't matter why there's an arbitrary `/eth/` at the start.  The key to that is making sure the latest version always works for all forks but I think that's an important requirement regardless.",
        "created_at": "2021-05-10T21:54:53.040000+00:00",
        "attachments": null
    }
]