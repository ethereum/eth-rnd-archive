[
    {
        "author": "alex.g.t",
        "category": "Consensus Layer",
        "parent": "",
        "content": "does anyone have any dumbed down docs for `aggregator_modulo` ? (\"Value which validator can use to calculate is_aggregator (aka bytes_to_int(hash(slot_signature)[0:8]) % aggregator_modulo == 0)\" from \u003chttps://ethereum.github.io/eth2.0-APIs/#/ValidatorRequiredApi/getAttesterDuties\u003e",
        "created_at": "2020-07-04T20:12:39.782000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "There's secret leader election, where everyone makes a signature, only they can know for themselves in advance. Then based on those bytes, there validator is assigned to aggregate or not. A modulo over a uint64 number derived from the signature bytes determines the chance. The lower the modulo, the higher the chance someone is assigned.",
        "created_at": "2020-07-04T20:19:58.796000+00:00",
        "attachments": null
    },
    {
        "author": "alex.g.t",
        "category": "Consensus Layer",
        "parent": "",
        "content": "so when i get duties as a validator (in the new api), how do i know how when to aggregate? sry for the dumb question, this seems to be doing my head in...",
        "created_at": "2020-07-04T20:40:24.791000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Sorry, afk, so answers are not as fast. What you need as input is a slot (for determinism in signature, it can't just be a signature of any data), a private key (of the validator), and the modulo number (to determine the chance used in the assignment formula).",
        "created_at": "2020-07-04T20:44:41.001000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The modulo number is computed based on committee size: if the committee grows bigger, we don't want there to be aggregators. So the chance is reduced proportionally, by increasing the modulo number",
        "created_at": "2020-07-04T20:46:57.536000+00:00",
        "attachments": null
    },
    {
        "author": "alex.g.t",
        "category": "Consensus Layer",
        "parent": "",
        "content": "is this for every slot, or just for slots you are assigned to attest?",
        "created_at": "2020-07-04T20:50:38.499000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "This way, we get TARGET_AGGREGATORS_PER_COMMITTEE secretly selected aggregators, who can proof their role with their signature. On average. Some numbers have been checked to see how often nobody ends up as aggregator, but it wasn't particularly significant to worry about",
        "created_at": "2020-07-04T20:51:08.368000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Only when you're part of the committee to function in as aggregator. That's another condition for the aggregator proof iirc. So that would be once per epoch for a single validator. I can check specs later for you.",
        "created_at": "2020-07-04T20:52:36.141000+00:00",
        "attachments": null
    },
    {
        "author": "alex.g.t",
        "category": "Consensus Layer",
        "parent": "",
        "content": "much appreciated \u003c@!203220829473996800\u003e don t woorry aboout checking the spec, this gives me so much more to understand it , so, for each eligible slot, you get the slot data, you sign it to get the signature you then mod  with the given aggregator_modulo and once in a while the result will be 0 and then you you are (one of) the aggregator(s) and need to act accordingly ?",
        "created_at": "2020-07-04T20:54:14.883000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Pretty much. The signature is quite simple, you just sign the slot number",
        "created_at": "2020-07-04T20:55:25.132000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "With domain etc mixed in like any other signature",
        "created_at": "2020-07-04T20:56:03.333000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It's outlined in the validator spec, if there is any text that is confusing, let us know and we can fix it",
        "created_at": "2020-07-04T20:57:00.181000+00:00",
        "attachments": null
    },
    {
        "author": "alex.g.t",
        "category": "Consensus Layer",
        "parent": "",
        "content": "so this means(and this was what i was trying to understand) that when you are an aggregator, you will need to request an additional signature from the signer, whoever that may be, right?",
        "created_at": "2020-07-04T20:57:11.731000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "No, so the aggregator role depends on the signature, so you'll have to always check",
        "created_at": "2020-07-04T20:58:01.654000+00:00",
        "attachments": null
    },
    {
        "author": "alex.g.t",
        "category": "Consensus Layer",
        "parent": "",
        "content": "yeah, rright, the other way around from what i said",
        "created_at": "2020-07-04T20:58:52.510000+00:00",
        "attachments": null
    },
    {
        "author": "alex.g.t",
        "category": "Consensus Layer",
        "parent": "",
        "content": "thanks \u003c@!203220829473996800\u003e will read through the spec, found it now",
        "created_at": "2020-07-04T21:01:35.930000+00:00",
        "attachments": null
    }
]