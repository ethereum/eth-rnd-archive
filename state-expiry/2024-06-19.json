[
    {
        "author": "mariusvanderwijden",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I was on vacation and had a chance to have my mind wander a bit. \nOne idea popped into my mind that I'm pretty sure others have thought off,\nbut I wanted to discuss it anyway:\nThe verkle transition would be a great place to do state-expiry (even as a one-off).\nWith verkle we're starting a new trie that is empty. Now we have the opportunity\nto decide what to fill it with. \n\nThe current plan is to migrate the old state over bit by bit. \nWhat if we only migrated the state over that we actually need and only \nnodes that produce blocks will need to store the old and the new state. Verifying \nnodes could get rid of the old state and only accept blocks where a proof resurrects\nthe state from the old to the new trie.\n\nOne gotcha I think is that nodes need to store what state has been resurrected, otherwise \nsomeone could resurrect a storage slot, clear it and resurrect it again. \nThis list of resurrected storage slots can be at most as big as the old trie. \nBut the parts of the old trie that were resurrected can be deleted. \nI guess in the worst case, the size of the data full nodes need to store could double.\n\nOtherwise the scheme would work as expected:\n- Users can send transactions that touch old and new state\n- The old state is resurrected into the verkle tree\n- The validator/block builder creates a merkle proof of the resurrected state to the pre-verkle state root\n- The other validators and full nodes receive the block\n- They verify the merkle proof\n- They make sure none of the resurrected slots was resurrected before\n- They add the slots to their resurrected list\n- They add the slots to the verkle tree\n- They execute the transaction on the verkle tree\n\nOne open question is how stateless nodes would handle resurrections though, \nand this is where the scheme would maybe break, as the resurrection list can't be\nstored by the stateless client.",
        "created_at": "2024-06-19T07:12:43.450000+00:00",
        "attachments": null
    },
    {
        "author": "tanishqjasoria",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i don't think we will need to keep a list of resurrected nodes. Verkle trees do not supported deletion, so even if someone clears the storage slot, we can still check if the value exists in the new tree or not. So this can even work for stateless nodes.\nAFAIR, one of the biggest argument against doing this will be the size of merkle proofs. Someone can create a block that only consists of resurrected state, then the merkle proof would be huge and we will need to propagate that with the blocks. We may be able to restrict the size of the merkle proof by keeping the gas costs for resurrecting the state really high.",
        "created_at": "2024-06-19T11:25:09.088000+00:00",
        "attachments": null
    },
    {
        "author": "tanishqjasoria",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, we can figure out ways to prune the data from the merkle tree that is already moved to the verkle tree - something similar to how we have construct a stateless tree post verkle. So we will never have the case where nodes will need to store double the state.",
        "created_at": "2024-06-19T11:27:12.345000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e We may be able to restrict the size of the merkle proof by keeping the gas costs for resurrecting the state really high.\nThis is almost always the correct response to all abuse-by-scale attacks.  Having the cost go up non-linearly with size is another option.",
        "created_at": "2024-06-19T14:33:06.056000+00:00",
        "attachments": null
    }
]