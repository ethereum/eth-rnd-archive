[
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One thing I realized: is there any reason why we should not just do:\n\n```\ndef compress(address: LongAddress) -\u003e ShortAddress:\n    return bytes([1] + [0] * 11 + address[6:])\n```\n\n?",
        "created_at": "2021-06-06T17:28:28.077000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\n        return address\n        # Here we revert, but potentially the more correct behaviour is truncating the input.\n        raise RevertTransaction()\n```\n\nThis seems wrong; the raise after the unconditional return would never actually be triggered?",
        "created_at": "2021-06-06T17:30:50.037000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Right, this part supposed to be rewritten so that it truncates the input to 20-bytes, to keep semantics unchanged from today.",
        "created_at": "2021-06-06T20:49:06.384000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Why do we need the translation map? Can't we just:\na) Structure the 32 byte addresses so that the hash component goes at the start\nb) Declare that a 20 byte address refers to the first address that starts with those 20 bytes that gets stored in the state trie\nc) Hold all payments to uninitialized 20 byte addresses in a holding state until someone proves ownership of an account corresponding to that address (either by creating a smart contract or making an EOA transaction)",
        "created_at": "2021-06-06T20:57:31.757000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The problem is that we don't just have to deal with payments, we also have to deal with addresses holding balances in existing ERC20 contracts",
        "created_at": "2021-06-06T21:01:15.582000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Another big problem is that existing on-chain bytecode handles various address related opcodes inconsistently. It may or may not be truncated, etc.",
        "created_at": "2021-06-06T21:05:32.486000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah this was not a response to that.",
        "created_at": "2021-06-06T21:05:49.915000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hm, assuming grinding that many zeroes is unfeasible ðŸ™‚",
        "created_at": "2021-06-06T21:06:54.636000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That doesn't break my scheme. The rule is: `A 20 byte address refers to the first account that sent a transaction or was created as a smart contract at a address that starts with those 20 bytes.` If you have a reference to a 20 byte address that hasn't been initialized it may refer to any of the 32 byte address that it corresponds to, but the correspondence will be fixed down as soon someone makes a transaction with one of those addresses.",
        "created_at": "2021-06-06T21:12:10.619000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm I think that might be equivalent to mine then?",
        "created_at": "2021-06-06T21:12:46.522000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You do have to store the reference in some translation table",
        "created_at": "2021-06-06T21:12:57.174000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Though mine is \"ends with those 20 bytes\" rather than \"starts with\"",
        "created_at": "2021-06-06T21:13:18.389000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You can look up all addresses that start with a prefix in a trie far easier that you can look up all addresses that end with a suffix.",
        "created_at": "2021-06-06T21:14:18.944000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The trie uses hashed addresses anyway though",
        "created_at": "2021-06-06T21:14:42.495000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And I think we are trying to avoid dependence on breaking the abstraction of key:value storage",
        "created_at": "2021-06-06T21:15:04.238000+00:00",
        "attachments": null
    }
]