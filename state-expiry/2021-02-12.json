[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Given the current flat DB architecture, how does a node *actually* prune stale state?",
        "created_at": "2021-02-12T01:55:04.199000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We discussed this a bit on a stateless call the other day, and prior to that it hadn't clicked for me that the state in most clients isn't actually in a tree.",
        "created_at": "2021-02-12T01:55:54.818000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So while theoretically we can prune a limb, in reality it is *much* harder than one would expect to prune a stale limb.",
        "created_at": "2021-02-12T01:56:29.132000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You could do a full pass once every N blocks",
        "created_at": "2021-02-12T02:55:11.291000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or you can reference count",
        "created_at": "2021-02-12T02:55:14.793000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I implemented reference counting years ago in python and it worked and passed tests",
        "created_at": "2021-02-12T02:55:32.563000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I imagine at least some of the other clients implemented it too",
        "created_at": "2021-02-12T02:56:22.134000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Though you can't auto-expire just with reference counts, you would need a priority queue or something similar for that",
        "created_at": "2021-02-12T02:56:50.500000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Reference counts for every storage slot will *increase* storage costs.  Any idea how much?",
        "created_at": "2021-02-12T02:57:12.790000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Should be quite little, no?",
        "created_at": "2021-02-12T02:57:23.099000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Do the gains of state clearing offset the costs of reference counters?",
        "created_at": "2021-02-12T02:57:25.972000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think so; the gains of state clearing are massive",
        "created_at": "2021-02-12T02:57:40.113000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, reference counting is notoriously hard to get right and easy to get wrong, which makes it come with high technical costs (which may or may not be worth it).",
        "created_at": "2021-02-12T02:58:00.798000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We map flat storage to a trie based on the common nibble prefixes, so I donâ€™t see how that makes a difference. Maybe I donâ€™t understand the problem itself.",
        "created_at": "2021-02-12T07:03:32.725000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Imagine two contracts that hold the exact same data it state.  The root of their respective storage tries will be identical.  This results in a single item on disk that is referenced by both accounts.",
        "created_at": "2021-02-12T07:16:11.993000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I believe TurboGeth has a different on-disk structure that I'm not familiar with, so maybe it doesn't affect you all?",
        "created_at": "2021-02-12T07:16:24.504000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I donâ€™t think we deduplicate this data ourselves at the moment. We leave this up to the DB implementation. I mean, we donâ€™t have to make the whole DB from scratch here, right? ðŸ™‚",
        "created_at": "2021-02-12T07:19:01.038000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Basically what Iâ€™m saying is that there should be a layered approach otherwise we sort of have to care about everything here.",
        "created_at": "2021-02-12T07:24:54.913000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The more layers of abstraction there are, the harder it is to performance tune toward a specific target.",
        "created_at": "2021-02-12T07:27:23.801000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Since the specific problem we are discussing is about \"performance\" (state size and access), I think we need to exercise caution in not adding too many layers of abstraction.",
        "created_at": "2021-02-12T07:28:11.077000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That isn't to say that they are bad, just that I don't think it is an obvious win here.",
        "created_at": "2021-02-12T07:28:24.363000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "On the other hand you can start optimizing on the wrong layer. Like in TG we didnâ€™t specifically optimized for never storing a duplicate sequence of bytes but still all the archival info is under 1TB. Because Alexey looked at the more abstract way of info storing scheme. \nI donâ€™t think that something like a ref count should be a part of the protocol discussion.  Thatâ€™s like more like a client implementation details.",
        "created_at": "2021-02-12T07:34:52.438000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Whatever protocol we come up with must ultimately be implemented and functional in a client.  I don't think we can completely ignore implementations in this case.",
        "created_at": "2021-02-12T07:39:31.684000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That is, there needs to at least one clear path to a full implementation and client devs need to be on board to go down that path.",
        "created_at": "2021-02-12T07:39:53.439000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But you canâ€™t also make a protocol that assumes a specific way of data deduplication in each client.",
        "created_at": "2021-02-12T07:45:38.345000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You *can*, though I agree that may not be ideal.",
        "created_at": "2021-02-12T07:46:12.900000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You might have some tech notes or an implementers handbook along the way",
        "created_at": "2021-02-12T07:46:30.996000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, that all is nothing to do with the flat data layout. If you have dedup in a tree, you have the same issues.",
        "created_at": "2021-02-12T07:47:35.069000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A lot of models of the state database assume a pure tree with no deduplication.  The point I was bringing up above is that I don't think we can ignore the fact that every full featured client *currently* dedupes the tree and that there will be costs with making that harder to do or removing the ability to do it.",
        "created_at": "2021-02-12T07:49:34.337000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I *would* be curious to know how much space state takes up with no deduplication.",
        "created_at": "2021-02-12T07:49:52.215000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That would give us a baseline to work from and we can analyze, \"if everyone stops deduping, state will grow by x%, but we'll then be able to \"easily\" prune old data which would give us a state reduction of y%.  If y \u003e x then it is an easy decision and we can leave it to client devs to decide if they want to try to solve deduplication or not, if y \u003c x then we'll need to make sure we have a good plan for how various clients will be able to continue deduping under the new scheme.",
        "created_at": "2021-02-12T07:51:39.819000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, refcount is hard when you donâ€™t have transactions in your DB, when you have itâ€™s a way simpler problem to solve.",
        "created_at": "2021-02-12T07:54:52.823000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Otherwise there is always stop-the-world garbage collection",
        "created_at": "2021-02-12T07:56:22.528000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Which is natural to be placed between blocks.",
        "created_at": "2021-02-12T07:56:40.149000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And you can check only actual dedup entries there.",
        "created_at": "2021-02-12T07:56:59.397000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The volume of duplicated state entries is high, and it is non-trivial to *find* all of the pointers to them.",
        "created_at": "2021-02-12T07:57:34.203000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I agree it is a solvable problem, I'm only arguing here that it is not trivial and I don't think we should ignore the costs of solutions to that problem.",
        "created_at": "2021-02-12T07:57:57.684000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "sure, but at that point we probably need a nice table with cost/benefit/risk analysis for each solution",
        "created_at": "2021-02-12T08:02:43.850000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I can agree that it is ~~less than trivial ~~ non-trivial if you have a potentially inconsistent DB backing up the data (like leveldb) and you have dedup",
        "created_at": "2021-02-12T08:03:20.457000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "oh, I need to wake up",
        "created_at": "2021-02-12T08:05:17.333000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\"less than trivial\" should be read as \"non trivial\"",
        "created_at": "2021-02-12T08:05:27.654000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Very nice overview, thank you Vitalik",
        "created_at": "2021-02-12T12:34:33.712000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "fwiw,\n\nThere was a refcounting in EthereumJ and we found garbage collection based on refcounting pretty easy to build and maintain, I'd say it's the optimal way of doing state trie pruning. The problem here is that there is no key-value engine with native refcounting support, at least there was no one and I suspect that there is still not.\n\nThe latter means that the client have to maintain refcounting on its own. Which requires additional read on each write (you read the data first then increase the refcounter and write the the record with value and refcounter back). The worst thing is that you have to do the read even for those trie nodes that does not exist yet. To improve on that there was a bloom filter that tracked all existing nodes to sort out non-existing nodes without request to the underlying source (there were no cache hits as value is not yet exist). Everything was fine before Q3 of 2017 where state growth blew up 128MB filter and it become inefficient, I can't imagine how big the filter must be today to retain efficiency. There was also a bloom filter for nodes with refcounter=1 to improve removals but that the less part of this machinery.\n\nAfter that blow up we switched to the scheme borrowed from parity: `node_hash[:16] + account_address[:16]` are started to get used as a key to the node. It served for two goals, (i) de-duplication to switch to a new GC scheme (ii) `GetNodeData` requests could still be processed (matching was done by the first `16` bytes of requested key).\n\nNote: flat state storage is a requirement to support `GetNodeData` efficiently",
        "created_at": "2021-02-12T15:41:25.146000+00:00",
        "attachments": null
    }
]