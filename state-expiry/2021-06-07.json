[
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I would suggest we look at removing rlp from the spec wherever possible. In places like keccac(rlp(...)) we should be able to reasonably easily swap that out for concatenation or something similar.",
        "created_at": "2021-06-07T03:07:26.046000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think rlp was used in the past as a sort of catch all for turning  a multipart payload into a byte stream. More recently there seems to be tacet agreement to move away from rlp when we can.",
        "created_at": "2021-06-07T03:10:55.126000+00:00",
        "attachments": []
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, I think the simplest version of my scheme is to store all 32 byte addresses corresponding to a given 20 byte address at the 20 byte address's node in the trie. This saves us having to do two trie lookups to resolve a legacy address. I presume we would have to double COLD_ACCOUNT_ACCESS_COST for looking up legacy accounts otherwise.",
        "created_at": "2021-06-07T09:46:59.053000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not exactly sure which part are you referring to, but the rlp is used for explaining how `CREATE` changes. Are you suggesting to change it entirely to not use rlp?",
        "created_at": "2021-06-07T09:47:44.158000+00:00",
        "attachments": []
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think `compress_and_touch` has a bug. You need to check that the legacy account doesn't exist before you put a translation for it in the the translation map. Otherwise you could clobber a legacy address with long_address.",
        "created_at": "2021-06-07T09:50:16.302000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, the assumption is that there are no clashes, that's one of the issues with the extension.",
        "created_at": "2021-06-07T09:51:14.501000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There is another case where a short version of the longaddress is sent to a legacy contract (through \"user error\") before the translation was touched. Later when the translation is in place, there will also be an entry unaccessible by legacy contracs. New contracts do have access to everything though.",
        "created_at": "2021-06-07T09:52:47.044000+00:00",
        "attachments": []
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Surely the goal should be to have the security property that once a 20 byte address has appeared on chain it can be trusted. Under your scheme a malicious actor can brute force a collision consisting of a 20 byte smart contract and a 32 byte EOA with the same 20 byte address. He can then, after the contract has been deployed, steal any ERC-20 tokens (held by a 20 byte ERC-20 contract) the smart contract holds using the EOA.",
        "created_at": "2021-06-07T10:03:56.101000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think tying together the tree upgrade process and the address upgrade process is a no-go; we're explicitly trying to keep things modular",
        "created_at": "2021-06-07T11:49:57.278000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(oh btw, I have an answer to my own question of \"why not just use the last 20 bytes\": we needed to have long addresses with the same hash but from different epochs to correspond to different short addresses)",
        "created_at": "2021-06-07T11:51:26.633000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, I was referring to CREATE usage.  Since we're touching the functionality it seems like the opportunity to drop RLP.",
        "created_at": "2021-06-07T13:33:12.325000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We could also use it as an opportunity to drop CREATE (and just keep CREATE2)",
        "created_at": "2021-06-07T13:33:33.058000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Would this only be applicable to long_address accounts?  Not clear how we'd be able to drop CREATE.  Is there a way to map CREATE -\u003e CREATE2?",
        "created_at": "2021-06-07T13:34:37.335000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah, only for long_address accounts",
        "created_at": "2021-06-07T13:34:46.877000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Which could make it easier for drop CREATE entirely N years from now",
        "created_at": "2021-06-07T13:35:15.142000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It is not only create, but create transactions, which use the same logic. See little point dropping the create opcode if the create transaction is left intact.",
        "created_at": "2021-06-07T13:54:48.460000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ah, if we drop the opcode then yeah drop the transaction type too",
        "created_at": "2021-06-07T13:55:05.263000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also don't see why the RLP part should be changed of it, since tools depend on it, and seems little benefit changing it.",
        "created_at": "2021-06-07T13:55:08.348000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I kinda feel like we should just drop create transactions entirely and do everything through the opcode (new chains would have a creator contract premined in) ðŸ¤£",
        "created_at": "2021-06-07T13:55:41.879000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "At some point during the typed transaction discussions we explored why not just switch to create2-style create transactions. And we realised that either of them can be done via proxies anyway, so one of the proposals was to remove all special transactions.",
        "created_at": "2021-06-07T13:55:56.094000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The bottom three sections were the notes: ttps://notes.ethereum.org/@axic/HyKW2yCIP\n\nWhile I still support overhauling this long term, not sure it makes sense batching it with address space extension.",
        "created_at": "2021-06-07T13:58:40.972000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Fair!",
        "created_at": "2021-06-07T13:59:01.007000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And one interesting point between create vs. create2 is, that contracts created via create can not be \"resurrected\", but create2-style contracts can be deployed again after selfdestruct. Right?",
        "created_at": "2021-06-07T13:59:24.836000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Well, I still have a dream of banning selfdestruct",
        "created_at": "2021-06-07T13:59:43.292000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And the easiest solution to implementing verkle trees basically requires doing that",
        "created_at": "2021-06-07T13:59:56.590000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, random idea about selfdestruct: how about it tranfers the funds and replaces the code with `0xFE`?",
        "created_at": "2021-06-07T14:03:36.384000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It renders the account as non-executable, but at least there's no need to prove it has been deleted from the account structure. Not sure whether storage should be freed or not, as that is the unbounded aspect of the instruction.",
        "created_at": "2021-06-07T14:05:22.542000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'd be happy with that!",
        "created_at": "2021-06-07T14:05:57.858000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or actually.... hold on",
        "created_at": "2021-06-07T14:06:31.511000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Two problems with that:",
        "created_at": "2021-06-07T14:06:37.698000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "1. That requires editing lots of code slots at the same time (but this is easily fixable if we just replace the first byte with 0xFE)",
        "created_at": "2021-06-07T14:06:58.578000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "2. It does not satisfy the nice-to-have property that once a contract has some nonzero code, it's guaranteed to keep having that code forever",
        "created_at": "2021-06-07T14:07:23.709000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah, in the verkle tree yes. In the current tree there is no difference.",
        "created_at": "2021-06-07T14:07:41.734000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(2) is nice to have eg. for account-abstracted wallets",
        "created_at": "2021-06-07T14:07:46.367000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Or anything that depends on user-provided libraries",
        "created_at": "2021-06-07T14:07:55.075000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, that is the problem with idea. Another option is to have `is_executable` flag in the account.",
        "created_at": "2021-06-07T14:08:12.389000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah, can do that",
        "created_at": "2021-06-07T14:08:24.664000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The other option of course is making SELFDESTRUCT _just_ be a \"send all ETH\" opcode",
        "created_at": "2021-06-07T14:08:47.879000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I was a fan of that when suggesting to rename it to TRANSFER, as some people are loud about having an unconditional transfer (i.e. execute no code).",
        "created_at": "2021-06-07T14:09:52.769000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But wonder how many existing cases depend on the fact that after selfdestruct that contract will not be executable anymore.",
        "created_at": "2021-06-07T14:10:14.726000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "New code can easily work this around by having a `isExecutable` within the contract, which is set before selfdestruct is called. The same can be mimicked with the above two options on a protocol level.",
        "created_at": "2021-06-07T14:11:02.162000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Fair! If it disrupts existing use cases less I'm fine with SELFDESTRUCT turning the account into an account-with-a-stub",
        "created_at": "2021-06-07T14:11:05.562000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Would it be possible putting out an RFP (or direct some apprentices at it) for a \"comprehensive analysis of selfdestruct use cases on mainnet\"?",
        "created_at": "2021-06-07T14:12:18.201000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I would support that!",
        "created_at": "2021-06-07T14:12:26.936000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think we are just beating around the bush all this time because nobody has time to actually research what would break in which case.",
        "created_at": "2021-06-07T14:12:39.238000+00:00",
        "attachments": []
    },
    {
        "author": "albusdompeldorius",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Do you think this would be a good project for the core developer apprenticeship program? I am one of the applicants, and I am currently compiling a list of possible projects that I find interesting.",
        "created_at": "2021-06-07T15:46:57.518000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's hard to say because it depends a lot on \"what you know\".  I think nobody is going to be able to answer this for you and the best way to figure it out would be to actually investigate it yourself.  Given that it's not a pressing thing and thus we don't \"need\" it to happen on a specific time table, that does make it a good CDAP project candidate.",
        "created_at": "2021-06-07T16:14:28.700000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, it's a good research topic because it has a somewhat clearly defined goal of finding all the places where SELFDESTRUCT is used and then analyzing them and writing it all down.  My intuition says that someone scrappy and technical could get pretty far with this while learning as they go since executing on it is mostly just analysis of existing data as opposed to trying to solve unsolved problems.",
        "created_at": "2021-06-07T16:17:04.464000+00:00",
        "attachments": []
    }
]