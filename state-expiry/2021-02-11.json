[
    {
        "author": "djrtwo",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "+1 . The way the merkle branch is exposed in the contract, you shouldn't have to have all historic entries. That said, I'm not sure if any client is doing that today",
        "created_at": "2021-02-11T13:07:07.782000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I wrote up a doc on state size management",
        "created_at": "2021-02-11T16:43:26.374000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://hackmd.io/@HWeNw8hNRimMm2m2GH56Cw/state_size_management",
        "created_at": "2021-02-11T16:43:26.761000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Would love feedback from people here!",
        "created_at": "2021-02-11T16:43:32.483000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'd be particularly interested in regenesis people's thoughts on resurrection conflicts",
        "created_at": "2021-02-11T16:44:11.957000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Hence, the least disruptive solution so far seems to me to be some form of stubs. However, there is an information-theoretic problem with stubs that leads to stubs having some tricky consequences. In order to serve the role of preventing new state objects from being created at N positions of expired state objects, a set covering those N addresses (and/or storage keys) must be part of the state. If that set covers them minimally (ie. it’s just the addresses), that set has size O(N), and therefore the state size is O(N); the size of the active state is proportional to the expired state, so we don’t actually solve the problem.\n\nI'm not 100% sure that is true. At least in TurboGeth storage keys are prepended by the account keys (single state trie), so we can put a \"tombstone\" onto an account and that will guarantee that no storages could be created for this account anymore.\n\nSo basically, if the state trie is merged (account+storage), this problem goes away if I read that right.",
        "created_at": "2021-02-11T21:03:10.179000+00:00",
        "attachments": null
    },
    {
        "author": "zahary.",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We've implemented this in Nimbus already and we plan to include snapshots of the deposit contract state within our weak subjectivity start options",
        "created_at": "2021-02-11T21:09:46.325000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The problem is that the tombstone is still part of the state",
        "created_at": "2021-02-11T21:10:29.409000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "As in, it's part of the information that nodes have to store forever to ensure that new objects cannot be created at that position",
        "created_at": "2021-02-11T21:10:54.494000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah, but it is only one slot per account, so supposed to be way less information than the whole account and its storage, especially for bigger smart contracts. but it is actually something that is relatively easy to measure",
        "created_at": "2021-02-11T21:18:28.310000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What do you mean by \"the state trie is merged\" btw? Like, getting rid of the two-level storage structure and just putting storage keys as members of the global state tree?",
        "created_at": "2021-02-11T21:24:13.008000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I unfortunately worry that it will not be way less information",
        "created_at": "2021-02-11T21:24:36.402000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, like in our data model each storage item is prefixed with the account key",
        "created_at": "2021-02-11T21:26:12.300000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "right, I support such ideas in principle",
        "created_at": "2021-02-11T21:26:27.107000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I can check how much data is storage and how much is account info",
        "created_at": "2021-02-11T21:26:40.346000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Though note that removing or neutering selfdestruct ( https://hackmd.io/@HWeNw8hNRimMm2m2GH56Cw/selfdestruct ) is a prerequisite of that sort of thing",
        "created_at": "2021-02-11T21:26:46.592000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I asked this morning:",
        "created_at": "2021-02-11T21:27:09.037000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "| Key-Value store | Account snapshot   | 5.44 GiB   |  117371228 |\n| Key-Value store | Storage snapshot   | 29.08 GiB  |  408601189 |",
        "created_at": "2021-02-11T21:27:09.914000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah, not as dramatic as I thought but still almost 6 times difference",
        "created_at": "2021-02-11T21:28:14.896000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And as I expand on in my post, I think if we do per-contract expiring, then contracts would have to rewrite themselves to make much of their state be in the form of separate accounts",
        "created_at": "2021-02-11T21:28:21.236000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I’ll need to read this part a bit closer",
        "created_at": "2021-02-11T21:29:10.590000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Btw don’t we have the same problem now with self destruct? Can’t there be conflicts?",
        "created_at": "2021-02-11T21:30:55.627000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I mean, what is the difference in principe between that and rent expiration",
        "created_at": "2021-02-11T21:31:18.786000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But with self destruct conflicts don't actually cause harm",
        "created_at": "2021-02-11T22:04:28.144000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, you need to think about this not just at contract level but also at the level of objects such as storage keys representing ERC20 token balances",
        "created_at": "2021-02-11T22:05:02.069000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "eg. what if your ERC20 balance expires, then someone sends you ERC20 tokens, and then you resurrect your ERC20 tokens; the contract would need adding logic. And ERC20s are only the simplest case",
        "created_at": "2021-02-11T22:06:13.156000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I understand, yeah, that’s a tricky problem, but “my balance expires” means that an entry in another account’s storage changes. Not my account as it is.  So if that contract is fine, I don’t see issue with ERC20. \n\nIf the smart contract expires on the other hand, how would anyone send anything to me?",
        "created_at": "2021-02-11T22:15:33.957000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But then with defi composability, it’s enough for one contract to expire to break a lot of stuff. \nAnd on the protocol level we have no idea and shouldn’t have ideas about semantics of data in storages, right? It’s an abstraction leak. \n\nBack to my initial oblivious question: what difference makes self destructed contracts to not cause harm and for expired to cause it?",
        "created_at": "2021-02-11T22:22:13.499000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e But then with defi composability, it’s enough for one contract to expire to break a lot of stuff. \n\nIt doesn't really \"break\" things, it just means that the next transaction would have to provide witnesses for everything",
        "created_at": "2021-02-11T22:25:27.746000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e And on the protocol level we have no idea and shouldn’t have ideas about semantics of data in storages, right? It’s an abstraction leak.",
        "created_at": "2021-02-11T22:25:33.514000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hmm, I don't think we can think about contract storage this way. The problem is that storage has unbounded size, which is the fundamental problem in any approach that treats contracts as units",
        "created_at": "2021-02-11T22:26:02.845000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But that’s the current status quo, right? We have storage slots, we have EVM opcodes, these opcodes can read and write but the node doesn’t know if it executes an ERC20 token or a proxy or anything else.",
        "created_at": "2021-02-11T22:33:07.199000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So this problem with potential conflicts start to look like a DB behavior under network partitioning. That’s why these recreations might cause conflict, gotcha.",
        "created_at": "2021-02-11T22:35:47.653000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I wonder how much data will a tombstone “map” take if we make sure that we put tombstones as early in the Merkle path as possible and also optimize common prefixes.",
        "created_at": "2021-02-11T22:41:41.295000+00:00",
        "attachments": null
    },
    {
        "author": "mandrigin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Because we need this info from somewhere, so we can figure out which account addresses are truly free and which were ReGenesis’d away.",
        "created_at": "2021-02-11T22:43:46.207000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "well if we're okay with tombstones being \"early in the merkle path\" then that's equivalent to the single-tree solution, which I like but that would require the possibility of node metadata",
        "created_at": "2021-02-11T22:44:33.708000+00:00",
        "attachments": null
    }
]