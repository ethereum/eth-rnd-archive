[
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Assuming we have strict fixed size chunking as the / a code merklization option, and people write their compilers / code to match the fixed size chunking due to some crypto economic driver we introduce, then we should try to work out how long typical functions are that execute. Having the code of a typical function in one chunk should make things more efficient. \nI will put this on my TODO list as part of the static code analysis / comparing code merklization techniques for blocks 9M to 10M.\nAnother thing to do is to try to work out if functions have become longer as Ethereum has progressed. Contracts have on average become longer (see graph in \u003c@!689635476826619924\u003e  and my slides from the meet-up talk). I assume this means contracts have become more complex, and hence functions are more complex. This could possibly be used to extrapolate future average function sizes. Of course, at the moment things are constrained by the 24K contract size limit...",
        "created_at": "2020-06-26T06:32:07.361000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "if two chunks are siblings in the merkle tree, then the merkle proof of these two chunks is smaller than merkle proof of one chunk ðŸ™‚ so smaller chunks are actually better in this regard, because they make it easy for compiler to make \"chunk alignment\" without wasting too much space. But wasting space in a merkelised code is not a big issue either. So I don't think these are things we need to worry about too much",
        "created_at": "2020-06-26T06:36:02.520000+00:00",
        "attachments": null
    }
]