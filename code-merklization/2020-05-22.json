[
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!636680106630316033\u003e Ah I see. The reason I wasn't too worried about the miner having to track the chunks is that they'll have to execute the tx anyway, and this tracking shouldn't add much overhead.\nAlso a question is what happens if the bytecode has dynamic jumps (i.e. jumpdest is determined at runtime)?",
        "created_at": "2020-05-22T10:55:26.527000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But this gives me an idea for another experiment. I can see what percentage of the bytecode sent to a stateless node is actually useful for the given tx and how much is sent just due to overhead of the chunking mechanism in the prototyped approach. That should give an idea how much gains we can expect with more optimizied-though-complicated schemes",
        "created_at": "2020-05-22T10:57:46.887000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e \u003c@!636680106630316033\u003e Ah I see. The reason I wasn't too worried about the miner having to track the chunks is that they'll have to execute the tx anyway, and this tracking shouldn't add much overhead.\n\u003e Also a question is what happens if the bytecode has dynamic jumps (i.e. jumpdest is determined at runtime)?\n\u003c@259648573401071617\u003e  Solidity doesn't use dynamic jumps. We should be able to detect code that does dynamic jumps - I will add this to the static code analysis tool - so we will know if any existing code uses dynamic jumps.",
        "created_at": "2020-05-22T23:08:44.422000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e But this gives me an idea for another experiment. I can see what percentage of the bytecode sent to a stateless node is actually useful for the given tx and how much is sent just due to overhead of the chunking mechanism in the prototyped approach. That should give an idea how much gains we can expect with more optimizied-though-complicated schemes\n\u003c@259648573401071617\u003e  that sounds like a great idea.",
        "created_at": "2020-05-22T23:10:00.744000+00:00",
        "attachments": []
    }
]