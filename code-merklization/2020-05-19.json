[
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "agree with \u003c@!259648573401071617\u003e   it will cost more.",
        "created_at": "2020-05-19T02:42:48.225000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!259648573401071617\u003e , when you do your calculations, do you assume that the offset of the 128 byte chunk isn't needed, because it can be determined by virtue of where is sits in the trie? Do you include the cost / size of the extra message digests, given a tree structure?",
        "created_at": "2020-05-19T02:45:05.159000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "My static code analysis, splitting code based on function id is coming together. I will release the code once I shake a few more bugs out of it.",
        "created_at": "2020-05-19T02:46:25.421000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!259648573401071617\u003e , I am correct in assuming that to use the jumpdest of fixed size splitting, the evm will need to keep a track of what code is used?",
        "created_at": "2020-05-19T02:47:27.557000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e offset of the 128 byte chunk isn't needed, because it can be determined by virtue of where is sits in the trie?\nyeah exactly, trie key would be the offset of the first byte in the chunk",
        "created_at": "2020-05-19T10:18:04.382000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e jumpdest of fixed size splitting, the evm will need to keep a track of what code is used?\ndo you mean how can evm tell if a jumpdest in a fixed sized chunk is valid and not pushdata?",
        "created_at": "2020-05-19T10:20:34.343000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e splitting code based on function id is coming together.\nso you're aiming to have each solidity function as one chunk? that might get easier with the subroutines eip. \u003c@!425279588009246720\u003e is thinking about that too",
        "created_at": "2020-05-19T10:24:38.543000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e do you mean how can evm tell if a jumpdest in a fixed sized chunk is valid and not pushdata?\n\u003c@!259648573401071617\u003e I did a typo which made my question confusing. \nFor the \"split by jumpdest approach\", or the \"split code into fixed size chunks approach\", am I correct in saying that the EVM will need to keep a track of what code is used?",
        "created_at": "2020-05-19T23:53:28.702000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e so you're aiming to have each solidity function as one chunk? that might get easier with the subroutines eip. \u003c@!425279588009246720\u003e is thinking about that too\n\u003c@!259648573401071617\u003e Correct \nHaving subroutines will help with next code, but won't help with contracts that have already been deployed.",
        "created_at": "2020-05-19T23:54:51.724000+00:00",
        "attachments": []
    }
]