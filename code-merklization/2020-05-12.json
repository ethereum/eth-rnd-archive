[
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e , Perhaps when a contract is deployed (or for historical contracts when they are being converted) a trial compression could be done. If the contract doesn't compress well, then don't compress it. In the code blob, have a flag that indicates if the code has been compressed + with what algorithm.",
        "created_at": "2020-05-12T03:49:01.043000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@636680106630316033\u003e The problem is that everything has to be designed around the assumption of lack of compression, this we can't have any in-protocol dependency on compression.  In other words, individual clients can implement compression locally to opportunistically improve performance, bet things like gas cost must assume uncompressed.",
        "created_at": "2020-05-12T07:48:59.323000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Actually the protocol implicitly assumes compression by saying \"zero bytes are cheaper than non-zero bytes because they can be compressed\" (in bytecode).",
        "created_at": "2020-05-12T08:04:21.655000+00:00",
        "attachments": null
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e  For communicating the witness, surely the smaller size the better.",
        "created_at": "2020-05-12T08:06:34.707000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I suspect there are specific situations where compression can fit into the protocol, just not generally.  One of the things to keep in mind is that many (most? all?) compression protocols can result in a final size that is *bigger* than the compressed size.",
        "created_at": "2020-05-12T08:24:39.601000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I suppose you could require that the user supply the smaller of either compressed or uncompressed and slash them if they give you the bigger one?",
        "created_at": "2020-05-12T08:25:25.229000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We are talking in terms of the witness specification, which already has multiple options for the bytecode (store complete bytecode or only store size+hash). It would be possible to extend that to allow yet another type, compressed bytecode. The spec \"stipulates\" that the encoding which produces the smallest output in terms of bytes must be produced.",
        "created_at": "2020-05-12T08:40:20.632000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The other thing to be careful of is malicious data that is smaller when compressed, but is designed to be extremely expensive to compress/decompress.",
        "created_at": "2020-05-12T08:42:57.481000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's a good point.",
        "created_at": "2020-05-12T08:54:13.064000+00:00",
        "attachments": null
    }
]