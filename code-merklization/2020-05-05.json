[
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!425279588009246720\u003e , I have been looking at the EVM opcode / asm output of compiled Solidity. I think more efficient Code Merklization will be possible for newly deployed contracts if the assembler layout was changed. The assembler seems to do:\n\nhappy path code\nDo conditional check and jump to happy1 if a check passes\nProcess failure case / revert\n\nhappy1: \nmore happy path code.\n\nIf this was changed to:\nhappy path code\nDo conditional check and jump to sad1 if a check fails\nmore happy path code\n\nsad1: \nerror handling revert",
        "created_at": "2020-05-05T03:58:21.623000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That is, aim to include the entire happy path in one contiguous piece, rather than intermixing failure code with happy path code.",
        "created_at": "2020-05-05T03:58:57.116000+00:00",
        "attachments": []
    },
    {
        "author": "_drinkcoffee",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Assuming witness size affects pricing of transactions, then could it be desirable to have a Solidity option to generate code that minimises run-time costing (witness size), over size of the contract (deployment size / cost)?",
        "created_at": "2020-05-05T04:50:36.398000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Thanks for looking into this! I think when witness size will be a factor of gas usage, this will become relevant to the optimiser. One complication is that the new IR generator may generate completely different code to the above and I expect that to be the norm by the the stateless ethereum launches.\n\nThe code generated via the IR is less strictly structured (at least in the terms of above) so not sure it will be easy to optimise it for witness layout.",
        "created_at": "2020-05-05T08:50:35.073000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's why I am more interested to get some of these restrictions into the subroutines proposal (https://ethereum-magicians.org/t/eip-2315-simple-subroutines-for-the-evm-analysis/4229) as that would simplify the work for the optimiser and merklization a potentially great deal.",
        "created_at": "2020-05-05T08:51:30.035000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Another \"problem\" we're facing for merklization is data contracts (discussed on \u003c#706868829900505180\u003e briefly).\n\nMaybe it is not a problem at all, because the high cost of the data witness will be a deterrent for users to use data contracts.",
        "created_at": "2020-05-05T09:38:51.322000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hm, a code trie is in some sense like a static storage trie, cost for reading from either (assuming same depth) should be similar",
        "created_at": "2020-05-05T09:47:38.993000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I mean it will be awkward to split up a data contract, perhaps only the fixed size split is workable. And this may be a reason to consider supporting multiple merklization strategies in the witness (I think I mentioned this somewhere before) and select the appropriate/shortest output.",
        "created_at": "2020-05-05T09:50:08.586000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And since data contracts are not targets of execution, they will only be referenced via `extcodecopy`s and for those cases maybe we need a completely different option.",
        "created_at": "2020-05-05T09:52:49.618000+00:00",
        "attachments": []
    }
]