[
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Random remark: since Solidity added \"immutable constants\" those are actually stored at the end of the bytecode (before the metadata) and filled out by the constructor during deployment. They are read via `codecopy`.\n\nThis means it may be possible that witnesses will frequently need to have those chunks.",
        "created_at": "2020-09-10T00:04:26.418000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e I posted an example SSZ schema that could be used in the discussion thread for the EIP if anyone wants to take a look.",
        "created_at": "2020-09-10T01:14:31.652000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "link?",
        "created_at": "2020-09-10T01:14:33.704000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!273808422753796097\u003e \n\nhttps://ethereum-magicians.org/t/eip-2926-chunk-based-code-merkleization/4555/5?u=pipermerriam",
        "created_at": "2020-09-10T03:48:55.066000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "why have `code` and `codeRoot`? If `core` is part of the structure, then `codeRoot` will be accessible automatically because it will just be an intermediate node in the hash tree",
        "created_at": "2020-09-10T04:24:14.112000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "aaah I see, you're defining all the sub-data-structures",
        "created_at": "2020-09-10T04:24:42.458000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "nvm",
        "created_at": "2020-09-10T04:24:44.101000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Not sure what this means",
        "created_at": "2020-09-10T04:25:12.288000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "`code = List[Vector[uint8, bytes[32]]]`",
        "created_at": "2020-09-10T04:25:13.532000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ah, I guess you want:\n\n```\ncode = List[Chunk, 24576 // 32]\n\nclass Chunk(Container):\n    codeStartByte: uint8\n    codeChunk: bytes32\n```",
        "created_at": "2020-09-10T04:26:07.034000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Sorry my ssz schema syntax is rusty",
        "created_at": "2020-09-10T04:52:46.544000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Thanks everyone for the feedback üôè  I'll be integrating them gradually into the spec.\n\u003e (it's possible that the existing binary state tree spec actually special-cases into a regular binary tree when the keys are all contiguous, would be good to see if that's true)\nI was talking to \u003c@!353136597522448385\u003e and it seems the binary spec *is* going in that direction, which is great for our purposes. That'd avoid 2 merkleization rules which means somewhat less complication for witness generation/verification. I think it might make sense to wait for the binarification spec dust to settle and then decide about adopting that spec or going with a new set of rules",
        "created_at": "2020-09-10T14:49:04.621000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!259648573401071617\u003e any thoughts using SSZ to both simplify and remove the dependency on binary spec?",
        "created_at": "2020-09-10T15:50:09.606000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm personally on-board with that (have to refresh my ssz background). But hearing from client devs on this would be nice",
        "created_at": "2020-09-10T15:51:24.285000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Specially if that's bundled with a migration of the transactions and receipts tries to ssz, so we don't end up with 3 merkleization rules",
        "created_at": "2020-09-10T15:52:43.237000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!329594653097721856\u003e \u003c@!213672586264051717\u003e \u003c@!211091239112671234\u003e \u003c@\u0026652918665943056397\u003e ^ Anyone have strong opinions about the introduction of SSZ into your dependency chain? üëç / üëé  / ü§∑",
        "created_at": "2020-09-10T15:54:18.432000+00:00",
        "attachments": []
    },
    {
        "author": "0xraino",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think we're ok with it. It's already in teku so we could pull it out into its own library.",
        "created_at": "2020-09-10T15:57:46.774000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "why? I am sorry SSZ is one of these things I keep failing to understand, though I tried a few times üôÇ perhaps it has some confusing naming in it. But, as I pointed out earlier, you do not need a serialisation just to produce input for hashing",
        "created_at": "2020-09-10T15:57:59.916000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "At least I know now that there are at least 2 different things, both called SSZ",
        "created_at": "2020-09-10T15:59:47.798000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so I am not sure which one you are talking about here",
        "created_at": "2020-09-10T16:00:02.046000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md",
        "created_at": "2020-09-10T16:00:28.738000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think this document is written for people who are already familiar with SSZ, but just need a reference",
        "created_at": "2020-09-10T16:02:31.714000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think I have tried to digest it before, but I could not figure out how all these pieces fit together",
        "created_at": "2020-09-10T16:02:54.576000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@456226577798135808\u003e I think it's about simplicity.  SSZ already has a well defined format for producing a merkle root for some set of data (with some sort of schema).  Leaning on existing work.  The benefit of using SSZ is that it is both a serialization and trie hashing which means that at the networking level, you can do things like splitting the object up into smaller pieces and having proofs that those chunks are part of the whole.",
        "created_at": "2020-09-10T16:03:15.826000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Just linked to the spec to define which SSZ I am referring to (I don't know about another SSZ)",
        "created_at": "2020-09-10T16:03:39.399000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "the two things that are called SSZ are serliasation format and trie hashing algorithm",
        "created_at": "2020-09-10T16:04:04.667000+00:00",
        "attachments": []
    },
    {
        "author": "vorot93",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "not to derail discussion, but I would appreciate a split between serialization and consensus",
        "created_at": "2020-09-10T16:04:07.995000+00:00",
        "attachments": []
    },
    {
        "author": "vorot93",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "and have something more widespread like messagepack on the wire in devp2p",
        "created_at": "2020-09-10T16:04:41.024000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think trying to squeeze in SSZ \"just because\" is premature",
        "created_at": "2020-09-10T16:05:34.599000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "as I said, when we do hashing, we do not need to split anything",
        "created_at": "2020-09-10T16:06:11.454000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "concatenation of two hashes works just fine",
        "created_at": "2020-09-10T16:06:37.071000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "the way the proofs are going to be constructed is a different matter",
        "created_at": "2020-09-10T16:07:28.254000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "and this is where something like common format will be useful",
        "created_at": "2020-09-10T16:07:41.841000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e I think trying to squeeze in SSZ \"just because\" is premature\nThe reasoning isn't \"just because\".  It removes a dependency and simplifies the spec (by leaning on a well established specification)",
        "created_at": "2020-09-10T16:09:03.352000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "similar to how we could lean on the existing yellow paper `TRIE(...)`",
        "created_at": "2020-09-10T16:09:39.407000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ok, my knowledge of the established specification is limited, I have to admit",
        "created_at": "2020-09-10T16:11:22.363000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The idea is that all you have to do is define an SSZ schema for the merklized code and meta data and you get a merkle trie for free",
        "created_at": "2020-09-10T16:12:06.497000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ok, I will need to understand what \"get for free\" really means here üôÇ",
        "created_at": "2020-09-10T16:14:06.858000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I've learned that nothing is for free",
        "created_at": "2020-09-10T16:14:29.844000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so the alternative would be to come up with a custom merkleization rule, which is basically an alternative to ssz hashing. but i think the idea is: it's nicer to use an existsing rule",
        "created_at": "2020-09-10T16:15:33.783000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "free = At the cost of SSZ as a dependency",
        "created_at": "2020-09-10T16:15:36.055000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't think we need to mix in the concerns of code dependency when we are designing data structures",
        "created_at": "2020-09-10T16:16:11.591000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "unless there structures are horrendously hard to implement",
        "created_at": "2020-09-10T16:16:28.294000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "By defining an SSZ type, you by default get a well formed serialization as well as a merkle tree structure that respects the structure of the type. For each sub-type in the definition, you can have the entirety of the sub-tree or replace it with it's merkle root and the outer type retains it's merkle root",
        "created_at": "2020-09-10T16:16:43.095000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ok, I feel I am not prepared to this argument, so I will need more time to think about these things",
        "created_at": "2020-09-10T16:18:07.868000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I hope there will be recourse later if I do not provide feedback right now",
        "created_at": "2020-09-10T16:18:22.793000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "you are correct in that the \"spec\" is not optimized for onboarding. that is a fault of most eth2 specs :/\nI will see if there is a good explainer somewhere",
        "created_at": "2020-09-10T16:18:59.535000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e I hope there will be recourse later if I do not provide feedback right now\nit's almost impossible that code merkleization will make it in the next 2 HFs at the very least, so you have plenty of time üôÇ",
        "created_at": "2020-09-10T16:19:25.716000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Does code merkleization brings any benefit besides making witnesses smaller? This version provides no benefit for code deduplication. And witnesses are (at least in my mind) in a bit of a limbo right now until there's clarity which direction the research is going.\n\nGiven that I think there's plenty of time to get this into a hard fork üòâ",
        "created_at": "2020-09-10T16:35:07.466000+00:00",
        "attachments": []
    },
    {
        "author": "axic3354",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "On the deduplication front: And mostly we assume anyhow that clients are free to optimise their storage/lookup and none of these EIPs define that.",
        "created_at": "2020-09-10T16:38:52.386000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "my worry is mostly about not over-optimising in the data structures, like it was done in the design of Merkle-Patricia tree",
        "created_at": "2020-09-10T16:39:40.030000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think I can see what is actually being suggested",
        "created_at": "2020-09-10T16:48:52.591000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "it is suggested that we use part of SSZ as a notation to describe an ordinary chunking to 32 byte chunks and constructing the binary merkle tree",
        "created_at": "2020-09-10T16:49:50.902000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "in effect, it will the same as just padding the code with zeroes to the first power of 2 of chunks of size 32, and then doing binary merkle tree",
        "created_at": "2020-09-10T16:50:56.921000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "but just expressed as `hash_tree_root(Bitvector)` from the SSZ description",
        "created_at": "2020-09-10T16:51:27.196000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "if this is what it is, then I am fine with that",
        "created_at": "2020-09-10T16:51:34.665000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "but equally I don't see the reason to have SSZ as a dependency just for that. This code isn't hard to write",
        "created_at": "2020-09-10T16:52:15.601000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "pros: simplicity in expression and common proof scheme that is being simultaneously developed in other areas of the stack",
        "created_at": "2020-09-10T16:53:14.595000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "(not deep in this convo) that looks correct, except it would be a `BytesN` or `List[byte]` type",
        "created_at": "2020-09-10T16:54:10.076000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "rather than the Bitlist",
        "created_at": "2020-09-10T16:54:12.782000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "a list or vector of bytes rather than of boolean bits",
        "created_at": "2020-09-10T16:54:37.395000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yes, I just did not see those things",
        "created_at": "2020-09-10T16:55:17.290000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "but I must say that the way it is described in that spec is way too obsure",
        "created_at": "2020-09-10T16:56:10.696000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "What I would do is to write down this",
        "created_at": "2020-09-10T16:56:40.358000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "1) in order to build binary merkle tree, we need a piece of data of size 32*2^K bytes",
        "created_at": "2020-09-10T16:57:24.237000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "2) this is how we convert any type into such piece of data",
        "created_at": "2020-09-10T16:57:39.770000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "goal is to pull it out into it's own spec and make it far more descriptive\n-- https://github.com/protolambda/eth2.0-ssz\n\nsome preliminary work was done by \u003c@!203220829473996800\u003e but hasn't hit the top of priorities recently :/",
        "created_at": "2020-09-10T16:57:50.568000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah, fair",
        "created_at": "2020-09-10T16:58:03.094000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "all this complicated description does is tries to describe padding to 32*2^K bytes, in a complicated way üôÇ",
        "created_at": "2020-09-10T16:59:22.842000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "why can't we just say - here is how we convert any type into string of bytes (serialisation)",
        "created_at": "2020-09-10T17:00:10.456000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "here is how we pad string of bytes to any length",
        "created_at": "2020-09-10T17:00:22.565000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "here is how we build a merkle tree from a string which is 32*2^K bytes",
        "created_at": "2020-09-10T17:00:38.932000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\"here are some basic types we care about, here is how you construct more sophisticated types, this is how you serialize them, and this is how you form them into a binary merkle tree with nice properties wrt the constituent types\"",
        "created_at": "2020-09-10T17:01:20.759000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "you don't need to describe deserialisation, because it should be obvious how to reverse serialisation",
        "created_at": "2020-09-10T17:01:38.650000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "unless you want to dictate the implementation",
        "created_at": "2020-09-10T17:01:53.690000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "which the spec should not do",
        "created_at": "2020-09-10T17:02:01.308000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "unless, of course, there is a type erasure, but this apparently does not happen here, because there is a schema available during de-serialisation",
        "created_at": "2020-09-10T17:03:05.392000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "which is another important fact the spec fails to mention",
        "created_at": "2020-09-10T17:03:24.008000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e \"here are some basic types we care about, here is how you construct more sophisticated types, this is how you serialize them, and this is how you form them into a binary merkle tree with nice properties wrt the constituent types\"\n\u003c@!291925846556540928\u003e if there is more to the \"merkleisation\" process than just padding, then this exact difference needs to be described, and not the triviality of padding process.",
        "created_at": "2020-09-10T17:05:02.635000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We tend to need to define the following three things for various parts of the protocol.\n\n1. how we arrive at a `hash` to represent the data\n2. how we serialize the data for transmission over the network\n3. how we provide \"proofs\" for subsets of the data.\n\nWe can manually define these for each case which is fine, and in some cases, very appropriate.  However, SSZ provides a standard framework that gives us all three of these things already well spec'd.  From my perspective SSZ in this case is a tool that can give us easier specifications, the same way that we've historically leaned on `RLP(...)` to produce binary representations of things, or how the `header.transactions_root` leans on `Trie(\u003ctransactions-and-indices-trie\u003e)` .\n\nAnd it is my expectation that increased use of SSZ in the protocol will reduce overall client complexity and give us a robust single tool in our toolchain that can be used across different types of libraries that interact with different parts of the protocol.",
        "created_at": "2020-09-10T18:01:31.872000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e you don't need to describe deserialisation, because it should be obvious how to reverse serialisation\nMixed feelings there. Yes, a good spec would make it easy to infer from serialization. But at the same time the current spec is \"not good enough for onboarding\". Minimalism vs readability is not easy",
        "created_at": "2020-09-10T18:01:39.304000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Also, SSZ is simple, but not a single triangular merkle tree of a byte slice. The generalized indices make it look like it (nice generalization...), but each type defines its own use of a binary tree, which are then just nested.",
        "created_at": "2020-09-10T18:03:10.884000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And if it comes to using SSZ for serialization, most of the time you're packing some bytes, integers little endian, and that's about it. Some offsets as well (Idea of Peter, works great) for dynamic types (edit: dynamic-length types). You indeed don't need an SSZ library in most small data type cases, to actually deal with the bytes.",
        "created_at": "2020-09-10T18:04:58.940000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Also, no sparse merkle trees in SSZ, yet. There's an issue about it that discusses many options, but none of which are as pure as what's currently in SSZ. And no need for it, until maybe now. If there's a need, comment in the issue, and we can fit in something that also works for you all. (edit: issue = https://github.com/ethereum/eth2.0-specs/issues/1472)",
        "created_at": "2020-09-10T18:09:11.870000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!364458974906548225\u003e I understand your intention. However, I do not yet see SSZ as a framework, but merely as a serialisation format, no more, no less. But perhaps I do not have the same context that you do",
        "created_at": "2020-09-10T18:10:58.811000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "and until I see how SSZ would be used in the spec for code merkelisation, I should stop arguing and just wait",
        "created_at": "2020-09-10T18:14:02.069000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "There are 10 libraries and all eth2 clients intend to use it in production soon. It may not be a general-purpose does-everything framework, but it's more than a format at this point. And I think we're happy to fill the gaps to accommodate any kind of integration with eth1(x)",
        "created_at": "2020-09-10T18:14:02.197000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'd say with coordination of a new type or two in the SSZ spec, we can make SSZ do things like code-merkleization well. It's not some external format we have no control over.",
        "created_at": "2020-09-10T18:20:40.375000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "SSZ has well defined typing, merkle tree structures based on types, and serialization. Which would be good for a spec, and worked for eth2. Just not the types that fit code-merkleization well (yet). They can be compatible",
        "created_at": "2020-09-10T18:22:57.493000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think I can see how this could work",
        "created_at": "2020-09-10T18:28:18.178000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That said, the ssz types (existing types) vitalik proposed to use here are looking ok. But if you see some way to merkleize/serialize it better, there's definitely room for it",
        "created_at": "2020-09-10T18:29:32.832000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, I think what SSZ is really lacking is a good description üôÇ",
        "created_at": "2020-09-10T18:30:57.066000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think I am starting to understand it now after several tries in the past and arguing with you on Discord",
        "created_at": "2020-09-10T18:31:20.915000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "perhaps other people get it quicker than me though",
        "created_at": "2020-09-10T18:31:38.808000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Sorry, maybe my fault, but feel free to tag me and discuss as needed, this would be great to get sorted",
        "created_at": "2020-09-10T18:32:04.968000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I would not describe as fault, you were probably too closely involved into designing it",
        "created_at": "2020-09-10T18:33:00.606000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I've actually introduced 0 types, and removed 1 (a second special-case hashtreeroot)",
        "created_at": "2020-09-10T18:33:26.115000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "perhaps a person who did not design it could describe it better",
        "created_at": "2020-09-10T18:33:26.456000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "but I remember all those partials that I never began understanding, what happened to those?",
        "created_at": "2020-09-10T18:33:52.981000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "No need for them",
        "created_at": "2020-09-10T18:34:05.185000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Idea and compatibility is still there",
        "created_at": "2020-09-10T18:34:13.350000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And described to some extent in my ssz draft repo",
        "created_at": "2020-09-10T18:34:25.751000+00:00",
        "attachments": []
    },
    {
        "author": "Deleted User",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "thanks to providence üôÇ",
        "created_at": "2020-09-10T18:34:36.436000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Anyway, once you're through the minimal ssz spec in the main eth2 specs repo, we can talk about those future options of ssz, if those are of interest now. Most of those don't even require a spec change. They are just abstractions over what's there, for things like light-clients etc. which are not prioritized for phase0",
        "created_at": "2020-09-10T18:39:13.271000+00:00",
        "attachments": []
    }
]