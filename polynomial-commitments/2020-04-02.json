[
    {
        "author": "olivier07468",
        "category": "Cross-layer",
        "parent": "",
        "content": "Hi, I had some questions around the polynomial commitments of state post of yours.\n1. when one creates the accumulator for points (x, P(x)), one must it seems to me, commit to Acc(x) and Acc(x+1) (i.e. P(\\omega x)). How does one check that the two commitments are \"coheren\", i.e. not just some commitment to two unrelated polynomials?",
        "created_at": "2020-04-02T14:18:43.455000+00:00",
        "attachments": []
    },
    {
        "author": "olivier07468",
        "category": "Cross-layer",
        "parent": "",
        "content": "2. Concerning the vast merges \"Full state\" + \"cached stuff\": how often should that happen? It seems to require the full state (for instance because one has to interleave the new keys with the existing keys) and must be computationally very expensive.",
        "created_at": "2020-04-02T14:22:12.704000+00:00",
        "attachments": []
    },
    {
        "author": "olivier07468",
        "category": "Cross-layer",
        "parent": "",
        "content": "3. when merging the Full state with a cached update, do verifiers need to know, say, the full list of keys that existed in the full state?",
        "created_at": "2020-04-02T14:27:25.734000+00:00",
        "attachments": []
    },
    {
        "author": "olivier07468",
        "category": "Cross-layer",
        "parent": "",
        "content": "(I will rephrase this: when verifying a merge of sets + ordering as for what happens when merging C1_k and C2_k, does a verifier need to know the keys that are in C1_k and C2_k to compute and interpolate the permutations that are used when creating the accumulator?",
        "created_at": "2020-04-02T14:31:08.348000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003e one must it seems to me, commit to Acc(x) and Acc(x+1)",
        "created_at": "2020-04-02T17:04:54.363000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "Nope!",
        "created_at": "2020-04-02T17:04:57.274000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "You commit to `Acc(x)`",
        "created_at": "2020-04-02T17:05:01.510000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "And then you check the equation by making an _opening_ at `r` and `r+1` for some random `r`",
        "created_at": "2020-04-02T17:05:16.446000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003e 2. Concerning the vast merges \"Full state\" + \"cached stuff\": how often should that happen? It seems to require the full state (for instance because one has to interleave the new keys with the existing keys) and must be computationally very expensive.\n\nYou want the ratio of size `cache / block` to equal `state / cache`. So you'd want a duration that allows the cache to get to the size that is the geometric average between block and state",
        "created_at": "2020-04-02T17:06:13.852000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "Roughly the sqrt of the blockchain's runtime in blocks",
        "created_at": "2020-04-02T17:06:21.737000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "sqrt(10m) = 3162 ~= 0.6 days",
        "created_at": "2020-04-02T17:06:27.947000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "So I suggested 1 day",
        "created_at": "2020-04-02T17:06:31.008000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "You can also do it with multiple layers of caching, eg. each 4x larger than the previous",
        "created_at": "2020-04-02T17:06:58.343000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "This increases proof generation efficiency, at the cost of requiring reads to read from more caches",
        "created_at": "2020-04-02T17:07:15.255000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003e 3. when merging the Full state with a cached update, do verifiers need to know, say, the full list of keys that existed in the full state?",
        "created_at": "2020-04-02T17:07:22.273000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "yes",
        "created_at": "2020-04-02T17:07:23.343000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Cross-layer",
        "parent": "",
        "content": "It ideally would not be regular block proposers that compute these crazy updates, it would be some separate class of prover that would get rewards for it",
        "created_at": "2020-04-02T17:07:57.933000+00:00",
        "attachments": []
    },
    {
        "author": "olivier07468",
        "category": "Cross-layer",
        "parent": "",
        "content": "Once a day is for the \"cache merges\" only, and the crazy merges would happen less frequently?",
        "created_at": "2020-04-02T17:10:58.720000+00:00",
        "attachments": []
    }
]