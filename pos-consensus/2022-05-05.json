[
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yeah, I would want this to be an \"everyone\" thing.  Even with that though, I worry the functional anonymity set will be extremely low if we can't integrate it into the whole system.",
        "created_at": "2022-05-05T04:28:17.583000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Spitballing here: what if signing an attestation and withdrawing required a proof that you have not been stashed?  I think in theory this would work, though it may not be pragmatic singe attestation verification needs to be fast.",
        "created_at": "2022-05-05T04:29:10.853000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Maybe we could just require each account produce such a proof once per `n` blocks and on withdraw.  This would allow someone who got slashed to keep attesting for up to `n` block (`1/n` on average), but maybe that is acceptable for some low enough value of `n`?",
        "created_at": "2022-05-05T04:30:01.842000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "With such a scheme, the user would make their deposit and attesters would attest, but no one would be able to trace the source of funds of the attestors back to the deposits.  On withdraw, attestors would prove that they are allowed to withdraw the amount they are trying, but it wouldn't be correlated with any attestations or any deposit.",
        "created_at": "2022-05-05T04:31:49.253000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Perhaps I shouldn't be asking this cause I'm asleep but I don't understand your concern about slashings. All earnings within the beacon chain go to the validating address, and slashings get discounted from that. So as long as you can't connect the depositing address to the validating address, earnings or slashings stay anonymous. Either way: you do not want to allow attestations from slashed validators, in fact not a single one should make it on chain. This is a known vulnerability, see for example \u003chttps://github.com/ethereum/consensus-specs/pull/2845\u003e",
        "created_at": "2022-05-05T04:36:09.251000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "If you see -32 ETH from address 0xabcd on the execution layer and then in the next block you see +32 ETH from address 0x1234 on the consensus layer, you can draw a pretty strong correlation that 0xabcd == 0x1234.  For anonymity to work, you need as much of the assets as possible to sit in an obscured state for a random amount of time so you cannot correlate inputs and outputs.  If we treat \"the duration people stake for\" as a proxy for \"random duration\", then we can end up with a strong anonymity set.",
        "created_at": "2022-05-05T08:30:07.431000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I agree that in the current design, being able attest after cheating is a vulnerability.  Perhaps we could design around this though and make it so we don't have a strong need to punish people *immediately*?",
        "created_at": "2022-05-05T08:30:49.180000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "This I understand but I don't see the issue with slashing here. What you seem to need is that in addition to any entry queue, you have a random delay in the deposit being seen by the beacon chain",
        "created_at": "2022-05-05T09:54:42.651000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "You want that random delay to be up to infinity (the closer the better).",
        "created_at": "2022-05-05T09:55:55.589000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "People would find it unacceptable if when they deposited their ETH it took a random amount of time between instant and infinite before it was available on the consensus layer for staking.",
        "created_at": "2022-05-05T09:56:30.674000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "There is no need for it to be too large, the upper bound could depend on the volume of validators entry queue. Presumably after the beacon chain is settled we would have a regular lower bound on this queue due to rotation.",
        "created_at": "2022-05-05T11:08:55.820000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Why do you think there is no need for it to be large?  A small anonymity set doesn't serve a purpose because it cannot provide people with real anonymity.",
        "created_at": "2022-05-05T11:12:02.926000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Because if there's a large entry queue anyway then you can't pin point the new validator",
        "created_at": "2022-05-05T11:12:41.166000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "You can because the entry queue timing is known.",
        "created_at": "2022-05-05T11:13:06.572000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Unless time in the entry queue is random, but presumably that time would be bounded which greatly limits the utility of the randomness.",
        "created_at": "2022-05-05T11:13:41.167000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "For example, if the entry queue is first come, first served, then it is very likely that someone who entered the queue at time X is the person who exited the queue at time X+n where `n` is the queue length (measured in time).",
        "created_at": "2022-05-05T11:14:30.283000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So functionally, you have no actual anonymity here because you can correlate deposits and withdraws.",
        "created_at": "2022-05-05T11:14:44.043000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "You could make it so you enter the queue and get a secret, and then the queue \"pumps\" on the other side every block or something and each block you can check to see if your secret is allowed to exit the other side of the queue.  If so, you would submit a proof that you are allowed to exit the queue and finally stake.",
        "created_at": "2022-05-05T11:16:49.388000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "However, this leads to potentially infinite wait times for some people which I *suspect* would be unacceptable.",
        "created_at": "2022-05-05T11:17:07.886000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "You could simply never get selected for deposit onto the consensus layer.",
        "created_at": "2022-05-05T11:17:18.234000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@340345049063882753\u003e to not continue polluting Michael's PR. Do you run fork choice when you process pending attestations? And if so when you import a block your forkchoice does not have any new attestation weight? Namely if you were to run forkchoice get_head you would be guaranteed to get the newly imported block if it's the child of your last head. Is this the way Teku works?",
        "created_at": "2022-05-05T23:01:40.821000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I'm not entirely sure I understand what you're asking. \n\u003e Namely if you were to run forkchoice get_head you would be guaranteed to get the newly imported block if it's the child of your last head.\nI'm not making that claim. What's actually in forkchoice post-block import doesn't actually matter. All we're doing is saying that given the last time we ran fork choice it picked block X as head, and we've just imported the only known child of X, so it will be our new chain head based on the attestations we'd applied when we selected X as head.",
        "created_at": "2022-05-05T23:09:58.733000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "What is the actual concern you have here? Because a node should be able to run fork choice anytime it wants based on the information it has validly processed (ie only attestations from prior slots).  It's totally ok for nodes to see a different chain head for a period of time as long as they converge on the right head.",
        "created_at": "2022-05-05T23:11:14.481000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yeah, this is what I find funny, cause this child of X that was just imported, and you included the attestations that this child was including in your forkchoice, this alone, without any other attestations that you didn't process from the previous slot, may be sufficient to make you reorg to a previous block",
        "created_at": "2022-05-05T23:11:27.957000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "It might and if it does we'll deal with that once we finish adding in all the other pending attestations and run a full fork choice.  But that's a very rare situation so not what we should optimise for.",
        "created_at": "2022-05-05T23:12:06.928000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "so with the information that you already included in your forkchoice at the point of importing this block, if you call forkchoice `get_head` it will give you a different block than this child",
        "created_at": "2022-05-05T23:12:07.761000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Well except we haven't yet reapplied all the vote changes from the block - just updated the votes themselves. So if we just called our get_head it would return the new block.",
        "created_at": "2022-05-05T23:12:55.520000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@\u0026595685821026271242\u003e I'm trying to have an honest fight here ðŸ˜„",
        "created_at": "2022-05-05T23:12:55.587000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "But that's a quirk of protoarray applying attestations in two steps whereas the spec does it in one.",
        "created_at": "2022-05-05T23:13:13.982000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Ok we're getting somewhere, our protoarray also does this in two steps, but our doubly linked one does it at once, so if we import that block and call for forkchoice it will reorg. What worries me of your approach is that if you have to attest say right after importing that block, then you need to call forkchoice to make sure you're attesting to the right thing. But alright, it becomes now an implementation detail.",
        "created_at": "2022-05-05T23:14:55.615000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So to be an honest validator, you cannot really trust your head until you actually run forkchoice before doing anything.",
        "created_at": "2022-05-05T23:15:26.764000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I think \"trust' is too strong a word here, but yes it makes sense to apply all the information you have before creating attestations.",
        "created_at": "2022-05-05T23:18:29.740000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So the way we're doing this is we run forkchoice right after importing a block, this way we know for sure what's our head at that precise moment when the block arrived. And we are safe to attest right at that moment to what it is surely the head then. I thought for a moment in this combo that we could save this call to forkchoice, but now I realized that we would be just moving it to before acting on the block.",
        "created_at": "2022-05-05T23:21:29.300000+00:00",
        "attachments": []
    }
]