[
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "If you have a validator that has attested with source epoch `e` and target epoch `e+x`, is there a situation where an honest validator would create a future attestation with source epoch less than `e+x`?",
        "created_at": "2020-02-19T19:49:33.272000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yes but not less than `e` so there is no chance an honest validator will surround the previous vote",
        "created_at": "2020-02-19T20:46:18.769000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "(Casper surround slashing condition)",
        "created_at": "2020-02-19T20:46:30.624000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Not less than `e` or always higher than `e`?",
        "created_at": "2020-02-19T20:50:09.734000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Also, what would stop an honest validator attesting `(e,e+3)` and then later validating `(e+1,e+2)` which would be a surround slashing condition?  Trying to understand the logic I would need to  avoid creating a slashing condition (in terms of source and target epochs of current and previous attestation) for a single validator and boil it down to its simplest form without stopping it from carrying out its legitimate attestations",
        "created_at": "2020-02-19T20:55:15.822000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "A validator always only makes targets in a strictly increasing manner",
        "created_at": "2020-02-19T20:56:05.252000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So an honest val wouldnt see an earlier justification source during a later epoch",
        "created_at": "2020-02-19T20:56:54.326000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Target is defined by the current epoch wrt wall clock time",
        "created_at": "2020-02-19T20:57:06.708000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "And the source is only strictly increasing",
        "created_at": "2020-02-19T20:57:14.539000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So at `e+2` they see latest justified as `e+1`. At `e+3` an honest node would never see an earlier latest justified (`e`) than at a prior epoch",
        "created_at": "2020-02-19T20:58:25.299000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Cool, that makes sense and will be easy enough to implement.  Thanks!",
        "created_at": "2020-02-19T20:58:58.377000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Even if a validator lost all their previosuly signed data, if they turned on their node and let a few epochs pass, they would be safe\n\nUnless their node previously advanced forward past wall clock time more than the number of epochs they wait when turning on node",
        "created_at": "2020-02-19T21:01:04.552000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Thinking in context of HSM logic to provide advanced stake protection, where the HSM will refuse to sign potentially slashing attestations.  My main concern is to be able to do so without requiring too much memory (state) inside the HSM, and without access to the beacon chain.",
        "created_at": "2020-02-19T21:05:16.654000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Seems like I can get away with the following rules:\n\n  - an attestation must have target epoch \u003e source epoch\n  - an attestation must have a higher source epoch than previous attestation's source epoch\n  - an attestation must have a higher target epoch than previous attestation's target epoch\n\nThis isn't perfect, in that the target epoch isn't guaranteed to be accurate as far as wall clock time is concerned, but it shouldn't be able to create a slashing situation and that's the bit that the HSM logic cares about.",
        "created_at": "2020-02-19T21:08:18.056000+00:00",
        "attachments": null
    }
]