[
    {
        "author": "bitfalls",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Hi all, I'm planning a new post on justification / finalization and had a lot of comments already from a few people, but the consensus seems to be that this is currently a little confusing for anyone not truly in it to understand. Here is a draft: https://our.status.im/p/54e0ce3c-6fcc-4b98-8354-c0736a2c2d83/\n\nMainly, two things I discussed with Justin (is he not in these channels? I cannot tag him) are still confusing and seem like they're missing a big part on my end in order to \"click\" well enough for me to explain this to others.\n\nIf we assume the following general finality criterion:\n\n\u003e let `r_n, r_{n+1}, ..., r_m` be roots on the same forks at epochs `n, n+1, ..., m`. If `r_n, ..., r_{m-1}` are justified and there is a 2/3 vote from `r_n` (the source) to `r_m` (the target) then `r_n` can be safely considered finalized\n\nAccording to above, my logic says that all `r_{n\u003cx\u003cm}` are ALSO finalized because they are justified and older than the target being voted on by 2/3. Why, then, do we bother with the rules in the justification docs (234, 23, 12) rather than just say that any pair of epochs that is justified with the largest time between them immediately finalizes the older epoch as long as the no-surround rule isn't broken?",
        "created_at": "2019-08-01T23:28:22.669000+00:00",
        "attachments": []
    },
    {
        "author": "bitfalls",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Another thing Justin mentioned -  \"If 2/3 of validators agree on a pair of epochs such that the source epoch is justified, then the target epoch is also justified.\". From this, in my mind, it follows that each justification also immediately results in a finalization, because the requirement is fulfilled - i.e. two justified epochs with one that is older.\n\nI also asked about why there's no 1-4 rule if we're already being explicit about cases, and his answer was \"1-4 only works for finality if 1, 2 and 3 are justified and the beacon state doesnâ€™t store enough information\" which, again, to me is confusing because a) how can a beacon state not store enough information without taking this edge case into consideration and preventing it during development, and b) how much information is enough information?\n\nI'm looking for major plotholes in my understanding of this whole thing to really drive it home, so I'd appreciate it if anyone could let me know if I seem to be misinterpreting something as Justin and I have realized that this short-form text medium (twitter messages, essentially) isn't the best for in depth discussion of this type.\n\nWould anyone be interested in a sort of \"webinar\" of this where someone would literally be drawing slots and blocks on screen and making assumptions about blocks, votes, numbers and forks in order to end up with a new diagram and an explainer covering different cases? I can draw if need be, guided by people's explanations.",
        "created_at": "2019-08-01T23:29:28.353000+00:00",
        "attachments": []
    }
]