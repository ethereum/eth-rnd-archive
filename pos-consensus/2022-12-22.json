[
    {
        "author": "odyxes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Is there an explanation somewhere about why we do not finalize checkpoints older than 4 epochs?",
        "created_at": "2022-12-22T08:48:40.458000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Attestations are valid for only one epoch",
        "created_at": "2022-12-22T13:26:00.074000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@357182713440239623\u003e",
        "created_at": "2022-12-22T13:26:08.408000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "You could finalize an older checkpoint by importing old blocks though",
        "created_at": "2022-12-22T13:26:27.295000+00:00",
        "attachments": []
    },
    {
        "author": "odyxes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yes, I was thinking about something related to this rule, but in this case, why 3 epochs isn't enough?",
        "created_at": "2022-12-22T13:56:41.175000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yes, and we only finalize max 3 epochs ago. \n```python\n    # The 2nd/3rd/4th most recent epochs are justified, the 2nd using the 4th as source\n    if all(bits[1:4]) and old_previous_justified_checkpoint.epoch + 3 == current_epoch:\n        state.finalized_checkpoint = old_previous_justified_checkpoint\n    # The 2nd/3rd most recent epochs are justified, the 2nd using the 3rd as source\n    if all(bits[1:3]) and old_previous_justified_checkpoint.epoch + 2 == current_epoch:\n        state.finalized_checkpoint = old_previous_justified_checkpoint\n    # The 1st/2nd/3rd most recent epochs are justified, the 1st using the 3rd as source\n    if all(bits[0:3]) and old_current_justified_checkpoint.epoch + 2 == current_epoch:\n        state.finalized_checkpoint = old_current_justified_checkpoint\n    # The 1st/2nd most recent epochs are justified, the 1st using the 2nd as source\n    if all(bits[0:2]) and old_current_justified_checkpoint.epoch + 1 == current_epoch:\n        state.finalized_checkpoint = old_current_justified_checkpoint\n```",
        "created_at": "2022-12-22T17:51:09.800000+00:00",
        "attachments": []
    }
]