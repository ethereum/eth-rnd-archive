[
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@399309815517544451\u003e np. Lol. I'm going to keep trying to find UX pain points",
        "created_at": "2020-01-31T01:33:23.013000+00:00",
        "attachments": []
    },
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Update: I'll be chatting with a few 1.x teams to help understand what our best option is for bls verification",
        "created_at": "2020-01-31T01:38:01.322000+00:00",
        "attachments": []
    },
    {
        "author": "trent_vanepps",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "alex vlasov was pursuing 1962 before istanbul, was not able to get benchmarks for it in time for inclusion. \n\nhe has recently restarted the process, and is actively working on it",
        "created_at": "2020-01-31T03:37:33.975000+00:00",
        "attachments": []
    },
    {
        "author": "trent_vanepps",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@!322222239850168331\u003e",
        "created_at": "2020-01-31T03:37:57.314000+00:00",
        "attachments": []
    },
    {
        "author": "trent_vanepps",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "i think he's hoping to get it into berlin",
        "created_at": "2020-01-31T03:38:28.450000+00:00",
        "attachments": []
    },
    {
        "author": "trent_vanepps",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "(the next fork)",
        "created_at": "2020-01-31T03:38:34.411000+00:00",
        "attachments": []
    },
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I've commented on it",
        "created_at": "2020-01-31T06:08:15.291000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I guess there is some value to making sure that the key checks out, but it seems like the kind of thing that you _should_ not need a concensus algorithm / blockchain for - an additional \"issue\" here would be that the final gatekeeper is not eth1 - it's eth2 - so if there are implemenation differences etc...",
        "created_at": "2020-01-31T13:53:02.238000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "now, I can see how it can be useful for the world at large to trust that a particular signature checks out without having to do that calculation themselves (for example if the deposit contract did check, eth2 in theory wouldn't have to?), but that's different..",
        "created_at": "2020-01-31T13:54:26.828000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "usually when you send a tx in crypto and you mess up a signature, it gets rejected and you keep the funds. The problem here is that it gets rejected and you lose the funds\n\nThis is certainly less user friendly than the norm",
        "created_at": "2020-01-31T14:36:54.386000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Its not a deal breaker and good checks can be built offchain, but it would be nice in general if eth1 could verify bls sigs and it would be useful to protect users to shove that into the deposit contract",
        "created_at": "2020-01-31T14:38:06.676000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "If we had a bridge back we could refund deposits with invalid signatures, and not worry about changes to eth1",
        "created_at": "2020-01-31T14:41:43.939000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I would say its even deal breaker, obviously bug in deposit contract.",
        "created_at": "2020-01-31T14:42:35.230000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Maybe we can spec something that logs invalid deposits into a tree, of which the root is maintained in the beacon state? Then refund deposits with invalid signatures once we have a (slow) bridge? It doesn't have to affect the already formally verified deposit contract",
        "created_at": "2020-01-31T15:01:52.452000+00:00",
        "attachments": []
    },
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I likr that idea!",
        "created_at": "2020-01-31T15:31:33.831000+00:00",
        "attachments": []
    },
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I sat on this a bit without a change to the contract this is definitely a bug",
        "created_at": "2020-01-31T15:31:59.927000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "my point was mainly that the source of truth is still not the deposit contract, so as long as the eth2 side is authorative, even a check inside the deposit contract would not be enough - you'd indeed need a bridge back to be _really_ safe",
        "created_at": "2020-01-31T15:53:47.471000+00:00",
        "attachments": []
    },
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Well yeah",
        "created_at": "2020-01-31T15:57:18.450000+00:00",
        "attachments": []
    },
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "But that got shot down a while ago",
        "created_at": "2020-01-31T15:57:26.301000+00:00",
        "attachments": []
    },
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The best we can do rn is take action on the eth1 chain",
        "created_at": "2020-01-31T15:57:45.507000+00:00",
        "attachments": []
    },
    {
        "author": "gregthegreek",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Imo it's not about an end all solution. It's about implementing as many fail safes as possible",
        "created_at": "2020-01-31T15:58:10.673000+00:00",
        "attachments": []
    },
    {
        "author": "arnetheduck",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "different topic: let's assume I'm the block proposer - what happens if I don't build my block not on the *latest* head I know about, but for example one slot back? I can include the attestations from the block I skipped.. when it's time for the next proposer to do their work, they now have to choose between my block and the block I skipped.",
        "created_at": "2020-01-31T16:18:00.387000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The fork choice is designed to make this very difficult. Given you a parent `P` at slot `N` and a child `C1` at `N+1`, the child `C1` in most circumstances gains attestation support during slot `N+1`. If a second child `C2` of `P` at `N+2` tries to ignore the `C1`, attesters at `N+2` are going to still see `C1` as having more support than `C2` and vote on `C1` again as the head in `N+2`. `C2` will quickly become orphaned.\n\n`C2` including attestations of `C1` onchain does not affect the fork choice view of nodes (actually, it could even further degrade `C2` by revealing to more nodes that `C1` has those attestaitons as support). An important note to remember is that the fork choice is wrt attestations in a node's view regardless of them being included on chain or not",
        "created_at": "2020-01-31T20:35:48.248000+00:00",
        "attachments": []
    }
]