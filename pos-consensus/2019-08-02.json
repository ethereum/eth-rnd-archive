[
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So we cant just finalize an epoch if two pairs are sequential. We can only do so if the second has the first as the source. You could imagine both having the same source K in the past and no finality was earned. \n\nThis more general case where n is the source for m and all are justified in between is a natural extension to just the normal ffg sequential justification/finalization criteria. This is very similar to the sequential case because the holes are \"filled\" so you can keep the no surround and no double vote and cant interweave between n and m to break the safety proof",
        "created_at": "2019-08-02T04:17:26.224000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The reason we have these additional cases is because we do a few things (1) we allow attestations to be included on chain during the current and next epoch (2) we eagerly try to justify/finalize with attestations from the current epoch but also try again in the next and (3) attesters attempt to vote on justification based on the state of the chain at the time they attest. These combine in such a way where you might get non-trivial combinations of justification with varied sources. \n\nFor example, say last justified during epoch 10 is epoch 8. The attesters of epoch 10 attempt to justify 10 with source 8 (8-\u003e10). At the end of epoch 10, not quite enough attestations made it on chain to justify 10 so at the start of epoch 11, 8 is still the last justified. Now attesters at epoch 11 attempt to justify 11 with source 8 (8-\u003e11). By the end of epoch 11, enough (8-\u003e10) made it on chain to justify 10, but not enough (8-\u003e11) made it yet. So at the start of epoch 12, attesters attempt (10-\u003e12). At the end of epoch 12, the all of the attestations from prev epoch (8-\u003e11) make it and enough from current (10-\u003e12)\n\nYay! We have finalized epoch 10 by satisfying that (10-\u003e12) is justified and all epochs in between (11) are justified as well regardless of their source",
        "created_at": "2019-08-02T04:29:38.982000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "You can construct similar such scenarios for each of the 4 finality cases in the spec due to the way things can delay and be included",
        "created_at": "2019-08-02T04:30:33.093000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "We have an almost complete paper taking the original ffg proofs and putting them in a more concrete pos instantiation with lmd ghost and proving the new more general finality cases. Will share this publicly very soon",
        "created_at": "2019-08-02T04:31:38.262000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I havent yet had a chance to review your draft but very happy to answer more questions here and review it as well. Ill be off most of next week but can do a video session the follwing week if there is demand",
        "created_at": "2019-08-02T04:33:36.190000+00:00",
        "attachments": []
    },
    {
        "author": "bitfalls",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Fantastic, thank you, parsing this!",
        "created_at": "2019-08-02T07:52:44.582000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Oh and finalizing 1-\u003e4  with 2 and 3 justified in the middle isnt unlikely, its impossible given how we only allow attestations on during their epoch and the next. If we gave attestations 3 epochs to be included, then we could get this k=3 kind of justification",
        "created_at": "2019-08-02T13:19:58.487000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "We could generalize the rule for k=N if we allowed attestations to be included for arbitrary lengths but the beacon chain doesnt remember enough information about past states to do this forever. The longer we allow attestations to be included from the past, the more shufflings a client would have to keep around for validation",
        "created_at": "2019-08-02T13:21:57.644000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "And for decreasingly likely finality situations",
        "created_at": "2019-08-02T13:22:18.676000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "in ssz, what is the `hash_tree_root` of an element in a list that has not been initialized?",
        "created_at": "2019-08-02T16:02:12.622000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "zeroes? And then don't forget the length mix in",
        "created_at": "2019-08-02T16:02:56.699000+00:00",
        "attachments": []
    },
    {
        "author": "raulj",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Hey \u003c@543900561460822016\u003e you mean if you have something like `[1024]*Crosslink`?",
        "created_at": "2019-08-02T16:03:14.084000+00:00",
        "attachments": []
    },
    {
        "author": "raulj",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "it will just be zero values",
        "created_at": "2019-08-02T16:03:35.511000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "for vectors you would use the hash of the zero-filled object of a crosslink (above). Not zeroes",
        "created_at": "2019-08-02T16:04:02.945000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "i'm just thinking of a simple example right now -- a List of containers with a max size of 8",
        "created_at": "2019-08-02T16:04:27.444000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "the root of that should be h(zero_hash(3), zero_hash(0)), right?",
        "created_at": "2019-08-02T16:05:03.624000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "in the case the length == 0",
        "created_at": "2019-08-02T16:05:18.736000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "element that has not been initialized? you mean the root of an empty list? Because non-existent elements do not have hashes defined...",
        "created_at": "2019-08-02T16:05:20.560000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yeah, the root of an empty list",
        "created_at": "2019-08-02T16:05:43.635000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "empty list wouldn't have any elements.. So that should be h(0, 0)",
        "created_at": "2019-08-02T16:06:43.557000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "hmm interesting",
        "created_at": "2019-08-02T16:06:55.343000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "oh wait, and pad to limit, forgot that",
        "created_at": "2019-08-02T16:08:04.531000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "thought you meant to say a container element of size 8 fields.",
        "created_at": "2019-08-02T16:08:23.116000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "so in this case:\n\n```\nclass Message(Serializable):\n    fields = [\n        ('timestamp', uint64),\n        ('message', Vector(uint8, 32)),\n    ]\n\nclass BazaarState(Serializable):\n    fields = [\n        ('new_messages', List(Message, 8))\n    ]\n\nbazaar_state_pre = BazaarState(\n    new_messages=[]\n)\n```",
        "created_at": "2019-08-02T16:08:47.563000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "maybe this is clearer ^^",
        "created_at": "2019-08-02T16:08:53.018000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "A list, with limit of 8, length of 0, always has a `h(zero_hashes(3), zero_hashes(0))` as hash.",
        "created_at": "2019-08-02T16:09:21.195000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Sorry, was confused by the un-initialized wording still. Empty lists are just empty lists; leafs fully padded from 0 to limit, merkleized, and with length mix in. Reduced to just 1 hash of two different zero hashes",
        "created_at": "2019-08-02T16:10:56.312000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Sorry for the confusion!  I think i got it now ðŸ˜ƒ",
        "created_at": "2019-08-02T16:13:15.755000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "so that would be `h(h((h(0,0), h(0,0)), (h(0,0), h(0,0))),   0)`",
        "created_at": "2019-08-02T16:13:18.679000+00:00",
        "attachments": []
    }
]