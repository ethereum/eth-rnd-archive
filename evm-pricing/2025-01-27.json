[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e I have a lot of comments. Not sure telegram is good for this, but here we go.",
        "created_at": "2025-01-27T08:35:42.680000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e How do we verify the new numbers are secure?\n\nIn my opinion, this should be a combination of:\n1. Pick a benchmark baseline. The same as in the imapp's report? By ECRECOVERY? Just a number, e.g. 100 Mgas/s?\n2. Specify the benchmarking env. E.g. use the minimal CPU rating from https://github.com/ethereum/EIPs/pull/9270.\n3. Produce worst case benchmarks. Something like Nethermind's approach is good. But they should contribute these to EEST (it has multiple backends including execution via Engine API). I'm happy to contribute my current and future benchmarks.",
        "created_at": "2025-01-27T08:43:31.465000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e In general, we should slip instructions into categories. E.g. does it modify state, is it revertable, have other dependencies. For some categories we may want to assign higher costs than the pure CPU cost.",
        "created_at": "2025-01-27T08:47:08.333000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e For the arithmetic instructions, the new numbers further disincentivize strength reduction. The most obvious example is that there is no incentive to replace DIV with SHR where DIV has ~10x more  complex implementation than SHR.",
        "created_at": "2025-01-27T08:50:28.570000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjacekglen\u003e Telegram is probably not the best place for these discussions. I've added a topic to ethresearch: https://ethresear.ch/t/gas-fee-schedule-update-proposal/21603. Can you put your comments there so we have traceability? (re @chfast: I have a lot of comments. Not sure telegram is good for this, but here we go.)",
        "created_at": "2025-01-27T11:16:38.544000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cjacekglen\u003e Fun fact: most EVM clients are terrible with SHL/SHR/SAR. For example the average measured cost for DIV is 0.9 and SDIV is 1.4. And then SHL is 1.2 and SHR is 0.9 - much more that you would expect!  I have added a related comment in the report: https://github.com/imapp-pl/gas-cost-estimator/blob/master/docs/report_stage_iv.md#arithmetic-and-logical-operations.\n\nMind you, even if your implementation is ~10x more complex, it does not necessary transforms to the opcode execution time. As this contains common elements like stack operations, program counter, etc, the actual difference is blurred. (re @chfast: For the arithmetic instructions, the new numbers further disincentivize strength reduction. The most obvious example is that there is no incentive to replace DIV with SHR where DIV has ~10x more  complex implementation than SHR.)",
        "created_at": "2025-01-27T11:25:30.102000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cfrangio\u003e shouldn't we expect that overhead to come down with EOF?",
        "created_at": "2025-01-27T14:47:33.106000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e Overhead of what? (re @frangio: shouldn't we expect that overhead to come down with EOF?)",
        "created_at": "2025-01-27T15:01:43.114000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cfrangio\u003e the \"stack operations, program counter, etc\" that reduce the impact of the implementation of an opcode on its actual cost. this is what i understood from @jacekglen (re @chfast: Overhead of what?)",
        "created_at": "2025-01-27T15:12:24.443000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e The biggest overhead EOF contracts can eliminate is stack checking.  But as long as legacy co-exists then it needs to be activatable for legacy frames.",
        "created_at": "2025-01-27T15:16:00.581000+00:00",
        "attachments": []
    }
]