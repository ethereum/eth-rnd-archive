[
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "A recommendation on retrying a call to EL after it has timed out. If anybody is opposed to this change leave your concern in comments\nhttps://github.com/ethereum/execution-apis/pull/253",
        "created_at": "2022-07-01T10:53:00.975000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "I'm not sure if these \"recommendations\" fit into specification or rather are implementation details. But certainly this is something we need to do. We will be adding a fallback retry on timeouts from the EE. \n\nRelated to this, I'd like to have a discussion about the viability of not storing payloads in the CL. Initially I was a strong proponent of this since we can get back the payload from the local EL and fullfil our P2P duties on time, Raul has a branch working on prysm which syncs well and is not being downgraded by peers. Now in these latest doom scenarios where the EL is pruned and there CL as well, it seems that no party having the payloads exacerbates the issue.",
        "created_at": "2022-07-01T11:33:42.965000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "The intention is to pay developers attention to a fact that retrying the call might be crucial to keep a node progressing, but which call in which situation worth retrying is implementation specific",
        "created_at": "2022-07-01T11:36:38.483000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "What is the scenario where EL is pruned?",
        "created_at": "2022-07-01T11:37:26.957000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "I meant CL has pruned from forkchoice and the EL doesn't have a chain to connect",
        "created_at": "2022-07-01T11:39:33.002000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "I am sorry, struggling to understand the exact case when this may happen. Could you please give more details?",
        "created_at": "2022-07-01T11:52:09.316000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "This is the case in your shared slides, where we have pruned right after a common ancestor",
        "created_at": "2022-07-01T11:53:49.501000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Ah, this pruning denotes EL state trie pruning, it doesn't mean EL blocks to be pruned at any point. Chain history pruning is  proposed by EIP-4444, but before this proposal takes into effect EL keeping an entire block history is an invariant",
        "created_at": "2022-07-01T11:59:23.729000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "I see so the EL would keep the blocks from the sidefork even in this case?",
        "created_at": "2022-07-01T12:01:14.880000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "cause we're thinking in not keeping any of those payloads and request them one by one by hash. My impression was that for those ELs that have a shallow state this could be an issue, but if they keep all payloads that we served then there's no change",
        "created_at": "2022-07-01T12:02:13.461000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "That's a good question. IIUC, geth won't give you a block if it wasn't added to the blockchain which I assume happens when `ACCEPTED` is returned. cc \u003c@360491619402776577\u003e",
        "created_at": "2022-07-01T12:05:23.407000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "We will store them and try to recreate their state if we are forced to reorg to the sidechain",
        "created_at": "2022-07-01T12:07:56.735000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "but will you serve them as well? if we request them by hash",
        "created_at": "2022-07-01T12:11:30.150000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "I don't think so, I'm not 100% sure though",
        "created_at": "2022-07-01T12:12:28.441000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "Nope, we only return the canonical block",
        "created_at": "2022-07-01T12:13:02.959000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Thanks, if this applies always that we have forks this may be an issue, but I am not sure how much of an issue, cause we are also only required to serve canonical blocks, so we would first send FCU to geth, and once geth has imported that chain you would start serving them, if I understood you correctly",
        "created_at": "2022-07-01T12:14:26.725000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "I'm not sure if \"imported\" is the right word there, whatever it's used for \"geth has verified the block that already had and recreated the corresponding state\"",
        "created_at": "2022-07-01T12:15:21.791000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Testing",
        "parent": "",
        "content": "https://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#errors shouldn't we add timeout to errors list?",
        "created_at": "2022-07-01T12:21:25.094000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "CL won't be able to serve `BeaconBlocksByRoot` for blocks which payload is `ACCEPTED` (is from a side fork that EL client doesn't have a state for)",
        "created_at": "2022-07-01T12:21:26.106000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "I don't think it's valuable as EL may send no response at all",
        "created_at": "2022-07-01T12:22:06.082000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "that's right",
        "created_at": "2022-07-01T12:24:25.302000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "LightHouse I think keeps the payloads from the forkchoice tree so it solves for this.",
        "created_at": "2022-07-01T12:25:36.324000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "But it's all edgy cause we are not really required to serve `BeaconBlocksByRoot` for a non-canonical block, you can't prove we had that block",
        "created_at": "2022-07-01T12:26:45.961000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "It also implies that these blocks haven't been fully verified, though, sending blocks with not verified execution is allowed by the p2p spec. yes, I agree that it's edgy and would have a negligible impact",
        "created_at": "2022-07-01T12:27:39.622000+00:00",
        "attachments": null
    },
    {
        "author": "lukaszrozmej",
        "category": "Testing",
        "parent": "",
        "content": "In Nethermind you can get potentially bad blocks by Hash, but not by Number, nor any of the flags.",
        "created_at": "2022-07-01T12:29:03.875000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "They could have been fully verified, they do not need to be optimistic, they could be from a chain that was previously canonical.",
        "created_at": "2022-07-01T12:31:13.436000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "I meant `ACCEPTED` status returned by EL would mean that they aren't fully verified yet",
        "created_at": "2022-07-01T12:39:34.807000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "yeah but what I understood from Marius above is that geth would not return the block by hash if its not canonical. So consider the situation that we are locksteping and get a block `A` which is VALID. We do not save the execution payload. Then we change forks to a chain that orphans `A`, geth replies `VALID` to a new head `B`. A peer requests `BeaconBlocksByRoot(A.root)` and we cannot serve it, even though geth had replied VALID.",
        "created_at": "2022-07-01T12:59:19.835000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "Yes exactly",
        "created_at": "2022-07-01T13:01:46.870000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "hm, I am assuming `eth_getBlockByHash` returns every block that has been executed and deemed `VALID`, not necessarily from the canonical chain",
        "created_at": "2022-07-01T13:02:02.161000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "No, judging from the code we only return the blocks in the canonical chain",
        "created_at": "2022-07-01T13:03:04.225000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "got it!",
        "created_at": "2022-07-01T13:03:20.339000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "It implies that in geth `getBlockByHash` doesn't return `INVALID` blocks as invalid blocks can never become canonical.\n\nUPD: I should have said that in geth `getBlockByHash` doesn't return a block that is coming from an invalid *beacon block* as CL can't designate invalid block as canonical",
        "created_at": "2022-07-01T13:07:17.168000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "yes",
        "created_at": "2022-07-01T13:12:57.174000+00:00",
        "attachments": null
    },
    {
        "author": "lukaszrozmej",
        "category": "Testing",
        "parent": "",
        "content": "not in Nethermind, we return any block that wasn't removed from block tree, so that we didn't decide is `INVALID`",
        "created_at": "2022-07-01T13:29:51.611000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "not `VALID` blocks in sidechains?",
        "created_at": "2022-07-01T14:38:25.500000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "(e.g., if there was a reorg)",
        "created_at": "2022-07-01T14:38:43.605000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "Nope",
        "created_at": "2022-07-01T15:55:20.673000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "Testing",
        "parent": "",
        "content": "What if part of the fCU response was also a list of forks/blocks that were \"invalidated\" by this fCU (e.g. no longer canonical due to a reorg)?  Not sure if that helps but it would at least allow the CL to short-circuit asking the EL for a block that's no longer valid.",
        "created_at": "2022-07-01T16:13:30.759000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "The CL knows at all times the non-canonical blocks. As long as we haven't finalized we would keep the full tree. The issue is that we don't want to keep the execution payloads. A peer is entitled to ask us for a non-canonical block, being non-canonical does not imply that it's invalid.  We are required to serve it if we have it. In this case we will not be able to serve it because we won't be able to assemble the missing execution payload. It is not terribly bad, after all it's a block that is not in our current view of the world, but it's not optimal",
        "created_at": "2022-07-01T16:17:00.897000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Testing",
        "parent": "",
        "content": "digging deeper into this: \"A peer is entitled to ask us for a non-canonical block\" what is the issue of not being able to serve such request?",
        "created_at": "2022-07-01T16:18:27.934000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "no big deal that I can think right now, we can always say that we didn't have that block",
        "created_at": "2022-07-01T16:19:12.768000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "but it makes the network less connected: that other peer requesting this block by hash may have seen a lot of attestations for that pending block, that we haven't seen",
        "created_at": "2022-07-01T16:19:53.743000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "The spec states\n```\nClients MUST support requesting blocks since the latest finalized epoch.\nClients MUST respond with at least one block, if they have it. Clients MAY limit the number of blocks in the response.\n```",
        "created_at": "2022-07-01T16:23:08.251000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Just hit an interesting failure syncing teku+geth on ropsten. Teku optimistically sync'd the chain fine, but when geth finished syncing and Teku went back to validate the transition block actually met the terminal total difficulty condition, it fails - consistently. Teku then aborts because it's finalized an invalid chain.\n\nWhat's interesting though is that the execution payload Teku is checking are exactly the same as what ropsten.beaconcha.in reports was in the transition block (https://ropsten.beaconcha.in/block/65144) and when checking ropsten.etherscan.io the transition payload is indeed above TTD (https://ropsten.etherscan.io/block/12350712) and its parent is below TTD (https://ropsten.etherscan.io/block/12350711).  Geth is reporting a different TTD for those two blocks, both of which are above the TTD making the transition block invalid.",
        "created_at": "2022-07-01T23:38:14.018000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "For the parent block 12350711 the exchange is:\n```json\n{\n  \"request\": {\n    \"jsonrpc\": \"2.0\",\n    \"method\": \"eth_getBlockByHash\",\n    \"params\": [\n      \"0x89cd8cab2f1530813b8d8a7abc9a3accb79123817507bc4bf9b3e42efa4c3ac3\",\n      false\n    ],\n    \"id\": 2\n  },\n  \"response\": {\n    \"jsonrpc\": \"2.0\",\n    \"id\": 2,\n    \"result\": {\n      \"baseFeePerGas\": \"0x7\",\n      \"difficulty\": \"0xc295d7aec8\",\n      \"extraData\": \"0xd883010a12846765746888676f312e31382e32856c696e7578\",\n      \"gasLimit\": \"0x1c9c380\",\n      \"gasUsed\": \"0x0\",\n      \"hash\": \"0x89cd8cab2f1530813b8d8a7abc9a3accb79123817507bc4bf9b3e42efa4c3ac3\",\n...\n      \"mixHash\": \"0xb917aaa3af7338087fb73f5bebbb5cec3442cef803447987d8bfc8c3a8fb69bc\",\n      \"nonce\": \"0xdc84ba27a235dd05\",\n      \"number\": \"0xbc74f7\",\n      \"parentHash\": \"0x43d17c9bb91853ae3698ed5f895126ca77b5e1534c31d69b644ef757da394099\",\n      \"receiptsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\",\n      \"sha3Uncles\": \"0xae62e0fe80825c5a16755ac79a3a09c40bb4e0475390dd4c820b7db00f5574a9\",\n      \"size\": \"0x655\",\n      \"stateRoot\": \"0x5e74bc39ab32fadee058206497b2a3dc37061f008201e3857c04de874274a141\",\n      \"timestamp\": \"0x62a0c93b\",\n      \"totalDifficulty\": \"0xb6eac57d1847ca\",\n      \"transactions\": [],\n      \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\",\n      \"uncles\": [\n        \"0xd99900352e6aaa3a20cb3b58721a26d4506334171927f96b62000fb29d00c89e\",\n        \"0xc7a9f77dcee77dbcb8bb68f609c234b7cdd5d224d3e81bdc3e67103cd39ba7a2\"\n      ]\n    }\n  }\n}\n```",
        "created_at": "2022-07-01T23:39:02.721000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "I snipped out the logsBloom to get that to fit in a message.",
        "created_at": "2022-07-01T23:39:14.162000+00:00",
        "attachments": null
    }
]