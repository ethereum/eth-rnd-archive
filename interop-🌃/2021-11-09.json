[
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "note -- I dumped \u003c@!360491619402776577\u003e's 4399 vectors here. please let me know when someone else  gets a chance to run them\nhttps://notes.ethereum.org/dfVXr2h2TqWDKSXZaMwGTw?view",
        "created_at": "2021-11-09T00:19:18.619000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "added these to the M1 milestone",
        "created_at": "2021-11-09T00:21:29.426000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "A short follow up on this announcement. There is a v2 change set section added to the Kintsugi spec that provides details on the changes in v2: http://spec.merge.wiki/#v2-change-set\n\nIn addition, the `message` field in the response object of the `engine_executePayload` call moved out of the scope of Kintsugi. It's yet a subject to change and is a UX improvement hence to a critical functionality. This update is also reflected in the change set.",
        "created_at": "2021-11-09T04:59:09.732000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "An issue on how to return `validationError` in response to `executePayload` is here https://github.com/ethereum/execution-apis/issues/120. Inputs from EL client teams are very much appreciated",
        "created_at": "2021-11-09T08:09:28.375000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Testing",
        "parent": "",
        "content": "Correct me if I am wrong. To handle such a situation, we have to save all invalid payloads in the execution engine database. Otherwise, we won't be able to find the path to the valid ancestor. In Nethermind, we were persisting payloads only when they were valid, and that was reasonable for me. I am wondering whether there is any other reason to save invalid payloads in execution engine DB.",
        "created_at": "2021-11-09T11:04:26.987000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "What if you store the chain of payloads or even block headers in memory in a state of the sync process and then if a subsequent call to `executePayload` hits this chain then respond to it accordingly? Would it be hard to implement it this way?",
        "created_at": "2021-11-09T11:18:41.390000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "After the sync process is finished EL client don't have to keep any invalid payload around",
        "created_at": "2021-11-09T11:21:55.402000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Testing",
        "parent": "",
        "content": "I wasn't worried about the implementation. My concerns were about additional data somewhere (memory/database). If we can drop invalid payloads after the sync - it sounds better now. Thx for your answer! ðŸ™‚ If I understand it correctly, we don't even need to store full headers/payloads. The hashes should be enough. Right?",
        "created_at": "2021-11-09T11:35:10.921000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "I think yes, keeping hashes should be enough too. Or just store the most recent hash (the \"head\" of invalid chain) and the information about the valid ancestor in this chain if this optimisation makes sense for you",
        "created_at": "2021-11-09T11:39:09.405000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Testing",
        "parent": "",
        "content": "\u003ctersec\u003e https://notes.ethereum.org/@9AeMAlpyQYaAAyuj47BzRw/rkwW3ceVY#unknown-header error case refers to now-gone engine_consensusValidated (and unknown payload case to engine_getPayload, not engine_getPayloadV1)",
        "created_at": "2021-11-09T12:31:12.289000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "Testing",
        "parent": "",
        "content": "Yes, I didn't update them properly yet",
        "created_at": "2021-11-09T13:23:49.874000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "\u003c@!203220829473996800\u003e and \u003c@!543900561460822016\u003e updated mergemock to the latest specs ðŸš€ \nhttps://github.com/protolambda/mergemock\n\n*This is now officially part of M1*",
        "created_at": "2021-11-09T15:11:42.602000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Testing",
        "parent": "",
        "content": "Keep me and/or \u003c@!543900561460822016\u003e up to date with mergemock testing! (both consensus and execution). \u003c@!543900561460822016\u003e is extending it with support for replaying static test-vectors, for now it does mocking based on the CLI arguments (there are quite some options though, see `engine --help` and `consensus --help`, also for mocking the POW-POS transition part). Open an issue/PR if something breaks and we'll look into it.",
        "created_at": "2021-11-09T15:21:25.797000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "Testing",
        "parent": "",
        "content": "Great work! Is there some place where one can track the progress of the real execution clients? Some list of active branches?",
        "created_at": "2021-11-09T15:24:46.564000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Testing",
        "parent": "",
        "content": "\u003c@!777935002263617576\u003e That's what the milestones doc is for, see: https://notes.ethereum.org/@djrtwo/kintsugi-milestones",
        "created_at": "2021-11-09T15:25:28.942000+00:00",
        "attachments": null
    },
    {
        "author": "marioevz",
        "category": "Testing",
        "parent": "",
        "content": "I am doing something similar (here: https://github.com/marioevz/kintsugi_testing ) to automate some test vectors based on the original test vector template that \u003c@!360491619402776577\u003e provided in the tracker, it's super simple at the moment and I am still adding test cases to it...\n\u003c@!543900561460822016\u003e could you share with me what you currently have so we don't duplicate efforts on this?",
        "created_at": "2021-11-09T15:29:10.320000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "Sure - so far we have `mergemock` which appears to be similar to you `kintsugi_testing` executor. It uses the `go-ethereum` packages to create a dynamic test chain and sends it to the client. Right now it supports the full transition so it can mine PoW blocks, give them to the client via devp2p, then it will start sending `engine` directives once PoS is reached. The goal is to support static test vectors as well. I was working on a test filler here https://github.com/lightclient/test-filler/ which is analogous to your `tests` module. Ideally the test filler will expose a few test \"types\" that the test filling framework understands how to fill. I ran into a snag where I didn't want the test filler to import any RLP libraries so currently writing a tool `b11r` (block builder) in the `t8n` family to construct the RLP of the block. Once thats done, the test filler will be able to generate `ethereum/test` like fixtures with `engine` directives",
        "created_at": "2021-11-09T16:02:03.500000+00:00",
        "attachments": null
    }
]