[
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "It must follow the `fcU` head because `newPayload(P)` might be coming from invalid beacon block which eventually will be discarded by CL even though the execution is `VALID`. Some CL clients process beacon blocks and execution payloads in parallel and doesn't know the result of beacon block validation before submitting a payload to EL",
        "created_at": "2022-06-29T15:40:05.867000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "There is no well-defined spec for JSON-RPC API, ideally `getBlockByHash` shouldn't return a block the execution of which is not yet validated, `getBlockByNumber` shouldn't return a block that isn't a part of canonical chain nominated by the most recent `fcU`. But there *might be* edge cases in particular implementations which doesn't follow this. Also, if EL is `SYNCING` `getBlockByFoo` shouldn't return anything beyond a fully validated block, for instance, get doesn't return anything but genesis block when sync from scratch is in progress.\n\nEngine API design allows for non-optimistic sync algorithms. Optimistic sync is required by EL's state sync which is the only sane sync approach for Mainnet for all EL clients except Erigon (Akula and other clients that are using Erigon's model). Suppose all ELs are block syncing, in this case CL could start from a checkpoint and send `fcU(headBlockHash: checkpoint.block.body.payload.block_hash)` and poll the status each time e.g. the new slot ticks and once `VALID` is returned CL may lock-step forward - this is the way to sync non-optimistically. But this can take weeks on Mainnet for some clients. Another potential approach is to pull EL state at the checkpoint from any source and then lock-step",
        "created_at": "2022-06-29T16:09:34.954000+00:00",
        "attachments": null
    }
]