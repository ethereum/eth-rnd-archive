[
    {
        "author": "suburbandad_",
        "category": "Testing",
        "parent": "",
        "content": "in fcU, are there constraints on safeBlockHash prior to the finalization of the TTD block?  the execution spec says it simply must be an ancestor of headBlockHash, but I presume it needs to be in the inclusive range of [finalized .. head]",
        "created_at": "2022-05-17T00:19:00.114000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "If we're using the justified checkpoint then yes it has to be in that range.",
        "created_at": "2022-05-17T00:34:53.381000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "It would always have to be in that range really - any algorithm that doesn't consider the finalized checkpoint as unable to be reverted is seriously broken. ðŸ™‚",
        "created_at": "2022-05-17T00:37:05.551000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "What I've been trying to think in the last few minutes is if it **has** to be in (finalized, head) namely if it has to be in the strict interior. But wouldn't surprise me if some very weird things happen that make people justify the same root in the next epoch thus using the same finalized and justified root? Don't know, it's just too late for me here",
        "created_at": "2022-05-17T00:40:42.015000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "I don't think you can ever have the same finalized and justified root but I would still suggest the EL should allow the safe head to be the finalized block.  It's no cost and is the strictest possible definition of \"safe\" so makes sense to allow.",
        "created_at": "2022-05-17T00:43:25.880000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Sure, it just woke my curiosity, it's not clear to me that's impossible, I thought head would be easier to prove that it can't be the justified root, but even that seems possible if some contentious fork carries enough votes to orphan themselves and then reorg to the justified root and call fcu... I kind of suspect that both limits are valid",
        "created_at": "2022-05-17T00:47:22.567000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Ah no, head can't be... Stupid me :)",
        "created_at": "2022-05-17T00:48:15.485000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Except for genesis, right? This is where we have finalized == justified, and if a chain starts post-Merge then execution genesis will be finalized and justified at the same time at the beginning. But this is a kind of degenerative case because genesis can't ever be re-orged anyway",
        "created_at": "2022-05-17T07:31:29.908000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "CL will start sending meaningful `safeBlockHash` once transition block gets justified, before this happens all zeroes hash should be expected. There is a PR to the spec that has a general note about finalized and safe block hashes to be zeroes before transition is finished (transition block is finalized) https://github.com/ethereum/execution-apis/pull/226/files#diff-571851156237b81c20006ce9d7a70b3421f19540cead91f45955316c52fe94c0R185",
        "created_at": "2022-05-17T07:33:40.179000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Oo good point. Also applies when doing checkpoint sync. The initial state is finalised justified and head all at once.",
        "created_at": "2022-05-17T07:34:55.666000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Oh, definitely! Checkpoint sync is more interesting and practical case of having these values pointing to the same block, and we need to be sure that EL makes and update of its forkchoice state correctly in this case. Sounds like it worth having a test case ðŸ¤”",
        "created_at": "2022-05-17T07:38:38.573000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Testing",
        "parent": "",
        "content": "Is any CL team using unauthenticated 8550 port? I think everyone switched to 8551. However, ping me if I should leave it for some reasons. I'm gonna remove it from our standard shadowfork config.",
        "created_at": "2022-05-17T09:02:41.432000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Testing",
        "parent": "",
        "content": "In Besu we currently have a PR open that removes it and only uses 8551. I think we will be able to merge it today.",
        "created_at": "2022-05-17T09:03:55.758000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "it is generally useful to have some way of setting this up for debug purposes -- not enabled by default, but coordinating JWT adds overhead to testing scenarios where the object isn't to test JWT, and it's difficult to just `curl`-test things, et cetera",
        "created_at": "2022-05-17T09:18:03.685000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Testing",
        "parent": "",
        "content": "yes, you can turn on it in Nethermind, but it will be disabled by default. For eth_ namespace you can use port 8545 ðŸ™‚",
        "created_at": "2022-05-17T09:26:36.767000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "If we're going to have non-authenticated ports around we should just ditch JWT entirely. The whole point was to stop people accidentally exposing it to the internet and being taken over. So definitely should be off by default and probably somewhat difficult to enable.",
        "created_at": "2022-05-17T09:31:36.946000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "Sure, I think there was already a PR to remove the idea of a non-JWT port from the spec?",
        "created_at": "2022-05-17T09:33:16.872000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "There is no non-JWT port in the spec anymore",
        "created_at": "2022-05-17T09:40:39.542000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "The PR: https://github.com/ethereum/execution-apis/pull/219",
        "created_at": "2022-05-17T09:41:23.263000+00:00",
        "attachments": null
    },
    {
        "author": "marekm3498",
        "category": "Testing",
        "parent": "",
        "content": "if you add engine module to any Nethermind port, we will add authentication (for any port you set 8545, 8550, 8551, 8560). To disable it, you need to add |no-auth explicitly, so there is no way to expose it accidentally. Of course, we will consider removing even this option",
        "created_at": "2022-05-17T09:42:12.572000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Testing",
        "parent": "",
        "content": "Am I right to assume that the transition block will always be the very first finalized block? No other block can be finalized before it, can't it?",
        "created_at": "2022-05-17T09:46:12.172000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "The first finalized block will either be transition or one of its descendants. A transition block will have to be the first block of an epoch to become the first finalized block which is less probable than for one its descendants.",
        "created_at": "2022-05-17T09:54:35.662000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Testing",
        "parent": "",
        "content": "So to rephrase this:\n\u003e *Note:* `safeBlockHash` and `finalizedBlockHash` fields are allowed to have `0x0000000000000000000000000000000000000000000000000000000000000000` value unless transition block is finalized.\n\nIs it to correct in the EL client to check that safeBlockHash and finalizedBlockHash are only allowed to be zero until I have at least one finalized block? Because once I have at least one, the transition block is finalized as well, either directly or through one of its descendants.",
        "created_at": "2022-05-17T10:05:28.637000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Yes, this is correct. Having the first finalized PoS block inherently means that transition block is finalized too",
        "created_at": "2022-05-17T10:12:53.420000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Hello, I'm wondering what do CC do when the EC is offline? we're considering sitting not doing anything until it comes back, without queuing blocks for later inclusion, literally doing nothing but polling the EC. Wondering if this is in line with what other clients do.",
        "created_at": "2022-05-17T14:02:32.498000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "Nimbus is currently set up to produce blocks without transactions, if there's a timeout or connection failure of some other sort from the EL client. Seems at least preferable, though trying to be careful about 1:1 EL client:CL client narrative too.",
        "created_at": "2022-05-17T14:04:45.645000+00:00",
        "attachments": null
    },
    {
        "author": "terence0083",
        "category": "Testing",
        "parent": "",
        "content": "https://github.com/sigp/lighthouse/pull/3094 lighthouse's direction and I pretty much agree that this would be the desired behavior, it's simple and reasonable",
        "created_at": "2022-05-17T14:05:23.203000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "That's against the spec, how would you know what your head is without the EE, you shouldn't be gossiping, much less be producing blocks. But in principle you could save them to later process them if it comes back online",
        "created_at": "2022-05-17T14:13:14.415000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "Sure, so if it's out of sync, those mechanisms already exist and will come into play -- just as in non-merge scenarios, it won't do any validator duties if it detects its head is out of date. But in a very specific scenario where the head is not out of date (and, it's fully verified -- this isn't some optimistic head), and it has to produce a block, it does attempt to do so.",
        "created_at": "2022-05-17T14:23:30.016000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "It's a bit of an edge case though, so I'm not sure how useful it is",
        "created_at": "2022-05-17T14:24:09.949000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Ah I see, yeah that makes sense. The scenario we're wondering is the ee disappearing for a while",
        "created_at": "2022-05-17T14:25:52.607000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "Otherwise, from Nimbus's perspective, it won't have been able to follow the chain, as you allude to, anyway, and there's no special proposer logic that triggers, just general out-of-sync logic",
        "created_at": "2022-05-17T14:26:21.090000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Testing",
        "parent": "",
        "content": "In which case, agree with what's been said so far",
        "created_at": "2022-05-17T14:26:41.285000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "I wanted to hear if someone implemented queueing for a few minutes in case the ee is just restarting (for example an upgrade) but it seems significant complexity for a slightly better UX",
        "created_at": "2022-05-17T14:30:26.257000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "I believe teku will hold on to a few blocks that couldnâ€™t be executed because the EL was down and periodically retry importing them. If the chain is progressing normally youâ€™d wind up triggering another attempt as part of backfilling to import a new block but it seems easy enough to have a small pending pool as well.",
        "created_at": "2022-05-17T20:37:01.308000+00:00",
        "attachments": null
    }
]