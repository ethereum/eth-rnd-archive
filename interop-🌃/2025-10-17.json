[
    {
        "author": "ethpandaops-devnet-pulse-v2",
        "category": "Testing",
        "parent": "",
        "content": "",
        "created_at": "2025-10-17T01:00:00.332000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Testing",
        "parent": "",
        "content": "To recover networks with long non-finality we must allow nodes to checkpoint into a non-finalized checkpoint. Consider a network where the finalized epoch is 1000, and the head is at epoch 2000. The node on startup downloads the state at epoch 2000. From the state it can learn the block roots of the finalized and the justified checkpoint. However, it doesn't know the execution hashes of those blocks.\n\nforkchoice_updated requires to pass safeBlockHash and finalizedBlockHash. The node has 3 options:\n1. Send to the EL the execution hash of the block at epoch 2000 (pass it's local view of irreversibility)\n2. Set `safeBlockHash` and `finalizedBlockHash` to zero until finalization advances or the node learns those values\n3. On initialization fetch from checkpointz the blocks of the finality checkpoints and learn the execution hashes\n\n**Questions**:\n- For CL devs that implemented non-finality checkpoint sync: what do you do?\n- For EL devs: could you handle receiving `safeBlockHash` and `finalizedBlockHash` zero-ed for some time?",
        "created_at": "2025-10-17T16:40:52.851000+00:00",
        "attachments": null
    },
    {
        "author": "__flcl",
        "category": "Testing",
        "parent": "",
        "content": "As EL we do handle zeros in some cases(specific L2 networks) as far as I remember. And there is chance it required a code change in engine_ methods. It happens usually during the initial sync",
        "created_at": "2025-10-17T16:53:54.863000+00:00",
        "attachments": null
    },
    {
        "author": "nflaig",
        "category": "Testing",
        "parent": "",
        "content": "We implement option 1. right now (see [forkchoice initialization](https://github.com/ChainSafe/lodestar/blob/5ff57446b727e78918a730fee4b9d5640f04e240/packages/beacon-node/src/chain/forkChoice/index.ts#L159)) but we haven't merged those changes yet https://github.com/ChainSafe/lodestar/pull/8527",
        "created_at": "2025-10-17T16:56:12.404000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Why not send the blockhash of the checkpoint you are downloading? are you going to allow reorgs from that checkpoint?",
        "created_at": "2025-10-17T18:30:51.684000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "FWIW, I haven't implemented this yet and I do not know how to implement it, this is probably the main reason why I haven't even started.",
        "created_at": "2025-10-17T18:31:56.718000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Testing",
        "parent": "",
        "content": "My worry is that you will comunicate to the EL your local view of irreversibility not the network's. The EL is used to the `finalizedBlockHash` to represent an Ethereum state that won't be reverted unless a very large percentage of stake becomes slashable. If you pass to the EL your randomly chosen starting block, the security guarantees of `finalizedBlockHash` dissapear.",
        "created_at": "2025-10-17T18:44:50.196000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "for finalized you can actually pass a finalized hash (which you can pass any old finalized hash for that matter, we're talking about extreme case recovery, our users could pass this as a flag). \n\nHowever, the only way that I can think I will implement this (even though I honestly don't know how to do it cause we rely on having the justified state in forkchoice to compute weights)  is that we won´t  allow any reorgs from the checkpoint we are downloading. So from the point of view of the EL we are driving, I think it's fair to call that the \"finalized hash\" since we won´t  ever reorg it unless we restart from a different checkpoint",
        "created_at": "2025-10-17T18:54:28.913000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Testing",
        "parent": "",
        "content": "Consider an exchange or a rollup that uses your client. They could make an offchain tx with a lot of value on your bogus finalized hash",
        "created_at": "2025-10-17T18:56:17.777000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Testing",
        "parent": "",
        "content": "If each client does a different thing it feels bad for consumers. I don’t see why users would care about the local irreversible node instead of the finalized checkpoint of the network",
        "created_at": "2025-10-17T18:59:57.311000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "I'm simply pointing to a practical point: I don't think we could handle a reorg of this checkpoint in the CL, or at least I don't know how to do it. So the CL would treat it as final. If you refer to the fact that the exchange honoring the \"safe hash\" from the EL's return, yeah definitely, it should be fine though in this case to pass a hash specified by the user at launch. This is a recovery mode situation anyway, so if we get there I feel it's fine to request our users to pass this hash by hand.",
        "created_at": "2025-10-17T19:04:48.154000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "At anyrate it does not seem hard to request the block by root and grab the payload hash",
        "created_at": "2025-10-17T19:05:21.657000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Testing",
        "parent": "",
        "content": "To recover networks with long non-",
        "created_at": "2025-10-17T19:38:49.794000+00:00",
        "attachments": null
    }
]