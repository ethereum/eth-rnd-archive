[
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Second finalized block, i.e. a finalized block with height greater than of the `FIRST_FINALIZED_BLOCK`. It's a bit tricky",
        "created_at": "2022-08-05T06:00:45.214000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "We finalize entire epochs at a time though, right?",
        "created_at": "2022-08-05T06:08:03.750000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "So if we finalize epoch 123, then there are a bunch of blocks that all get finalized at once (every block in that epoch).",
        "created_at": "2022-08-05T06:08:31.788000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Is \"the first finalized block\" the same as \"the oldest block in the first finalized epoch\"?",
        "created_at": "2022-08-05T06:09:02.140000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "It is actually the same as the latest block of canonical chain at the first slot of the epoch. The intention of the spec is \"on the update of the finalized block next to the first one remove handlers\"",
        "created_at": "2022-08-05T06:13:57.145000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Hmm, I'm still struggling to follow.  Perhaps a diagram or example would help?",
        "created_at": "2022-08-05T07:40:05.234000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Sure, we have the following Engine API calls:\n```\n// Beacon chain finalizes the first checkpoint with non-empty execution payload\nforkchoiceUpdated(finalizedBlockHash=X, ...) -- FIRST_FINALIZED_BLOCK, transition committed, block gossip messages are discarded, no propagation happens\n\n...\n\n// Beacon chain finalizes the second checkpoint with non-empty execution payload\nforkchoiceUpdated(finalizedBlockHash=Y, ...) -- gossip handlers entirely dropped, remote peers that are still gossiping blocks are likely on the PoW chain and should be disconnected\n```",
        "created_at": "2022-08-05T08:09:43.567000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Though, the second requirement is more nice to have than a MUST",
        "created_at": "2022-08-05T08:16:14.339000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Probably, we should remove the second requirement at all and write that once the first block gets finalized messages MUST be discarded and handlers MAY be removed.",
        "created_at": "2022-08-05T08:18:50.187000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Am I incorrect that entire epochs are finalized at once?",
        "created_at": "2022-08-05T08:19:31.487000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "If so, doesn't that mean you'll get an epoch's worth of `forkChoiceUpdated(i, ...)` calls, one for each block in the finalized epoch?",
        "created_at": "2022-08-05T08:20:00.143000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Epochs are finalized at once but EL will receive this message only with latest finalized block, i.e. finalized block hash jumps from the hash of say `block.number = 64` to the hash of `block.number = 96`",
        "created_at": "2022-08-05T08:22:59.680000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Where block.number 64 and 96 are both most recent blocks in their respective epochs?",
        "created_at": "2022-08-05T08:24:51.242000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "(assuming we didn't go an entire epoch with 0 blocks)",
        "created_at": "2022-08-05T08:25:16.935000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "In the case that an epoch passes with no new blocks, then I guess finality of that epoch will *not* result in a `forkChoiceUpdated` call?",
        "created_at": "2022-08-05T08:25:39.545000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Or maybe a `forkChoiceUpdated` but with a block from a previous epoch?",
        "created_at": "2022-08-05T08:25:53.610000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Finality needs to be witnessed on chain to have `forkChoiceUpdated` with the new `finalizedBlockHash`, otherwise, it will be sending the block hash from the previous finalized checkpoint",
        "created_at": "2022-08-05T08:28:08.898000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Ah, so we cannot finalize an epoch with no blocks?",
        "created_at": "2022-08-05T08:29:43.794000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "To be strict we can finalize an epoch if this epoch has no blocks, but we can't do this without blocks in next epochs that will carry enough attestations to finalize it",
        "created_at": "2022-08-05T08:37:03.494000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "As a hypothetical, if epoch 2, 3, 5, 6 all have blocks in every slot, while epoch 4 has no blocks at all, would epoch 3 finalize and then epoch 5 would finalize?  Or is it that epoch 3 would be the one to fail to finalize, and epoch 4 would finalize?",
        "created_at": "2022-08-05T08:42:04.529000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Or perhaps all would finalize, but epoch 3 wouldn't finalize until during epoch 5?",
        "created_at": "2022-08-05T08:42:22.339000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Speaking of beacon chain (not EL chain), to finalize 4:\n- 4 needs to be justified, and \n- there should be `4 -\u003e 5` supermajority link (i.e. 5 is justified with a source at 4).\n\nTheoretically, it is possible for blocks in 5 to include attestations justifying 4, if these attestations have been produced. Then 4 will be justified in the first block of 6.",
        "created_at": "2022-08-05T08:49:51.137000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "If `4` has no blocks then the checkpoint in 4 will be `(epoch=4, root=lastBlockOf(3).root)`",
        "created_at": "2022-08-05T08:50:48.822000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "In practice, if `4` has no blocks it likely has no attestations with `target = (epoch=4, root=lastBlockOf(3).root)` either. So, practically it's unlikely that epoch with no blocks is justified",
        "created_at": "2022-08-05T08:52:36.187000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Why would there be no attestations because there are no blocks?  Can you not attest over an empty slot?",
        "created_at": "2022-08-05T08:54:21.983000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "I'm thinking of a hypothetical where the block producers are all down, but validators are all still running.  For example, if everyone uses MEV Boost and it has a bug that causes it to not release any blocks for an epoch.",
        "created_at": "2022-08-05T08:54:57.545000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "Oh, that's a good point. I was assuming proposers went offline because of partitioning in the network meaning that validators are offline and doesn't produce enough attestations. But this mev-boost thing is a possible way to break proposals without affection attesters",
        "created_at": "2022-08-05T08:59:14.150000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "I think you're not correctly thinking **which group** of blocks get finalized at once. We finalize by checkpoints, that is a pair (Root, epoch). The root points to a block (with that root) and the epoch is a number, say n. The group of blocks that finalizes is every ancestor of that block with that root that wasn't final already. Now, typically, that block is the **first one** in the epoch, so every other block of the epoch n will not be final",
        "created_at": "2022-08-05T09:57:46.519000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Why do we finalize the first block in an epoch rather than the last?",
        "created_at": "2022-08-05T09:58:34.831000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Testing",
        "parent": "",
        "content": "Doesn't matter I suppose, just feels like it would be more clear to say \"this epoch is finalized or not\".",
        "created_at": "2022-08-05T09:59:04.116000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "It gets nastier than that: the root may point to a block that is not even in the epoch",
        "created_at": "2022-08-05T10:00:52.518000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "That is not the case, the proposer does not send a full block to the relayer, if the relayer does not assemble a full block there will be no consensus block either.",
        "created_at": "2022-08-05T10:08:07.364000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Testing",
        "parent": "",
        "content": "If a relay doesn't respond with a full block and doesn't propagate it then we may end up in this situation",
        "created_at": "2022-08-05T10:16:24.891000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Regarding the above discussion, perhaps we should start moving to saying things like \"the second block after the first finalization\" instead of \"the second finalized block\". It's more verbose, but I feel like we may be hurt by confusing the community with the second form",
        "created_at": "2022-08-05T13:27:09.126000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "Testing",
        "parent": "",
        "content": "mildly arbitrary design decision",
        "created_at": "2022-08-05T14:42:03.871000+00:00",
        "attachments": null
    }
]