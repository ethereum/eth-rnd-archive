[
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "anyway i have a couple of questions for this discussion over here",
        "created_at": "2022-03-20T17:29:50.268000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "so, the CL gives us blocks until the head but how does it actually validates them if it does not have the state",
        "created_at": "2022-03-20T17:30:46.712000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "does that mean that CL can sync without EL then",
        "created_at": "2022-03-20T17:31:15.973000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Yes the cl will sync validating just the consensus part of the block and will not act on any block until the El tells it that it's validated the execution part",
        "created_at": "2022-03-20T17:33:12.972000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "okay, another question (completely non-related), how much does it usually take to sync an ETH 2 node on mainnet? i heard that teku can snapshot-sync in a less than a minute but is such sync still usable post-merge?",
        "created_at": "2022-03-20T17:35:33.292000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Yes, you can bootstrap a node with a state that you assume to be valid in less than a minute",
        "created_at": "2022-03-20T17:36:17.976000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "oh but it requires state, if you do not have state then that would not work i imagine",
        "created_at": "2022-03-20T17:37:08.798000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "I think lighthouse supports this as well and prysm already has an open PR for this",
        "created_at": "2022-03-20T17:37:10.345000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "This is the beacon state",
        "created_at": "2022-03-20T17:37:26.220000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "It's much smaller than the execution one",
        "created_at": "2022-03-20T17:37:40.321000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "so you can just download it through p2p and bootstrap the node really fast right?",
        "created_at": "2022-03-20T17:39:14.069000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "anyway i did some testing about how fast CL supplies EL with blocks as Syncing is returned and it turns out it is 43 blk/sec on my machine, that does not seem really good, on top of the fact that it is not EL-related",
        "created_at": "2022-03-20T17:50:18.540000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Yes exactly",
        "created_at": "2022-03-20T17:56:37.997000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "So in the normal case, CL will start near head. You can then use that to reverse header sync and use whatever full sync you want from there",
        "created_at": "2022-03-20T17:57:03.488000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "The rate limit in the block insertion from CL shouldn't really be your bound on getting sync done",
        "created_at": "2022-03-20T17:57:29.644000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "With optimistic sync you can sync the EL however you do now, and just near the head you will get blocks one by one by the cl",
        "created_at": "2022-03-20T17:57:33.641000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "so everyone is going to use snapshot-sync by default",
        "created_at": "2022-03-20T17:57:33.873000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Yes. It's actually the only safe way due to weak subjectivity in pos. That or at least show up with a recent block root and full sync to that",
        "created_at": "2022-03-20T17:58:03.848000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "If CL starts insertions from Genesis, as EL you have two option nd",
        "created_at": "2022-03-20T17:58:20.481000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "okay, but if we are getting supplied blocks at a rate of 43 blk/sec, it would not matter much",
        "created_at": "2022-03-20T17:58:41.813000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "1. Execute in lockstep\n2. Wait until info near head and do your own sync",
        "created_at": "2022-03-20T17:58:50.827000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "okay, i understand so again we would all need to be in snapshot-sync and if we are not then we would have to sync slowly",
        "created_at": "2022-03-20T18:00:40.255000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "As long as it's faster than 1 per 12 seconds you should be fine. You only need the current blocks being spoon fed, perhaps I'm not understanding the just l issue you're facing",
        "created_at": "2022-03-20T18:00:59.256000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Yes the El will use whatever mean they just use currently to catch up, and after that they'll be fed new blocks as they come",
        "created_at": "2022-03-20T18:02:02.637000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "that is really slow, my problem with that would be what if you are not running snapshot-sync",
        "created_at": "2022-03-20T18:05:03.875000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "what if you need the full history to comply legal matters with your government for example about your staking as a node operator for example",
        "created_at": "2022-03-20T18:06:09.697000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "or because of whatever reason that is just an example",
        "created_at": "2022-03-20T18:06:19.282000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "How do you sync currently to head? Why wouldn't you be able to sync the same way?",
        "created_at": "2022-03-20T18:06:45.146000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "for now, we are not running snapshot-sync at least from CL side so we are going by executing block as they come in",
        "created_at": "2022-03-20T18:07:36.889000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "we are in the process of optimizing it of course",
        "created_at": "2022-03-20T18:07:47.923000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "but thing is that if we still get info so slowly that does matter",
        "created_at": "2022-03-20T18:08:07.792000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Ok so most probably here is that I don't know the differences between fast, full, snapshot or whatever sync the EL uses: my understanding was that you would get information about your current head from the CL, then you will try to sync to that head by whatever means you **currently** use to sync, so this assumes that you can catch up head right now. While you're catching up to that head the CL will be updating it by telling you that new blocks arrived. These will be only 1 each 12 seconds.",
        "created_at": "2022-03-20T18:11:54.378000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "our mean so far is linear sync, so in order to be competitive all clients will need a snapshot-sync implementation",
        "created_at": "2022-03-20T18:14:20.675000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "which of course is slow",
        "created_at": "2022-03-20T18:14:51.094000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "i think geth is slow as well though",
        "created_at": "2022-03-20T18:14:57.859000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "What I'm asking is what changes in the merge on your way of syncing. Optimistic sync is there so that the EL does not need to change their way of syncing. Whatever works for you now should continue working after the merge",
        "created_at": "2022-03-20T18:16:11.655000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "we either go step by step or reverse sync after the merge",
        "created_at": "2022-03-20T18:18:32.632000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Testing",
        "parent": "",
        "content": "is the snapshot sync for CL enshrined in the p2p protocol or is it implemented out-of-band? Trying to search for it",
        "created_at": "2022-03-20T18:19:20.992000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Here you mean the snapshot sync purely on the beacon chain side right?",
        "created_at": "2022-03-20T18:20:11.988000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Testing",
        "parent": "",
        "content": "Yes",
        "created_at": "2022-03-20T18:22:53.308000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Testing",
        "parent": "",
        "content": "I just know that snapshot sync on near-empty state is easy, but when state grows, it becomes a hard engineering problem. I am just wondering how this is designed for CL",
        "created_at": "2022-03-20T18:23:30.668000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "the CL state is very small, and it has a cap except perhaps to the number of validators. It's not expected to grow much, so it's not the same problem as in the EL.",
        "created_at": "2022-03-20T18:24:50.076000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Validators are required to have and to serve all history blocks, so even if you do a snapshot sync, you need to download all blocks back to genesis, and this takes time anyway. The difference is that you can do this while still validating",
        "created_at": "2022-03-20T18:25:47.669000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Testing",
        "parent": "",
        "content": "but am I right in thinking that each CL implementation has its own mechanism for snapshotting the state? (so far I only found article for Teku downloading snapshots from Infura via Https, but I could not find for others yet)",
        "created_at": "2022-03-20T18:35:55.182000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "Yes indeed, Lighthouse has a flag `--checkpoint-sync-url` to point from where to download the snapthot state. Prysm has something similar",
        "created_at": "2022-03-20T18:37:29.530000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Only past 4 months",
        "created_at": "2022-03-20T18:37:31.340000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "https://github.com/prysmaticlabs/prysm/pull/10386",
        "created_at": "2022-03-20T18:37:50.361000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "that's right, I keep forgetting about WS, we still keep them all as far as I know though, haven't pruned yet",
        "created_at": "2022-03-20T18:38:16.282000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Testing",
        "parent": "",
        "content": "I found it for lighthouse: https://lighthouse-book.sigmaprime.io/checkpoint-sync.html",
        "created_at": "2022-03-20T18:39:06.054000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "There's an attempt at defining a common uri scheme for it so you can get it generically from various providers and different protocols (https, portal, etc)\n\nNot sure where that is atm",
        "created_at": "2022-03-20T18:40:40.910000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "But the format is an ssz state",
        "created_at": "2022-03-20T18:40:48.222000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Testing",
        "parent": "",
        "content": "Ok, I think I understand it better now, thank you",
        "created_at": "2022-03-20T18:42:35.975000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Some notes I wrote about beacon state distribution methods\n\nhttps://notes.ethereum.org/Mp5Iv4N0Qb-d6KZvNuBspg?both",
        "created_at": "2022-03-20T18:44:52.644000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Testing",
        "parent": "",
        "content": "Thank you!",
        "created_at": "2022-03-20T18:49:18.798000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "For the record Teku literally just needs a url to the SSZ state (or a path to the state as a local file). We donâ€™t need to query anything else which makes distribution of the state extremely easy. The current challenge is that only Infura provide public access to a state but it would be grat to start seeing block explorers and other infrastructure providers expose the current finalised state (at minimum) so things become less centralised.",
        "created_at": "2022-03-20T20:59:52.011000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "hello, i did a little benchmark for the sync up and as it turns both geth and erigon with lighthouse sync at roughly 14 blk/sec",
        "created_at": "2022-03-20T22:28:54.006000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "it would take almost an hour to fully sync an empty chain",
        "created_at": "2022-03-20T22:29:09.819000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "perhaps something needs to be optimized",
        "created_at": "2022-03-20T22:29:19.551000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "CLs don't spend much time optimising sync speed since we have checkpoint sync",
        "created_at": "2022-03-20T22:29:41.972000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "checkpoint sync is a very small version of it though",
        "created_at": "2022-03-20T22:30:21.293000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "what if people needs the data in the future",
        "created_at": "2022-03-20T22:30:29.816000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "for whatever reason: tax compliance or just mere statistics",
        "created_at": "2022-03-20T22:30:43.050000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Once we checkpoint sync we go and backfill all the old blocks",
        "created_at": "2022-03-20T22:30:56.779000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "So we have the entire history",
        "created_at": "2022-03-20T22:31:01.720000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Backfill is much faster that syncing forwards",
        "created_at": "2022-03-20T22:31:13.461000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "this honestly feels very duct-taped",
        "created_at": "2022-03-20T22:32:03.627000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "okay, we can just copy-paste something instead of optimizing but that does not feel right",
        "created_at": "2022-03-20T22:32:28.247000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "like we could do like BSC, raise gas, make it work somehow but then?",
        "created_at": "2022-03-20T22:32:48.028000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Proof-of-stake has the \"weak subjectivity\" problem, so we need some form of checkpoint sync anyway.",
        "created_at": "2022-03-20T22:32:52.175000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Syncing from genesis doesn't guarantee we land on the correct chain",
        "created_at": "2022-03-20T22:33:05.056000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Perhaps asking questions is more helpful than throwing stones",
        "created_at": "2022-03-20T22:34:00.442000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "my point is that Ethereum cannot go in production with something that is inneficient, with so much complexity in running it and it is sub-optimized",
        "created_at": "2022-03-20T22:34:40.007000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "i am not throwing stones, would you call what BSC is doing not duct-taped, because this is very similar in its own way",
        "created_at": "2022-03-20T22:35:19.519000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "maybe it was bad-phrased sorry",
        "created_at": "2022-03-20T22:35:38.803000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "but i hope this gets the point in, i think that needing an infura key all the time is not also really optimal",
        "created_at": "2022-03-20T22:36:44.708000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "infura or whatever",
        "created_at": "2022-03-20T22:36:49.336000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "it works okay, but it does not look ready for production",
        "created_at": "2022-03-20T22:37:02.159000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "at least in my opinion",
        "created_at": "2022-03-20T22:37:30.567000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Alrighty, so first point is this:\n\nIt is unsafe to sync a beacon chain of any reasonable age (e.g., a few weeks) without receiving a recent checkpoint from a trusted peer.\n\nDo you agree with this and understand it?",
        "created_at": "2022-03-20T22:38:09.147000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "(a checkpoint being, at the very least, a block root)",
        "created_at": "2022-03-20T22:39:21.584000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "okay, yes i understand that why not using it if we already have it",
        "created_at": "2022-03-20T22:42:38.096000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Ok good. So syncing from a recent checkpoint to the head of the chain isn't a duct-tape fix. We MUST sync with reference to some recent checkpoint, and syncing forwards from that to the head before doing a backfill is a very appealing optimisation and UX improvement.",
        "created_at": "2022-03-20T22:44:32.712000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "I understand that doesn't address the question of \"why don't we make sync faster\", but it does address the point that checkpoint sync is just a duct-tape fix. Do you agree?",
        "created_at": "2022-03-20T22:46:12.203000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "It is duct-taped in the sense, that you cannot port an unoptimized, make it rely on something else and then release it to the second largest cryptocurrency in the world",
        "created_at": "2022-03-20T22:47:59.366000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "i agree with it yes, it is not duct-taped in that sense",
        "created_at": "2022-03-20T22:48:26.095000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Ok good, let's address the \"unoptimised\" claim then.",
        "created_at": "2022-03-20T22:48:36.676000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "another thing, how is needing to have an infura key an UX improvement?",
        "created_at": "2022-03-20T22:58:09.239000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "as far as i know you need one in order to checkpoint-sync at least for now",
        "created_at": "2022-03-20T22:58:30.318000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "The term \"unoptimised\" is a bit unclear. I would imagine it means either:\n\n1. \"No one has bothered to improve it\", or\n2. \"It's not fast enough for our purposes\"\n\nWhen it comes to (1), it's clearly not the case when looking at the history of beacon chain development. One primary time-sink is BLS verification; we've gone through several BLS libraries over the years and have settled on a purpose-build library written in hand-crafted assembly by domain experts (this library is BLST). The EF funded this and all teams have implemented. Another time-sink is computing the merkle-root of the beacon state. All the teams have implemented a form of \"tree hash caching\", to ensure that we only update nodes which have changed. This reduced times by an order of magnitude and we're basically at the point where we need faster a SHA2 to get faster.\n\nWhen it comes to (2), I would argue that it is suitable for our purposes. We can go from nothing to the head in a matter of minutes (or less) with checkpoint sync, which we agreed isn't inherently a duck-tape solution. We can then do a backfill which might take several hours for mainnet now. We might differ in opinion, but I think those numbers are viable for production and involve no duct-taping.",
        "created_at": "2022-03-20T23:00:46.241000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "You don't need infura, you just need either:\n\n1. Another beacon node running and accessible via HTTP.\n2. The ability to download the necessary information as files (e.g., torrents).",
        "created_at": "2022-03-20T23:01:39.876000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "yeah you either need a torrent or another node, most people will use an infura since as far as i can see it is the most used, at least so far.",
        "created_at": "2022-03-20T23:02:51.749000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "I will be honest 100%, it does not convince, what we get so far is too little period. but i might be wrong, i understand this goes more at the core-level of the CL specs, but time will tell if that is the case or not.",
        "created_at": "2022-03-20T23:04:57.571000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "People's tendency to use Infura when a more-decentralized but higher-friction alternative is available is not unique to the beacon chain. Furthermore, I don't think it has anything to do with whether or not beacon chain sync is optimal enough for production.",
        "created_at": "2022-03-20T23:05:00.514000+00:00",
        "attachments": null
    },
    {
        "author": "funnygiulio",
        "category": "Testing",
        "parent": "",
        "content": "we will see if it will make it to prod only time will tell",
        "created_at": "2022-03-20T23:05:10.366000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Also worth noting that before Infura started exposing the state via an API the most common way people acquired states for checkpoint sync was by me putting one in a github repo for them. There's been a real chicken-and-egg scenario with checkpoint sync. It was put off being implemented because it was too hard to get an initial state. Teku bit the bullet and implemented it but it was awkward to get the state.  Infura started making the state available and then it finally started seeing some real traction. As other clients have supported checkpoint sync it's become more and more the expected way to sync.\nI'm hopeful that the next step is that other providers see there is in fact demand for access to the finalized state and that it's actually quite easy to provide, so we'll see multiple sources for those states. But if we had waiting for a lot of providers to provide the state before starting to implement and use checkpoint sync we'd have never gotten anywhere.",
        "created_at": "2022-03-20T23:08:30.758000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Did we ever create a standard beacon API call for fetching these checkpoint states (and, separately, their roots)?",
        "created_at": "2022-03-20T23:12:00.984000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "We've just been pulling the latest finalized state via the existing API methods.",
        "created_at": "2022-03-20T23:13:57.711000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "yes and no. ðŸ™‚ There was an agreed format for specifying the ws checkpoint epoch and root which for a while was supported by beaconscan but got very little use and seems to have been removed again.\nFor checkpoint sync, the standard REST API includes everything required. For Teku you just need the state as SSZ, other clients require the state and block and some have some additional conditions and so use more of the standard REST API.",
        "created_at": "2022-03-20T23:14:30.682000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Two thoughts on the current API:\n  - fetching state is currently in the `/debug` group, which doesn't make it feel like a critical endpoint\n  - using a state ID of `finalized` can change relatively frequently, and so that makes it harder for external services (_i.e._ not beacon nodes) to provide the info\n\nTwo specific endpoints, one to fetch the current `wss` state and one its root, may help for decentralization.  It would allow a client to start up, pick from a subset of well-known providers that could return roots, and then obtain a root from one of said providers.  And the `wss` state could change a lot less frequently, for example every 256 epochs, which would allow different implementations to remain broadly in sync with each other using external processes (_e.g._ pushing the root and state to a CDN, or some other \"out of beacon node\" system).",
        "created_at": "2022-03-20T23:19:30.824000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Tbh, I don't think this goes in the rest API",
        "created_at": "2022-03-20T23:19:53.722000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "The rest API is a user api",
        "created_at": "2022-03-20T23:19:58.353000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "This is instead for public endpoints",
        "created_at": "2022-03-20T23:20:09.298000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "I agree on the mod 256 and agree it should be specified",
        "created_at": "2022-03-20T23:20:38.033000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "But shoving it into beacon API seems slightly wrong? Or at least should be in its own namespace",
        "created_at": "2022-03-20T23:21:05.014000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "I think you want two endpoints btw\n\nget_root(epoch)\nget_state(epoch)",
        "created_at": "2022-03-20T23:21:33.835000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "As discussed here\nhttps://notes.ethereum.org/Mp5Iv4N0Qb-d6KZvNuBspg?both",
        "created_at": "2022-03-20T23:21:50.837000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "So you can query N for the root and one for the state",
        "created_at": "2022-03-20T23:22:00.994000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Syncing up another beacon node when you already have one running would be a reasonable \"user\" action IMO.",
        "created_at": "2022-03-20T23:22:43.002000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Hm fair. I worry that leads accidentally opening up user apis to the internet",
        "created_at": "2022-03-20T23:23:22.757000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "I'd say it's very useful to have in the standard REST API because then you can use any node to checkpoint sync from.  But I also agree it makes sense to have a subset of the API that can be exposed more simply and safely by providers. That's a big part of why we went to the extra effort of only requiring the state - it means no real \"API\" is required, you just need any URL that returns a suitable starting state.",
        "created_at": "2022-03-20T23:23:23.095000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "But I can certainly be convinced",
        "created_at": "2022-03-20T23:23:30.027000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Why include the `epoch` parameter?  Wouldn't it always be latest wss checkpoint?",
        "created_at": "2022-03-20T23:24:03.388000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "What's the inefficiency in syncing in 1 minute?",
        "created_at": "2022-03-20T23:24:19.821000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Race conditions?\n\nEpoch or \"period\"",
        "created_at": "2022-03-20T23:24:47.394000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "I'd also say that users would prefer getting the latest finalized state rather than a significantly older wss checkpoint if providers are happy to provide it.",
        "created_at": "2022-03-20T23:25:01.240000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Perhaps it isn't a part of the beacon API, but beacon nodes would support it in addition to the existing API and then you could have lightweight processes that just served the root/state.",
        "created_at": "2022-03-20T23:25:02.859000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "And if leave none, then current",
        "created_at": "2022-03-20T23:25:03.594000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "I think you make the job of ws provider and content delivery network and torrents and portal and and easier/better if you serve mod 256",
        "created_at": "2022-03-20T23:25:42.076000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "That's a tricky one.  If you're fetching data from one or two other active beacon nodes then that would work, but what if you wanted to fetch from multiple sources or from third-party systems?  The time delay in setting them up could mean that some are never usefully in sync.",
        "created_at": "2022-03-20T23:26:09.199000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "I think it's worth having the option to serve something old.  I suspect users will significantly prefer something more recent.",
        "created_at": "2022-03-20T23:26:25.788000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Right so I think default is latest on the 256 epoch period",
        "created_at": "2022-03-20T23:26:50.718000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "It shouldn't take long for nodes to agree on the finalized checkpoint.  You may find it hasn't updated immediately but it should do so within a few seconds generally.",
        "created_at": "2022-03-20T23:26:51.877000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Rather than always the latest",
        "created_at": "2022-03-20T23:26:56.208000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Is there much difference in being up to 256 epochs out?  What's the delay in that, realistically.",
        "created_at": "2022-03-20T23:26:56.713000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "It's also nice because I could run a twitter account and tweet a hash once a day",
        "created_at": "2022-03-20T23:27:26.699000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "And it's easy to look at and verify",
        "created_at": "2022-03-20T23:27:35.442000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Well that's 8192 blocks to execute which isn't insignificant, particularly post merge.",
        "created_at": "2022-03-20T23:27:39.399000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "But it is!",
        "created_at": "2022-03-20T23:27:54.193000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Like 1 minute?",
        "created_at": "2022-03-20T23:27:59.971000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "13mins at 100ms per block, which is probably about 5x higher than what we see now.",
        "created_at": "2022-03-20T23:28:05.924000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "EL blocks in geth take 10ms or something",
        "created_at": "2022-03-20T23:28:16.195000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Yeah sorry this wasn't meant to be for beacon nodes, but say that you wanted to push the wss state to S3 and then replicate it using a CDN or similar, and only then start serving?  You could do that once a day (give or take), but trying to do it every epoch would result in incoherent caches.",
        "created_at": "2022-03-20T23:28:16.731000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Also if you are fresh syncing, EL is going to take much longer than your ws sync",
        "created_at": "2022-03-20T23:28:42.823000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "Testing",
        "parent": "",
        "content": "as long as the initial state can be specified do we need to be super perscriptive? it shouldn't really matter if someone chooses finalized vs. someone choosing a hash tweeted once a day... its their choice?",
        "created_at": "2022-03-20T23:29:13.648000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Am I off by an order of magnitude?",
        "created_at": "2022-03-20T23:29:16.485000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "Someone should look at optimising EL sync ðŸ˜‰",
        "created_at": "2022-03-20T23:29:19.897000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Perhaps every 64 epochs then?  I just think that for non-beacon nodes attempting to do it every epoch could be painful.",
        "created_at": "2022-03-20T23:29:26.489000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Yes being specific helps UX around different delivery methods",
        "created_at": "2022-03-20T23:29:37.673000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "I don't think using the wss checkpoint is the end of the world, but I think we've demonstrated that distributing the finalized checkpoint isn't actually hard. It's pretty ideally suited for HTTP caching really.",
        "created_at": "2022-03-20T23:30:20.479000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "Testing",
        "parent": "",
        "content": "UX wise would be my argument for just using finalized straight off the beacon-api, becuase its there, and its recent",
        "created_at": "2022-03-20T23:30:42.310000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "we're seeing 50ms before the merge on the CL side",
        "created_at": "2022-03-20T23:30:43.624000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "On EL?",
        "created_at": "2022-03-20T23:30:52.200000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "EL should generally be parallelized instead of additive",
        "created_at": "2022-03-20T23:31:14.137000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "And is on that same order",
        "created_at": "2022-03-20T23:31:17.844000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Testing",
        "parent": "",
        "content": "on kiln we're seeing higher than 200ms right now, still need to be optimized, but won't be much better",
        "created_at": "2022-03-20T23:31:35.409000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "I'd say the first step is to get CL clients to agree on what's needed.  My understanding is most implementations need more than just the state so the biggest barrier for providers currently is meeting those varying needs.",
        "created_at": "2022-03-20T23:31:57.014000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Testing",
        "parent": "",
        "content": "We see about 25-50ms on Geth on Kiln for newPayload and forkchoiceUpdated. Those are probably inflated a bit since we're also doing some work inside those times too.",
        "created_at": "2022-03-20T23:32:15.025000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "It should generally be the greater of either EL or CL plus some overhead",
        "created_at": "2022-03-20T23:32:37.899000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "True, but are we then tying ourselves in to beacon nodes being the only useful servers of that information?  Because the REST API isn't designed to be facing the external network so we would either have to have a second (public-facing) interface just for serving this data or some sort of ACL on the existing API.  Neither of those appeal particularly to me.",
        "created_at": "2022-03-20T23:33:16.288000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Right doing every 256 with a simple uri scheme makes it easy for all sorts of services to serve this",
        "created_at": "2022-03-20T23:33:56.052000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Given every service has to run a beacon node that's the source of this information we're ultimately just talking about what interval new data is published.  You can set that to once an epoch or once every 256 epochs or anything in between and the system still works. Even if you set it to 256 epochs you can't assume that all providers will actually update at the same time (there's still a race condition there).",
        "created_at": "2022-03-20T23:38:28.785000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "Testing",
        "parent": "",
        "content": "caching wise it'd be nice to be able to not have it change every epoch, I can definitely see that side of it. If it was a longer duration then that would reduce the need to actually ask beacon-api. Having it on a specific endpoint and a cache duration set could mean you get both - it ultimately is rest api, but can be cached to the desired rate...",
        "created_at": "2022-03-20T23:38:43.043000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "I think there's value in the latest ws root period being longer than the average time it takes a user to attempt to get things configured. So that user can go check various sources for a hash and see that hash come down via the providers. Instead of a hash that changes every 6 minuyed",
        "created_at": "2022-03-20T23:38:50.648000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "State API is also debug currently",
        "created_at": "2022-03-20T23:42:25.998000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "If we make it so it's every 256 for the ws state namespace and make it only a week or something",
        "created_at": "2022-03-20T23:42:49.689000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Then you can easily put that as a requirement on nodes without it being undo requirements",
        "created_at": "2022-03-20T23:43:05.338000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "It's worth noting that by default Teku nodes don't keep finalized states, so requiring a node to serve a state that's 256 epochs old is a significant extra burden.",
        "created_at": "2022-03-20T23:44:46.641000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "We do keep the latest finalized state obviously. ðŸ™‚",
        "created_at": "2022-03-20T23:44:58.937000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Perhaps we solve this by adding a third endpoint that fetches the epoch of the WSS.  Then a simple system that just fetches whatever is available from a single source will be happy with anything, and a more complex system that requests information from multiple sources can filter servers in/out depending on its own requirements (perhaps simple majority, perhaps strictly latest, whatever).",
        "created_at": "2022-03-20T23:46:04.081000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "But you can configure to store more states on intervals right? \n(Not claiming no burden. But just turning the debug endpoint public is not the way to go)",
        "created_at": "2022-03-20T23:48:20.080000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "(That would be better with a single endpoint returning (`state_root`,`epoch`), thinking about it).",
        "created_at": "2022-03-20T23:48:22.485000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "Testing",
        "parent": "",
        "content": "we only store 1/2048 finalized states by default, so storing 1/256 adds a lot of data",
        "created_at": "2022-03-20T23:49:01.668000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "But then you need to be able to query by epoch",
        "created_at": "2022-03-20T23:49:11.335000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "We can currently chose between archive mode (storing finalized states at selected intervals or storing all states as a trie for fast access with high disk usage) or we use prune by default and don't store any state prior to the finalized epoch.",
        "created_at": "2022-03-20T23:49:14.731000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "On some finite interval. Call it one week",
        "created_at": "2022-03-20T23:49:25.501000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Bound cost",
        "created_at": "2022-03-20T23:49:28.434000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "We don't even store that by default.",
        "created_at": "2022-03-20T23:49:29.455000+00:00",
        "attachments": null
    },
    {
        "author": ".paulharris",
        "category": "Testing",
        "parent": "",
        "content": "true - we dont even store finalized states unless someone sets archive mode",
        "created_at": "2022-03-20T23:49:52.885000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Storing 7 states is not high cost. Maybe high complexity but not disk space",
        "created_at": "2022-03-20T23:49:54.672000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Basically to support this we'd basically write the wss checkpoint to a separate file periodically. It would be minimal disk space but also a useful function for most users.",
        "created_at": "2022-03-20T23:50:20.060000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "And if you're syncing from your own node you'd *definitely* want the finalized checkpoint because you trust the node.",
        "created_at": "2022-03-20T23:50:40.864000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Or perhaps you request the state via the state root.  So:\n  - step 1 fetch `(state_root,epoch)` from your checkpoint nodes\n  - step 2 once you have selected a suitable epoch and server, fetch `state(state_root)` from it",
        "created_at": "2022-03-20T23:51:02.715000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Pulling the state by either latest or some epoch/period identifier seems better to me",
        "created_at": "2022-03-20T23:51:42.427000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "And then calculating the root yourself",
        "created_at": "2022-03-20T23:51:52.024000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "State look up via arbitrary root needs all sorts of qualifiers",
        "created_at": "2022-03-20T23:52:18.301000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Could that be inconsistent?  If one node fails to obtain the last block of an epoch, but another doesn't, would they have different roots but the same epoch specifier?",
        "created_at": "2022-03-20T23:53:09.260000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "This should be restricted internally to the subset of state roots that the node is keeping for wss checkpoints, so may not be too problematic.",
        "created_at": "2022-03-20T23:53:44.537000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "Right but there's also (in this design) fixed periods they would do lookups on",
        "created_at": "2022-03-20T23:54:27.390000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "And you need to compute the root locally anyway",
        "created_at": "2022-03-20T23:54:35.425000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "To verify",
        "created_at": "2022-03-20T23:54:39.807000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "I like the general `nxn` idea in that linked doc, though, \u003c@!291925846556540928\u003e I think that having better checkpoint sync is important.",
        "created_at": "2022-03-20T23:54:57.407000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "True.",
        "created_at": "2022-03-20T23:55:02.090000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "I agree both generally work. Looking up state via period and calculating the root seems to me to be the more straightforward way to specify",
        "created_at": "2022-03-20T23:55:06.035000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "Testing",
        "parent": "",
        "content": "(and to Adrian, even if \"period\" means latest finalized)",
        "created_at": "2022-03-20T23:55:41.887000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Probably worth noting that all block explorers already provide a way to verify a state is on the canonical chain once you have the state.  So if you can get a state from anywhere, you then know it's state root, block root, slot and epoch which makes it easy to check validity.  If we have an agreed checkpoint period (eg 256 epochs) and you can request that the state you get aligns to that then you also open up additional much more manual means of verifying the state by checking twitter posts etc.",
        "created_at": "2022-03-20T23:58:20.757000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "The big challenge here though is still getting users to do the verification (or provide multiple services to automate the check). I'm loathe to embed specific services in a client but if the user has to source multiple URLs and specify them they generally won't.",
        "created_at": "2022-03-20T23:59:48.296000+00:00",
        "attachments": null
    }
]