[
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e Re L1SLOAD conversation, seeing that next year thereâ€™ll be probably the first Keystore rollups + namespace rollups (e.g. ENS) in production\n\nHow can we take this RIP further? I think itâ€™s interesting that it also leaves to rollups the freedom to include in protocol or not the inclusion proof etc.\n\nhttps://github.com/ethereum/RIPs/pull/27",
        "created_at": "2024-08-13T10:07:13.210000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e would be great to see who's interested in adopting L1Sload. so far it seems it's Scroll and Kakarot (?)\n\nthen, the main outstanding questions are whether everyone is happy with the current interface, and to define reasonable gas costs.\n\nany other comments are welcome here: https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388 (or in this group) (re @eliastzr: Re L1SLOAD conversation, seeing that next year thereâ€™ll be probably the first Keystore rollups + namespace rollups (e.g. ENS) in production\n\nHow can we take this RIP further? I think itâ€™s interesting that it also leaves to rollups the freedom to include in protocol or not the inclusion proof etc.\n\nhttps://github.com/ethereum/RIPs/pull/27)",
        "created_at": "2024-08-13T10:53:58.322000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e we can help defining reasonable gas costs with early benchmarks of what it costs to prove in a stark a specific l1 storage slot (thatâ€™s the design we are looking to go with, to keep the storage inclusion proof verification off protocol) (re @thegaram33: would be great to see who's interested in adopting L1Sload. so far it seems it's Scroll and Kakarot (?)\n\nthen, the main outstanding questions are whether everyone is happy with the current interface, and to define reasonable gas costs.\n\nany other comments are welcome here: https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388 (or in this group))",
        "created_at": "2024-08-13T11:18:52.735000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e my intuition is that this RIP is a generic version of the ccip-read implementations that iâ€™ve seen pop up on twitter, where Linea, Zksync and Scroll support ENS, right? (re @thegaram33: would be great to see who's interested in adopting L1Sload. so far it seems it's Scroll and Kakarot (?)\n\nthen, the main outstanding questions are whether everyone is happy with the current interface, and to define reasonable gas costs.\n\nany other comments are welcome here: https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388 (or in this group))",
        "created_at": "2024-08-13T11:20:19.225000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e in some ways ccip-read is more generic, since it allows multiple off-chain sources and any client can relay data. on the other hand l1sload can be a general building block for any use case that needs to read L1 state.\n\nanother difference is that l1sload is a service that the rollup provides to its users, so users / devs don't need to deal with the complexity of verifying the results (re @eliastzr: my intuition is that this RIP is a generic version of the ccip-read implementations that iâ€™ve seen pop up on twitter, where Linea, Zksync and Scroll support ENS, right?)",
        "created_at": "2024-08-13T11:58:34.411000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e technically we could have multiple off protocol sources for l1sload but thatâ€™s abstracted by the rollup itself (re @thegaram33: in some ways ccip-read is more generic, since it allows multiple off-chain sources and any client can relay data. on the other hand l1sload can be a general building block for any use case that needs to read L1 state.\n\nanother difference is that l1sload is a service that the rollup provides to its users, so users / devs don't need to deal with the complexity of verifying the results)",
        "created_at": "2024-08-13T12:20:28.375000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e like some pull oracle model",
        "created_at": "2024-08-13T12:22:29.784000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e what other sources you have in mind?\n\nL1 state as a data source is a great fit for rollups, because rollup nodes already need to connect to L1 (at least sequencers do), and we can make verification trustless by passing the correct L1 state root to the zk verifier on L1. not sure we could guarantee the same level of verifiability for other data sources. (re @eliastzr: technically we could have multiple off protocol sources for l1sload but thatâ€™s abstracted by the rollup itself)",
        "created_at": "2024-08-13T12:37:43.229000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e As zk rollup, if you donâ€™t want to change your core contract on L1, or if youâ€™re optimistic you could want to verify the L1 state directly in your L2 transaction (re @thegaram33: what other sources you have in mind?\n\nL1 state as a data source is a great fit for rollups, because rollup nodes already need to connect to L1 (at least sequencers do), and we can make verification trustless by passing the correct L1 state root to the zk verifier on L1. not sure we could guarantee the same level of verifiability for other data sources.)",
        "created_at": "2024-08-13T12:42:44.398000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctoml01\u003e Thanks for bringing this up, it's an interesting proposal and it would be useful for us at Fhenix.\nI also think it's useful to have block height as an additional optional parameter (commented that in ethereum-magicians too).\n\nAnyways, would be great to be involved @eliastzr @thegaram33 , let me know if we can help! (re @thegaram33: would be great to see who's interested in adopting L1Sload. so far it seems it's Scroll and Kakarot (?)\n\nthen, the main outstanding questions are whether everyone is happy with the current interface, and to define reasonable gas costs.\n\nany other comments are welcome here: https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388 (or in this group))",
        "created_at": "2024-08-13T14:32:19.875000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e In my mind L1SLOAD solves keystore rollups and anytype of appchain which state needs to be read by other L2s, such as ENS v2 (appchain)\n\nNot sure if it is true / if it makes sense to make this feature generic (re @thegaram33: in some ways ccip-read is more generic, since it allows multiple off-chain sources and any client can relay data. on the other hand l1sload can be a general building block for any use case that needs to read L1 state.\n\nanother difference is that l1sload is a service that the rollup provides to its users, so users / devs don't need to deal with the complexity of verifying the results)",
        "created_at": "2024-08-13T14:37:43.892000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e yeah, I don't see L1SLOAD and 3668 as being competitive",
        "created_at": "2024-08-13T14:38:44.129000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e L1SLOAD is for reading L1 from L2s",
        "created_at": "2024-08-13T14:38:48.517000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e 3668 is for reading L2s from L1",
        "created_at": "2024-08-13T14:38:54.456000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e (btw how do people feel about calling it 3668 instead of ccip-read? I worry that with the name CCIP people keep getting confused and thinking that it has something to do with chainlink ðŸ˜‚)",
        "created_at": "2024-08-13T14:39:24.852000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e happened to me last week (re @vb271828: (btw how do people feel about calling it 3668 instead of ccip-read? I worry that with the name CCIP people keep getting confused and thinking that it has something to do with chainlink ðŸ˜‚))",
        "created_at": "2024-08-13T14:39:39.921000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e But how about trustlessly reading an L2 from another L2, youâ€™d need L1SLOAD + reading the L2â€™s core contract right + some type of inclusion proofs (re @vb271828: 3668 is for reading L2s from L1)",
        "created_at": "2024-08-13T14:43:42.096000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e correct, you would have to stack both",
        "created_at": "2024-08-13T14:46:43.727000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e if we want full standards compliance \"for free\", technically you would want not just L1SLOAD, but L1STATICCALL",
        "created_at": "2024-08-13T14:47:25.197000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e you L1STATICCALL an L2 state proof",
        "created_at": "2024-08-13T14:47:33.777000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e In some sense, this difficulty is unavoidable",
        "created_at": "2024-08-13T14:48:09.413000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e Because if our philosophy is that an L2's config is its contract, and so the L2 defines its state proof verification function in EVM code, then for your L2 to process that natively, it needs to run the EVM code",
        "created_at": "2024-08-13T14:48:47.926000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cFlorian_Huc\u003e In case of decentralized sequencing, ie if we have multiple validator voting on a block then using the latest block is ambiguous. Different validators could have different views, no?",
        "created_at": "2024-08-13T14:50:02.954000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e right, so you would have to specify a \"speculative\" version and a \"safe\" version",
        "created_at": "2024-08-13T14:52:35.262000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e that has to be part of any light client spec",
        "created_at": "2024-08-13T14:52:42.777000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cFlorian_Huc\u003e Also I didn't get how you can determine what was the latest l1 block known by the sequencer when you replay the history. You would need to store it no?",
        "created_at": "2024-08-13T14:52:59.862000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e For anything that needs to be cross-L2 atomic, you would have to use the \"safe\" option",
        "created_at": "2024-08-13T14:53:03.553000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e you use the same mechanism that the L2 uses already to process deposits (re @Florian_Huc: Also I didn't get how you can determine what was the latest l1 block known by the sequencer when you replay the history. You would need to store it no?)",
        "created_at": "2024-08-13T14:53:21.377000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e to process deposits you have to be aware of some L1 blocks at some point. So you can piggyback off of that functionality",
        "created_at": "2024-08-13T14:53:48.185000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cFlorian_Huc\u003e Also to deal with l1 reorg, we may need to use the latest finalized block?",
        "created_at": "2024-08-13T14:54:00.075000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e are you assuming that a specific L2 core contract exposes an endpoint on L1 to verify inclusion in its tree? Is that why someone would need to use L1STATICCALL? (re @vb271828: if we want full standards compliance \"for free\", technically you would want not just L1SLOAD, but L1STATICCALL)",
        "created_at": "2024-08-13T14:56:16.631000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctoml01\u003e it depends on the implementation i guess? if you can get the current known l1 block but the precompile interface is a more generic `l1sload(l1Address, key, blockHeight)` - then it should be no issue in replay (re @Florian_Huc: Also I didn't get how you can determine what was the latest l1 block known by the sequencer when you replay the history. You would need to store it no?)",
        "created_at": "2024-08-13T14:56:18.131000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e \u003e Different validators could have different views, no?\n\n\u003e didn't get how you can determine what was the latest l1 block known by the sequencer when you replay the history\n\nthe exact mechanism is not in scope for rip-7728. but there are ways to do this.\n\nfor instance, we can allow (and incentivize) the current sequencer to relay one or more L1 blocks as part of their L2 block. other nodes can easily check this. if the relayed L1 block is part of the L2 state, then all nodes can evaluate l1sload calls on this consistent state.\n\nthere are different error cases:\n1. sequencer relays the wrong L1 block =\u003e easy to detect and won't pass validity proof\n2. sequencer does not relay available L1 blocks =\u003e could offer some incentives here\n3. sequencer relays very recent blocks not yet seen by other nodes =\u003e hard to check, other nodes can only wait (re @Florian_Huc: In case of decentralized sequencing, ie if we have multiple validator voting on a block then using the latest block is ambiguous. Different validators could have different views, no?)",
        "created_at": "2024-08-13T16:52:22.602000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e waiting for L1 finalization is the most conservative way. (but it conflicts with point 3. in the previous message: if a sequencer decides to relay more recent blocks, do you reject these?)\n\nor you can optimistically relay more recent blocks (knowing that post-merge Ethereum almost never has deep reorgs). if there is an L1 reorg, the L2 ledger must reorg along with it. (re @Florian_Huc: Also to deal with l1 reorg, we may need to use the latest finalized block?)",
        "created_at": "2024-08-13T16:55:19.280000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e btw here are the l1sload slides presented at the last RollCall, for anyone interested https://bit.ly/l1sload-rollcall-6",
        "created_at": "2024-08-13T16:56:50.589000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e I wonder if we can build this RIP to cater the needs of the people who most need it; it seems keystore rollups and ens v2 are the most direct candidates?\nare there other protocols or dapps that need this?",
        "created_at": "2024-08-13T17:40:06.186000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cCarlBeek\u003e As we don't have any new topics added to the RollCall agenda and I don't like having unnecessary calls, I'm canceling the upcoming call.",
        "created_at": "2024-08-13T22:29:42.179000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctoml01\u003e Yup, token balance snapshots for confidential voting is interesting for us too (re @eliastzr: I wonder if we can build this RIP to cater the needs of the people who most need it; it seems keystore rollups and ens v2 are the most direct candidates?\nare there other protocols or dapps that need this?)",
        "created_at": "2024-08-13T22:57:03.118000+00:00",
        "attachments": null
    }
]