[
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e interesting approach, but it seems like this would only work if the blob-carrying transaction does not require any additional evm execution. in Scroll's case we currently do rely on a contract to calculate an on-chain commitment and do some bookkeeping on the l1 message queue. (re @ethrnd_rollcall_bot: \u003cconvexityjunkie\u003e Hi all, I built a toy project to demonstrate allowing blob senders to specify pre-execution blob tips\n\nWould love to hear your opinions\n\nhttps://github.com/lu-bann/blob-middleware)",
        "created_at": "2024-06-27T12:54:35.167000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cicemelon\u003e hi all, we would like to share a new RIP (https://ethereum-magicians.org/t/rip-7728-l1sload-precompile/20388) that we recently proposed. The RIP proposes a new precompiled contract `L1SLOAD` that allows contracts to read L1 storage slots from L2 without providing Merkle proofs. We want to hear feedbacks and throughts here first before the next rollcall",
        "created_at": "2024-06-27T16:38:08.449000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e I know some other L2s (just optimism, or also others?) also have L1STATICCALL. Would it make sense to standardize both as RIPs?",
        "created_at": "2024-06-27T16:39:22.890000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e It definitely feels like an important functionality to have as a standard, and if there's two \"natural\" form factors of it with different tradeoffs, may as well make both versions available",
        "created_at": "2024-06-27T16:40:06.422000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e So that every rollup standardizes the way they currently do L2-\u003eL1 messaging? (re @vb271828: I know some other L2s (just optimism, or also others?) also have L1STATICCALL. Would it make sense to standardize both as RIPs?)",
        "created_at": "2024-06-27T16:40:45.721000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cicemelon\u003e Yes, we mentioned it in the RIP. I think the `L1SLOAD` can be a first step and a building block towards it. As I explained in the proposal, the `L1STATICCALL` is a more heavy-weight precompile that forces L2s to embed the L1 evm execution to be part of L2. This may stop some L2s from adopting it (re @vb271828: I know some other L2s (just optimism, or also others?) also have L1STATICCALL. Would it make sense to standardize both as RIPs?)",
        "created_at": "2024-06-27T16:42:08.096000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e So there's two versions of \"L2s reading L1\" that make sense: (i) staticcall, and (ii) sload. Staticcall is more powerful, but it requires type-1 zkevm and is more complex to implement (and unviable entirely for non-evm L2s). Sload is weaker, and harder to work with because eg. if you use it to interact with \"pluggable\" contracts that follow some ERC, you need to impose additional standards about the locations of storage slots and not just the ABI interface, but OTOH it's very easy to use and implement",
        "created_at": "2024-06-27T16:42:31.640000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e I think the RIP should explicitly say that if it is adopted, any ERCs meant for cross-L2 use (eg. keystores) should explicitly specify storage slot locations for exposed info, and not just an ABI interface",
        "created_at": "2024-06-27T16:44:56.027000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cRenoRen79\u003e Another solution would be to have the L1 root hash available on each L2, and a cheap proof of storage. This would delegate the burden of reading slots from L2 from nodes to the Dapp. (re @icemelon: hi all, we would like to share a new RIP that we recently proposed. The RIP proposes a new precompiled contract L1SLOAD that allows contracts to read L1 storage slots from L2 without providing Merkle proofs. We want to hear feedbacks and throughts here first before the next rollcall)",
        "created_at": "2024-06-27T16:46:00.627000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e that one is much weaker imo",
        "created_at": "2024-06-27T16:46:31.091000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e Because proofs of storage on L2 are not \"cheap\"",
        "created_at": "2024-06-27T16:46:39.199000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e they're data heavy, and ultimately it's easier for L2s to make computation cheaper than to make data cheaper",
        "created_at": "2024-06-27T16:47:01.979000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cRenoRen79\u003e For ZK Rollups, indeed it is expensive",
        "created_at": "2024-06-27T16:47:03.878000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e optimistic too",
        "created_at": "2024-06-27T16:47:09.942000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e the problem is the data size of a merkle proof",
        "created_at": "2024-06-27T16:47:16.723000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e actually if you zk-snark the proof, and have good snark aggregation, it gets easier, so I guess ultimately you can get to the same place and it's just a question of where the infrastructure lives, but I think it would be easier on dapps if that infrastructure lives as part of the L2 itself",
        "created_at": "2024-06-27T16:48:07.036000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e Why don’t dApps use dApps that propose this L1Sload trustlessly? Such as Herodotus or other zk co-processors? \n\nWhy make it an RIP?",
        "created_at": "2024-06-27T16:49:22.323000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cRenoRen79\u003e Because for Developpers that would like to have cross chain deployments, they dont want to rely to a different proof of storage system, and an ocean of different messenging systems.\n\nTo solve cross chain fragmentation, L1\u003c\u003eL2 messenging shall be a standard.",
        "created_at": "2024-06-27T16:50:41.230000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e I don't think you can make something equivalent to l1sload trustlessly?",
        "created_at": "2024-06-27T16:51:12.992000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e I guess L2s already have access to recent L1 state roots to process deposits, and you can overload that functionality, and then have a system where contracts can ask for specific sloads, and then there is some incentive to bulk-respond every slot or two",
        "created_at": "2024-06-27T16:52:34.326000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e but that's asynchronous",
        "created_at": "2024-06-27T16:52:36.949000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e and it's much harder for devs to work with",
        "created_at": "2024-06-27T16:52:42.811000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e than just an opcode",
        "created_at": "2024-06-27T16:52:46.592000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e yes I meant async*",
        "created_at": "2024-06-27T16:52:48.590000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e Like, think of the keystore use case",
        "created_at": "2024-06-27T16:53:03.943000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e You want to read L1 to get the account's current public key, and then use that info immediately, within the same transaction",
        "created_at": "2024-06-27T16:53:18.640000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e that's inherently synchronous",
        "created_at": "2024-06-27T16:53:24.036000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e you could technically have some kind of “pull oracle” system for cross-chain storage proof?",
        "created_at": "2024-06-27T16:53:47.982000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e that’d make it synchronous?",
        "created_at": "2024-06-27T16:53:56.649000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cyezhang1998\u003e context for l1sload, check out our post about keystore:\nhttps://scroll.io/blog/towards-the-wallet-endgame-with-keystore (re @vb271828: Like, think of the keystore use case)",
        "created_at": "2024-06-27T16:54:12.591000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e right but that just feels so heavy duty if we're expecting a future world where literally the average transaction uses this feature",
        "created_at": "2024-06-27T16:54:16.097000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e So it’s essentially enabling people to use synchronously L1 storage, and adding to the L2 protocol the responsibility of asynchronously (during prover job) to validate the inclusion data?",
        "created_at": "2024-06-27T16:57:19.254000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e right",
        "created_at": "2024-06-27T17:01:43.691000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e And in principle, L2s need to track the L1 already, to handle deposits",
        "created_at": "2024-06-27T17:01:57.035000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e So why not also piggyback on that visibility into L1 to do sloads (or staticcalls)",
        "created_at": "2024-06-27T17:02:15.345000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e btw @icemelon that's one approach I would consider for the rationale section of the RIP: say \"as a first step, L2s implementing this can use the same delay that they already use for deposits, though we recommend working hard to reduce that duration over time\"",
        "created_at": "2024-06-27T17:03:27.414000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e I think realistically, there are three durations that make sense:\n\n1. Finality (15 mins normally, up to 3 weeks in inactivity leak / 51% attack case). So the L2 literally never reverts\n2. The ~10 slot range. So the L2 reverts rarely enough that you can make parts of revert handling manual\n3. The ~1-2 slot range. Basically, as fast as possible; once you have the programmatic ability to handle reverts easily, you just crank it up and rely on it fully, in order to get the most seamless interoperability",
        "created_at": "2024-06-27T17:05:09.013000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cicemelon\u003e Sounds good and will update it (re @vb271828: btw @icemelon that's one approach I would consider for the rationale section of the RIP: say \"as a first step, L2s implementing this can use the same delay that they already use for deposits, though we recommend working hard to reduce that duration over time\")",
        "created_at": "2024-06-27T17:06:49.216000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cicemelon\u003e The three-tier makes a lot sense (re @vb271828: I think realistically, there are three durations that make sense:\n\n1. Finality (15 mins normally, up to 3 weeks in inactivity leak / 51% attack case). So the L2 literally never reverts\n2. The ~10 slot range. So the L2 reverts rarely enough that you can make parts of revert handling manual\n3. The ~1-2 slot range. Basically, as fast as possible; once you have the programmatic ability to handle reverts easily, you just crank it up and rely on it fully, in order to get the most seamless interoperability)",
        "created_at": "2024-06-27T17:07:55.129000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e I’m not sure I understand? Durations of what? (re @vb271828: I think realistically, there are three durations that make sense:\n\n1. Finality (15 mins normally, up to 3 weeks in inactivity leak / 51% attack case). So the L2 literally never reverts\n2. The ~10 slot range. So the L2 reverts rarely enough that you can make parts of revert handling manual\n3. The ~1-2 slot range. Basically, as fast as possible; once you have the programmatic ability to handle reverts easily, you just crank it up and rely on it fully, in order to get the most seamless interoperability)",
        "created_at": "2024-06-27T17:09:04.768000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e Durations of how far back the L1 block that you're reading is",
        "created_at": "2024-06-27T17:10:07.608000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cicemelon\u003e In fact, to make the L1SLOAD work, it needs the L2 to have a system contract that stores the last known L1 block to the L2 (see here (https://github.com/ethereum/RIPs/blob/d75e5bb4cd4a3a642090ba15249c11bfccb064db/RIPS/rip-7728.md#which-l1-block-does-l1sload-read-the-storage-value-at) in the RIP) in order to have a consistent return for the precompile. But the design of such system contract is out of the scope of this RIP (re @RenoRen79: Another solution would be to have the L1 root hash available on each L2, and a cheap proof of storage. This would delegate the burden of reading slots from L2 from nodes to the Dapp.)",
        "created_at": "2024-06-27T17:10:55.366000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e technically you don't need a system contract, you could just have the L2 block contain a pointer to the most recent L1 block that it knows about, and the STF read that directly",
        "created_at": "2024-06-27T17:13:49.289000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cRenoRen79\u003e But if the block rate is lower, and many blocks are processed in a single proving L2 block, doesn't it means that the L2 shall store a window of blocks instead of just one ? It seems necessary to include the block number processed, and then the prover need an oracle to provide the value of the associated (slot, blocknumber) value. (re @icemelon: In fact, to make the L1SLOAD work, it needs the L2 to have a system contract that stores the last known L1 block to the L2 (see here in the RIP) in order to have a consistent return for the precompile. But the design of such system contract is out of the scope of this RIP)",
        "created_at": "2024-06-27T17:13:55.930000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e but I can see how a system contract would be the easiest way to implement it for many people",
        "created_at": "2024-06-27T17:14:02.027000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cFlorian_Huc\u003e Personally I feel that requiring L2 nodes to follow the L1 is a really strong requirement. I would expect light clients to be able to attest the validity of an L2 block without needing to follow L1.\nI am not sure how we could avoid this with S1sload for instance.",
        "created_at": "2024-06-27T17:18:37.425000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctyneslol\u003e The OP Stack has a remote static call precompile proof of concept, its not used in production anywhere: https://github.com/ethereum-optimism/op-geth/pull/114\n\nI also opened an issue on the RIPs repo for a L1 blockhash precompile/predeploy but like what was mentioned already, the proof size isn't ideal. With verkle it would get better but still not great\nhttps://github.com/ethereum/RIPs/issues/16 (re @vb271828: I know some other L2s (just optimism, or also others?) also have L1STATICCALL. Would it make sense to standardize both as RIPs?)",
        "created_at": "2024-06-27T17:20:24.089000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e One other challenge with the blockhash approach is, it requires proofs to be bound to a particular hash, and so txs can expire. There's probably ways to manage it, but it adds complexity",
        "created_at": "2024-06-27T17:22:15.962000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cvb271828\u003e Whereas with L1sload or L1staticcall, you don't have this issue",
        "created_at": "2024-06-27T17:22:33.158000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e how would such client verify deposits without following L1? I expect all rollup nodes already require access to L1 nodes (or they trust whatever block the sequencer produces) (re @Florian_Huc: Personally I feel that requiring L2 nodes to follow the L1 is a really strong requirement. I would expect light clients to be able to attest the validity of an L2 block without needing to follow L1.\nI am not sure how we could avoid this with S1sload for instance.)",
        "created_at": "2024-06-27T17:22:44.049000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ctyneslol\u003e The problem with remote static call that we found was the requirement of an L1 archive node for historical sync, which is mentioned in the RIP. A way around this could be to use EIP-7685 (https://github.com/ethereum/EIPs/blob/72523ee3f865e09f8a6117c1b5e74cbb2df4f60e/EIPS/eip-7685.md) and embed the data in the block itself",
        "created_at": "2024-06-27T17:25:28.620000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cRenoRen79\u003e It depends on the use targetted. Having instant L1 state reading from L2 appears a large task. While propagating last block hash is really easy (L2 nodes needs to read at least settlement contract) .\n\n\nFor some applications knowing that \"a recent value of this slot was ...\", might suffice. For Key management, having a latency for revocation/update equal to the slowest block rate seems tolerable. (It shall be rare event). \n\nFor balances, ofc, it is not. Can be solve with timelock procedures, but it is dangerous. (re @vb271828: One other challenge with the blockhash approach is, it requires proofs to be bound to a particular hash, and so txs can expire. There's probably ways to manage it, but it adds complexity)",
        "created_at": "2024-06-27T17:42:18.856000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e From the work of herodotus (colleagues) on starknet, the process of:\n=== Preprocessing ===\ngenerate a huge MMR with all historical L1 blockhashes.\nStarkify this computation.\n=== Consumption ===\nVerify an MPT proof onchain against a state root retrieved from the MMR\n\nThis costs 0.04$ currently on starknet",
        "created_at": "2024-06-27T17:47:20.476000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e there is merit in using a shared infra for l2s no?",
        "created_at": "2024-06-27T17:48:03.551000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003celiastzr\u003e maybe some state proof market",
        "created_at": "2024-06-27T17:48:26.006000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cFlorian_Huc\u003e We have two types of finality: L2 finality where you indeed need to trust the sequencer or the L2 consensus but you don't need to track L1 at all  and the L1 finality where you need to track L1 to know when an L2 block is L1 final. But to evaluate an L2 block you don't need to track L1. (re @thegaram33: how would such client verify deposits without following L1? I expect all rollup nodes already require access to L1 nodes (or they trust whatever block the sequencer produces))",
        "created_at": "2024-06-27T18:39:01.010000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cthegaram33\u003e I see your point. as an L2 follower node, you can process deposit txs even without having access to an L1 node (though you cannot verify them). but to process calls to `L1SLOAD`, you must have access to an L1 node.",
        "created_at": "2024-06-27T18:45:42.916000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cFlorian_Huc\u003e Exact (re @thegaram33: I see your point. as an L2 follower node, you can process deposit txs even without having access to an L1 node (though you cannot verify them). but to process calls to L1SLOAD, you must have access to an L1 node.)",
        "created_at": "2024-06-27T18:46:19.604000+00:00",
        "attachments": null
    }
]