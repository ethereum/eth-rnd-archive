[
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cAndrew_Beal\u003e Would like to discuss this. It's been a common piece of feedback from L2s (re @mratsim: I'm not even sure how to start proving this in a zkEVM.)",
        "created_at": "2024-02-14T01:13:13.870000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cAndrew_Beal\u003e Great question. One point of clarification - RIP 7614 would simply provide DeFi protocols, for example, with more visibility about incoming transactions.  It won't prevent an exploit by itself - it needs to be coupled with a prevention mechanism, of which transaction screening is just one option. \n\nA majority of exploits can be detected early today, either by identifying the malicious smart contract or by monitoring the mempool. The challenge is prevention after the detection.\n\nYes, an atomic exploit via a private mempool might be difficult to detect in advance, but the majority of attacks don't have that pattern. But we are anticipating more of this behavior as attackers grow more sophisticated, and in response are working on a complimentary mechanism that would check contract age. If a contract is deployed in the same transaction, a dapp could decide to block that tx. (re @stanbreadless: It would be interesting to also see more concrete examples on which of the recent attacks it could have prevented. \n\nAnd example from the EIP:\n\n\u003e Moreover, blackhats deploy attack contracts before launching the attack and that gives a time frame to scan and detect the malicious contract. If the attack transaction does a DELEGATECALL from a proxy to the attack contract, to call the victim contract, then the msg.sender observed by the victim contract is the proxy contract (and not the actual malicious attack contract). The call stack breaks this evasion by exposing the DELEGATECALLed addresses in the call stack.\n\nFor instance, this defense can be circuimvented by having a single tx where there is firstly a contract deployed and then called. This could be done through private mempool not giving enough time for anyone to react. Even if it is done on an L2 (which at this moment dont usually have private mempool), the first-come-first-serve which employed by most of the rollups today would still let this transaction int \u003cclipped message\u003e",
        "created_at": "2024-02-14T01:25:55.576000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cCarlBeek\u003e Reminder: RollCall #3 in 1 hour:\n\n- Agenda - https://github.com/ethereum/pm/issues/944\n- Zoom link to follow in this chat\n- Recording will be on YouTube",
        "created_at": "2024-02-14T13:00:31.408000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cCarlBeek\u003e Rollcall starting in 15 mins: https://ethereumfoundation.zoom.us/j/82673576599?pwd=5eM5d0bqTKZvCeXIWEAmMc8Hk6zm2k.1",
        "created_at": "2024-02-14T13:45:15.438000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cHighlander1969\u003e What happens if the attack is executed in the constructor of the attacking contract deployed by the proxy? Token approvals for the attack can be given to the attacking contract using create2 to predetermine the contract address. (re @Andrew_Beal: Great question. One point of clarification - RIP 7614 would simply provide DeFi protocols, for example, with more visibility about incoming transactions.  It won't prevent an exploit by itself - it needs to be coupled with a prevention mechanism, of which transaction screening is just one option. \n\nA majority of exploits can be detected early today, either by identifying the malicious smart contract or by monitoring the mempool. The challenge is prevention after the detection.\n\nYes, an atomic exploit via a private mempool might be difficult to detect in advance, but the majority of attacks don't have that pattern. But we are anticipating more of this behavior as attackers grow more sophisticated, and in response are working on a complimentary mechanism that would check contract age. If a contract is deployed in the same transaction, a dapp could decide to block that tx.)",
        "created_at": "2024-02-14T14:24:36.389000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003cCarlBeek\u003e RollCall recording from earlier is up: https://youtu.be/rwDpX08PiXQ",
        "created_at": "2024-02-14T18:01:55.994000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "general",
        "parent": "",
        "content": "\u003ccanercdm\u003e If I understand correctly, then the attacker contract would either be called or delegatecalled, then that contract would call the victim contract so the attack logic contract would appear in the call stack. The victim contract can elect to refuse the transaction by checking either the contract age (somehow) or checking a whitelist. Since the logic contract wouldn't be known to the offchain actors yet, the risk/reputation data wouldn't exist and the transaction would be reverted. (re @Highlander1969: What happens if the attack is executed in the constructor of the attacking contract deployed by the proxy? Token approvals for the attack can be given to the attacking contract using create2 to predetermine the contract address.)",
        "created_at": "2024-02-14T18:12:20.730000+00:00",
        "attachments": null
    }
]