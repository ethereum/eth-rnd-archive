[
    {
        "author": "nishant0",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@427491045308235776\u003e \u003c@592004585506340885\u003e Do you guys see any low hanging fruits or optimizations in the computation of cells and kzg proofs from a blob ? In devnets that we have run we do see that the computing of data columns takes a non-trivial amount of time. ( 1- 2s in the average case) . If the node is stressed it can blow up to (6 - 7s). Even in the average case, its not reasonable to have the data columns take that long to create as it increases the risk of the block being reorged by quite a bit.",
        "created_at": "2024-08-29T15:01:09.091000+00:00",
        "attachments": []
    },
    {
        "author": "jtraglia",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Even 1-2 seconds is longer than I think it should take. I have some questions. In this situation, how many blobs are there? Is this computing cells/proofs for 6 blobs sequentially? In our tests, it should take ~200ms to do this per blob or 1.2s for 6 blobs sequentially. Could you run the benchmarks in the c-kzg-4844 repo? I can provide instructions for this. Also, how expensive are the conversions from blobs to data columns?",
        "created_at": "2024-08-29T15:11:34.910000+00:00",
        "attachments": []
    },
    {
        "author": "jtraglia",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "One low hanging fruit optimiziation would be to configure `precompute=8` when loading the trusted setup, if you aren't already doing this.",
        "created_at": "2024-08-29T15:12:42.406000+00:00",
        "attachments": []
    },
    {
        "author": "nishant0",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "These are all for 6 blobs, and the numbers were after parallelization. It would be relevant to mention that the node was doing other stuff too ( advancing states, verifying attestations and aggregates, etc) which is why it might be different from a standard benchmark. \n\nI can try running the ckzg benchmarks tomorrow on my machine",
        "created_at": "2024-08-29T15:15:09.870000+00:00",
        "attachments": []
    },
    {
        "author": "nishant0",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Thanks ! I can try that, is there any downside to it ?",
        "created_at": "2024-08-29T15:16:03.464000+00:00",
        "attachments": []
    },
    {
        "author": "jtraglia",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yes, higher memory usage. Here's a table of performance/memory usage:\nhttps://notes.ethereum.org/@jtraglia/windowed_multiplications",
        "created_at": "2024-08-29T15:17:00.495000+00:00",
        "attachments": []
    },
    {
        "author": "cskiraly",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I remember running the tests before even there was the precompute, and I think it was around 200ms per blob also on my M1.",
        "created_at": "2024-08-29T15:18:01.287000+00:00",
        "attachments": []
    },
    {
        "author": "cskiraly",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Actually, it wasn't the M1, but a 12th gen Intel. These were the measurements back then:\n\n12th Gen Intel(R) Core(TM) i5-12450H, with 4 P-cores and 4 E-cores\n\n# Performance Core\n(avoid cores 0,1, since 0 is mostly used by system, 1 is it's HT pair)\n```\ncskiraly@beelink-i5:~/DAS/c-kzg-4844/bindings/go$ taskset -c 2 go test -bench=Benchmark/VerifyRows -run=Benchmark/VerifyRows\ngoos: linux\ngoarch: amd64\npkg: github.com/ethereum/c-kzg-4844/bindings/go\ncpu: 12th Gen Intel(R) Core(TM) i5-12450H\nBenchmark/VerifyRows(count=1)                 27          42468229 ns/op\nBenchmark/VerifyRows(count=2)                 14          77891558 ns/op\nBenchmark/VerifyRows(count=4)                  7         147629896 ns/op\nBenchmark/VerifyRows(count=8)                  4         282894263 ns/op\nBenchmark/VerifyRows(count=16)                 2         549648874 ns/op\nBenchmark/VerifyRows(count=32)                 1        1074110572 ns/op\nBenchmark/VerifyRows(count=64)                 1        2103399612 ns/op\nPASS\nok      github.com/ethereum/c-kzg-4844/bindings/go      49.788s\n```\n\n# Efficiency core\n```\ncskiraly@beelink-i5:~/DAS/c-kzg-4844/bindings/go$ taskset -c 9 go test -bench=Benchmark/VerifyRows -run=Benchmark/VerifyRows\ncpu: 12th Gen Intel(R) Core(TM) i5-12450H\nBenchmark/VerifyRows(count=1)                 10         103660779 ns/op\nBenchmark/VerifyRows(count=2)                  6         190962519 ns/op\nBenchmark/VerifyRows(count=4)                  3         361197748 ns/op\nBenchmark/VerifyRows(count=8)                  2         692331416 ns/op\nBenchmark/VerifyRows(count=16)                 1        1343995351 ns/op\nBenchmark/VerifyRows(count=32)                 1        2626470604 ns/op\nBenchmark/VerifyRows(count=64)                 1        5152357216 ns/op\nPASS\nok      github.com/ethereum/c-kzg-4844/bindings/go      106.907s\n```",
        "created_at": "2024-08-29T15:21:07.291000+00:00",
        "attachments": []
    },
    {
        "author": "cskiraly",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "this is however for the verification",
        "created_at": "2024-08-29T15:22:01.900000+00:00",
        "attachments": []
    },
    {
        "author": "cskiraly",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I can't find the logs of other tests now, but it should be easy to run them.",
        "created_at": "2024-08-29T15:22:30.981000+00:00",
        "attachments": []
    },
    {
        "author": "jtraglia",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Cool sounds good. As a sanity check, it might be worth adding timers around the call to `kzg.ComputeCellsAndKZGProof`. If these times seems reasonable, then the problem is elsewhere, probably in conversions. And here's how to run the ckzg benchmarks:\n\n```\ngit clone git@github.com:ethereum/c-kzg-4844.git\ncd c-kzg-4844/bindings/go\ngo clean -cache \u0026\u0026 go test -cpu=1 -bench=Benchmark\n```",
        "created_at": "2024-08-29T15:24:18.071000+00:00",
        "attachments": []
    },
    {
        "author": "cskiraly",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Here are the results for a few CPUs. Just giving the `precompute=8` values, on a single core\n```\nBenchmark/ComputeCellsAndKZGProofs(precompute=8) \n- Apple M1:  178ms\n- Intel 12th gen P-core: 315ms\n- Intel 12th gen E-core: 541ms\n```\nIt is indeed more than 200ms on the Intel. Also, I've noticed that precompute=0 is faster than precompute=1,2,3. Is that normal?",
        "created_at": "2024-08-29T17:06:04.506000+00:00",
        "attachments": []
    },
    {
        "author": "jtraglia",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yes, `precompute=8` is expected to be faster üëç it uses a different MSM function.",
        "created_at": "2024-08-29T17:12:50.678000+00:00",
        "attachments": []
    },
    {
        "author": "jtraglia",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@857052906495017000\u003e the Intel results are a bit slower than I expected, but reasonable I suppose. As a sanity test, could you re-run the benchmarks on that machine with the \"portable\" flag? This:\n\n```\nCGO_CFLAGS=\"-O2 -D__BLST_PORTABLE__\" go test -cpu=1 -bench=Benchmark/ComputeCellsAndKZGProofs -run=Benchmark/ComputeCellsAndKZGProofs\n```",
        "created_at": "2024-08-29T17:14:25.865000+00:00",
        "attachments": []
    }
]