[
    {
        "author": "bridge-bot",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003cnashatyrev_a\u003e I would prefer HAVEs to contain full `DataColumnIdentifier` to make sure a peer has the exact column and must respond to a subsequent `data_column_sidecars_by_root` request. It would still be neglected amount of traffic from my perspective.",
        "created_at": "2024-04-22T11:51:23.816000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003cnashatyrev_a\u003e I believe a sampler may request HAVEs as soon as the beginning of a slot. If he needs a better security he may request excessive/all column indexes. \n\nWith respect to req/resp interactions I think there are several possible approaches (I believe you have mentioned them already): \n- Long polling: just a single method which keeps a stream opened until all the requested HAVEs are responded or until a timeout. This is a new req/resp approach so may require some extra engineering/testing efforts \n- Subscribe/notify: there are 2 (one-way) methods: sampler subscribes to slot+indexes, custody notifies the subscriber with HAVEs whenever a new column is received. No timeouts are needed here IMO (re @cskiraly: Yeah, collecting HAVE information is important. In my version we do that with usual IHAVEs, plus by piggybacking HAVE information on Resp messages. Note that HAVEs are very cheap, in case of 1D they are just 128 bits for a specific block. Basically free to piggyback if there is some message anyway.\n\nWhen sampling columns, explicitly requesting HAVE info in advance might make sense because of the huge difference in size between data and the HAVE info. I see your point on that. I'm always starting with the 2D segment level sampling in mind. \nWhat is not clear to me is the timing of requesting the identifiers (the HAVE info). We do the timeout based request explicitly to free ourselves from having to decide a timing on receiver side without info on the state of others, reaching almost minimum delay on the happy path in most cases. This is because most of your peers will receive close in time to each other due to the exponential nature of the GS distribution. At the same time, we add the sequential logic to bound duplicates and still stay in delay bounds if we are not on the happy path.\n\nFor columns, the combined approach you mention might worth doing. Although it is not clear to me when would you send out t \u003cclipped message\u003e",
        "created_at": "2024-04-22T12:06:13.619000+00:00",
        "attachments": null
    }
]