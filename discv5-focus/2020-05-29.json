[
    {
        "author": "agemanning",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@194432762315407360\u003e in the process of building this, I rediscovered why we needed ENRs for dialing. In the same scenario, A connecting to B with a multiaddr, \nB sends back a WHOAREYOU and A now needs to generate session keys. A therefore needs Bs public key and identity scheme to perform DH.\n\nMultiaddr by default don't have these fields as they're designed for protocols. Got any ideas here?",
        "created_at": "2020-05-29T16:29:44.275000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hmm, OK",
        "created_at": "2020-05-29T16:44:44.146000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I didn't think about this",
        "created_at": "2020-05-29T16:44:50.735000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I guess it would still work as long as there is only one public key in the multiaddr",
        "created_at": "2020-05-29T16:45:51.355000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The idea is that the handshake always uses whatever key is the 'primary' identity public key. That would also be the key you put into the multiaddr.",
        "created_at": "2020-05-29T16:47:48.003000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If a node has multiple public keys, there will still be only one 'primary' one because it needs to pick an identity scheme.",
        "created_at": "2020-05-29T16:48:32.394000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Does the multiaddr include the Peer ID as well?",
        "created_at": "2020-05-29T16:48:53.795000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't know much about libp2p's peer identity model. But they wouldn't allow multiple IDs for one node, right?",
        "created_at": "2020-05-29T16:49:43.794000+00:00",
        "attachments": null
    },
    {
        "author": "dryajov",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "so it depends, if the key is less than 42 bits, then the peerid itself can be encoded as the key in `/p2p/QmXXX`, if anything larger is used, then the digest is the id",
        "created_at": "2020-05-29T16:52:50.999000+00:00",
        "attachments": null
    },
    {
        "author": "agemanning",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For rust these are default variants in a multiaddr https://docs.rs/multiaddr/0.3.1/multiaddr/enum.AddrComponent.html\n\nRust-libp2p doesn't require the peer_id to dial, but other impls do. \n\nIt just so happens that both ed25519 and secp256k1 keys get inlined so for these keys we can infact get the public key with a bit of work",
        "created_at": "2020-05-29T16:52:53.342000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "OK",
        "created_at": "2020-05-29T16:54:01.229000+00:00",
        "attachments": null
    },
    {
        "author": "agemanning",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So I guess implementations could have this as an optional feature for these keys",
        "created_at": "2020-05-29T16:54:03.174000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We need the identity public key before connecting. We've always had that. It's a very very important part of all the protocols in eth so far. We wouldn't be able to make the handshake so quick if we didn't have that.",
        "created_at": "2020-05-29T16:56:21.081000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Really hope we never have to give that up.",
        "created_at": "2020-05-29T16:56:38.384000+00:00",
        "attachments": null
    },
    {
        "author": "dryajov",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e Rust-libp2p doesn't require the peer_id to dial, but other impls do. \nbtw we don't, the keys are also exchanged during identify, so dialing without an id should be totally valid",
        "created_at": "2020-05-29T16:56:43.726000+00:00",
        "attachments": null
    },
    {
        "author": "dryajov",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "err, we nim-libp2p",
        "created_at": "2020-05-29T16:57:01.864000+00:00",
        "attachments": null
    },
    {
        "author": "agemanning",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, so ok, it is possible to still dial discv5 using a multiaddr if the keys get inlined. Works for me, I continue about my business. Thanks guys :)",
        "created_at": "2020-05-29T16:58:31.837000+00:00",
        "attachments": null
    },
    {
        "author": "dryajov",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ok, have fun",
        "created_at": "2020-05-29T16:59:09.836000+00:00",
        "attachments": null
    },
    {
        "author": "dryajov",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e We need the identity public key before connecting. We've always had that. It's a very very important part of all the protocols in eth so far. We wouldn't be able to make the handshake so quick if we didn't have that.\n\u003c@!194432762315407360\u003e btw, like \u003c@!498009160982724610\u003e said, it should be possibly to inline the keys in the multiaddr string, I don't remember if there is a size limit on the peerid itself (my digging suggest there is one, but not 100% sure), but we can always extend multiaddrs to include additional keys/fields if required. Afaik, the concern with long peerid string was possible limits when encoding as url's, but we don't have that limitation.",
        "created_at": "2020-05-29T17:07:35.801000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "OK",
        "created_at": "2020-05-29T17:10:21.182000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Happy to hear that",
        "created_at": "2020-05-29T17:10:26.693000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@194432762315407360\u003e i did an experiment recently, extending the discovery v5 protocol to include DHT style key/value storage and retrieval with the expressed goal of storing \u0026 retrieving historical chain data (headers /blocks /transactions /receipts). It seemed promising. Curious if you have any strong feelings or thoughts  on the idea.",
        "created_at": "2020-05-29T17:45:18.990000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't have anything against re-using the protocol for this kind of thing, but we can't  really go ahead and require everyone to participate in a multi-purpose data DHT.",
        "created_at": "2020-05-29T19:40:37.455000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The idea behind discovery as a DHT is pretty simple: you run this low-resource thing in the background, find your peers, and in return, you participate in this large network helping everyone else find theirs",
        "created_at": "2020-05-29T19:41:48.302000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Discovery is a pretty universal need that all kinds of peer-to-peer systems have, so in theory the network can grow very large and work for all kinds of p2p systems.",
        "created_at": "2020-05-29T19:42:37.436000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's my view at least",
        "created_at": "2020-05-29T19:43:01.133000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But what you can always do is re-use the protocol and build specific sub-networks with more message types for specialized things",
        "created_at": "2020-05-29T19:43:35.657000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In the stable spec release, due next week, I  will add the TALKREQ/TALKRESP messages.",
        "created_at": "2020-05-29T19:44:11.651000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The idea behind those is allowing you to install basic message handlers behind a protocol name, in discovery",
        "created_at": "2020-05-29T19:44:58.725000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The request is `TALKREQ [ req-id, protocol, data ]`",
        "created_at": "2020-05-29T19:45:41.499000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You could use this mechanism for your data DHT experiment",
        "created_at": "2020-05-29T19:46:23.755000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "e.g. you could add a handler for your \"chaindata\" protocol (or whatever you want to call it) and serve the requests this way. If you announce the capability to serve data this way in ENR, it should be pretty easy to build an extra routing table for your data DHT.",
        "created_at": "2020-05-29T19:48:13.338000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Does that sound like a good starting point?",
        "created_at": "2020-05-29T19:48:34.155000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The TALKREQ thing is a very flexible extension point, I think. The intended use for this is 'agreeing to talk', which is why it's called TALKREQ. But since it's a totally free-form extension point, it could also be used for experiments.",
        "created_at": "2020-05-29T19:52:34.613000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yes, this sounds like a more ideal approach than a second network.",
        "created_at": "2020-05-29T21:01:43.856000+00:00",
        "attachments": null
    }
]