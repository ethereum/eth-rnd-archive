[
    {
        "author": "deme1744",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@194432762315407360\u003e I just ran your latest test on the Nim implementation. It fails the `PingHandshakeInterrupted` test. I wanted to clarify that this is because I currently don't follow the handshake implementation considerations and a bit reluctant to do so (for now at least), instead I allow only for 1 handshake to be ongoing (per ip + id) and ignore newer packets until handshake timeout. Originally I did this to avoid having to store and reply on these messages in case of an attack, call it poor man's rate limiter I guess. I think 1 downside is that if an attacker manages to spoof your ip you might get blocked from doing any handshake at all.",
        "created_at": "2020-10-08T09:20:31.583000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, I wanted to notify you about this.",
        "created_at": "2020-10-08T09:20:57.837000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This is basically the second part of this spec section: https://github.com/ethereum/devp2p/blob/master/discv5/discv5-theory.md#handshake-implementation-considerations",
        "created_at": "2020-10-08T09:21:32.886000+00:00",
        "attachments": []
    },
    {
        "author": "deme1744",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah, I realized that. I guess best would be to get rate limiting in and follow the considerations",
        "created_at": "2020-10-08T09:21:49.866000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We added that because Piper found the other behavior problematic",
        "created_at": "2020-10-08T09:21:56.198000+00:00",
        "attachments": []
    },
    {
        "author": "deme1744",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In which way?",
        "created_at": "2020-10-08T09:22:04.952000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "https://github.com/ethereum/devp2p/pull/157#issuecomment-679481919",
        "created_at": "2020-10-08T09:22:29.958000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If we want to change this again, or come up with a more sophisticated solution, we can do that still. I just went with Piper's recommendation because it's the simplest solution.",
        "created_at": "2020-10-08T09:23:54.203000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "What's important to understand is that there is always potential for some handshakes to fail due to reordering or packet drop. But that's OK, and that's also why we generally don't have retries for any send.",
        "created_at": "2020-10-08T09:25:06.142000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think Pipers solution captures this spirit pretty well. This issue will only really matter for implementations which send multiple messages concurrently. If your implementation only performs a single request/response at a time (per destination), this is very unlikely to happen.",
        "created_at": "2020-10-08T09:26:24.218000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Damn, I forgot to update the packet layout images in the spec",
        "created_at": "2020-10-08T09:27:14.322000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Doing it now",
        "created_at": "2020-10-08T09:27:17.340000+00:00",
        "attachments": []
    },
    {
        "author": "deme1744",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, agree. Not sure what is best solution right now, have to think about it :-). But I don't think I'd like to support the buffering for case A there, don't want to rebuild TCP here. Don't really agree with that the `WhoAreYouPacket` can be ignored in that case A also, based on which ground? (perhaps some time between previously received whoareyou?) I think in those cases, you will just end up doing a handshake once again.",
        "created_at": "2020-10-08T09:37:12.330000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I didn't implement this WHOAREYOU ignoring part",
        "created_at": "2020-10-08T09:38:37.395000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But I think it would be possible to implement that because the source of the message packets knows the correct ordering",
        "created_at": "2020-10-08T09:39:12.081000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "i.e. consider the situation on the initiator side: it sends two message packets (p1, p2) in certain order. It receives WHOAREYOU for one of them (p1) and sends the handshake (p1.1). The other side receives them in order (p1, p2, p1.1). It will generate a new WHOAREYOU for p2. When the initiator receives that, it knows the handshake for p1 didn't work and can redo it.",
        "created_at": "2020-10-08T09:41:50.686000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Concurrent messaging + the handshake is very tricky to implement correctly, that's why I didn't do it in my implementation. But I think it's *possible* to implement, the current spec text doesn't prevent it.",
        "created_at": "2020-10-08T09:43:18.365000+00:00",
        "attachments": []
    },
    {
        "author": "deme1744",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But in that example, it then doesn't ignore the whoareyou of p2, it could do so however by waiting a bit for the response of p1.1. But I'm not sure if you'd want to do that.\nAnyhow, yeah, it is tricky to get it right/optimal.  But in general, the network can deal with this I guess. There might just be some inefficient re-handshaking going on. Anyway, I'll might have a better look at it later, after I get some more important parts  in order ðŸ™‚",
        "created_at": "2020-10-08T09:52:18.613000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "OK",
        "created_at": "2020-10-08T09:56:25.982000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Please remove the part that ignores the second message though",
        "created_at": "2020-10-08T09:56:48.485000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Regarding interop, we're in a really good place right now. The only implementation we're still missing is rust. They're in the middle of a crypto library transition right now and Age said he'll be done with it tomorrow.",
        "created_at": "2020-10-08T09:58:00.265000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We need to make some deployment plans I guess",
        "created_at": "2020-10-08T10:00:43.320000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Not sure what's the current cross-client testnet right now",
        "created_at": "2020-10-08T10:06:10.592000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Should we try to update it in-flight?",
        "created_at": "2020-10-08T10:06:22.157000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "proto was in favor of doing it that way",
        "created_at": "2020-10-08T10:06:46.984000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'd personally be happier with a v5.1 launch that coincides with the next testnet, but not sure if that will happen soon or if we're just going to keep upgrading the current ones until mainnet comes",
        "created_at": "2020-10-08T10:07:29.183000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I definitely don't want to keep the 5.0 implementation around in go-ethereum unless it's absolutely required.",
        "created_at": "2020-10-08T10:08:21.358000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In other languages, maybe there's an easy way to have both versions simultaneously with build system tricks or whatever.",
        "created_at": "2020-10-08T10:09:08.343000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "From a protocol perspective, it's possible to multiplex both versions on the same socket. Basically just decrypt the header obfuscation and check for protocol-id, if it doesn't match, dispatch the packet to 5.0.",
        "created_at": "2020-10-08T10:10:53.995000+00:00",
        "attachments": []
    }
]