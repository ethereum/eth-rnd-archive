[
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "One thing we haven't probably taken into account is proposer boost. If a block is timely it gets a proposer boost which significantly reduces attack surface on LMD GHOST (via inducing re-orgs) as boosted block is likely to be accepted (it temporarily receives 70% weight in the fork choice). So, with proposer boost it makes it more or less comparative to the PoW status quo. In both PoW and PoS we have: timely + valid = unlikely to get re-orged, while there is a difference between nature of PoW's \"being uncled\" and PoS' \"not timely\" I would disregard it for this particular case.",
        "created_at": "2022-03-05T07:41:14.806000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "To dive deeper into semantics of these block tags:\n- \"finalized\" \n    - irreversible in terms of Casper FFG\n    - irreversibility (safety) assumes 6.5 minutes synchrony\n    - irreversibility (safety) is crypto-economically secured, i.e. adversary owning 2/3 of stake will be slashed attempting to finalize conflicting checkpoints\n- \"safe\"\n    - irreversible in terms of LMD-GHOST\n    - irreversibility assumes honest majority (\u003e1/2) and 4s synchrony, no crypto-economics security\n- \"unsafe\"\n    - if it's built atop of a safe head and is timely it becomes next safe head, thanks to proposer boost\n    - if it's built atop of unsafe or ins't timely then it depends\n    - timeliness assumes 4s synchrony and absence of local proposer failures\n\ncc \u003c@!273808422753796097\u003e \u003c@!555483069038198827\u003e to double check me",
        "created_at": "2022-03-05T08:31:26.696000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "I also don't think that we should play with \"safe\" semantics on CL side; it should rather be strict by it's definition and allow users and dapps to adjust behaviour depending on the gap between \"safe\" and \"unsafe\". And in this case \"latest\" == \"unsafe\" might be more reasonable",
        "created_at": "2022-03-05T08:41:31.340000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Another benefit of safe as default is if there is a network partition and you are on the minority side, you will correctly not progress.  Latest however can result in continued chain progression that may result in a large reorg.",
        "created_at": "2022-03-05T08:50:58.604000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "For novice users, seeing their transaction confirm and then coming back later to see it all unwound is a very poor experience.  Similarly, a user who does X and then after success does Y will be frustrated to find later that X and Y didn't actually succeed.",
        "created_at": "2022-03-05T08:51:58.296000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "I see. We probably need a network with latest == safe where we have dapps and infra deployed, and then induce pretty long chain of unsafe blocks ending up with re-org to see if latest as an alias for safe would work",
        "created_at": "2022-03-05T08:59:17.838000+00:00",
        "attachments": null
    }
]