[
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "I am wondering what would the benefit be? Simplified EL code?",
        "created_at": "2023-09-21T11:05:21.646000+00:00",
        "attachments": []
    },
    {
        "author": "robocopsgonemad",
        "category": "Execution Layer",
        "parent": "",
        "content": "yes, lower maintenance for the ELs and possibly CLs, assuming both sides only maintain 2 versions for either side of upcoming fork. I am assuming that the CL can send blocks being imported to the EL over newer versions of the api.  So it would be ok to send paris blocks over v3.",
        "created_at": "2023-09-21T11:41:43.035000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "did you mean sending paris block over *v2*? i believe that when v4 is introduced during the next hardfork we won't be able to deprecate v2. So deprecating v1 is a one time thing we can do because it can be handled by v2",
        "created_at": "2023-09-21T11:59:18.679000+00:00",
        "attachments": []
    },
    {
        "author": "robocopsgonemad",
        "category": "Execution Layer",
        "parent": "",
        "content": "i did mean v2, thx",
        "created_at": "2023-09-21T12:19:10.110000+00:00",
        "attachments": []
    },
    {
        "author": "robocopsgonemad",
        "category": "Execution Layer",
        "parent": "",
        "content": "so the ability for a version Y to allow deprecation of prior version X is a per-upgrade question. for example, if version Y is only additive to version X, it may happen to be the case that CLs can send a vX payload to a vY endpoint, and then vX can be deprecated.  This is a bit ugly, but if specified explicitly, would allow for pruning old code versions.",
        "created_at": "2023-09-21T12:23:55.488000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "We got this discussion before and decided not to mix several versions in one method as it leads to ever growing complexity and increased risk of bugs",
        "created_at": "2023-09-21T12:27:02.062000+00:00",
        "attachments": []
    },
    {
        "author": "robocopsgonemad",
        "category": "Execution Layer",
        "parent": "",
        "content": "yes, and thank you for that, because it's a good move. I think i'm talking about something subtly different... what I'm imagining doesn't result in any switching within the method implementation... ðŸ¤”",
        "created_at": "2023-09-21T12:31:44.534000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "whenever we decide that say paris and shanghai blocks won't have to be imported in lock-step we can deprecate v2. i don't think this is gonna happen soon, maybe when those blocks are pruned from the network due to 4444 proposal",
        "created_at": "2023-09-21T12:43:48.187000+00:00",
        "attachments": []
    },
    {
        "author": "robocopsgonemad",
        "category": "Execution Layer",
        "parent": "",
        "content": "ok thanks. I think i'm just gonna expect this to work just like p2p fork handling does, with each version being eternal for its fork.",
        "created_at": "2023-09-21T12:58:30.300000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "A developer from 1inch reached out to us and reported that our `eth_estimateGas` logic, when using the timestamp opcode, could be improved. We decided to implement the suggested change. Based on what they said, other clients seem to behave in a similar way.\n\nThe issue was that for our estimation, we used to add 1 to the timestamp, while a better estimate would be to add SLOT_TIME to the timestamp. https://github.com/NethermindEth/nethermind/pull/6037/files\n\nThis change is important when estimating values using the timestamp opcode. It appears to be an obvious improvement in estimation, so I'm sharing it in case other clients wish to implement the same logic.",
        "created_at": "2023-09-21T13:04:04.099000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution Layer",
        "parent": "",
        "content": "How exactly does this work though? `eth_estimateGas` takes in the block hash or number on which to estimate the call against. We don't increment the timestamp at all, we use the timestamp of the block they requested. I see how this could cause issue a bit, but this seems to change the meaning of the block hash/number value from \"execute as if at the end of this block\" to \"execute as if first in the next block\"",
        "created_at": "2023-09-21T13:26:06.889000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution Layer",
        "parent": "",
        "content": "we have always done the former",
        "created_at": "2023-09-21T13:26:13.093000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "Interesting, never ending story of JSON RPC standarization ðŸ˜„ so for Nethermind we have this flag treatBlockHeaderAsParentBlock and we set it true for eth_estimateGas. For eth_call it is set to false. Tbh I think our logic makes sense for gas estimation. In most use cases it would work better\n\nhttps://github.com/NethermindEth/nethermind/blob/master/src/Nethermind/Nethermind.Facade/BlockchainBridge.cs#L247",
        "created_at": "2023-09-21T13:31:11.455000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "Is it specified in JSON-RPC spec? I mean\n\"execute as if at the end of this block\" vs\n\"execute as if first in the next block\"",
        "created_at": "2023-09-21T13:31:48.775000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution Layer",
        "parent": "",
        "content": "it isn't clear from the spec if the param is the parent or current block to execute under",
        "created_at": "2023-09-21T13:32:55.564000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution Layer",
        "parent": "",
        "content": "i do agree that trying to execute in the context of the next block is probably what 99% of people actually want",
        "created_at": "2023-09-21T13:33:15.902000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution Layer",
        "parent": "",
        "content": "is your `treatBlockHeaderAsParentBlock` flag the third param in the call after the block hash?",
        "created_at": "2023-09-21T13:34:15.896000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "no, it is set to true for eth_estimateGas\nand it is set to false for eth_call and eth_createAccessList",
        "created_at": "2023-09-21T13:35:18.245000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Execution Layer",
        "parent": "",
        "content": "I think we should solve it by allowing users override timestamp (and other block fields). In geth eth_call optionally takes in a `BlockOverride` object which lets you do that. We could add the same to estimateGas",
        "created_at": "2023-09-21T13:35:19.836000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "Yeah, makes sense. However, the best UX we will have if by default estimateGas will work in the context of the next block",
        "created_at": "2023-09-21T13:36:43.036000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "the other solution would be distinguish \"pending\" and \"latest\" as a blockParameter",
        "created_at": "2023-09-21T13:37:28.866000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution Layer",
        "parent": "",
        "content": "yeah i wondered if there could be a \"next\" tag",
        "created_at": "2023-09-21T13:37:42.930000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "and by default for estimateGas we should use \"next\", not sure about eth_call - probably not",
        "created_at": "2023-09-21T13:38:15.186000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "Btw thx for this, I will create an issue to add support for `BlockOverride` in Nethermind",
        "created_at": "2023-09-21T13:39:43.540000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Execution Layer",
        "parent": "",
        "content": "I think it makes sense for eth_call not to increment timestamp and number. But for estimateGas yes. However for `pending` we also apply the pending txes on top which changes the state. Not sure that's desirable either",
        "created_at": "2023-09-21T13:49:23.839000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "You're right!",
        "created_at": "2023-09-21T13:57:21.439000+00:00",
        "attachments": []
    },
    {
        "author": "s1na",
        "category": "Execution Layer",
        "parent": "",
        "content": "Thanks for sharing btw, created an issue to track this",
        "created_at": "2023-09-21T14:09:46.758000+00:00",
        "attachments": []
    },
    {
        "author": "marekm3498",
        "category": "Execution Layer",
        "parent": "",
        "content": "Cool, let me know when you decide what you plan to implement ðŸ™‚",
        "created_at": "2023-09-21T15:31:03.455000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Execution Layer",
        "parent": "",
        "content": "Sure, as far as i know some CL clients had an option to lock-step from genesis, not sure that this is still the case, but at least Nimbus supported it in the past cc \u003c@654267572107083777\u003e \n\nIf lock-step from genesis is no longer the case then we can deprecate e.g. v2 with transitioning to v4 and say that Shanghai and older blocks have to be backfilled.",
        "created_at": "2023-09-21T16:51:14.839000+00:00",
        "attachments": []
    },
    {
        "author": "robocopsgonemad",
        "category": "Execution Layer",
        "parent": "",
        "content": "out of curiousity, why do we mandate the checking of the param validity before checking for the fork being supported?  https://github.com/ethereum/execution-apis/blob/main/src/engine/cancun.md#engine_newpayloadv3",
        "created_at": "2023-09-21T18:00:29.404000+00:00",
        "attachments": []
    },
    {
        "author": "robocopsgonemad",
        "category": "Execution Layer",
        "parent": "",
        "content": "asking because \"you shouldn't even be calling this\" seems to me it should take precedence over \"you called it wrong\" but perhaps that is an aesthetic opinion",
        "created_at": "2023-09-21T18:02:51.830000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Nice to be able to check if you have a bug/incompatibility prior to the fork being activated?",
        "created_at": "2023-09-21T19:06:00.161000+00:00",
        "attachments": []
    },
    {
        "author": "siladu",
        "category": "Execution Layer",
        "parent": "",
        "content": "so IIUC, once deneb fork has passed, a CL needs to look at the timestamp of the EL block and if it is pre-cancunTime, send it to the EL using engine_newPayloadV2 otherwise EL should invalidate?",
        "created_at": "2023-09-21T21:08:03.316000+00:00",
        "attachments": []
    }
]