[
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "yeah, we actually do not even store the bloom in the database in geth",
        "created_at": "2024-02-21T11:48:26.721000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "it's kind of useless",
        "created_at": "2024-02-21T11:48:37.280000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "so I agree we should not send it in this new endpoint",
        "created_at": "2024-02-21T11:48:56.568000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003c@1068184824575184896\u003e since you have an opinion, can you please open an issue in ethereum/execution-apis about this new method?",
        "created_at": "2024-02-21T11:49:33.937000+00:00",
        "attachments": []
    },
    {
        "author": "jens4601",
        "category": "Execution Layer",
        "parent": "",
        "content": "Sure, though I'm not sure what the best way of handling the bloom should be, as it is still needed for computing the receipts_root, so if it isn't sent the light client will still have to compute the bloom (though it saves bandwidth). I think there are three options:\n- Send the receipts rlp encoded, so it can easily be checked against the receipts_root - Means computing the bloom in geth and sending it over the network\n- Send the receipts as json or a custom format (e.g. rlp encoded without bloom field) - Means computing the bloom in the light client =\u003e Less bandwidth needed but more complex light client implementation (as the bloom still has to be computed for checking the proof), also not sure how exactly receipts without bloom should be formatted.\n- A third option could be to remove the per-receipt bloom from the merkle trie (potentially when changing to verkle tries), then the per-receipt bloom wouldn't even be needed. Unfortunately that breaks backwards compatibility. I don't think anything relies on the per-receipt bloom being part of the merkle trie, but I don't know it for sure. Also, that's probably a bigger change than I think it is.\n\nI see that third one as either far in the future or not going to happen (for backwards compatibility, even though the entire data structure changes).\nAs for which of the first two is better: I don't know. Any input/thoughts on that? I can also add both to the issue in ethereum/execution-apis, with the trade-off I've mentioned above.",
        "created_at": "2024-02-21T13:06:12.304000+00:00",
        "attachments": []
    }
]