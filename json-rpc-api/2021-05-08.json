[
    {
        "author": "timbeiko",
        "category": "Execution Layer",
        "parent": "",
        "content": "Will give folks the weekend to chime in, \u003c@!543900561460822016\u003e and merge early next week üëç Please ping me if I'm the blocker üôÇ",
        "created_at": "2021-05-08T00:13:43.253000+00:00",
        "attachments": []
    },
    {
        "author": "alita85",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003c@!88765147048333312\u003e mentioned this as well, the primary issue I saw with it was the specificity but I'm also not sure what exactly the goal is, then. If it's just to be a documentation for others to use the JSON RPC then that makes sense, but if it's meant to capture all the edge-cases / be used to specify a reproducible api then I think the specifics are necessary. As I understand it, this was discussed in the JSON RPC calls which \u003c@!489256758989029405\u003e may be able to provide more info on. I was considering that we could do a high fidelity specification for the purposes of the implementation and then follow up with a surface level documentation formatted in the OpenRPC style. cc \u003c@!543900561460822016\u003e",
        "created_at": "2021-05-08T04:49:27.661000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "My thoughts on the matter is that I think we want extreme specificity, but the current layout puts all of that specificity front and center where I think it would be more valuable if you could \"drill in\".",
        "created_at": "2021-05-08T05:18:38.439000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "For example, specifying what an `Address` type is somewhere, and then just referring to that in the spec instead of re-specifying an Address in each spec.",
        "created_at": "2021-05-08T05:19:04.242000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Similarly, I think utilizing a structure similar to what people are already familiar with is valuable.  For example, I think everyone knows that `{ apple: bigint }` represents an object with an apple property that is a `bigint`, and this is *much* more terse and readable than 15 lines of a specification that painstakingly describe an object in English.",
        "created_at": "2021-05-08T05:20:34.542000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Picking a language with an expressive type system I think could get us like 98% of the way there.  I like TypeScript's type system for its expressiveness, but I'm open to other type systems.  We probably shouldn't use native types, and we would want types that have constraints on them.  If the spec is executable that is even better.",
        "created_at": "2021-05-08T05:22:10.753000+00:00",
        "attachments": []
    },
    {
        "author": "alita85",
        "category": "Execution Layer",
        "parent": "",
        "content": "I don't totally follow because when I think of a specification I think of an excessively wordy document. On the one hand, this is impossible to read, but on the other it is easier to draft (because it is derived directly from the tests that establish a behavior). So converting what is given in eth_call to another format is also fine. We have type definitions and will define types explicitly and use them wherever possible. From my point of view I think the hard part of the JSON RPC is collecting, itemizing, and agreeing on all the edgecases. How we format and display that information is sort of trivial and can be changed much more easily after the fact. Just my 2 cents.",
        "created_at": "2021-05-08T05:54:17.340000+00:00",
        "attachments": []
    }
]