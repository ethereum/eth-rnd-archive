[
    {
        "author": "jens4601",
        "category": "Execution Layer",
        "parent": "",
        "content": "I think I got a bit confused because there are 3 representations (unless I got it wrong again). I didn't have the last one in mind when writing this message:\n- `payload` The RLP list that contains the logs at index 3\n- `tx-type || payload` Additional transaction type byte for non-legacy transactions - 'consensus encoding' as you described, I was thinking about and is returned in Go-Ethereum's GraphQL endpoint.\n- `rlp.encode_bytes(tx-type || payload)` Which (if I got it correct) is the way it is thrown into the merkle trie for calculating receipts_root - What I described and it's what I thought of when reading 'consensus encoding' (which is easy enough to add when needed)\n\nSo I guess I just confused myself by not having the exact detail in my head.",
        "created_at": "2024-02-19T10:03:27.156000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "Yes you are right",
        "created_at": "2024-02-19T10:16:09.028000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "So it looks there are no big objections to defining the geth behavior canon",
        "created_at": "2024-02-19T10:16:45.848000+00:00",
        "attachments": []
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "I.e. return `tx-type || payload`",
        "created_at": "2024-02-19T10:17:11.814000+00:00",
        "attachments": []
    },
    {
        "author": "jens4601",
        "category": "Execution Layer",
        "parent": "",
        "content": "Throwing in my 2ct:\nI think a `eth_getRawReceipts` or `eth_getRawBlockReceipts` would make a lot of sense to have in the enabled-by-default namespace. Before the addition of `eth_getBlockReceipts` (returns json) you had to request individual receipts (unless using GraphQL) and at the moment (without using the `debug_` namespace) light clients have to receive, json decode, rlp encode, add tx-type and rlp encode again before checking validity against `header.receipts_root` and using the json decoded data. Whereas with a `RawReceipts` method they only have to receive it (which is less data because it's more compact) and add the envelope + rlp bytes encoding before checking validity, and can then get the data needed directly out of the RLP list. Thus saving bandwidth, probably execution resources on both sides and the amount of steps needed before the data can be used.\n\nIt's the minimal amount of information needed by a light client to check validity of logs against a header and it is slightly more future proof (although that likely doesn't matter much), since a light client could check validity of all transactions of a block without knowing the encoding of not-yet-known transaction types (as long as it can check the validity of the consensus-layer), since it then requires no logic for how those are structured/encoded.",
        "created_at": "2024-02-19T10:23:11.640000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003c@1068184824575184896\u003e I think we could be open to that. I also wonder if a namespace explicitly for light clients would be useful. And every method can have an accompanying proof",
        "created_at": "2024-02-19T18:20:42.308000+00:00",
        "attachments": []
    },
    {
        "author": "jens4601",
        "category": "Execution Layer",
        "parent": "",
        "content": "That does sound nice, especially when they're designed so you never or rarely have to re-encode (RLP) something just to check the validity. Though there might not be too many of those methods:\n- Many methods such as `eth_call`, `eth_estimateGas`, `eth_createAccessList`, ... simply cannot have a proof and require the client to execute EVM code itself or cannot have a proof with them by their nature (e.g. `eth_coinbase`)\n- Some already exist and are usable, though require re-encoding the data to match the format, here such a namespace could be useful: `eth_getBllockBy*`, `eth_getBlockReceipts`\n- Many would basically just be a `eth_getProof` with easier to use parameters: e.g. `eth_getCode`, `eth_getStorageAt`\n    - Some of those require needlessly big proofs given the current way things are stored/hashed (e.g. `eth_getTransactionReceipt` requiring the entire receipt list if I remember correctly)\n- Almost everything with `Filter` in the name won't work\n- `eth_getLogs` might as well just be a proof + complete receipts list\n\nOverall I can only think of the following that would be really useful (besides modifying some others slightly to make the output easier to use):\n- `getRawBlockReceipts` - All receipts of a block\n- `getRawHeader` - Though often you'd probably want it with another one\n- Something that allows getting a header and receipts or transactions only if the bloom matches a condition (otherwise just the header), can currently be done with two requests",
        "created_at": "2024-02-19T19:38:41.054000+00:00",
        "attachments": []
    },
    {
        "author": "jens4601",
        "category": "Execution Layer",
        "parent": "",
        "content": "Other than that I honestly can't think of much that would go into that namespace, so it might as well be part of the eth namespace if you ask me.",
        "created_at": "2024-02-19T19:40:10.192000+00:00",
        "attachments": []
    },
    {
        "author": "jens4601",
        "category": "Execution Layer",
        "parent": "",
        "content": "I do like the idea of methods specifically made for light clients though.",
        "created_at": "2024-02-19T19:40:34.863000+00:00",
        "attachments": []
    }
]