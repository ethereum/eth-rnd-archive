[
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "I am totally not sure this is the right place to raise this - if not - happy for any guidance to find the relevant place for it.\n\nWe are not very happy with the JSON-RPC security for requests that require a signature, rather than data-reading.  \n\nThe general idea:\nToday's Ethereum development flow relies on clients sending JSON-RPC requests to nodes.\nThe original JSON-RPC spec does not define an authentication or authorization mechanism. Some JSON-RPC providers added authentication that largely depends on API tokens, either in the request path or headers.\n\nSecurity in private key management is paramount. For read-only operations, the current authentication methods may suffice. However, for operations needing access to private keys, like signing transactions and messages and sending them to the blockchain, enhanced security is crucial.\n\nWe wrote a short doc on it to start a conversation and it has a bit more details in it: https://hackmd.io/@FBmScpM6RVWuOxk-3aXkVw/S1mLcQGNT",
        "created_at": "2024-02-26T08:20:07.395000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "When are private keys being sent over JSON-RPC?  I'm not aware of any methods that include private keys over the wire.",
        "created_at": "2024-02-26T10:22:45.625000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "not private keys that are being sent - signatures that are being created.",
        "created_at": "2024-02-26T11:15:13.292000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "If you are sending a signed transaction over JSON-RPC, you already have authenticated yourself as the transaction is signed.",
        "created_at": "2024-02-26T11:17:10.829000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Adding a second layer of authentication feels redundant.",
        "created_at": "2024-02-26T11:17:36.404000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "I might not be using the right terms/standard names to describe the problem.\nLet's say I use web3.js to interact with the ethereum. Some of the calls are to get data and some are to sign/send transactions - I am talking about something like eth_sign or eth_sendTransaction.",
        "created_at": "2024-02-26T13:20:13.820000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "The question is what is the authentication that is considered standard in those requests.\nOf course anyone can define any authentication they want - but if all the tools do not support it - that's not helpful.",
        "created_at": "2024-02-26T13:21:37.153000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Ah, you are talking about the communication channel between the wallet and the application.  Ultimately, the application is not/should not be trusted and the wallet should tell you what is being signed.  The fact that most wallets fail to do this effectively *is* a big problem, but the solution isn't to sign the communication channel between application and wallet, but rather to make it so the application doesn't need to be trusted at all.",
        "created_at": "2024-02-26T13:50:54.963000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "An example of this is website + browser.  The browser goes to great lengths to ensure that even if you go to a malicious website, they can't do anything particularly bad.  Wallets should be doing the same thing.",
        "created_at": "2024-02-26T13:51:33.405000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "As for dealing with MitM attacks and similar, JSON-RPC can be done over an communication channel, which includes encrypted channels like TLS, which I think is the right place for encryption/authentication of the channel itself to be.",
        "created_at": "2024-02-26T13:52:27.203000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "The way that the EVM ecosystem evolved is that applications expect wallets to provide them with an API that is compatible with the JSON-RPC definition. We are not talking just about enduser oriented dapps, bit also for production execution developer tools, \"wallet\" that is more of a complete blockchain access layer a lot of times. That layer handles both sending (including signing) and getting data from the blockchain.",
        "created_at": "2024-02-26T14:06:50.728000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "of course the wallet has additional security elements in it - where it will not sign every message, but an important thing a wallet needs to check is that the request received is legit and provided by the expected user.",
        "created_at": "2024-02-26T14:08:09.045000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "The initiator of the transaction is not necessarily going to be the signer... there might be differentiation there, but we want both initiator and signer security constraints for \"defense in depth\".",
        "created_at": "2024-02-26T14:10:13.541000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "The wallet should never assume that a request is legitimate.  There are a lot of scam apps out there and assuming legitimacy will lead to even more fund losses than we currently see.",
        "created_at": "2024-02-26T15:03:46.014000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "exactly... so you need some level of authentication involved...",
        "created_at": "2024-02-26T15:04:47.691000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Even if you use something like TLS or any other mechanism for signing over a request, you still cannot trust the source because anyone can make up a private key or have one registered with a certificate authority and then sign a request.",
        "created_at": "2024-02-26T15:04:54.444000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "What do you mean \"make up a private key\"? in this situation the private key is not on the client side - it's on the \"server/node side\"...",
        "created_at": "2024-02-26T15:15:07.115000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Application makes a request to a wallet to send a transaction.  Even if the application somehow authenticated/signed/certified the request, the wallet still cannot trust it anymore than if it did not.  The application is unknown to the wallet in advance.",
        "created_at": "2024-02-26T15:19:14.768000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "There is no existing trust relationship that a signature over the JSON-RPC payload would resolve.",
        "created_at": "2024-02-26T15:19:33.643000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "I'm referring to a different use case, when there is pre-existing trust.",
        "created_at": "2024-02-26T15:56:22.465000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Then it isn't the standard JSON-RPC over `window.ethereum` or JSON-RPC over HTTP to an Ethereum client and you can use a communication channel that is encrypted/signed.",
        "created_at": "2024-02-26T16:02:21.047000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "For example, you can do JSON-RPC over HTTPS, which would give you TLS and you could use a pre-shared certificate.",
        "created_at": "2024-02-26T16:02:39.666000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "Or you could do JSON-RPC over HTTP(S) with an authorization header containing a pre-shared key or signed identifier.",
        "created_at": "2024-02-26T16:03:04.570000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "This is all to say, if you have some trusted connection, you can use whatever communication channel you want, there is no need to standardize it.  All of the current broadly used JSON-RPC communication in Ethereum is untrusted (no established relationship).",
        "created_at": "2024-02-26T16:03:46.056000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "The Consensus client and Execution client communicate in a trusted way, but they use a pre-shared key and do REST over HTTPS I believe (someone can correct me here), but that is unrelated to the client JSON-RPC API.",
        "created_at": "2024-02-26T16:04:21.849000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "agree with you that I *could* use an authentication layer on top of this connection in this case and the standard that evolved over time is using a simple API token header or no authentication at all.\n\nAnd the problem I am trying to solve is how can we get the ecosystem to support options that are more secure when it's not about a single relationships, but the entire ecosystem needs to adopt a new \"standard\" of authentication.\nAlthuogh the usecase is trusted, it does not mean we control both sides of the interaction... and the client side is using the existing \"unofficial standard\" of no authentication or API token header only.",
        "created_at": "2024-02-26T16:10:37.851000+00:00",
        "attachments": null
    },
    {
        "author": "arik_g",
        "category": "Execution Layer",
        "parent": "",
        "content": "That is why I thought as standard could be useful - cause it would be a way to align multiple ecosystem actors towards an accepted way of doing the authentication in the trusted secure use cases",
        "created_at": "2024-02-26T16:11:50.567000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution Layer",
        "parent": "",
        "content": "It may help if you can give more specifics on what you are trying to achieve.  All of the situations I'm familiar with where the JSON-RPC is used are either untrusted (explicitly so), or they are already over secure communication channels.",
        "created_at": "2024-02-26T16:20:42.563000+00:00",
        "attachments": null
    }
]