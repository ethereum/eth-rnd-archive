[
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Makes sense; I think it should be okay if we decompress within the guest program rather than compress. So the compression is done by the builder only and they can use whichever version they want given the compression format itself is stable\n\nCompressing within the guest program would likely mean that we would need to pin a library and version though",
    "created_at": "2026-02-02T13:55:23.076000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Encode also includes the packing, so if we are packing more bytes it contributes to the overhead",
    "created_at": "2026-02-02T13:56:04.334000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "In a systems language like Rust, I think the packing would negligible though",
    "created_at": "2026-02-02T13:56:23.129000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yep that would be the idea but then how do you determine what the compressed size of each tx is?",
    "created_at": "2026-02-02T13:56:29.921000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ideally transactions should pay for compressed number of bytes their tx consumes",
    "created_at": "2026-02-02T13:57:03.803000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "maybe simpler to just pay for uncompressed number of bytes however",
    "created_at": "2026-02-02T13:57:25.617000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "In the current EIP, I think transactions don't pay for the payload blobs -- if we added that then I think it would require some changes",
    "created_at": "2026-02-02T14:04:32.685000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think it will be needed to make the transaction inclusion process fair",
    "created_at": "2026-02-02T14:05:05.953000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "otherwise the economics of type 3 / non-type 3 are assymetrical",
    "created_at": "2026-02-02T14:05:24.207000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "that's essentially only charging type 3 transactions for blob resource consumption and letting non type-3 transactions get it for free",
    "created_at": "2026-02-02T14:07:29.634000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "sorry was in a call",
    "created_at": "2026-02-02T14:49:52.180000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yep I agree (noted in the PR), I think it would be good to get RIG's opinion on this because the non type-3 transactions are payload blobs which are produced by the builder",
    "created_at": "2026-02-02T14:50:45.084000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "> RLP gave us slightly better results than SSZ, but this shouldn't be a stopper for SSZ adoption, if any.\nThis is RLP of the transaction list to be clear and not of the transaction. It likely does not make a significant difference in this case\n\n> Although it is rare, bitpack_254 led us to smaller blobs than naive_31. bitpack_254 took nearly 6 times more for decoding, which is roughly 6 milliseconds per blob.\nThe slowdown is mainly because of python overallocating for bits -- I think it should be roughly the same. Yep, I think bitpack can be made readable, I was originally thinking of the more denser complicated strategy where the packing is made based on the modulus\n\n> With current gas limit (60M), there are 1-2 payload blobs per block, and current target blob is 14. Let's see how this changes by the time BiB could be shipped.\nIsn't it roughly linear?\n\n> I've noticed that the data used is execution_payload not transactions, but it shouldn't matter much.\nCan you say where this was?",
    "created_at": "2026-02-02T14:56:42.813000+00:00",
    "attachments": []
  }
]