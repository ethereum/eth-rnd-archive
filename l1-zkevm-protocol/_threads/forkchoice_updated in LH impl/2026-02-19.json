[
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "",
    "created_at": "2026-02-19T13:30:56.788000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "<@402080271563751435>  moving conversation here as github UI is bad\n\nReference here: https://github.com/eth-act/lighthouse/pull/16/changes#r2827892388",
    "created_at": "2026-02-19T13:30:58.114000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Agreed ðŸ˜…",
    "created_at": "2026-02-19T13:31:36.397000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Shall we resume forkchoice discussion here?",
    "created_at": "2026-02-19T13:31:51.356000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yes please ser",
    "created_at": "2026-02-19T13:33:43.785000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Maybe if we start from the top, re what problem it is solving",
    "created_at": "2026-02-19T13:33:54.732000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "The problem it solves the assertion that the execution block hashes in the fork choice state form a valid chain.",
    "created_at": "2026-02-19T13:35:40.166000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "To clarify this is not to be confused with the chain of CL block roots",
    "created_at": "2026-02-19T13:35:59.953000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Why can't we get this from the beacon block, ie the chain of beacon blocks implicitly form a chain of EL blocks no?",
    "created_at": "2026-02-19T13:36:45.340000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yes if you add a check for execution block ancestry but specs don't have this",
    "created_at": "2026-02-19T13:37:09.794000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Is the tradeoff between the two solutions:\n\n- Add check for execution block ancestry\n- Add fork choice related logic into state component\n\n?",
    "created_at": "2026-02-19T13:38:24.893000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think the tradeoff is that if you add the check somewhere else then the spec could diverge and require hardfork.",
    "created_at": "2026-02-19T13:39:26.974000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I'm not certain of this but there may be test case failures and other unkown issues that arrise if we do this check upfront or soemwhere else.",
    "created_at": "2026-02-19T13:40:09.656000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah right, I am under the assumption that this would need to be specced somewhere since it decides on the validity of a block",
    "created_at": "2026-02-19T13:40:59.346000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think it's optimal to perform the check early, i.e., during the initial block gossip verification step. My concern is that this diverges from what is currently in place and therefore has ramifications for downstream tests, interop tests and other things.",
    "created_at": "2026-02-19T13:42:01.423000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Also to be clear when we say ancestry checks, we mean: currently the EL (stateful) checks that the EL chain forms a valid and continuous chain of blocks -- and with the zk attester, this logic needs to go somewhere",
    "created_at": "2026-02-19T13:42:15.237000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yep",
    "created_at": "2026-02-19T13:42:45.711000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ideally, the full test framework should pass irrespective of whether you have an EL or a PE activated.",
    "created_at": "2026-02-19T13:48:26.787000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "If we migrate the responsibilities of forkchoice assertions now, this may not hold true.",
    "created_at": "2026-02-19T13:48:55.490000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "This may not be practical in some cases because with proofs (in their current form) we can't assert that a payload is invalid in every case.",
    "created_at": "2026-02-19T13:51:40.694000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Can you elaborate?",
    "created_at": "2026-02-19T13:52:34.721000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So maybe some test cases require knowing that a specific block is invalid. Proofs only tell you if a block is valid but absence of a proof does not mean the block is invalid, it just means we don't know if its valid or not.",
    "created_at": "2026-02-19T13:53:25.524000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "In the current protocol we only have proofs of validity but not proofs of invalidity",
    "created_at": "2026-02-19T13:54:12.932000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "This would be the case where we get a beacon block with an execution payload that is invalid?",
    "created_at": "2026-02-19T13:55:12.831000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yep",
    "created_at": "2026-02-19T13:55:29.001000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So I think we have the following options:\n- Do the execution block hash ancestry check during block import (this is a divergence from the spec)\n- Do the execution block hash ancestry check in the fork choice store (this requires modification of the CL forkchoice store)\n- Do the execution block hash ancestry check in the proof engine, which aligns with the current spec.",
    "created_at": "2026-02-19T13:58:17.543000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I haven't looked at the new gloas changes from LH, but I think the check would go before block import, ie where we do the da checks",
    "created_at": "2026-02-19T14:00:11.168000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "> Do the execution block hash ancestry check in the proof engine, which aligns with the current spec.\nThe option I was thinking of above would be to have the CL expose a list of EL block hashes and have the proof engine use that? \n\nThe difference I'm thinking of here is that the proof engine doesn't know about forking, it just gets a list of EL block hashes that the CL says forms a valid EL chain",
    "created_at": "2026-02-19T14:04:07.808000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "could you elaborate",
    "created_at": "2026-02-19T14:05:30.632000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "The CL currently has lets say `Vec<BeaconBlock>` so a  list of beacon blocks that form a chain. From this we could derive `Vec<ELBlockHash>` since every beacon block corresponds to an EL block.\n\nIf a proof is missing for an execution payload, then the CL wouldn't add the corresponding beacon block to its list",
    "created_at": "2026-02-19T14:08:23.885000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "How is that list used in practice?",
    "created_at": "2026-02-19T14:09:47.573000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "When verifying a proof, since we want to extend the head, we take the latest EL blockh hash and use that as a public input to verify a proof for example",
    "created_at": "2026-02-19T14:11:57.297000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Or maybe I misunderstand your question",
    "created_at": "2026-02-19T14:12:05.725000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "so on a high level you mean replacing the `State` object in the proof engine with some interface on the CL forkchoice store?",
    "created_at": "2026-02-19T14:13:39.745000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yeah exactly, so logic related to head/safe/finalized block stays within the CL",
    "created_at": "2026-02-19T14:14:18.418000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think it could be done but it will be more invasive I think",
    "created_at": "2026-02-19T14:14:48.257000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah maybe it was my internet, I wrote a Rust example and it disappeared",
    "created_at": "2026-02-19T14:14:56.664000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Wouldnâ€™t the interface just be a method that exposes a list of el block hashes?",
    "created_at": "2026-02-19T14:17:32.665000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I'm not entirely sure. I would need to give it more thought.",
    "created_at": "2026-02-19T14:18:43.569000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I definitely think we can optimise and reduce redundancy in the implementation, but for simplicity and isolation, I think it's ok for now.  If possible, it would be great if you could write up some pseudocode in a GitHub issue, and then we can evaluate it with a pseudo-implementation. In the mean time I will proceed with the network sync stuff and then we can loop back to this.",
    "created_at": "2026-02-19T14:20:54.506000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But on a high level I agree there is likely to be a number of optimisations and simplications we can make by leveraging beacon chain fork choice store.",
    "created_at": "2026-02-19T14:22:00.226000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Agreed â€” the reason I pointed this part out in particular is because I think for forking related logic we ideally donâ€™t want to duplicate",
    "created_at": "2026-02-19T14:28:02.910000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah I donâ€™t think itâ€™s a P0 since PR is still draft, though I also donâ€™t think itâ€™s simpler ðŸ˜… unless Iâ€™m missing something re what needs to be exposed",
    "created_at": "2026-02-19T14:30:14.411000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I guess what I mean by \"simpler\" is that everything we need to reason about or modify is within a single, isolated context that we \"own\", with no external dependencies (i.e., the beacon chain fork choice store) and no changes to any pre-existing interfaces.",
    "created_at": "2026-02-19T14:34:20.752000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But I do also see the argument that there is redundancy here",
    "created_at": "2026-02-19T14:35:38.284000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think having some concrete pseudo code will help evaluate the feasibility, and if we can fulfil all requirements using the beacon chain FCS.",
    "created_at": "2026-02-19T14:36:19.201000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "~~Just looked at this, and it looks like the Beacon fork choice store doesn't hold any execution block hashes~~ <@427491045308235776> edit: it does in the ExecutionStatus type",
    "created_at": "2026-02-19T14:57:41.569000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Iâ€™ve looked into this a little more. I think the change is practical. I will impl following networking initial impl completion.",
    "created_at": "2026-02-19T15:52:46.574000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Did you find any additional downsides to doing it from your first cursory look?",
    "created_at": "2026-02-19T16:00:46.999000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "For the initial implementation, I'm trying to keep all code paths and types isolated as much as possible. The initial implementation is not focused on optimality but more on so on building something functional, isolated and aligned with pre-existing interfaces. The idea is that when we have something functional, we can proceed with optimisation. There are still some open questions about making the forkchoice store work but I think we can probably address/resolve them when doing the impl.",
    "created_at": "2026-02-19T17:15:48.061000+00:00",
    "attachments": []
  }
]