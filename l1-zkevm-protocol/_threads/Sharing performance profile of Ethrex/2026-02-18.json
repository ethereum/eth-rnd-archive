[
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "",
    "created_at": "2026-02-18T13:28:15.804000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "cc <@402080271563751435> i think you were interested in this\ncc <@281967554572976128>, this can guide internal optimization efforts \nshared also with matthias from reth (not sure about his discord handle)",
    "created_at": "2026-02-18T13:28:16.855000+00:00",
    "attachments": []
  },
  {
    "author": "ivanlitteri",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Hey! Thanks Ignacio, I'll take a look at it",
    "created_at": "2026-02-18T13:32:55.650000+00:00",
    "attachments": []
  },
  {
    "author": "ivanlitteri",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Interesting to see the rkyv vs bincode numbers, I'd have expected the opposite result",
    "created_at": "2026-02-18T13:39:25.150000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yes, was also a suprise to me. Though be mindful that I think your current way of sending inputs don't send the `Vec<Bytes>` of mpt nodes, but you do some other construction where you serialize an \"in memory trie\" and send that serialized... so can be coming from that transformation. (Reth receives the Vec<Bytes>)",
    "created_at": "2026-02-18T13:43:09.781000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Said differently, your raw bytes input is probably bigger and more complex that can offset potential inherent rkyv benefits",
    "created_at": "2026-02-18T13:44:06.404000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Can be a tradeoff of bigger cost in read input, but saving time after when validating the trie (prob would benefit for further digging)",
    "created_at": "2026-02-18T13:45:29.701000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Super insightful, nice work! Can you add more context on \"AIR-cost analyzer\". How are costs computed in `ziskemu`? Is it some combination of rows * chip constraint degree or?",
    "created_at": "2026-02-18T13:45:55.547000+00:00",
    "attachments": []
  },
  {
    "author": "ivanlitteri",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "You're right about that, now that I remember, at that time the trade off was worth spending more cycles in the deserialization",
    "created_at": "2026-02-18T13:45:55.828000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I asked zkronos from Zisk about this since he is the one that worked on this feature. He told me is about \"cell values\" only and doesn't consider constraints since that's what they found correlates better to proving times for them. He also told me that he are continue to refine that \"cost\" to potenially involve other things like internal \"plannings\" done in their proving system.\nI would see this \"cost\" metric they use as something potenially \"unstable\" in its definition for a while and just getting refined to be more and more representative of proving times.\n\nIf you want to see tha \"raw\" output of ziskemu for this, you can see this https://gist.githubusercontent.com/jsign/6744700e1bf423604cf03ab6e80eb3ae/raw/fc32cc0861e2e928ddc5c74fb2e4952019822c8f/block_23326233.txt (a bit old ish, but today looks mostly the same). Can give more detail at RISCV level, methods, etc.",
    "created_at": "2026-02-18T13:49:41.197000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "While this \"cost\" is only meaningful for Zisk, I think can prob be a good general guide for guests optimizations.\nI think ideally we would like other zkVMs to also have a similar \"cost\" tooling that isn't cycles.",
    "created_at": "2026-02-18T13:51:40.083000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "The part I like hte most is that you only have to do \"execution\" of hte guest program, and not prove which is quite slow. So allows for quicker experimentation",
    "created_at": "2026-02-18T13:52:02.463000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah thats very useful. How quick is a run on a single block?",
    "created_at": "2026-02-18T13:52:52.282000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I suppose we can also reduce the benchmark scope to be exclusively a section of code that we are trying to optimise at that point in time, as well, right?",
    "created_at": "2026-02-18T13:53:41.765000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "<5s  in a normalish cpu(although ideally should be <1s in a production prover setup, since executing the block in riscv is part of proving time ha)",
    "created_at": "2026-02-18T13:53:50.300000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I would assume the `ziskemu` analysis adds some overhead compared to just pure execution or is the overhead mininal?",
    "created_at": "2026-02-18T13:54:38.303000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "As far as I know the overhead is minimal, since the way this is implemented is only adding one single RISCV instruction to put markers to define guest program scopes. So when they do the riscv execution, they just use it to after count AIR tables spans.",
    "created_at": "2026-02-18T13:56:42.581000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "They use this internally in their team to guide all their optimizations, so prob is the best tool available and they have a high motivation to make it the best possible.",
    "created_at": "2026-02-18T13:57:30.064000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Right, I see this makes a lot of sense. Following up on my question above, does this only count rows / cells in the main table?",
    "created_at": "2026-02-18T13:58:36.709000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "AFAIK, yes.",
    "created_at": "2026-02-18T13:58:55.300000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But as mentioned, the zisk team told me they will keep evolving the \"cost\" to include other parts of the proving system to refine the metric",
    "created_at": "2026-02-18T13:59:28.039000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Is it possible that this will skew results?",
    "created_at": "2026-02-18T13:59:35.393000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "For example if there is a keccak chip we may not get visibility of that?",
    "created_at": "2026-02-18T13:59:57.834000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah no, they consider the main table, but also all precompiles tables and memory costs",
    "created_at": "2026-02-18T14:00:20.480000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So it has a fair representation of precompiles too.",
    "created_at": "2026-02-18T14:00:33.153000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "ahh nice!",
    "created_at": "2026-02-18T14:00:40.198000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "In that raw output i shared above you can see this:\n```\nREPORT                              \n------------------------------------\nSTEPS                    214,070,839\n\nCOST DISTRIBUTION               COST       %\n--------------------------------------------\nBASE                     293,601,280   1.14%\nMAIN                  14,556,817,052  56.49%\nOPCODES                3,375,402,776  13.10%\nPRECOMPILES            5,780,354,908  22.43%\nMEMORY                 1,762,099,785   6.84%\n```",
    "created_at": "2026-02-18T14:01:02.489000+00:00",
    "attachments": []
  },
  {
    "author": "taulepton_",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Very insightful and looks to be a useful tool in guest optimisation. I will dive deeper over the coming days.",
    "created_at": "2026-02-18T14:01:53.454000+00:00",
    "attachments": []
  }
]