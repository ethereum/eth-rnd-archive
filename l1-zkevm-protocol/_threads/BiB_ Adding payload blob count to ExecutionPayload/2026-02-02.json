[
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "",
    "created_at": "2026-02-02T21:33:40.458000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "<@774033563732541451> github UX is killing me üòÑ",
    "created_at": "2026-02-02T21:33:41.092000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "on this last comment: https://github.com/ethereum/EIPs/pull/11212#discussion_r2756186243",
    "created_at": "2026-02-02T21:34:05.072000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Why would ‚Å®`payload_kzg_commitments`‚Å© be a public input?",
    "created_at": "2026-02-02T21:34:31.240000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "In the current design, ‚Å®`payload_kzg_commitments`‚Å© and ‚Å®`payload_kzg_proofs`‚Å©  are used to link the ‚Å®`ExecutionPayload`‚Å© to ‚Å®`payload_kzg_commitments`‚Å©\n\nThen we show that the first ‚Å®`payload_blob_count`‚Å© version hashes link to ‚Å®`payload_kzg_commitments`‚Å©\n\nImplying that the the first ‚Å®`payload_blob_count`‚Å© version hashes link to the payload blobs",
    "created_at": "2026-02-02T21:38:43.347000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "<@427491045308235776> , copying reply üòÖ :\n> Wouldn't be needed by the CL to connect the proof used kzg commitments of payload with whatever was DASed?\n> \n> Mainly the same reason why type-3 verisoned hashes are public input since they're part of NewPayloadRequest (which is what we defined as public input) i.e. check that what was DASed is really what hte block asserted as used blobs.",
    "created_at": "2026-02-02T21:40:08.971000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "LMK if makes sense",
    "created_at": "2026-02-02T21:40:43.896000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Does this imply that ‚Å®‚Å®`NewPayloadRequest`‚Å©‚Å© has the kzg commitments for all blobs (including type-3)?",
    "created_at": "2026-02-02T21:41:24.780000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "`NewPayloadRequest` already has the hashed kzg commitments for type3 txs.",
    "created_at": "2026-02-02T21:42:33.254000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "From my perspective should also have the ones for payload",
    "created_at": "2026-02-02T21:42:40.299000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "If not, how would hte CL know which kzg commitments were validated in the proof?",
    "created_at": "2026-02-02T21:42:50+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yep exactly",
    "created_at": "2026-02-02T21:42:55.448000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So the ‚Å®`expected_versioned_hashes`‚Å© includes the payload blobs",
    "created_at": "2026-02-02T21:43:23.230000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But I don't see why the ‚Å®`payload_kzg_commitments`‚Å© also needs to be a public input too",
    "created_at": "2026-02-02T21:43:41.753000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "From the CLs perspective, they would not be any different than normal blobs",
    "created_at": "2026-02-02T21:44:20.543000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Sorry, i think i missed this line `    expected_blob_versioned_hashes: List[VersionedHash], # public input`",
    "created_at": "2026-02-02T21:45:32.028000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think i originally read it as the already existing versioned hashes from type3 txs",
    "created_at": "2026-02-02T21:45:46.656000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ahh right",
    "created_at": "2026-02-02T21:45:58.445000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So that includes type3 and payload versioned hashes, no?",
    "created_at": "2026-02-02T21:46:07.601000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yeah exactly",
    "created_at": "2026-02-02T21:46:14.183000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "`    assert expected_blob_versioned_hashes[:n] == payload_versioned_hashes`\nmakes sense.\n\nAlthough this code feels weirdish that i don't see where the [n:] existing checks are",
    "created_at": "2026-02-02T21:47:29.833000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "but maybe that is somewhat implicit that that still exist before the `    return execute_payload(payload)`",
    "created_at": "2026-02-02T21:47:48.490000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah right, yeah I was being lazy and didn't want to add in all of the previous checks before BiB, I think a comment can be added to say \"we are extending newPayload and the existing checks apply\"",
    "created_at": "2026-02-02T21:48:42.454000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Sounds good!",
    "created_at": "2026-02-02T21:48:57.417000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah this would still mean that we would need a parameter to distinguish which of the ‚Å®`payload_blob_count`‚Å© are for the payload blobs -- which can be done by adding it into ExecutionPayload or as something else",
    "created_at": "2026-02-02T21:49:49.443000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "> which of the ‚Å®payload_blob_count‚Å© are for the payload blobs\ngot a bit lost there",
    "created_at": "2026-02-02T21:50:39.984000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah in the case where we verify a proof and I know that these 10 version hashes correspond to the blob",
    "created_at": "2026-02-02T21:51:22.690000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But then I want to fetch the ones that correspond to only the payload blobs",
    "created_at": "2026-02-02T21:51:39.849000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah you mean for data fetching reasons for reconstruciton",
    "created_at": "2026-02-02T21:52:07.175000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "For this, I would need to know the ‚Å®`payload_blob_count`‚Å© so I can say get the first 3 blobs",
    "created_at": "2026-02-02T21:52:09.783000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah, makes sense. From the guets program perspective you can avoid it since you have the private inputs as help. But as an external \"data fetcher\" needs, looks like you need it to know which one to pull",
    "created_at": "2026-02-02T21:52:38.924000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "but perhaps it can just be an extra parameter and then the ExecutionPayload would be left untouched",
    "created_at": "2026-02-02T21:53:35.518000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So maybe something only at the CL outside execution payload?",
    "created_at": "2026-02-02T21:54:00.646000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yeah exactly",
    "created_at": "2026-02-02T21:54:14.233000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "There would be a field in the EL block header, thats not in the ExecutionPayload, which I guess is fine",
    "created_at": "2026-02-02T21:54:22.527000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "To triple check: So this would mean the only \"change\"  is no new fields in the NewPayloadRequest but only including pyaload versioned hashes in the already existing `versoined_hashes` field as prefixes",
    "created_at": "2026-02-02T21:54:55.215000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "If we want to make ‚Å®`payload_blob_count`‚Å© public, I think we would need to put it either in ExecutionPayload or in NewPayloadRequest",
    "created_at": "2026-02-02T21:56:04.137000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Though apart from that, the CL is left untouched",
    "created_at": "2026-02-02T21:56:21.598000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "If it is in the EL block, it is already public (not in the sense of guets public input, but easily available)?",
    "created_at": "2026-02-02T21:56:48.123000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But yeah, maybe it is better to formally include it in the execution payload",
    "created_at": "2026-02-02T21:57:37.203000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah yeah that is true, so for blob retrieval, someone would need to fetch the corresponding EL block header to figure out the blob count",
    "created_at": "2026-02-02T21:58:05.619000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yeah",
    "created_at": "2026-02-02T21:58:14.466000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Technically since the proof proved the block_hash, it is indirectly commited",
    "created_at": "2026-02-02T21:58:56.630000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Right thats true, just thinking about the workflow for fetching the EL block header",
    "created_at": "2026-02-02T21:59:21.178000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But not sure if relyin on EL header for this is \"nice\" for CL layer",
    "created_at": "2026-02-02T21:59:23.016000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I would trust more a CL expert opinion on this front",
    "created_at": "2026-02-02T21:59:29.339000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Seems like it would be nicer if the CL knew, but payload retrieval would happen on the EL, since the EL knows how to convert those blobs back into the transactions",
    "created_at": "2026-02-02T22:00:48.667000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah, this data is basically EL related",
    "created_at": "2026-02-02T22:01:05.550000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Just thinking out loud:\n\nSo I think one of the questions is: Will the nodes that want to do payload blob retrieval already have a working EL p2p?\n\nIf so, then they should already have the EL block headers. \nIf they are zk-attesters though for example, then it becomes more convenient to have it in the ExecutionPayload, because they don't need an EL",
    "created_at": "2026-02-02T22:11:38.163000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "okay still thinking",
    "created_at": "2026-02-02T22:13:10.644000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Makes sense, to not rely on an EL RPC for the use case I guess",
    "created_at": "2026-02-02T22:16:01.751000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Just thinking about the usecase where you download BALs + proofs",
    "created_at": "2026-02-02T22:16:38.642000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Note that BALs are not related to payload blobs no?",
    "created_at": "2026-02-02T22:16:51.787000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "There was a comment in the EIP about whether they should go into payload blobs too -- I was thinking of the case where the BALs are not on lets say the ‚Å®`bals_topic`‚Å© on the CL, so you need to get it from blobs",
    "created_at": "2026-02-02T22:17:48.650000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Mmm",
    "created_at": "2026-02-02T22:19:55.687000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Wondering how including BALs in the payload blobs would be managed reg \"blob boundaries\" if we only want to pull BALs and not tx or viceversa",
    "created_at": "2026-02-02T22:20:36.335000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "maybe aren't part of the same payload blobs list",
    "created_at": "2026-02-02T22:20:50.416000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So in the case where the BALs is not on the fast path, the ‚Å®`bals_topic`‚Å© , I think the node would then need to download payload blobs and reconstruct, though as a side note, perhaps we want to be smart here since we may want the BAL and not the transaction",
    "created_at": "2026-02-02T22:20:55.695000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah haha yeah same concern üòÑ",
    "created_at": "2026-02-02T22:21:11.869000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "We could put the BALs first, if its less than a blob, then we download the BAL plus some of the payload data",
    "created_at": "2026-02-02T22:21:58.519000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "then have a header on the first blob that tells us how big the BAL is and how big the payload is",
    "created_at": "2026-02-02T22:22:21.827000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "so you would need to pull the first blob always, read the bal length, and from that derive the remaining blob count to pull for hte ocmplete BALs",
    "created_at": "2026-02-02T22:23:12.955000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yeah exactly -- though we need to pull the first blob always today because the first four bytes tells us how big the payload is",
    "created_at": "2026-02-02T22:23:52.878000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yeah but without BALs in payload blobs, you alreayd know how many blobs to pull withotu reading the first i.e. `payload_blob_count`",
    "created_at": "2026-02-02T22:24:27.247000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah yeah thats true",
    "created_at": "2026-02-02T22:25:13.862000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "we could also have `payload_bal_blob_count` as a helper but maybe is wasted 4 bytes ha",
    "created_at": "2026-02-02T22:25:31.505000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah üòÑ",
    "created_at": "2026-02-02T22:25:39.594000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think thats not so bad, so payload_bal_blob_count and then in the first blob we still need to know how many bytes is for the BAL and how many for the payload",
    "created_at": "2026-02-02T22:26:30.014000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Would BAL reconstruction via blob be a perf concern maybe for the hw setup of entities interested in them?",
    "created_at": "2026-02-02T22:26:46.660000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think ideally its the fallback case",
    "created_at": "2026-02-02T22:27:11.654000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "And only one person needs to do it and then seed the bals gossip topic",
    "created_at": "2026-02-02T22:27:32.759000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "<@774033563732541451> was thinking to maybe put it in NewPayloadRequest instead of in ExecutionPayload header, but ‚Å®`tree_hash_root`‚Å© seems to be hashing the payload?",
    "created_at": "2026-02-02T23:13:49.111000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "The public input we defined in EIP-8025 is the ‚Å®‚Å®`tree_hash_root`‚Å©‚Å© of ‚Å®‚Å®`NewPayloadRequest`‚Å©‚Å©, so that means indirectly ‚Å®‚Å®`ExecutionPayload`‚Å©‚Å© plus all the sidecar fields i.e. versioned_hashes, parent_beacon_root, requests.",
    "created_at": "2026-02-02T23:17:54.497000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "https://github.com/eth-act/ere-guests/blob/a629f4937379a67263070e28324d7ff65ea4c401/crates/stateless-validator-common/src/new_payload_request.rs#L240-L246",
    "created_at": "2026-02-02T23:19:09.877000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah was checking this out,  with ‚Å®`block_hash`‚Å© we can have a proof reveal ‚Å®`parent_block_hash`‚Å© and ‚Å®`child_block_hash`‚Å© then its possible to link the previous proof with the current proof via blockhashes -- How does this work with NewPayloadRequest.tree_hash_root again?",
    "created_at": "2026-02-02T23:21:19.533000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "ExecutionPayload has ‚Å®`block_hash`‚Å© as a field",
    "created_at": "2026-02-02T23:23:35.044000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "so you can still do that linking if you're interested",
    "created_at": "2026-02-02T23:23:44.715000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "The attester/verifier would need to download the ExecutionPayload?",
    "created_at": "2026-02-02T23:24:03.043000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah hmm I guess this NewPayloadRequest will change for mandatory proofs, since an attester won't have the ExecutionPayload",
    "created_at": "2026-02-02T23:24:46.096000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "‚Å®`hash_tree_root`‚Å© is the SSZ commitment, so you can prove internal fields with merkle proofs",
    "created_at": "2026-02-02T23:25:08.628000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah remember that ‚Å®`hash_tree_root`‚Å© of the ExecutionPayload is the same of the ExecutionPayloadHeader",
    "created_at": "2026-02-02T23:25:52.225000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah thats confusing üòÑ",
    "created_at": "2026-02-02T23:26:28.033000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "The ExecutionPayloadHeader for the transactions have the hash_tree_root of the tx list",
    "created_at": "2026-02-02T23:26:43.149000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "so ta the end of the day doing ‚Å®`hash_tree_root`‚Å© of the ExecutionPayload you can think about it as calculating the ExecutionPayloadHeader and then do hash_tree_root again",
    "created_at": "2026-02-02T23:27:04.254000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So its skipping transactions, logs_bloom and withdrawals?",
    "created_at": "2026-02-02T23:27:46.027000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Nop, for withdrawals is the same thinking as with txs",
    "created_at": "2026-02-02T23:28:54.641000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "logs bloom is an array of bytes tough so not a list",
    "created_at": "2026-02-02T23:29:01.101000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "",
    "created_at": "2026-02-02T23:29:36.002000+00:00",
    "attachments": [
      {
        "type": "image/webp",
        "origin_name": "image.png",
        "content": "0a3c2eae879f19709588e5320fdcc1458ad8fee9557d4a42b861f8acf268ef21"
      }
    ]
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "That ‚Å®‚Å®`Root`‚Å©‚Å© type used in fields is ‚Å®‚Å®`hash_tree_root`‚Å©‚Å© of the corresponding lists in the ExecutionPayload",
    "created_at": "2026-02-02T23:29:54.206000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "So it is basically a tree. \nIf you look it fro mthe ExecutionPayload perspective is a deeper tree -- but the \"Top tree\" is the ExecutionPayloadHeader angle of looking at it",
    "created_at": "2026-02-02T23:30:52.680000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "(hopefully i'm not confusing you more)",
    "created_at": "2026-02-02T23:31:05.325000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah right, its not skipping fields",
    "created_at": "2026-02-02T23:32:12.715000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "This is why ‚Å®‚Å®`hash_tree_root`‚Å©‚Å© calcl from the guest program perspective using ExecutionPayload as public input works for 8025, since the CL has the ExecutionPaylaodHeader",
    "created_at": "2026-02-02T23:32:16.434000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Since both are teh same, all is good for public input verification from the CL side",
    "created_at": "2026-02-02T23:32:33.147000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "The transaction list is tree_hash_root ed and it corresponds to the root in the header struct",
    "created_at": "2026-02-02T23:32:50.484000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Just to double check with you -- this won't be the case. The current strategy works fine for zkCL (mandatory proofs)",
    "created_at": "2026-02-02T23:34:40.775000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah exactly, since tree hash root converts:\n\n‚Å®```rust\nstruct NewPayloadRequest {\n  payload: ExecutionPayload\n}\n```‚Å©\n\ninto\n\n‚Å®```rust\nstruct NewPayloadRequest {\n  header: ExecutionPayloadHeader\n}\n```‚Å©\n\nThen into a single root",
    "created_at": "2026-02-02T23:37:07.635000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yep",
    "created_at": "2026-02-02T23:37:32.678000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think you would still need a proof for the block_hash no?",
    "created_at": "2026-02-02T23:37:48.430000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "You would need a merkel proof for the ‚Å®`block_hash`‚Å© field in the SSZ tree yes (with root = ‚Å®`hash_tree_root`‚Å© we discussed so far)",
    "created_at": "2026-02-02T23:38:30.116000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "yep, does that come with the proof?",
    "created_at": "2026-02-02T23:39:06.365000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Which proof?",
    "created_at": "2026-02-02T23:39:15.517000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "the zkVM proof",
    "created_at": "2026-02-02T23:39:21.615000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Nop",
    "created_at": "2026-02-02T23:39:24.567000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "When we had the ‚Å®`block_hash`‚Å© and ‚Å®`parent_hash`‚Å© as public inputs that was somewhat a lie too since we actually commited to sha256 of all public inputs or zkVM \"public input\" design reasons.",
    "created_at": "2026-02-02T23:40:09.722000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But I guess we could include it \"manually\" as part of the proof i.e. the preimage of the thing",
    "created_at": "2026-02-02T23:40:22.141000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "When I replied \"Nop\" i mean as part of the proof constructed by zkVM SDKs",
    "created_at": "2026-02-02T23:40:38.592000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I remember Vitalik mentioning would be useful to be sure the ExecutionPayloadHeader is part of the proof in the L1 (which I guess could be a wrapper of hte zkVM SDK one)",
    "created_at": "2026-02-02T23:41:18.466000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Maybe would be useful to define a bit better this in some spec?",
    "created_at": "2026-02-02T23:41:28.220000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "I think he was thinking for wallets or some use cases that could try to use the L1 proofs for other reasons",
    "created_at": "2026-02-02T23:42:13.085000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "The CL gets this \"preimage\" (i.e. NewPayloadRequestHeader) by its own means, but this might not apply so easily for other cases (which I think is what you're thinking of?)",
    "created_at": "2026-02-02T23:44:04.649000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah I was thinking of the CL currently, ie the flow for it to get the preimage without downloading the whole payload",
    "created_at": "2026-02-02T23:45:09.585000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Isn't the ExecutionPayloadHeader planned to be pulled from the network?",
    "created_at": "2026-02-02T23:45:27.503000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "In ePBS or something else?",
    "created_at": "2026-02-02T23:45:55.322000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "ePBS yes",
    "created_at": "2026-02-02T23:46:02.682000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah I think it is getting pulled, AFAICT it was being used for blind signing",
    "created_at": "2026-02-02T23:46:22.731000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Right for mevboost stuff",
    "created_at": "2026-02-02T23:46:54.047000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But I think it makes sense to add it back as a proper data structure instead of having a flat data structure",
    "created_at": "2026-02-02T23:47:01.036000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "On our original question, so it would be okay to add payload_blob_count into ExecutionPayload technically in the ExecutionPayloadHeader. Though it seems we may need to think a bit more about how this public input flow works with PayloadBid -- does that sound correct?",
    "created_at": "2026-02-02T23:48:59.682000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Not sure yet if as part of ExecutionPayload or at the same level of ‚Å®‚Å®`versioned_hashes`‚Å©‚Å© and other CL-related fields in ‚Å®‚Å®`NewPayloadRequest`‚Å©‚Å©",
    "created_at": "2026-02-02T23:50:10.783000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "But I don't think that changes much the conclusion",
    "created_at": "2026-02-02T23:50:18.933000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Yeah was just writing that since I think we want to have the preimage for NewPayloadRequest, not just ExecutionPayload",
    "created_at": "2026-02-02T23:50:45.684000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "> though it seems we may need to think a bit more about how this public input flow works with PayloadBid\nüëç",
    "created_at": "2026-02-02T23:50:47.837000+00:00",
    "attachments": []
  },
  {
    "author": "jsign",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "NewPayloadRequestHeader, no?",
    "created_at": "2026-02-02T23:51:13.145000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Ah yeah exactly",
    "created_at": "2026-02-02T23:51:31.289000+00:00",
    "attachments": []
  },
  {
    "author": "kevaundray",
    "category": "Cross-layer",
    "parent": "l1-zkevm-protocol",
    "content": "Still thinking üòÑ -- It seems like it may be better to have the ssz proof arrive with the zkVM proof or we get to scenario where we receive the zkVM proof and then need to fetch the ssz proof from another source.\n\nWe then get the invariant that if a proof verifies as true, we have enough information to decide whether it should extend the current chain or not",
    "created_at": "2026-02-02T23:59:42.894000+00:00",
    "attachments": []
  }
]