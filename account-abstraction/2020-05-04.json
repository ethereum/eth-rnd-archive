[
    {
        "author": "will7466",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "A discussion that we all had recently and worth posting in here:\nShould the gas limit for a transaction be defined by the \"gas\" field in the transaction or should it be a parameter passed in via the PAYGAS opcode - thereby being contract controlled.",
        "created_at": "2020-05-04T13:49:05.204000+00:00",
        "attachments": null
    },
    {
        "author": "will7466",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "There are good arguments in both directions. In favor of PAYGAS taking a limit:\n1. Since the contract has funds, there's a strong argument for it having control over the total gas limit, especially when there are Calls to other contracts.  It may be less than ideal to let the user set this value.",
        "created_at": "2020-05-04T13:51:07.419000+00:00",
        "attachments": null
    },
    {
        "author": "will7466",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Against PAYGAS taking a limit:\n1. The validation phase **could** calculate the gas price it is willing to accept based on gas left as a workaround.\n2. EVM does pass a gas limit with the various Call opcodes - solidity can just add this feature or contract developers can add this manually to their contracts to protect against external calls.\n3. Possibly simplifies implementation by just going with the existing transaction field.",
        "created_at": "2020-05-04T13:52:57.874000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e which is\n\u003e `0x3373ffffffffffffffffffffffffffffffffffffffff14601e57600080fd5b`\nI have updated the prefix to allow for incoming ETH transfers from non-`ENTRY_POINT` addresses:",
        "created_at": "2020-05-04T15:03:59.076000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "the new bytecode prefix is `0x337304d867459000b8371b7d88c2de900f6a4c074a001460245736601f57005b600080fd5b`",
        "created_at": "2020-05-04T15:04:18.817000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "visual disassembly",
        "created_at": "2020-05-04T15:05:00.293000+00:00",
        "attachments": [
            {
                "type": "",
                "origin_name": "Screenshot_2020-05-04_at_17.04.34.png",
                "content": "c86e9fcd4ae2b476e25957ccf8151147b11e9e90d3599355431efab44262c659"
            }
        ]
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Again with the understanding that for a final mainnet version the code would be optimized, e.g.\n\u003e Oh oh `PC NOT PUSH1 12 SHR` OK finally 5 bytes\n\u003c@!273808422753796097\u003e",
        "created_at": "2020-05-04T15:05:38.277000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e the new bytecode prefix is `0x337304d867459000b8371b7d88c2de900f6a4c074a001460245736601f57005b600080fd5b`\nFor now that also includes a check for empty calldata, not sure if we would want to keep that for a final version.",
        "created_at": "2020-05-04T15:06:57.124000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e https://hackmd.io/@KuiKHwIPT4e8_VWfnKLHvw/Byd91DvKI\nI have been thinking about these questions some more, it seems to me that splitting verification into a first pure part and a second state-dependent part would make a lot of sense. Clients could just cache the result of the pure part for pending mempool txs. It seems to me that for most applications the state-dependent part should be able to operate with a quite low gas limit, with demanding processing like verification of a ZKP pushed to the pure part.",
        "created_at": "2020-05-04T15:12:56.323000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "E.g. for Tornado Cash: verification of the ZKP as the pure part, checking that the nullifier has not yet been spent as the state-dependent part, which in essence is only a single mapping lookup.",
        "created_at": "2020-05-04T15:14:28.960000+00:00",
        "attachments": null
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e Again with the understanding that for a final mainnet version the code would be optimized, e.g.\n\u003e \u003c@!273808422753796097\u003e\n(sorry for the ping; new to discord, forgot to remove the mention from the quote)",
        "created_at": "2020-05-04T15:19:20.927000+00:00",
        "attachments": null
    }
]