[
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Any feedback from core devs or anyone else yet?",
        "created_at": "2020-09-22T11:05:44.174000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm still uncertain whether the complexity/risk of AA is worth it over Rich Transactions.",
        "created_at": "2020-09-22T14:17:24.037000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I do like the benefits (such as contract pays gas), even with the latest proposal I'm still concerned that there are a whole lot more risks with that (DoS vectors and whatnot that have to be accounted for) than with Rich Transactions (where gas and nonce are handled outside the rich transaction).",
        "created_at": "2020-09-22T14:18:51.394000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't have anything concrete though, just FUD, so it is reasonable to ignore my fears.",
        "created_at": "2020-09-22T14:19:11.351000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Is there any reason to not just ban CREATE from AA?  I feel like the multi-increment nonces causes problems and we don't really gain anything from CREATE vs CREATE2 that I know of.  If you really want CREATE semantics you can have an internal nonce storage variable.",
        "created_at": "2020-09-22T15:05:53.007000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Would be nice to get more rationale about why nonce are still enshrined.  What is it about clients today that makes it a challenge to move the nonces into the AA call?",
        "created_at": "2020-09-22T15:06:43.113000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I suppose it makes transaction replacement a *little* easier, but you still have to execute up to paygas to determine which transaction pays more so it is of minimal benefit I think.",
        "created_at": "2020-09-22T15:08:42.949000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The difficult part about moving the nonce into the AA calldata is then it would be possible for the AA contract to accept a non-unique transaction (creating a duplicate tx hash). This is a current invariant in the protocol that we wanted to uphold to avoid breakage in downstream infrastructure.",
        "created_at": "2020-09-22T15:09:55.019000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm not aware of a strong reason for allowing `CREATE` within an AA contract",
        "created_at": "2020-09-22T15:12:16.861000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e I know something you've been interested in is finding ways to stop including reverted \"noop\" txs within blocks. Do you feel like AA helps on that front?",
        "created_at": "2020-09-22T15:20:53.252000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Not with the current restrictions on not being able to access any external contract state.",
        "created_at": "2020-09-22T15:43:58.940000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "You can't even access timestamp, so can't do expiring transactions.",
        "created_at": "2020-09-22T15:45:51.349000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Also, since the client can't differentiate between \"always failing\" and \"transiently failing\", there is no way to have a transaction that becomes valid in the future.",
        "created_at": "2020-09-22T15:46:34.034000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hmm, a potential attack vector is to have a transaction that is valid initially, but then a change in the contract's storage from some other transaction causes the transaction to no longer be valid.",
        "created_at": "2020-09-22T15:47:42.139000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The only way to learn about this change in validity from valid to invalid is to re-run the transaction again up to paygas.  Are clients expected to constantly be re-running all transactions?",
        "created_at": "2020-09-22T15:48:27.946000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "```typescript\ncontract Apple {\n    bool flag;\n    owner;\n    function transact(uint8 v, bytes32 r, bytes32 s) {\n        // TODO: validate signature\n        require(flag);\n    }\n    function other() {\n        flag = !flag;\n    }\n}\n```",
        "created_at": "2020-09-22T15:50:39.299000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Does the AA contract's nonce only update when it is the tx.origin, or does it also update on internal calls?  If the latter, that means it introduces a DoS vector to have any externally accessible functions, which really limits usability.  If the former, that means then the above is possible because someone can internal-call `other` to flip the flag while an AA transaction to `transact` is pending.",
        "created_at": "2020-09-22T15:52:19.638000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The restrictions disallowing access to environment information like timestamp or block number feel like the illusion of security for the reasons \u003c@301186049323958275\u003e just mentioned. Are there other reasons for restricting use of these opcodes?",
        "created_at": "2020-09-22T17:02:39.378000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I *think* the idea is so we don't have to think about them for initial rollout.",
        "created_at": "2020-09-22T17:03:38.841000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think in theory we could actually get rid of SLOAD as well.  You can still do single/multisig, but it would require hard-coding the signers, which makes it significantly less useful.  Also, you couldn't do anything with social recovery or fallback recovery, etc.",
        "created_at": "2020-09-22T17:04:49.343000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The lack of access to timestamp does mean that my time-delay recoverable wallet can't be ported fully.  The recovery mechanism requires being able to access `timestamp`: \u003chttps://github.com/Zoltu/recoverable-wallet/blob/master/contracts/source/recoverable-wallet.sol#L225\u003e",
        "created_at": "2020-09-22T17:07:01.024000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The restriction on timestamp and block number is specifically to prevent the invalidation of a large number of pending transactions.",
        "created_at": "2020-09-22T18:06:30.520000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Right now we have the rough assurance that any transaction that is propagated will eventually have to pay gas, meaning an attacker has to actually pay _something_ to _someone_ to flood the network with transactions.\n\nWithout the environment restrictions (like `COINBASE`, external state, etc), an attacker can pay for a single transaction (or even no transaction) and flood the network with useless transactions.",
        "created_at": "2020-09-22T18:08:51.258000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That makes sense O(1) cost of invalidating with timestamp vs O(n) is a cost for SLOAD",
        "created_at": "2020-09-22T18:09:01.887000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e \n\n\u003e Hmm, a potential attack vector is to have a transaction that is valid initially, but then a change in the contract's storage from some other transaction causes the transaction to no longer be valid.\n\nThat's the entire reason the EIP prohibits any external information from leaking into the validation logic (code before `PAYGAS`.) Once an EIP-2938 transaction is valid, it stays valid unless a transaction targetting the same AA contract arrives in a block.",
        "created_at": "2020-09-22T18:13:04.601000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e Also, since the client can't differentiate between \"always failing\" and \"transiently failing\", there is no way to have a transaction that becomes valid in the future.\n\nThis is true. Propagating invalid transactions seems like a denial of service vector.",
        "created_at": "2020-09-22T18:14:01.588000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e The only way to learn about this change in validity from valid to invalid is to re-run the transaction again up to paygas.  Are clients expected to constantly be re-running all transactions?\n\nNot in the single-tenant version (EIP-2938). If you have two pending transactions to the same AA contract, they'd both have the same nonce. If one of them is mined, the other becomes invalid because of the nonce change.",
        "created_at": "2020-09-22T18:17:02.335000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We're calling EIP-2938 single-tenant AA because the nonce and pending transaction rules really limit use cases to just smart contract wallets and other low traffic applications where you can be reasonably confidant the nonce won't change out from under you.",
        "created_at": "2020-09-22T18:18:44.934000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We do have a plan to expand EIP-2938 to support multi-tenant use cases like mixers and exchanges, which I'm writing a follow-up article about.",
        "created_at": "2020-09-22T18:20:27.305000+00:00",
        "attachments": []
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Just to clarify: There are two parts to EIP-2938: The consensus changes and the additional mempool restrictions. On the consensus level, AA transactions are pretty much as unrestricted as normal txs, can access external state, use environment opcodes and everything. The mempool restrictions are the ones preventing all of that.",
        "created_at": "2020-09-22T18:43:05.071000+00:00",
        "attachments": []
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e We put together an explainer for EIP-2938, before the ACD call tomorrow:\n\u003e \n\u003e https://hackmd.io/@SamWilsn/ryhxoGp4D\n\u003e \n\u003e Comments welcome!\nI think this explainer post does a good job talking about that difference",
        "created_at": "2020-09-22T18:43:40.569000+00:00",
        "attachments": []
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The nice thing about that is that you would not necessarily need further consensus changes to later on extend AA to multi-tenant use cases. You only need to adjust these mempool rules. The main mechanism is what we call AA prefixes, which determine what kinds of contracts a mempool accepts pending AA transactions for",
        "created_at": "2020-09-22T18:45:25.196000+00:00",
        "attachments": []
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e ```typescript\n\u003e contract Apple {\n\u003e     bool flag;\n\u003e     owner;\n\u003e     function transact(uint8 v, bytes32 r, bytes32 s) {\n\u003e         // TODO: validate signature\n\u003e         require(flag);\n\u003e     }\n\u003e     function other() {\n\u003e         flag = !flag;\n\u003e     }\n\u003e }\n\u003e ```\nso in the first version, mempools would simply not keep pending transactions to a contract like this, precisely because that would necessitate this constant re-validation.",
        "created_at": "2020-09-22T18:46:20.228000+00:00",
        "attachments": []
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "but later versions of AA will indeed make re-validation logic necessary. this is a solvable problem though, as you can basically make sure that triggering re-validation is costly (you only need to re-validate txs for a contract whose storage was touched in the latest block).",
        "created_at": "2020-09-22T18:48:12.012000+00:00",
        "attachments": []
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "the version of AA we implemented in geth was actually already capable of re-validations, so we have metrics on that. Will's ethresearch piece from a few weeks ago goes into quite a bit of detail on that:",
        "created_at": "2020-09-22T18:50:08.322000+00:00",
        "attachments": []
    },
    {
        "author": "ansgar.eth",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "https://ethresear.ch/t/dos-vectors-in-account-abstraction-aa-or-validation-generalization-a-case-study-in-geth/7937",
        "created_at": "2020-09-22T18:50:10.782000+00:00",
        "attachments": []
    }
]