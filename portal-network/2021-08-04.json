[
    {
        "author": "mike.ferris",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Piper has mentioned using WebRTC",
        "created_at": "2021-08-04T14:00:22.185000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's definitely a possibility, but WebRTC seems to be way harder to implement (at least in my experience)",
        "created_at": "2021-08-04T14:00:52.241000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "it's honestly a better choice since browsers only allow websocket clients and not servers so I would need for trin/fluffy/nodejs-Ultralight to run a websocket server for it to work",
        "created_at": "2021-08-04T14:01:43.971000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "but, i'm starting with that to see if it's even a possibility.  I'm working on building out a primitive websocket transport module for the JS/TS discv5 library and will see if I can get it up and running and get ultralight to at least do the discv5 handshake from the browser over a websocket",
        "created_at": "2021-08-04T14:02:40.479000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I believe one difficulty here is going to be the dichotomy between long-lived-connections and datagram/connectionless. My understanding of websockers and webrtc is that both are long lived connections and it may be awkward to map the discv5 protocol onto that since it wasn't designed for that purpose/context",
        "created_at": "2021-08-04T18:50:35.992000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "(I know very little about webrtc)",
        "created_at": "2021-08-04T18:52:00.816000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It's pretty similar as far as I can tell and implemented naively, I think you're exactly right that it's not a right fit.  What I'm contemplating is where the non browser nodes run a web socket server as one of their multiaddrs and then browser based clients would temporarily open sockets each time they want to send data.  It's not ideal but I don't see any other way around it.  It's also limiting because browser clients would only be able to connect to non-browser clients",
        "created_at": "2021-08-04T18:54:07.295000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "None of that is intended to discourage. I'm really curious to see what you find in this experiment",
        "created_at": "2021-08-04T18:54:17.066000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It's a pretty sub-optimal place to land but I think it's the only way that browser-based clients could interact with the portal network",
        "created_at": "2021-08-04T18:54:40.529000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "think of it as kind of an ultra-ultralight client ðŸ™‚",
        "created_at": "2021-08-04T18:54:58.979000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Webrtc allows for a broader range of options since it shows for browsers to cross connect to each other without middleman? But still suffers from needing to open/maintain new connections for every interaction?",
        "created_at": "2021-08-04T18:56:14.802000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "because if you think about it, browser based clients wouldn't be able to really store any data/state/history.  They'd be purely consumers of the network, so I dunno if we even want to do that, now that I think more about it",
        "created_at": "2021-08-04T18:56:17.772000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "What about localstorage?",
        "created_at": "2021-08-04T18:56:39.850000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "WebRTC is about long-lived connections and generally needs a signaling server in the middle to connect up individual browser clients",
        "created_at": "2021-08-04T18:56:54.666000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "but once they're connected, they are p2p",
        "created_at": "2021-08-04T18:57:18.415000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "it might work, it's kind of how libp2p has things today",
        "created_at": "2021-08-04T18:57:27.576000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Right, they may need help getting connected but it can be done with that assistance",
        "created_at": "2021-08-04T18:57:32.087000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah, i think the difference is WebRTC is still about long-lived connections (as far as I know).  You can't open/close them willy-nilly",
        "created_at": "2021-08-04T18:58:05.226000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "unless I've misunderstood the tech",
        "created_at": "2021-08-04T18:58:09.019000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I dunno, I'm just experimenting at this point but if it's not desirable to have a truly client only browser based node, then I won't chase it.  To your point, it's all dependent on long-lived connections in the browser so kind of antithetical to the whole proposed architecture",
        "created_at": "2021-08-04T18:59:29.211000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "and browser based nodes are going to be pretty ephemeral even by portal network standards so not useful participants in the overall sharing of data.  To your point, you could store stuff in localstorage but the node would have to have an open socket, either websocket or webRTC channel with another node to ever get requests",
        "created_at": "2021-08-04T19:00:43.072000+00:00",
        "attachments": null
    }
]