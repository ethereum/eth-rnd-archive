[
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I realized this week that there's an unsolved piece of functionality to be worked out for state network. Right now the proposed gossip mechanism will ensure that proofs for new and updated state will be distributed to the appropriate nodes at each block. What is missing is a mechanism to allow nodes storing untouched state to update their proofs to be valid against the new state root.",
        "created_at": "2021-08-13T16:28:59.460000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "going to open an issue in the stateless specs repo",
        "created_at": "2021-08-13T16:36:50.094000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "issue opened here: https://github.com/ethereum/stateless-ethereum-specs/issues/69",
        "created_at": "2021-08-13T17:08:38.489000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!472419717970133002\u003e taking a look at your preliminary spec here: https://hackmd.io/JDr8ffpqRQqZcSIoHvxM0Q\n\nIt looks like your plans for the Epoch tries are slightly different than I've been modeling in my head.  Here's my understanding of what you are proposing:\n\nSpecifically, you propose a \"rolling\" window of blocks for the epoch trie.  Supposing an epoch size of 4, my understanding is that the progression would look like this:\n\n- block 0:\n  - master: [root([0,])]\n  - epoch: [0,]\n- block 1:\n  - master: [root([0, 1])]\n  - epoch: [0, 1]\n- block 2:\n  - master: [root([0, 1, 2])]\n  - epoch: [0, 1, 2]\n- block 3:\n  - master: [root([0, 1, 2, 3])]\n  - epoch: [0, 1, 2, 3]\n- block 4:\n  - master: [root([0, 1, 2, 3]), root([1, 2, 3, 4])]\n  - epoch: [1, 2, 3, 4]\n\nIs this accurate?  If so, I believe it introduces a level of overhead that we may wish to avoid.  Specifically, the epoch accumulator will be constantly shifting the leftmost value out of the list and appending a new value to the end.  This will require the SSZ merkle trie to be completely rebuilt at each block.  If we assume epoch sizes of 2048, then at each block, a node will have to perform 2047 hashes to recompute the merkle root once the accumulator is full.\n\nThe alternate model is to not use a rolling window:\n\n- block 0:\n  - master: [root([0,])]\n  - epoch: [0,]\n- block 1:\n  - master: [root([0, 1])]\n  - epoch: [0, 1]\n- block 2:\n  - master: [root([0, 1, 2])]\n  - epoch: [0, 1, 2]\n- block 3:\n  - master: [root([0, 1, 2, 3])]\n  - epoch: [0, 1, 2, 3]\n- block 4:\n  - master: [root([0, 1, 2, 3]), root([4,])]\n  - epoch: [4,]\n\nUnder this model, the node only has to perform `log2(N)` hashes to recompute the merkle root of the accumulator at each block, which for an epoch size of 2048 is just 11 hashes.",
        "created_at": "2021-08-13T17:22:46.819000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "On the surface, eliminating the rolling window might look like it makes re-orgs harder, but I think in practice there's not really much added difficulty, since it's just a matter of keeping around the accumulator from the previous epoch until the \"finality\" window has passed (with finality meaning whatever number the client chooses as the maximum supported re-org size)",
        "created_at": "2021-08-13T17:25:28.248000+00:00",
        "attachments": null
    },
    {
        "author": "mike.ferris",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "did you type out those Ascii tries or do you have a tool that does that for you?",
        "created_at": "2021-08-13T19:03:21.612000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Manually drew them with some vim-fu",
        "created_at": "2021-08-13T19:50:48.524000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I really would love a simple tool for modeling simple merkle proof diagrams but just manually modifying one of those ascii diagrams is pretty low effort",
        "created_at": "2021-08-13T19:52:02.020000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "^ this would be really awesome",
        "created_at": "2021-08-13T19:57:42.601000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ASCII representation of hexary trie seems clumsy....  hard to fit so much into the space and still have it have any visually meaning\n\n```\n    0:  R\n        |\n    1:  0 1 2 3 4 5 6 7 8 9 a b c d e f\n        | | | | | | | | | | | | | | | |\n        | | | | | | | | | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | | | | | | | | | |\n        | | | | | | | | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | | | | | | | | |\n        | | | | | | | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | | | | | | | |\n        | | | | | | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | | | | | | |\n        | | | | | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | | | | | |\n        | | | | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | | | | |\n        | | | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | | | |\n        | | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | | |\n        | | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | | |\n        | | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | | |\n        | | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | | |\n        | | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | | |\n        | | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | | |\n        | | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        | |\n        | +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n        |\n        +--- 0 1 2 3 4 5 6 7 8 9 0 a b c d e f\n```",
        "created_at": "2021-08-13T20:40:13.047000+00:00",
        "attachments": null
    }
]