[
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think we need better numbers on expected proof sizes to be able to evaluate the POKE scenario so that we can know:\n\n- actual range of proof sizes\n- can they be divided up so that each message can be verified as they come in (assuming messages are in correct order)\n- how man UDP packets do we expect to need",
        "created_at": "2021-02-25T00:13:32.939000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Is making a decision on UDP vs. TCP POKEs actually necessary to make a choice between POKE vs. gossip?",
        "created_at": "2021-02-25T04:06:03.150000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I kinda feel like we can use TCP pokes if the proofs are too big for UDP, and use UDP otherwise.",
        "created_at": "2021-02-25T04:07:11.302000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think we are nearly guaranteed that proofs will be too big for UDP?",
        "created_at": "2021-02-25T04:12:46.726000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Sure, so we poke over TCP",
        "created_at": "2021-02-25T04:45:08.803000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Can you expand on this?  Would we have a new libp2p sub-protocol that's just for POKE?  Node-A wants to POKE Node-B.  Node-A initiates a handshake with Node-B, and once established, sends the POKE payload and then disconnects?",
        "created_at": "2021-02-25T14:28:08.724000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Also, worth looking at how bittorrent uses TCP and the UTP protocol as well which establishes streams over UDP.\n\n- https://www.bittorrent.org/beps/bep_0029.html\n- https://www.bittorrent.org/beps/bep_0003.html",
        "created_at": "2021-02-25T14:33:21.786000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I linked this stuff before having really read and ingested it.  We can't actually use either of these protocols.  They don't have any encryption, but we might be able to learn from uTP or Quic, both of which IIUC establish streams on top of UDP packets.  I guess doing it over UDP is just as griefable as doing it over TCP.  You could absolutely send 99% of the data stream over TCP and then close the connection which I think would be even more costly since it requires the receiver to open a whole new TCP connection and perform a handshake....",
        "created_at": "2021-02-25T14:46:57.516000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't know that much about libp2p specifically. I'd have to look into it. That is general idea I'm trying to suggest though.",
        "created_at": "2021-02-25T15:08:25.803000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Is making the receiver open a new TCP connection that bad?",
        "created_at": "2021-02-25T15:12:13.766000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In any case, I don't think there's much point discussing the transport layer for POKEs until we decide that they distribute cold state to the network they way we want.",
        "created_at": "2021-02-25T15:21:00.316000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think POKE does what we want.  We need three mechanisms and I think POKE handles one of them.\n\n1. New state makes it's way into the network via benevolent bridge nodes that push it into the network over a libp2p based gossip network (TBD on how that network topology is constructed, but likely something in the direction of the radius approach that has already been discussed)\n2. Missing/Lost cold state is patched up by benevolent bridge nodes.  This mechanism might be the exact same as how new state makes its way in over gossip.  The exact manner in which lost state is detected is TBD.\n3. A mechanism to allow nodes that join the network to acquire existing state held by other nodes that falls within their radius.\n    - POKE does this, but only for state that is actively being requested.\n    - It would be *nice* but maybe not 100% necessary for there to be a more generic \"discovery\" mechanism.",
        "created_at": "2021-02-25T15:47:43.246000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The purist in me is really grossed out by the complexity of doing multi-packed UDP, but I think it's better to prioritize forward movement towards a working network and improve the transport options for POKE messages later once the whole system is working.",
        "created_at": "2021-02-25T16:11:23.173000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think 2 \u0026 3 are actually the same thing, or at least could be implemented in the same way.\n\nHow does a benevolent bridge node know if state is lost? They don't, not really.\n\nSo either benevolent nodes:\n\n - Just _exist_ , are discoverable, and provide the state when requested, and POKEs spread that state around; or\n - Publish that cold state back into the network over time (gossip, or unsolicited POKEs?)",
        "created_at": "2021-02-25T17:49:18.764000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I just like that POKEs are never rebroadcast, so we don't need to worry about amplification attacks.",
        "created_at": "2021-02-25T17:50:28.026000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Probably worth a bit of exploration into the problem space of where the proofs come from for POKE.  It would be really nice if it was easy for nodes to more easily spread the data they are storing to their neighboring nodes.\n\nThis does map relatively cleanly onto the mental model I've got for gossip which is a 3-message combo of advertise/request/response.  A node on the network who's well connected to their peers *could* actively push the data they are storing out towards their closest peers but doing so will require acquisition of an inclusion proof against recent state.\n\nI can imagine a network where nodes continually scan through their locally stored data, building updated proofs by fetching the necessary nodes from the network.  Along the way they POKE things back along the search paths since they'll be doing regular lookups and will have acquired the necessary proof along the way.  Then they advertise those proofs out through the gossip network towards their most proximate nodes (who might pass the data onward if they deem it of interest).",
        "created_at": "2021-02-25T18:19:14.926000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "There's also something interesting about proofs going on here.  A *proof* is any collection of nodes that can be assembled into a valid merkle proof.  Each proof will contain some set of nodes `n1, n2, n3, ..., N`, but in theory, only one of those nodes is what is being \"proven\".  `N` is the node being proven.  `n1, n2, n3, ...` are the supporting nodes that prove it against the state root.  All of the supporting nodes are also \"proven\" so a proof for `N` is just as valid for proving any of `n1/n2/etc` so it's reasonable to assume proofs in the gossip network  might have some optimal size or construction that makes them maximally useful to the most nodes in the network (thus improving the efficiency of gossip in general).  Maybe there's an optimal proof size that balances bandwidth usage with packaging up as many nodes as possible to be shipped around the network.",
        "created_at": "2021-02-25T18:24:59.868000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Peers that request data still only need the node hash, right? Only the put \u0026 delete requests need the trie path?",
        "created_at": "2021-02-25T20:59:45.013000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "No, requests would need to know path since we need to define `content_id = hash(path + node_hash)` so that different nodes with the same hash map to different locations in the network (in order to remove de-duplication)",
        "created_at": "2021-02-25T21:00:58.093000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "anyone doing a GET should have the path.  Anyone doing a PUT/DELETE will be providing a proof alongside the payload (which means the path will be known)",
        "created_at": "2021-02-25T21:02:11.922000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Can't you define `content_id` to be `node_hash` or `hash(path + node_hash)`?",
        "created_at": "2021-02-25T21:02:16.344000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hm, no, I guess you can't",
        "created_at": "2021-02-25T21:02:49.440000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, everything needs to have it's own \"unique\" `content_id`, allowing lookups using either probably screws with garbage collection and with properly replicating nodes that have the same hash",
        "created_at": "2021-02-25T21:04:39.868000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If people started just looking things up with `node_hash` then the `(path, node_hash)` items wouldn't get replicated.",
        "created_at": "2021-02-25T21:05:14.183000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ah, bummer. So that means that you can't use the current `wit/0` to collect all the state for a block, at least without some accounting step in between, and some less parallelism near the root",
        "created_at": "2021-02-25T21:05:17.441000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think \u003c@!296630428754771968\u003e work on leveraging turbo-geth to do this is our most promising route.  In theory we could use `wit/0` but you'd need to re-assemble the data into a proof and then derive the paths.",
        "created_at": "2021-02-25T21:06:22.968000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Our hacky bridge infra probably looks something like TG as data provider, and something new on libp2p to implement gossip and push data into the gossip network that slurps the data out of TG",
        "created_at": "2021-02-25T21:07:21.761000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Talked with \u003c@!514629735339261993\u003e yesterday about prototyping the libp2p part for us",
        "created_at": "2021-02-25T21:07:42.765000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Right, I'm not talking about building the bridge. I'm saying if you have a particular recent block that you want to execute for some reason, can you use the meta-witness to pre-download all the state?",
        "created_at": "2021-02-25T21:08:07.427000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I'm not really arguing for being able to do hash-only lookups right now",
        "created_at": "2021-02-25T21:08:24.931000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think you can still use `wit/0`.  You'd request the state root node, which is at the null path.",
        "created_at": "2021-02-25T21:08:51.333000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Until/unless I come up with a common/valuable use case for executing full blocks (that aren't just for client devs :))",
        "created_at": "2021-02-25T21:08:54.732000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And then from there, you can build the path elements as you go.",
        "created_at": "2021-02-25T21:08:59.784000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "oh, right, you lose some amount of the paralellism (you just said this)",
        "created_at": "2021-02-25T21:09:11.122000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I was just daydreaming about using the state network to easily test some recent yolo network blocks as I tinker on py-evm",
        "created_at": "2021-02-25T21:09:43.979000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Still probably a high degree of concurrency that could be thrown at it, just bottlenecked on the first layer or two of the trie",
        "created_at": "2021-02-25T21:09:43.995000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Besides, I think `wit` for v\u003e0 will switch to addresses \u0026 slots, and be more compatible with the path approach. (Though we still need to do similar/reverse accounting for actually discovering the node hashes, then)",
        "created_at": "2021-02-25T21:12:38.351000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "We should look at focusing on what our first \"deliverable\" might be.  I'm only a day or two worth of work away from being able to spin up DDHT nodes with a very primitive implementation of the DHT, something that can store and serve data as a naive key/value store.  Seems like that could be worked on concurrently with the libp2p gossip implementation for data ingress...  Ideally we move away from DDHT towards something like `trin`  but it could be a starting point to bootstrap a simple testnetwork.",
        "created_at": "2021-02-25T21:13:42.673000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "adding an *ugly/minimal/dirty* version of POKE to the DHT would be relatively easy, but only worth doing if there's something actively requesting data from the network.",
        "created_at": "2021-02-25T21:14:33.345000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think very simple is the first: supporting `eth_getBalance`, (plus nonce, and other things that are trivial once you have the account leaf node)",
        "created_at": "2021-02-25T21:15:10.147000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "might be nice if we were able to structure the network so that it was healthy even if 80% of the DHT nodes weren't part of the gossip network.  Allow data to flow into the network through a subset of the nodes and then  something like POKE + \u003cother-mechanism-for-cold-state\u003e to allow existing data to spread out to new nodes as they join the network.",
        "created_at": "2021-02-25T21:16:00.964000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That would allow trin to skip the libp2p overhead and more loosely couple the two networks.",
        "created_at": "2021-02-25T21:17:11.452000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So supporrting `eth_getBalance`, we can ignore gossip, maybe use our own testnet to reduce total state size, or look at using gorlie or something if the state sizes are small enough...  spin up however many nodes we need for a redundancy factor of something like ~5-10x.... push all the data into the network....  \n\nAnd then start playing with it?  Measure latency?  Gain some understanding on how quickly you can bootstrap into the network?",
        "created_at": "2021-02-25T21:21:31.686000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e That would allow trin to skip the libp2p overhead and more loosely couple the two networks.\nAh, interesting",
        "created_at": "2021-02-25T21:22:08.271000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I don't have a clean solution though for how cold state can be actively/passively replicated.  The approach of having nodes build up a proof for their *cold* state and then POKE it to nodes may not scale well enough or may prove to be too much work to put on the individual nodes.... or it might be just the right mechanism",
        "created_at": "2021-02-25T21:23:43.368000+00:00",
        "attachments": null
    },
    {
        "author": "jason.carver",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e And then start playing with it?  Measure latency?  Gain some understanding on how quickly you can bootstrap into the network?\nYeah, I think it will have to be a bit of raw exploration. What's hard, what's slow? The number of requests needed in practice to collect a trie node, though with a different state size and network topology, those things can change dramatically, so I'm not sure how much empirical data helps us there.",
        "created_at": "2021-02-25T21:25:41.280000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, a 100 node network will result in most nodes having about 50% of the full network in their routing table.",
        "created_at": "2021-02-25T21:26:47.444000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That number needs to get pushed up into the 500-1000 range before I think you start seeing more realistic round trip times.  We *could* reduce the bucket size for the routing table down from 16 to something like 8 which improves the situation a bit...",
        "created_at": "2021-02-25T21:27:56.020000+00:00",
        "attachments": null
    },
    {
        "author": "__lithp__",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ahh, this is interesting! It sounds pretty useful to back py-evm with JSON-RPC calls, I think the RPCs I'm working on now would be enough to do it, thought they'd be slightly inefficient",
        "created_at": "2021-02-25T23:58:45.193000+00:00",
        "attachments": null
    }
]