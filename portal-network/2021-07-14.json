[
    {
        "author": "mike.ferris",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think our weekly status call can just be the general Portal Network meeting (Tuesdays at 11am EST), and then we can keep the Monday at 11am meeting for less formal work-together sessions if we want",
        "created_at": "2021-07-14T00:07:43.863000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I know I've mentioned this a couple of times but here's the repo for my typescript implementation of the portal client so far - https://github.com/acolytec3/ultralight",
        "created_at": "2021-07-14T01:52:54.337000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "How's the implementation been going so far?",
        "created_at": "2021-07-14T02:39:00.632000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Early days right now. At this point, I've really just proved that the chainsafe discv5 implementation in typescript can talk to the equivalent in Nim and Python. Next step for me is to try and do some work in the lower levels of their code to enable the TALKREQ message type and then start wrapping my mind around the specifics of the current state of our spec. I suspect it'll be slow going for a bit",
        "created_at": "2021-07-14T09:46:06.638000+00:00",
        "attachments": null
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That's some serious progress!",
        "created_at": "2021-07-14T14:04:02.459000+00:00",
        "attachments": null
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Well...\u003c@\u0026595681771690000403\u003e already has a basically working discv5 client so I'm really just tinkering around the edges.  Basically took this https://github.com/ChainSafe/discv5-cli and added a really simple json-rpc server to give me something to work with as I'm working on the deeper levels of the portal network specific pieces",
        "created_at": "2021-07-14T15:36:23.067000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "With respect to network design for our discovery v5 sub-protocols....\n\nCurrently, we are looking at as many as maybe 6 independent sub-protocols.\n\n- state\n- history\n- canonical block index\n- canonical transaction index\n- tx gossip\n- new block gossip\n\nEach one of these is easy to model as its own sub-protocol and there are benefits to doing so.  Here are the benefits as I see them:\n\n- the ability to only use the parts you care about....  stateless clients that only care about validating blocks could only be part of new block gossip.....  miners could choose to only participate in tx gossip.... \n- keep differently shaped data stored separately..... 1 billion transactions vs 12 million block bodies... canonical transaction index data is way less important that chain history data so we probably don't want to apply the same eviction rules to them....\n\nBut doing 6x new sub-protocols, all with their own PING/PONG/FIND/FOUND message pairs might be a lot of architecture overhead.  Every one has to manage its own routing table and it may be architecturally complex to try and do this in a sane manner.  So the **challenge** is for us to look at how we can make this architecturally less complex.  Is there a way for us to establish a common sub-protocol that contains PING/PONG/FIND/FOUND such that we can build a common \"overlay-network\" sub-protocol that is used by all 6 of these sub-protocols?",
        "created_at": "2021-07-14T17:54:49.672000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Here is a document that might be a viable starting point for this: https://notes.ethereum.org/tPzmxQD_S3S3uvtpUSA0-g\n\nIt defines a new sub-protocol that I'm calling the `\"overlay\"` protocol, which would in theory provide an re-usable general purpose protocol for establishing and managing an overlay network for any number of other sub-protocols.",
        "created_at": "2021-07-14T19:06:19.177000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This same design could in theory be extended to `FINDCONTENT/FOUNDCONTENT` maybe as its own general purpose sub-protocol for content retrieval.",
        "created_at": "2021-07-14T19:07:54.227000+00:00",
        "attachments": null
    },
    {
        "author": "jacobkaufmann",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It's not clear to me how another layer, the \"overlay\" protocol, would remove the need to maintain separate routing tables for each sub-sub-protocol (e.g. history). If the PING/PONG/FIND/FOUND messages specify  `sub_protocol_id`, wouldn't each node need to maintain a separate routing table for each unique `sub_protocol_id`?",
        "created_at": "2021-07-14T20:40:55.675000+00:00",
        "attachments": null
    },
    {
        "author": "ogenev",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think the ''overlay'\" protocol idea is to just remove the boilerplate code of duplicating all messages for every sub-protocol, it still needs to maintain separate routing tables?",
        "created_at": "2021-07-14T21:37:05.238000+00:00",
        "attachments": null
    },
    {
        "author": "jacobkaufmann",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "That is not my understanding. Removing boilerplate could make implementations less complex, but it would not make the network(s) \"architecturally less complex\"",
        "created_at": "2021-07-14T22:36:30.525000+00:00",
        "attachments": null
    },
    {
        "author": "mike.ferris",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "or can you still use a single routing table, and the information about which nodes support which sub-protocols is embedded in the ENR?",
        "created_at": "2021-07-14T23:10:56.813000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It's what \u003c@!690224518383534174\u003e said, removal of boilerplate, by having a standardized protocol that implements the management of the overlay networks for an arbitrary number of networks it makes it easier at the implementation/architecture level",
        "created_at": "2021-07-14T23:12:56.593000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think it is N routing tables for N sub-protocols, all built on the same base \"overlay\" protocol (who's purpose it is to standardize the protocol messages).",
        "created_at": "2021-07-14T23:15:00.191000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This also removes some level of specification overhead.  If we had 6x sub-protocols (state/history/canonical-txn/canonical-block/tx-gossip/new-block-gossip) then we also have to have 6x specifications which all duplicate the same PING/PONG/FIND/FOUND messages and some of which also duplicate the same FINDCONTENT/FOUNDCONTENT messages.",
        "created_at": "2021-07-14T23:16:24.808000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "In theory there is some streamlining that can be done.  Things like liviliness checks can probably be shared across sub-protocols.  A recent success checking liviness in the \"state\" sub-protocol is probably adequate for skipping the liviliness check in the \"history\" sub-protocol.",
        "created_at": "2021-07-14T23:17:36.669000+00:00",
        "attachments": null
    }
]