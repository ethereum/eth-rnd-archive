[
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Badass.  Is the idea here that non-browser clients in the network could/would benevolently act as the proxy for browser-based nodes?  Do the proxy nodes open additional UDP ports for the clients they are serving as a proxy for?",
        "created_at": "2021-09-02T03:29:00.656000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Probably a dumb question, but if every node runs these proxies, why not just make the proxy the default network protocol?",
        "created_at": "2021-09-02T03:30:35.967000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think the proxy is less ideal because its websocket-or-webrtc which are long lived connections, the theory which has not been validated that trying to do UDP-shaped stuff over these types of connections will end up incurring additional overhead due to redularly opening and closing the connections.",
        "created_at": "2021-09-02T03:32:39.250000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But, the same isn't true for using websocket-or-webrtc for a single long lived connection that is being stapled to a UDP socket because it's a single websocket/webrtc connection that stays open the whole time",
        "created_at": "2021-09-02T03:34:02.158000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So you negotiate with another peer to maintain a long lived connection, that peer handles the shortlived stuff, mitigating the overhead of many expensive-to-establish connections for the browser client?",
        "created_at": "2021-09-02T03:34:21.127000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yes, assuming my assumptions about what Andrew posted above are correct",
        "created_at": "2021-09-02T03:34:46.125000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I guess this would let a browser contribute storage to the network, at the expense of leeching bandwidth.",
        "created_at": "2021-09-02T03:36:03.046000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Interesting.",
        "created_at": "2021-09-02T03:36:07.059000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I haven't gotten far enough to figure out the proxy piece.  At present, I've got ultralight (my nodejs client) talking `discv5` to both browser based clients over websockets and then other portal network clients (fluffy in my experiments last night) over UDP in a single application but I'm not bridging traffic between the two yet.  I've never built anything like a straight up pass-through proxy so will need to think through how to make that work.  My thought for a first step from what I have now is to basically have the ultralight client consume requests from the browser clients, rebroadcast them to the UDP network, and then take any responses and send them back over websockets to the browser clients",
        "created_at": "2021-09-02T12:18:43.433000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "though this would be sub-optimal at best",
        "created_at": "2021-09-02T12:18:50.154000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "since we've basically reduced the whole browser thing to a client/server model again",
        "created_at": "2021-09-02T12:19:02.920000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I need to dig deeper into how libp2p does their relay server.  Conceptually, the relay server becomes close to invisible on the network except for at the multiaddr level so a browser client's multiaddr would ideally look something like `/dns/ultralightrelay.server/p2p/browserclient.ip.address/` to the broader network",
        "created_at": "2021-09-02T12:22:16.827000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Or maybe it's even simpler than that.  I need to research how to build network proxies ðŸ™‚",
        "created_at": "2021-09-02T12:24:24.644000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "This is more or less what I want to imitate - https://gateway.ipfs.io/ipfs/bafybeidyvt7edehj4uvjdomv4um5hxvg5wzlcnax3aooljylbdruor2z6y/concepts/circuit-relay/",
        "created_at": "2021-09-02T12:29:25.423000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "If it's a thin proxy I think it's slightly different from client/server because in theory a cheap VPS could proxy hundreds-or-thousands  of nodes, unilke today where you need a big fat server to run an ethereum node which can serve ~50-100 light nodes? The *cost-per-server* in the proxy model could be very very inexpensive.",
        "created_at": "2021-09-02T13:52:14.278000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "sure, if it's a true proxy and not re-broadcasting which is all I really know how to do right now.",
        "created_at": "2021-09-02T13:53:18.735000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "My mental model for this has been to establish a very simple protocol over the stream side to frame the raw UDP packet payloads in both directions.",
        "created_at": "2021-09-02T13:53:52.764000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "right, and I think I get what you're saying, but I just don't know how to build it at this point ðŸ™‚",
        "created_at": "2021-09-02T13:54:09.596000+00:00",
        "attachments": []
    },
    {
        "author": "acolytec3",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "my current level of knowledge says that the browser clients are actually sending their messages directly to ultralight which is consuming them and then rebroadcasting just the content from that message out to the UDP network, gathering responses, and then responding back to the browser client with the actual desired content",
        "created_at": "2021-09-02T13:55:19.098000+00:00",
        "attachments": []
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "maybe I can write my thoughts down on what that simple protocol would look like in more objective/descriptive terms",
        "created_at": "2021-09-02T13:55:20.481000+00:00",
        "attachments": []
    },
    {
        "author": "nick.ghita",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "@ everyone contributing to trin - I have a pr up proposing a change to the base trin architecture, I'd love to hear everyone's thoughts on the proposal https://github.com/ethereum/trin/pull/89",
        "created_at": "2021-09-02T15:55:27.126000+00:00",
        "attachments": []
    },
    {
        "author": "kolbyml",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I am not home yet and I'm just viewing it from my phone, but I really like this approach I would call it an improvement, because ideally I think we should only have 1 instance of discv5 and this seems to do that instead of having a separate initialization for each network which would use different ports and be unideal. So that is a thumbs up from me :).",
        "created_at": "2021-09-02T22:13:53.278000+00:00",
        "attachments": []
    }
]