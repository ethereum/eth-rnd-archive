[
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I suppose he means to hash the serialization of the state as a single byte buffer instead of as a Merkle tree. This takes essentially half the time than hashing it as a tree. But Merkle proofs, while not being used today in the beacon chain. Will surely be useful",
        "created_at": "2021-12-24T01:16:49.883000+00:00",
        "attachments": []
    },
    {
        "author": "80raghavendra",
        "category": "general",
        "parent": "",
        "content": "I understand the role of Merkle proofs (and hence Merkle trees / MPT) in case of light clients and stateless clients. But I do not understand the necessity of it when all the nodes in the system are full-current-state nodes and they are already storing it inside rocksDB which provides faster retrieval and insertion times. \n\nI understand a full-current-state-node's operations as:\n- Load from on-disk rocksDB and convert it to MPT\n- Do all the operations like reading data, writing data onto MPT\n- Periodically write onto rocksDB \nIs my understanding correct? If so, I see one can do all reads and writes on rocksDB (perhaps in-memory).\n\nThanks \u003c@364458974906548225\u003e for the question. Yes, thanks \u003c@!755590043632140352\u003e I did mean that serialise and take the hash... How long does it take to serialise and hashing it? Any ideas..",
        "created_at": "2021-12-24T02:53:17.157000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "It would be too costly to re-hash an entire state every time, this would be needed when transactions in a block affect left-most leaves of a state tree and there is no way to re-use the state of hashing instance",
        "created_at": "2021-12-24T05:58:37.090000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Oh I thought the question was purely about proofs, but yes as Mikhail explains, hashing it as a tree allows you to cache most of the state hashtree and only recompute dirty leaves on state transitions. Last I checked a few months ago hashing a full beacon state from scratch took about 300ms on all clients but Teku. That can be a bit longer these days",
        "created_at": "2021-12-24T10:30:19.179000+00:00",
        "attachments": []
    },
    {
        "author": "80raghavendra",
        "category": "general",
        "parent": "",
        "content": "Thanks \u003c@!425572898787426305\u003e and \u003c@!755590043632140352\u003e I now understand the problem with just hashing.\n\nBTW \u003c@!755590043632140352\u003e do you know the size of the full Beacon state when you tried hashing?",
        "created_at": "2021-12-24T13:39:54.117000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I've been working on hashing for a while now, I'm finishing an assembly library optimized for Merkle Trees, you can take a look at \u003chttps://hackmd.io/80mJ75A5QeeRcrNmqcuU-g\u003e and \u003chttps://hackmd.io/hOZnkh50RKehsOyf0b3CdQ\u003e I'm not sure if the sizes are there, but the dates are right, I remember the state to be around 30Mb when I checked, but I may be wrong. I'll run a new set of benchmarks with the new library soon cause I want to try to convince at least the non-vm clients to run with it instead of blst/openssl or whatever hashing library they use",
        "created_at": "2021-12-24T13:57:02.538000+00:00",
        "attachments": []
    }
]