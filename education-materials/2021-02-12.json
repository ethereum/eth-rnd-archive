[
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Can you be more specific about exactly what feature you want?  Callbacks and promises are higher level constructs that don't exist at the bytecode level for any language that I know of.",
        "created_at": "2021-02-12T00:55:03.105000+00:00",
        "attachments": []
    },
    {
        "author": "paperliss",
        "category": "general",
        "parent": "",
        "content": "I mean something that will make smart contracts like Maker and Compound not be dependant on external actors to liquidate funds",
        "created_at": "2021-02-12T02:08:52.941000+00:00",
        "attachments": []
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "You probably want to look into Account Abstraction",
        "created_at": "2021-02-12T02:09:37.998000+00:00",
        "attachments": []
    },
    {
        "author": "timbeiko",
        "category": "general",
        "parent": "",
        "content": "https://eips.ethereum.org/EIPS/eip-2938",
        "created_at": "2021-02-12T02:09:47.433000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Someone has to pay for transaction execution, and there is no mechanism for time based or block based triggers nor for state change triggers built into the EVM.  You can write a contract that calls a callback anytime some particular state in that contract changes if you want though.",
        "created_at": "2021-02-12T02:12:51.580000+00:00",
        "attachments": []
    },
    {
        "author": "marcoh00",
        "category": "general",
        "parent": "",
        "content": "Hello everyone! I began reading about eth2 and its protocols a few weeks ago and now everything starts to make a little more sense everyday. The most useful overview certainly was the Gasper Paper, but in the last few days I began looking at the specs and some client implementations (namely prysm and lighthouse) and noticed that there seem to be quite a few differences by now! One thing I wasn't able to understand until now is the handling of Casper FFG votes. While the Gasper paper states that votes usually occur on (EBB, Epoch) pairs, where EBB ist the epoch's first slot or any block seen right before that, the eth2 spec always uses the epoch's first block. When looking at the clients' codebases I noticed that (according to spec) everytime they generate an attestation, they include the epoch's first block root and fail when they can't look it up. Wouldn't that mean that if a proposer failed to propose a block in the first slot, the clients wouldn't be able to generate valid attestations for the whole epoch?",
        "created_at": "2021-02-12T14:08:30.632000+00:00",
        "attachments": []
    },
    {
        "author": "marcoh00",
        "category": "general",
        "parent": "",
        "content": "Oh and in general, does anyone know some good resources which document the actual differences between the papers and the specification (a little bit like bejaminion's great annotated beacon chain spec does, but for the other documents as well)? Until now I was able to find most of reasonings behind changes by git blaming certain passages of the spec and identifying the corresponding PRs or by googling and finding relevant discussions on ethresear.ch, but this turned out to be very very time consuming and not always successful. Anyway, thanks a lot for your help - and the very insightful discussions around here ðŸ™‚",
        "created_at": "2021-02-12T14:14:24.741000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "\u003e epoch's first block root and fail when they can't look it up.\nThey should be reading it from the state. If there is no block in that slot, the state will hold a copy of the last actual block before it. That's why the Checkpoint type has both the block root and epoch number: the block root alone is not sufficient for voting purposes.",
        "created_at": "2021-02-12T15:12:21.904000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Here are a few more resources:\n- Alternative annotated spec, by Vitalik: https://github.com/ethereum/annotated-spec\n- The old information hub, contains a lot of context, but may lag behind the very latest: https://hackmd.io/@benjaminion/eth2_info\n- A recent workshop about sharding and eth1-eth2 merge, for the latest eth2 info: https://www.youtube.com/watch?v=uGeIDNEwHjs\n\u003c@!708049324495601745\u003e",
        "created_at": "2021-02-12T15:16:25.055000+00:00",
        "attachments": []
    },
    {
        "author": "marcoh00",
        "category": "general",
        "parent": "",
        "content": "\u003e Thanks for pointing this out, now I knew where to look. I missed that `process_slots` is called inside the attestation creation code, too in case the requested slot is greater than the `headState`'s slot. And I missed that `process_slot` actually copies the the previous block's information. And I see vitalik created an annotated version of the fork-choice's spec, I'm sure this will be very helpful as well. I will checkout the other links, too when I find some time. Thanks again ðŸ™‚",
        "created_at": "2021-02-12T15:39:38.871000+00:00",
        "attachments": []
    }
]