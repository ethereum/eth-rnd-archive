[
    {
        "author": "kevaundray",
        "category": "general",
        "parent": "",
        "content": "Maybe I can help a bit with these questions;\n\nFor Elliptic curves there are usually two important items; Points and Scalars/Field elements.\n\n1) From what I understand, all inner nodes can be transformed into polynomials by taking the Hash of their children. If the child is also an inner node, then we take the commitment of that child inner node and then hash it. I believe your question is why do we take the hash in this case and why we cannot use the commitment of the child inner node. A commitment is a point, while the polynomial is a vector of scalars, so we hash the commitment to turn it into a scalar. (losing it's linearity property) and also strengthening the trie against collisions\n\n2) Yeah I agree, but the tree will be sparse so you don't need to have 1024 * X bytes of memory until it is necessary. You could use something like a HashMap, where if the key is not there, then it means that that node is empty.",
        "created_at": "2021-06-13T16:17:14.871000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "general",
        "parent": "",
        "content": "3) I think the attack you are talking about is when two leaves have very similar keys. IIUC the more parts of the key which are similar, the more expensive it will be to create an inclusion proof, because each similar part adds another polynomial to the KZG opening proof. In the very worse case, it would be num_bits_in_key / width . In your second question, the width would be 10, so if the key size is 32 bytes, then the  maximum number of collisions will be floor(256/10), so everything collides except for the the very last part.\n\nI'm not too familiar with PMT to give any context on how/whether it applies there unfortunately.\n\nThe worse case of 25 is more of a theoretical worse case because the keys are not chosen directly by the attacker, I believe they will be the hashes, so pseudo random which makes it improbable to get 25 collisions unless the hash function is broken. \n\nHopefully that helps ðŸ™‚ Let me know if you spot any mistakes!",
        "created_at": "2021-06-13T16:17:33.777000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "general",
        "parent": "",
        "content": "Those are very helpful answers and they make perfect sense, thanks a bunch!\n\nI'm not sure what you mean by \"losing its linear property\" however?\n\nIf someone else wants to chime in on how much of a concerns the collisions attacks against the verkle trees (or even merkle trees) are, I'm still interested in that.",
        "created_at": "2021-06-13T18:26:26.126000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "general",
        "parent": "",
        "content": "Oh I meant that if you have a commitment C and B, you can add them together to get their sum, but once you hash the commitment, adding the hashes together have no meaning",
        "created_at": "2021-06-13T18:29:50.907000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "general",
        "parent": "",
        "content": "I believe collision attacks against the verkle tree reduce to finding collisions with sha256 which gets more impractical the more bits you want to collide, because the keys are not controlled by the attacker",
        "created_at": "2021-06-13T18:32:02.385000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "As for 1. A point in G2 (for BLS12-381) takes 96 bytes at least (on one coordinate) while a hash takes 32. Given a few nodes this adds up",
        "created_at": "2021-06-13T22:52:14.685000+00:00",
        "attachments": null
    }
]