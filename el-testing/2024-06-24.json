[
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "2) Should definitely be stated as those values get deserialised into some types and this can be a consensus error if someone uses `U256` and others  `u64`, usage of u64 would make tx invalid.",
        "created_at": "2024-06-24T11:53:41.602000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "Side note: we should get a definition meta-EIP somewhere for these variables. Are `U64`s for instance bounded by numbers 0 - 2^64-1, but encoded as being stripped with zeros? And `Byte8`s to always have 8 bytes? (So could have leading zeros?)",
        "created_at": "2024-06-24T18:44:54.460000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "It is more about limiting max numbers or incorrect values. Max number example would be nonce that should be u64, and incorrect values would be Address that is 20bytes.",
        "created_at": "2024-06-24T18:55:53.165000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "There was EIP that talks about sane values inside Ethereum (can't find it rn). And there is EIP for limiting nonce max value: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-3338.md",
        "created_at": "2024-06-24T18:56:18.717000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "Yes this is a good point - but note, if you encode the number 1 as `0x01` or `0x0001` then this will change the tx hash ðŸ™‚ So it should be well defined ðŸ™‚",
        "created_at": "2024-06-24T19:10:30.657000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "yes, i think so, i don't see a reason to reintroduce signature malleability",
        "created_at": "2024-06-24T19:17:29.459000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "when encoded in rlp, the numbers can't have leading zeros, so I think that's covered here",
        "created_at": "2024-06-24T19:18:40.385000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "I tihnk it would be valuable to have a spec with actual types though",
        "created_at": "2024-06-24T19:20:23.393000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "with encoding routines / tests",
        "created_at": "2024-06-24T19:20:39.626000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "well, I guess this is EELS",
        "created_at": "2024-06-24T19:20:51.181000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "But having common / precise _types_ to refer to in EIPs would be nice",
        "created_at": "2024-06-24T19:21:15.024000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Testing",
        "parent": "",
        "content": "My (rather basic) understanding is that RLP just has two types: bytes and sequences.",
        "created_at": "2024-06-24T19:22:14.656000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "well yeah",
        "created_at": "2024-06-24T19:22:21.130000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "but in practice, for example, the fields of a 2718 tx are typed",
        "created_at": "2024-06-24T19:23:31.615000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "according to rlp or otherwise",
        "created_at": "2024-06-24T19:23:41.032000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Testing",
        "parent": "",
        "content": "For sure, I'm getting a link ðŸ˜…",
        "created_at": "2024-06-24T19:23:44.456000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Testing",
        "parent": "",
        "content": "https://github.com/ethereum/execution-specs/blob/656e3d2494d96e21298edb506a048103aa110ea2/src/ethereum/rlp.py#L64-L98\n\nFor the general RLP encode algorithm, and this one for integers specifically:\n\nhttps://github.com/ethereum/execution-specs/blob/656e3d2494d96e21298edb506a048103aa110ea2/src/ethereum/base_types.py#L290-L297",
        "created_at": "2024-06-24T19:25:01.408000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "RLP can encode 0x01 and 0x0001",
        "created_at": "2024-06-24T19:25:52.196000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "Testing",
        "parent": "",
        "content": "Integers are encoded as big endian byte sequences with leading zeros omitted.",
        "created_at": "2024-06-24T19:26:27.771000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "Ah ok I guess in our JS version we only support bytes and lists so you have to manually convert them / remove the leading 0s",
        "created_at": "2024-06-24T19:26:58.394000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "When reading the 7702 spec, I had the thought that the optional nonce could be defined as `Option\u003cu64\u003e` or something, and encoding defined as \"use a list, guarantee length 0 or 1\"",
        "created_at": "2024-06-24T19:27:55.795000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "maybe interesting if the optional pattern is used again",
        "created_at": "2024-06-24T19:28:33.349000+00:00",
        "attachments": []
    },
    {
        "author": "rjected",
        "category": "Testing",
        "parent": "",
        "content": "maybe useless if not",
        "created_at": "2024-06-24T19:28:40.563000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "This is how I interpreted it too, but it would be nice to specifically note that it should either be the empty list, or the list with 1 element, and that it should always be present. (so `nonce` field is always present in spec)",
        "created_at": "2024-06-24T19:28:51.318000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "BTW also side note, not sure if someone has realized this, but you can use CREATE(2) to bump the EOA account nonce, thus in order to invalidate any sig when signed with a `[nonce]` (I guess this is a nice feature)",
        "created_at": "2024-06-24T19:33:14.361000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "Ah ok and just realized, you can now also bypass the create txn which costs 32000 base fee by now using a 7702 tx which copies code to an EOA account which just CALLDATALOADs the data and then performs CREATE ðŸ¤” Also an interesting pattern",
        "created_at": "2024-06-24T19:39:57.930000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "So it would now cost calldata + 21000 + 2500, so this is a decrease of 11000 - 2500 for a CREATE txn cost ðŸ¤” EDIT: nvm, CREATE gas cost is 32k by default",
        "created_at": "2024-06-24T19:40:46.114000+00:00",
        "attachments": []
    },
    {
        "author": "chfast",
        "category": "Testing",
        "parent": "",
        "content": "This is true, but there are additional rules how to convert other types to bytes",
        "created_at": "2024-06-24T20:10:29.084000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "Ok I have another question. What if we have an EOA with balance 0, nonce 0, no storage, no code, and now we do a 7702 tx which stores something in storage in this account via SSTORE. Then, I am rather sure that by EIP-161, we should destroy this account since it is empty. Is this correct?",
        "created_at": "2024-06-24T21:23:49.382000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "If the nonce/balance is nonzero then it will not be deleted",
        "created_at": "2024-06-24T21:25:35.504000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "~~Oh huh, wait, did 158 get updated? It used to be zero nonce, zero code, zero balance then it was considered empty, but now it also should have empty storage? I am rather sure when I once edited it EthereumJS started failing state tests ðŸ˜…~~\n\nEDIT nvm I should read 161, not 158",
        "created_at": "2024-06-24T22:17:54.206000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "I just tested this scenario in EthJS by:\n\n(1) setup sender account C with enough funds\n(2) setup code account B with code PUSH1 PUSH1 SSTORE STOP `600160015500`\n(3) sign auth msg from account A to put code in account A from account B\n(4) send tx from C -\u003e A with auth list to set A code to B\n\nIf I change the tx to send value, then the storage does not get deleted. If I send 0 value, the account gets deleted.",
        "created_at": "2024-06-24T22:35:28.290000+00:00",
        "attachments": []
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "https://github.com/ethereumjs/ethereumjs-monorepo/blob/09108c5b27554af9126a0b3174a7f333c2e9b3b3/packages/vm/test/api/EIPs/eip-7702.spec.ts Can be found here",
        "created_at": "2024-06-24T22:39:21.205000+00:00",
        "attachments": []
    }
]