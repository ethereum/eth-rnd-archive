[
    {
        "author": "danceratopz",
        "category": "Testing",
        "parent": "",
        "content": "This is great, thank you for the insight",
        "created_at": "2024-09-03T08:16:56.344000+00:00",
        "attachments": null
    },
    {
        "author": "ak4222",
        "category": "Testing",
        "parent": "",
        "content": "I think its worth having a discussion around how the refunds should work in this instance, because it breaks with the conventional refund mechanism, and it would need some sort of special case handling.",
        "created_at": "2024-09-03T09:21:36.438000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "how does it break the conventional refund handling?",
        "created_at": "2024-09-03T10:08:56.580000+00:00",
        "attachments": null
    },
    {
        "author": "ak4222",
        "category": "Testing",
        "parent": "",
        "content": "I dont think there was refunds outside the EVM before and refunds did not happen if the tx failed",
        "created_at": "2024-09-03T11:27:42.629000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Testing",
        "parent": "",
        "content": "I'm confused about these releases: pectra-devnet-3@v1.4.0. Don't we have `fixtures_develop` for this?",
        "created_at": "2024-09-03T11:58:36.120000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "Not sure here, think the spec is clear, add refunds to the global refund counter",
        "created_at": "2024-09-03T12:04:58.495000+00:00",
        "attachments": null
    },
    {
        "author": "ak4222",
        "category": "Testing",
        "parent": "",
        "content": "Maybe im just confused about the term \"global refund counter\". I have not come across it before this EIP.",
        "created_at": "2024-09-03T12:21:06.947000+00:00",
        "attachments": null
    },
    {
        "author": "danceratopz",
        "category": "Testing",
        "parent": "",
        "content": "ethereum/execution-spec-tests release names",
        "created_at": "2024-09-03T12:21:56.643000+00:00",
        "attachments": null
    },
    {
        "author": "gurukamath",
        "category": "Testing",
        "parent": "",
        "content": "In case of EXTCODESIZE opcode, if an account has delegated to itself, it looks like we are charging the access cost twice. I think we should charge the access cost only once in case of self delegation since we are not accessing a different account\n\nExample - `{'test_file': 'blockchain_tests/prague/eip7702_set_code_tx/gas/self_set_code_cost.json', 'test_key': 'tests/prague/eip7702_set_code_tx/test_gas.py::test_self_set_code_cost[fork_Prague-blockchain_test-pre_authorized_False]'}`",
        "created_at": "2024-09-03T13:47:29.133000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Testing",
        "parent": "",
        "content": "I have some troubles with some of the 7702 tests: Why do we in the `test_ext_code_on_set_code` tests, like for example `test_ext_code_on_set_code[fork_Prague-blockchain_test-EMPTY_ACCOUNT-balance_0]`,  expect that `EXTCODEHASH` should return `0x00`  for the authorizer account? The authorizer has no balance and has delegated its code to an account with no code, but its nonce is 1, because we have increased it after processing the valid authorization. So shouldn't we return `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470` according to EIP-1052, because it has a non-zero nonce?",
        "created_at": "2024-09-03T14:24:00.864000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "Let me check",
        "created_at": "2024-09-03T14:26:51.392000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "No, it should put 0. We extcodehash 0xa94f, which is delegated to 0x8a0a. We should thus report EXTCODEHASH of 0x8a0a, which is an account which does not exist, so per EIP-1052 we should put 0 on stack",
        "created_at": "2024-09-03T14:31:01.718000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "So yes, 0xa94f is created, but the account it is delegated to does not exist. If instead 0x8a0a would exist in trie then we would indeed put `0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470`",
        "created_at": "2024-09-03T14:31:31.648000+00:00",
        "attachments": null
    },
    {
        "author": "marioevz",
        "category": "Testing",
        "parent": "",
        "content": "The set-code address' nonce is not bumped during the authorization, only the authority nonce is bumped",
        "created_at": "2024-09-03T14:45:06.422000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Testing",
        "parent": "",
        "content": "But we only get the code from `0x8a0a`, we still get the balance and the nonce from `0xa94f` in this case.  Or do I misunderstand that? Because in the 7702 EIP is says:\n\n\u003e This designator requires all code retrieving operations follow the address pointer to fill the accounts observable code.\n\nI am understanding this as loading only the code, but keeping the other values of the account. If that is true, in this case we still need to check the nonce of `0xa94f` which is 1.",
        "created_at": "2024-09-03T14:49:51.610000+00:00",
        "attachments": null
    },
    {
        "author": "jochembrouwer",
        "category": "Testing",
        "parent": "",
        "content": "\u003e The following instructions are impacted: EXTCODESIZE, EXTCODECOPY, EXTCODEHASH, CALL, CALLCODE, STATICCALL, DELEGATECALL.\n\u003e \n\u003e For example, EXTCODESIZE would return the size of the code pointed to by address instead of 23 which would represent the delegation designation. CALL would similarly load the code from address and execute it in the context of authority.",
        "created_at": "2024-09-03T14:51:35.836000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Testing",
        "parent": "",
        "content": "Maybe \u003c@543900561460822016\u003e can weigh in here on what's the correct interpretation of the EIP.",
        "created_at": "2024-09-03T15:07:52.548000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Testing",
        "parent": "",
        "content": "To resolve the issue.",
        "created_at": "2024-09-03T15:07:58.649000+00:00",
        "attachments": null
    },
    {
        "author": "marioevz",
        "category": "Testing",
        "parent": "",
        "content": "Definitely, I think we should get to consensus, and your concern makes sense to me",
        "created_at": "2024-09-03T15:08:51.788000+00:00",
        "attachments": null
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "This can get confusing, i would expect that we check emptiness of authorized account, not a mix of authorized account code and delegator nonce.",
        "created_at": "2024-09-03T15:35:22.354000+00:00",
        "attachments": null
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "Code wise, either way is trivial change",
        "created_at": "2024-09-03T15:36:17.729000+00:00",
        "attachments": null
    }
]