[
    {
        "author": "yperbasis",
        "category": "Testing",
        "parent": "",
        "content": "Looks like a good option (set beaconroot precompile non-zero nonce). I agree that changing the empty rule is a more involved option that will require substantial code changes and testing.",
        "created_at": "2023-08-01T07:57:10.734000+00:00",
        "attachments": []
    },
    {
        "author": "chfast",
        "category": "Testing",
        "parent": "",
        "content": "So this is another precompile?",
        "created_at": "2023-08-01T11:03:36.774000+00:00",
        "attachments": []
    },
    {
        "author": "yperbasis",
        "category": "Testing",
        "parent": "",
        "content": "Yes, EIP-4788 introduces another precompile",
        "created_at": "2023-08-01T11:08:02.598000+00:00",
        "attachments": []
    },
    {
        "author": "holiman",
        "category": "Testing",
        "parent": "",
        "content": "A stateful precompile. Evmone will love it ðŸ§Œ",
        "created_at": "2023-08-01T13:50:17.578000+00:00",
        "attachments": []
    },
    {
        "author": "chfast",
        "category": "Testing",
        "parent": "",
        "content": "Just deploy the real bytecode!",
        "created_at": "2023-08-01T17:23:54.583000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Testing",
        "parent": "",
        "content": "PRs welcome ðŸ™‚ although it is a bit late in the game to be changing the EIP",
        "created_at": "2023-08-01T20:00:19.110000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "What is reasoning behind stateful precompile, why dont we use same mechanism that we have for     \n`BLOCKHASH` for `BEACONROOT`?",
        "created_at": "2023-08-01T20:53:37.548000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "I cant find anything about it inside EIP, there is section about reusing of `BLOCKHASH` but there is nothing about having different opcode for `BEACONROOT`",
        "created_at": "2023-08-01T20:57:59.367000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "I mean this is different way from something that we already had, and in EIP it is not expressed why is it made in that but just how to do it, should contain that part imo",
        "created_at": "2023-08-01T21:01:51.007000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "I am not agains stateful precompiles, I am neutral, but this part is missing for me",
        "created_at": "2023-08-01T21:02:40.001000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "\u003c@539495253418180618\u003e ping, as i see i didn't hit reply ðŸ™‚",
        "created_at": "2023-08-01T21:07:58.914000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "generally ppl want to get rid of the notion of clients having data they need to store persistently outside of the state - this EIP uses the model from EIP-2935 with some updates",
        "created_at": "2023-08-01T21:18:51.536000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "Who are the people who is going to benefit of it, this is maybe first question and it is probably the answer. And second part is until we remove BLOCKHASH this is half solution (if we want to move to that direction)",
        "created_at": "2023-08-01T21:28:49.404000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "This opens up in my mind a lot more question how to fully solve it, should be put values of both BLOCKHASH and BEACONROOT to stateful precompile, or maybe full blocks so any values can be read?",
        "created_at": "2023-08-01T21:30:06.224000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "well the block hash values are embedded in beacon roots so probably unlikely to duplicate the functionality",
        "created_at": "2023-08-01T21:31:19.116000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "wdym by this, as beacon root can be used as a proof of block hash?",
        "created_at": "2023-08-01T21:32:30.703000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "yes you can make a proof about a block hash into a beacon root",
        "created_at": "2023-08-01T21:33:11.066000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "But coudn't you do the same with blockhash, as beaconroot will be part of the block?",
        "created_at": "2023-08-01T21:33:36.458000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "no blockhash is the EL block hash",
        "created_at": "2023-08-01T21:33:47.209000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "i know but arent block expanded with previous beaconroot? (Maybe i misread)",
        "created_at": "2023-08-01T21:34:20.401000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "ah that is true!",
        "created_at": "2023-08-01T21:34:51.385000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "yeah it needs to be inside, so that it can be shared for example over p2p",
        "created_at": "2023-08-01T21:35:50.310000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "what do you mean?",
        "created_at": "2023-08-01T21:36:00.607000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "also you would only have access to the previous _previous_ beacon root if you use blockhash",
        "created_at": "2023-08-01T21:36:29.488000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "for any sync when you get block over p2p you somehow need to know beaconroot, so it needs to be embedded inside block.",
        "created_at": "2023-08-01T21:36:37.369000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "That is true, but can be have present beaconroot for block that is still not voted on? (We can't for BLOCKHASH)",
        "created_at": "2023-08-01T21:37:38.123000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "you need this to full sync, yes",
        "created_at": "2023-08-01T21:38:44.552000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "not sure if i understand the question?",
        "created_at": "2023-08-01T21:39:17.711000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "not just full sync, but if you start to lag you probably need to fetch blocks from p2p and you would need beaconhash",
        "created_at": "2023-08-01T21:39:43.099000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "you would be getting the beacon root from your CL at that point",
        "created_at": "2023-08-01T21:40:33.781000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "For BLOCKHASH you dont have hash for current block but just for past blocks, obvious reason is while executing transaction you dont have block hash, i dont know if this behaviour is similar for CL",
        "created_at": "2023-08-01T21:40:48.964000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "same behavior for the CL - you don't know the root of the current beacon block until the EL block is constructed",
        "created_at": "2023-08-01T21:41:18.044000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "We are diverging now, beaconroot is going to be places inside header so it is not problem.",
        "created_at": "2023-08-01T21:44:37.465000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "My point is you would have just previous beaconroot not previous of previous beaconroot.",
        "created_at": "2023-08-01T21:45:12.943000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "But if you make proof in history then you will have previous of previous, i get now that part.",
        "created_at": "2023-08-01T21:46:01.406000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "So to the main point, why is it needed as stateful precompile and who needs it",
        "created_at": "2023-08-01T21:47:30.186000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "So you can't really have just one beacon root at a time in EVM bc then it makes txs very brittle - you need to be included immediately so that the proof doesn't become stale. That means we need to store some number of beacon roots so we have some flexibility. We have a mechanism for this, it's how blockhash works. We could've reused that, but seems like most ppl think this design was a mistake and we should include it in state. That is ultimately how we got to a stateful precompile. Simple way to it is to store every beacon root into state keyed on timestamp. It didn't seem nice to add something with unbounded storage requirements, so a ring buffer was added.",
        "created_at": "2023-08-01T21:54:55.420000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "\"other the most ppl think it should be included in state\" is not a discussion, answer to who and why  should be somewhere in EIP",
        "created_at": "2023-08-01T21:57:45.855000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "I get that, but this was same reasoning that  `EIP-2315 simple subroutines` had, that we removed from Berlin, and we got that answer only when we asked who is going to use this and why",
        "created_at": "2023-08-01T21:59:45.904000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "\u003e Roots of the beacon chain blocks are cryptographic accumulators that allow proofs of arbitrary consensus state. Exposing these roots inside the EVM allows for trust-minimized access to the consensus layer. This functionality supports a wide variety of use cases that improve trust assumptions of staking pools, restaking constructions, smart contract bridges, MEV mitigations and more.\nthe motivation section explains who plans to use it",
        "created_at": "2023-08-01T22:01:47.643000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "also i think rollups intend to use it so they don't need to store their own commitments to data posted on chain",
        "created_at": "2023-08-01T22:02:12.904000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "it's an improvement to block hash because it allows log size proofs to any historical block whereas today, outside the bound of 256 recent hashes it requires linear sized proofs",
        "created_at": "2023-08-01T22:02:57.752000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "Isn't that reasoning for including BEACONROOT, not about stateful precompile?",
        "created_at": "2023-08-01T22:03:19.724000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "We could always increment that number, i doesn't need to be 256.",
        "created_at": "2023-08-01T22:04:35.764000+00:00",
        "attachments": []
    },
    {
        "author": "lightclient",
        "category": "Testing",
        "parent": "",
        "content": "here is a good comment from alex on why a stateful precompile is preferred: https://ethereum-magicians.org/t/eip-4788-beacon-root-in-evm/8281/17?u=matt",
        "created_at": "2023-08-01T22:06:08.577000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "This is great comment!",
        "created_at": "2023-08-01T22:10:15.270000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "In essence it would allow you to with beaconroot of block N-1 to make direct proof to beaconroot of N-100 (for example),",
        "created_at": "2023-08-01T22:18:32.310000+00:00",
        "attachments": []
    },
    {
        "author": "draganrakita",
        "category": "Testing",
        "parent": "",
        "content": "You could still do that with headers, but you would need to include all header data from N-1,N-2...N-100.",
        "created_at": "2023-08-01T22:19:55.042000+00:00",
        "attachments": []
    }
]