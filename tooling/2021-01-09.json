[
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "\u003c@!144468805697929216\u003e Should chaind only record canonical blocks or does it keep around every block it manages to grab? I see to have wound up with an orphaned block in the db.  Could just be a bug which isn't a big deal for me but if its meant to happen I'll need to make my query smarter as it skews the stats a little.",
        "created_at": "2021-01-09T08:27:43.373000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "It tries to obtain all blocks, including orphaned, although many of them are discarded by beacon nodes.\n\nI do want to add some sort of canonical flag to blocks, but in the meantime the obvious way to find canonical is \"start with known finalized block, iterate up the blocks via `f_parent_root`, ignore anything else\".  Some sort of recursive query would do the trick.\n\n(If you aren't interested at all in non-canonical blocks you could delete the ones you find from `t_blocks`; doing so should remove all of the data from the linked tables)",
        "created_at": "2021-01-09T08:47:30.586000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "hmm, I think my query is already a few orders of magnitude too slow so might just have to wait until a canonical flag appears and put up with the occasional inaccuracy in the mean time.",
        "created_at": "2021-01-09T08:50:13.337000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Though I'm hoping I can get the same result from metrics now that I've worked out the details of what I actually need.",
        "created_at": "2021-01-09T08:50:49.626000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "If you have specific queries you need to run that aren't going quick please throw them over, I can take a look and see if I can speed them up by throwing indices at them or whatever (or update the DB with additional fields)",
        "created_at": "2021-01-09T08:59:09.500000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "It's about a page long. I'm basically calculating the attestation rewards for validators in sql.  I think its generally hitting indices well but winds up being expensive to a) decode the attestation bits and find the actual validator indices and b) determine if the target and head roots are correct (joining to the block table which is where the inaccuracy is coming in if the root points to an orphaned block).",
        "created_at": "2021-01-09T09:02:08.350000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "It's probably not the type of query you need to run often though so giving it a heap of time to churn through a week of data at a time and produce a report isn't the end of the  world.",
        "created_at": "2021-01-09T09:03:11.478000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Ah yes.  Calculating the indices is probably quite painful, at the least.  Will see if I can add them in to the DB, as that's generally useful.",
        "created_at": "2021-01-09T09:03:22.448000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "Quick(ish) query to fetch the chain of canonical blocks given a known head:\n```\nWITH RECURSIVE f_canonical_blocks AS (\n   SELECT f_slot, f_root, f_parent_root\n   FROM t_blocks\n   WHERE f_root = '\\x3df28c5831b9362596480cc0c6900c85680eefbe1dd39f0fe474a564dc1a4ed5'\n   \n   UNION\n     SELECT b.f_slot, b.f_root, b.f_parent_root\n     FROM t_blocks b\n     INNER JOIN f_canonical_blocks cb ON cb.f_parent_root = b.f_root\n)\nSELECT f_slot, f_root\nFROM f_canonical_blocks\nORDER BY f_slot;\n```\n\n(At least, I think it is.  Threw it together quickly so have may mucked something up)",
        "created_at": "2021-01-09T09:04:43.478000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Testing",
        "parent": "",
        "content": "(I'd definitely go the route of deleting non-canonical blocks rather than attempting to filter them each time, if you don't care about them)",
        "created_at": "2021-01-09T09:05:22.429000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Cool, thanks.  I'm tempted to add a few triggers to the database to create some denormalised data like that until I get around to learning Go properly so I can add it to chaind. ðŸ™‚",
        "created_at": "2021-01-09T09:05:27.788000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Testing",
        "parent": "",
        "content": "Yeah I could safely delete them I think.",
        "created_at": "2021-01-09T09:05:48.132000+00:00",
        "attachments": []
    }
]