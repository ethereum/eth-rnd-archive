[
    {
        "author": "not.rithik",
        "category": "Testing",
        "parent": "",
        "content": "Hi, I'm a student with a background in formal verification and protocol architecture. I came across https://security.ethereum.org/wishlist and I'd like to try my hand at writing a differential llm based testing tool.",
        "created_at": "2025-12-02T05:26:40.234000+00:00",
        "attachments": null
    },
    {
        "author": "not.rithik",
        "category": "Testing",
        "parent": "",
        "content": "Would anyone have any suggestions on which EL/CL implementation specs I can test it on? Something that hasn't had a lot of testing gone into it would be ideal to test the tool",
        "created_at": "2025-12-02T05:27:37.282000+00:00",
        "attachments": null
    },
    {
        "author": "not.rithik",
        "category": "Testing",
        "parent": "",
        "content": "If this is the wrong channel to be asking this question, please let me know - I'll ask in \u003c#910910348922589184\u003e or \u003c#753271902520213625\u003e if those are the appropriate channels",
        "created_at": "2025-12-02T05:28:11.571000+00:00",
        "attachments": null
    },
    {
        "author": "alex.vlasov",
        "category": "Testing",
        "parent": "",
        "content": "Hey \u003c@264490359541858304\u003e \nthere is a number of execution/consensus clients: https://clientdiversity.org/#clients . Some of them have pre-alpha | alpha | beta status, so are not as well tested as stable ones. Additionally, there are standalone EVM or consensus implementations, which might be of interest too. Two examples are: https://github.com/ipsilon/evmone and https://github.com/protolambda/zrnt. There are multiple research implementations too.\nThe specs themselves can be found here: https://github.com/ethereum/execution-specs and https://github.com/ethereum/consensus-specs\n\nIn my opinion, in the context of an LLM tool, a particular choice of implementation should not be very relevant, as LLMs should be able to adapt, provided with a reasonable guidance from user.\nOf course, to simplify initial efforts, it makes sense to focus on a particular aspect of the EL or CL spec (e.g. in the case of CL that can be fork choice, state transition, etc). From the \"testedness\" point of view, it makes sense to focus on the recent protocol changes (e.g. gloas, fulu, electra for EL and amsterdam, osaka, prague in case of EL), which hasn't yet received extensive testing. So, it might be the best to combine both approaches, e.g. compare `fork choice` changes introduced in the `gloas` CL update.",
        "created_at": "2025-12-02T16:36:36.642000+00:00",
        "attachments": null
    },
    {
        "author": "alex.vlasov",
        "category": "Testing",
        "parent": "",
        "content": "Additionally, both consensus and execution specs are executable and written in Python, Therefore, it might be reasonable to diff test the EL/CL executable specs vs EL/CL implementations:\n- CL/EL specs are simpler and easier to work with than production-oriented implementations\n- Python is a very popular language, so there should be less problems from LLM perspective.",
        "created_at": "2025-12-02T16:46:36.703000+00:00",
        "attachments": null
    }
]