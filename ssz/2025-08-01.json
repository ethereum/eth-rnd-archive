[
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "Do you think there is a world where we do one single sweeping migration from RLP to SSZ?",
        "created_at": "2025-08-01T00:35:01.090000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "What's going to bite us is we keep adding new transaction formats for new random features, and the StableContainer/ProgressiveContainer are the way to go to make sure we don't have to add a new TX type every time there's a new execution feature we need like access lists, blobs, bring-your-own-state, etc. I'm not seeing an RLP solution that accepts that level of extensibility in the transaction definition. And TX features are not the only issue, what happens when we need to introduce new signature algorithms? L2s would love to add BLS sigs but the RLP setup is a solid barrier to progress.",
        "created_at": "2025-08-01T00:37:58.569000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "So the options are big bang or incrementally (mostly through new features). Is there a third way I'm missing?  I don't want it to turn into \"never SSZ\"",
        "created_at": "2025-08-01T00:38:41.996000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Cross-layer",
        "parent": "",
        "content": "Classic way of doing these kinds of migrations piecemeal is to use the new format for new stuff and convert at least one \"old thing\" per release. Takes a fair bit of discipline to always do that one conversion but if you can stick to it, you will eventually complete the process and not wind up stuck in the middle with weird tech debt forever.",
        "created_at": "2025-08-01T00:41:11.735000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "I expect we will always have to support existing rlp transaction types, since the signature is over the rlp form.  But we can move p2p data such as headers and bodies over.",
        "created_at": "2025-08-01T00:44:12.545000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Cross-layer",
        "parent": "",
        "content": "Yeah good point. I was thinking more about the situation of having some fields in a block by RLP and others SSZ (or similar).  Existing transaction types are indeed going to be pretty stuck on their current encoding.",
        "created_at": "2025-08-01T00:46:36.730000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "But I intend to push for an ssz form the next time a new tx type shows up, so we can stop creating tx types.",
        "created_at": "2025-08-01T00:48:39.008000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Cross-layer",
        "parent": "",
        "content": "Personally I think I would never want a SSZ migration as headliner for the EL, because of the amount of work it would need to be a headliner. Piece by piece migration seems much more realistic, while doing more important headliners. Only downside of this approach is that we'll break a lot a libraries that interact with the RPC endpoints, because they will all need to do the same migration.",
        "created_at": "2025-08-01T07:08:41.468000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "RPC is transient, not like a 100 year deposit contract and a pre-signed withdrawl transaction, so with proper notice we shouldn't feel bad breaking RPCs",
        "created_at": "2025-08-01T14:56:08.080000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "just because the signature is based on RLP doesn't mean that the transaction cannot be represented as SSZ on-chain (as part of the transactions-root). see 6404",
        "created_at": "2025-08-01T15:29:21.471000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "RPC endpoints consume JSON and don't verify against the roots. it doesn't break RPC",
        "created_at": "2025-08-01T15:29:58.442000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "Correct, but to validate the hash it needs to be in RLP form.",
        "created_at": "2025-08-01T15:29:59.307000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "In it's special no-signature-fields rlp form.",
        "created_at": "2025-08-01T15:30:37.554000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Cross-layer",
        "parent": "",
        "content": "Splitting payload ffrom signature is one of the best features of the current SSZ transaction proposal, solves this ugly step.",
        "created_at": "2025-08-01T15:31:19.929000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "it solves it for new types, not for converted ones. but it's not additional work for ELs",
        "created_at": "2025-08-01T15:31:39.694000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "ELs already have an internal transaction object that they use, it doesn't have a canonical serialization",
        "created_at": "2025-08-01T15:31:51.948000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "RLP sighash is used to obtain the from address. that's the only use for that. it's not on-chain",
        "created_at": "2025-08-01T15:32:05.617000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "as part of BAL, I'd advise to at least base it on EIP-7916 / EIP-7495 progressive types to avoid breaking verifiers when the limits change or new access list kinds get added lateron..\n\nePBS could likewise be built on top of 7916 / 7495, to give rocketpool / lido / other apps consuming CL data forward compatibility, reducing the need for involving security council to deploy smart contract updates at forks that don't change semantics beside Merkle tree shape changes.\n\nhttps://github.com/ethereum/consensus-specs/blob/master/ssz/simple-serialize.md#typing\nprogressive list is here today, I'll look in getting progerssive container in there as well. could be an initial scope for SSZification to get rid of the \"we don't have mature SSZ libraries\" argument (that argument was used for years, without any progress). then build BAL / ePBS on top of the new types.",
        "created_at": "2025-08-01T15:35:40.973000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "another thing that _could_ be done is a minimal form of SSZ where solely the hashes get updated initially.\nbut networking / db / rpc continue using whatever they currently use.\nthen, can add SSZ protocol on the side without needing further hard fork, and once it is widely adopted phase out the existing one, maybe initially with a rebroadcasting service that takes RLP transactions and rebroadcasts them on SSZ.\nlikewise, for RPC, could define a secondary binary rest RPC based on SSZ, and host it on top of JSON-RPC, and verifying clients (e.g. helios) would then just use the new one.\ncrucially, nothing except the hashes would need a hard fork",
        "created_at": "2025-08-01T15:48:28.124000+00:00",
        "attachments": null
    }
]