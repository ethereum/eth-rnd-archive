[
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It needs to be forced somehow",
        "created_at": "2021-02-21T00:21:31.139000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It‚Äôs not an issue of willingness TurboGeth spent what 3 or 4 years working on those improvements? These are very major changes that need to be made and affect huge parts of the client codebase. Implementation will take time and will have to come at the expense of other priorities. Teams need to find the right balance for that to fit their own situations.",
        "created_at": "2021-02-21T01:04:13.376000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I would say that now it is probably easier to write a new implementation that to try to migrate any existing well-established implementation to the data model and other things in Turbo-Geth. These 3-4 years were mostly spent on iterating on the data model (and then also architecture). But once iterations are mostly done, and the working data model and architecture are figured out, then rewriting should not take 3-4 years again. That figuring out is our main contribution. We will see how it will go with Silkworm (which is a fresh rewrite in C++). I personally much more relaxed now about others not \"adopting\" these findings - they've got to do what they've got to do. I am hoping that with the \"beta\" release we will be done with \"proving that it works\", and after that I am planning to supervise the hopefully accelerated Silkworm project, and otherwise spend time on code cleanup, bug fixes and documentation for Turbo-Geth.",
        "created_at": "2021-02-21T08:32:28.946000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think most teams are looking at adopting something like the approach turbogeth pioneered and it won‚Äôt take 3-4 years because as you said many of the concepts have been worked through now. But it still takes time and needs to be balanced with other priorities. \nHaving had the experience of building both an eth1 and eth2 client from scratch I can confirm that development and prioritisation is a lot easier before you get to 1.0 and have a lot of different users and a lot more complex afterwards. üôÇ",
        "created_at": "2021-02-21T08:40:33.161000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That‚Äôs exactly about priorities, as stated in the first messages of the channel",
        "created_at": "2021-02-21T11:08:30.525000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Regarding the actual topic of this channel, I would say that the main deciding factor for the viability of such proposals will be something that is not clearly defined from my point of view. In the Eth1 \u003c-\u003e Eth2 merge plan, there are two competing desirata - 1. making things different and fixing errors of past (ergo the proposal of this channel) 2. inheriting as many things from Eth1 that are perceived to be valuable. I don't think we know very well, what are the most valuable things about Eth1 that we must not lose during migration. Is it current distribution of ETH? Is it the infrastructure/integrations with other systems? Is it deployed smart contracts? Is it some dapps (which ones are more valuable than others)?. As an old saying goes \"when everything is a priority, nothing is a priority\". Meaning that you cannot upgrade the system and keep everything, just in case it turned out to be valuable. So you've got to decide what to keep and what to sacrifice, and take a risk. If someone has different and very strong opinions on what is valuable, they might want to create a different version of the system. But the inherent risk is there",
        "created_at": "2021-02-21T12:32:32.084000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One extreme approach would be to completely revamp EVM and \"plug\" it into Eth2, and then let the Eth migrate over, and Dapps redeploy. This approach makes an assumption that the distribution of Eth is the most valuable thing, but not the currently deployed apps. It leaves time for the new infrastructure and integrations to build up around Eth2, not expecting everything to switch over overnight. Another extreme is keeping everything in Eth1, but just swapping the consensus engine. This approach assumes that deployed dapps and their user data is as valuable as the ETH distribution. Also, it assumes that EVM-level integrations are very hard to change and need to be kept. I personally think the first extreme is the right approach, but obviously there are other opinions",
        "created_at": "2021-02-21T12:39:52.665000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The reason I think the first extreme is the right approach is that fundamental premise of Ethereum is that it is easier to evolve and changes Dapps than to change the core-level infrastructure. So instead of trying to twists ourselves to help Dapps avoid rewriting their code, and make migrations/merge fiendishly complex, we should do it another way around, according to the fundamental premise",
        "created_at": "2021-02-21T12:42:24.544000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "it is cheaper to change App code than ISA of the CPUs",
        "created_at": "2021-02-21T12:42:38.046000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Considering all that, I find the hope of using Eth1/Eth2 merge as the \"last opportunity\" to fix EVM a bit misguided",
        "created_at": "2021-02-21T12:43:40.347000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I would not fight back against approach 1.  I would also be OK with ETH1 living on indefinitely due to such a decision.  I think the future is ETH2 (PoS, stateless, sharding) and I *think* most of the core developers think the future is ETH2, so I suspect that most of the core devs would migrate, and with them the vast majority of improvements to Ethereum.",
        "created_at": "2021-02-21T12:45:30.896000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The biggest risk IMO would be that enough core developers stay behind on ETH1 to *maintain* it, which just means backport everything that goes into ETH2 (minus the stuff we axed).",
        "created_at": "2021-02-21T12:46:16.991000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Has anyone thought about whether we could turn ETH1 into an ETH2 rollup or side chain of some kind?",
        "created_at": "2021-02-21T12:48:14.610000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So ETH1 could use ETH2 consensus, but ETH2 could basically ignore it and people who didn't want to keep running ever-growing ETH1 nodes wouldn't have to?",
        "created_at": "2021-02-21T12:48:43.652000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't see ETH2 as replacing anything in ETH1 except the consensus mechanism.  Most other changes are those that could take place regardless of if ETH1 was PoW or PoS.\n\nThat said, the shards give the ability to eventually create some sort of \"fresh start\" where an ETH1-like chain is secured as a rollup or data root secured by ETH2.  But that would be alongside, rather than instead of, the current ETH1.  If done right then the tx costs would be such that we'd end up seeing dapps naturally migrate there.  Some sort of bridging in the beacon chain, or perhaps even direct between the old and new ETH1s,would allow for composition between them if required, allowing for a smooth/phased transition.",
        "created_at": "2021-02-21T14:30:20.002000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It sounds like you are closer to the latter extreme that \u003c@456226577798135808\u003e described above?  Don't break *anything* with the move to Proof of Stake?",
        "created_at": "2021-02-21T14:43:51.738000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not necessarily, just decouple the two things.  I very much think the Ethereum 1 needs a do-over, but the changes that are made for the move to PoS should be the minimum possible.",
        "created_at": "2021-02-21T14:49:54.671000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If it then turns out that there are some things that break as a result (blockhash as a random number source springs to mind) then that gives something to work on, but I don't think this is inherently more of an opportunity to make changes than any other hard fork (although it should give the platform to make changes _after_ the consensus change)",
        "created_at": "2021-02-21T14:51:32.966000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm fine with doing a big \"breaking\" change *before* PoS.  I think the general argument is that we should try to do any big breaking changes *before* PoS launch so new clients that are written won't need to be able to deal with all that legacy stuff (assuming they start syncing from The Merge forward).",
        "created_at": "2021-02-21T15:29:39.093000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Since the ambition for Eth2 starting from mid-2018 has been the creation of a new system, with all things new, I think this ambition should to be carried out and Eth2 to create at least one \"shard\" with obviously superior capabilities over Eth1. Then, since the flow of ETH from Eth1 to Eth2 is already established, you can just watch (and encourage) the dapps flock into the new system. On the other hand, the merge might create a situation where Eth2 is neither here nor there, with most of the baggage of Eth1's design shortfalls and large state, and without superior tech being in place yet",
        "created_at": "2021-02-21T15:39:19.261000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, one realisation I am coming to is that more successful systems will be those that manage to get to the point where their improvement/progress can become \"multi-dimensional\" and not just follow a single \"roadmap\". By this I mean conceding that most precious innovation will most likely come from outside of the established circles of researches and devs, and to encourage such innovation, the system needs to contain enough places where experimentation can happen. For example, if Eth2 quickly got to the point of multiple \"shards\" but without necessarily cross-shard transactions (but still with ETH flowing between them), this might already be enough for figuring out the best execution environment and data models. Similar to what I think Cosmos wants to create with their focus on IBC instead of introducing smart-contract languages",
        "created_at": "2021-02-21T15:44:04.089000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think that would be unrealistic given the broad timeframe of the merge, not least because it would put pressure not doing breaking changes _after_ PoS so would likely be a long list.  Having the merge and the changes to ETH1 each ticking along on their own clock doesn't seem like it would be particularly onerous; the post-merge ETH2 clients are most likely to lean on the existing ETH1 clients for a lot of the heavy lifting around EVM and state anyway (at least initially) so it wouldn't be additional burden on the ETH2 clients.",
        "created_at": "2021-02-21T18:16:01.618000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think that this is true, but that's because the merge won't be the last step.  The merge does bring the benefits of PoS (reduced electricity usage, deterministic block times, reduced issuance _etc_.) but it won't solve a number of the other pressing issues with Ethereum.  That seems reasonable to me, and the efforts to iterate on ETH1 will no doubt continue (or, as you say, a potential reboot.)",
        "created_at": "2021-02-21T18:18:07.478000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Breaking (or just large) changes should (subjectively) be viewed completely independent from the merge, but back to the setting of the original proposals I think there are various problems that are breaking and urgent and that should be implemented before the Vitalik‚Äôs proposed set of changes. But unfortunately there is no will to risk and do any breaking changes at all at the moment",
        "created_at": "2021-02-21T18:24:48.046000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What sort of breaking changes would you like to see?",
        "created_at": "2021-02-21T18:26:34.662000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Independently, if EVM is changed into register machine (ABI can be preserved by the way) it can eliminate around 70% of ‚Äústeps‚Äù in the execution trace and make contract code potentially more compact",
        "created_at": "2021-02-21T18:26:40.067000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don‚Äôt know if it should be called a breaking change or just a restriction, but I would want to see those famous IO problems to be forced to be fixed in all the clients, with some sort of hard restriction that a ‚Äúcore‚Äù Eth client must process IO at the speed \u003eX. Related truly breaking change is moving to binary tree or VC based schemes (not a huge fan of the latter though) for a storage",
        "created_at": "2021-02-21T18:29:48.568000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "IIUC, moving to binary or verkle trees will be problematic without first removing self destruct?",
        "created_at": "2021-02-21T18:31:27.097000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Though, maybe I have that wrong.",
        "created_at": "2021-02-21T18:31:34.034000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "From technical perspective I think it can be done without removing this opcode, but a proposed guarantee that any storage related operation can not change more than 1 storage slot is good. At the very bottom self destruct can still just affect 32 bytes + some marker that storage tree of the destroyed construct can be (later and in lazy mode, in parallel, in separate thread, etc) cleared from the disk",
        "created_at": "2021-02-21T18:34:12.614000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Large breaking changes to the EVM just aren't likely to happen at this point.  Breaking changes to get the EVM partway to level of the JVM or Wasm (EIP-615) failed after years of work.  Small non-breaking changes to get it partway to the level of Forth (EIP-2315) took less time, but remain undeployed.  And I see little point in changing from a stack machine to a register machine.  Stack machine interpreters are easier to implement, stack machine code is more compact, and stack machine code is more easily compiled to register machine code than the reverse.  These are some of the reasons that Forth, JVM, Wasm and many others are stack machines.  I suspect \u003c@!194433073394352129\u003e's recent non-breaking proposal to support auxiliary stack frames in memory might go a long way towards providing what you might want from a register machine.",
        "created_at": "2021-02-21T20:31:39.135000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I‚Äôm not professional enough to propose such change in full, but had some time to prototype over ‚Äúflavors‚Äù of possible EVM and analyze ‚Äútypical‚Äù contracts (well, largely AMMs). Found it curious",
        "created_at": "2021-02-21T20:34:03.419000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah I think the best we can do is kill a few limited capabilities to add more invariants",
        "created_at": "2021-02-21T20:34:46.343000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And there is something to be said for that! One random example is that if we move to relative jumps then code could more easily be moved around and composed",
        "created_at": "2021-02-21T20:35:33.051000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "May be code size would not reduce due to a bit richer opcode format, but implementation wise I didn‚Äôt find it much more complicated",
        "created_at": "2021-02-21T20:36:29.811000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "They're not \"auxiliary stack frames in memory\"; I'm simply proposing a way to use memory for locals/return addresses/parameters the same way more usual architectures do.",
        "created_at": "2021-02-21T20:50:37.257000+00:00",
        "attachments": null
    },
    {
        "author": "shamatar",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Everything that fixes ‚Äústack is too deep‚Äù problem should be the most welcome. I assume that this change is ‚Äúnon-breaking‚Äù in a sense that it would be largely a compiler‚Äôs job now to use memory instead of stack?",
        "created_at": "2021-02-21T20:54:30.040000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yup",
        "created_at": "2021-02-21T20:54:40.405000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The proposal is basically to introduce four new opcodes:\n - SETFP - takes the top argument from the stack and sets an internal variable 'frame pointer' to it.\n - GETFP - pushes the current frame pointer to the stack\n - MLOADFP - takes one argument from the stack, adds the frame pointer, and loads the memory at that address.\n - MSTOREFP - takes one argument from the stack, adds the frame pointer, and stores the second stack element at that address in memory.",
        "created_at": "2021-02-21T20:55:50.852000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In addition it would be much more useful if we switched to billing for memory in a paged manner instead of linearly from 0.",
        "created_at": "2021-02-21T20:56:07.410000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not wanting to put words to your proposal, but I think \"stack frames in memory\" are where many systems keep locals, return addresses, and parameters.  The EVM already has a stack which is currently used  for all of those, and (come Berlin) will have a separate stack for return addresses.  So \"auxiliary\" to those stacks, and quite useful for getting stuff off of the main stack.",
        "created_at": "2021-02-21T21:55:07.074000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\"Auxiliary\" supposes that it's connected in some way to the evaluation stack.",
        "created_at": "2021-02-21T21:55:40.595000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But it's just a way of managing those variables that happens to be in LIFO order.",
        "created_at": "2021-02-21T21:55:49.099000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Just because two different parts of the program use stacks doesn't mean they have to be the same, or connected.",
        "created_at": "2021-02-21T21:56:14.239000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The connection is via SETFP and GETFP?  I'm not trying to be very precise in a Sunday afternoon chat.",
        "created_at": "2021-02-21T21:58:16.307000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't think that makes it \"auxiliary\"",
        "created_at": "2021-02-21T21:58:53.679000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And although it facilitates keeping a stack, there's nothing about those instructions that means they have to be used for that, either.",
        "created_at": "2021-02-21T21:59:35.080000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My point is that it's an entirely independent mechanism of the EVM evaluation stack. If the EVM was register-based, these same operations would be equally useful.",
        "created_at": "2021-02-21T22:00:05.826000+00:00",
        "attachments": null
    },
    {
        "author": "nickjohnson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There's no real connection here other than that they both happen to use the same data structure.",
        "created_at": "2021-02-21T22:00:22.305000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Gotcha, I think.  I'm not sure we really disagree on the substance here, I'm running on fumes after 10 days on the run from the Great North American Storms of 2021, and there is a 6-year-old girl here who'd rather I be playing hide-and-seek with her than dealing with Ethereum stuff.  I like this proposal.",
        "created_at": "2021-02-21T22:08:29.480000+00:00",
        "attachments": null
    }
]