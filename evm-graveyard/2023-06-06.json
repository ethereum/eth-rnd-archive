[
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, I can't see any reason not to make it global.",
        "created_at": "2023-06-06T01:08:40.092000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Another memory-accounting change I'd love to see is to remove the fixed stack size.  There are two reasons for this theoretical and practical . \n\nFirst, Rick Dudley points out that it isn't gas that prevents the EVM from being Turing-complete -- it's the fixed stack size.  In theory you can always buy more gas, which will buy you as much runtime and memory as you like.  No amount of gas will get you more stack, but Turing machines have infinitely long tapes.\n\nPractically speaking , an unbounded stack simplifies clients by eliminating stack checks - PUSH is just another way to burn gas, which has to be counted anyway. (I'm assuming all client languages have a growable array type)  And it simplifies EOF because stack heights need not be specified.\n\nFinally, life is lot easier for developers and users if stack size can grow at runtime to fit the input.",
        "created_at": "2023-06-06T01:38:00.211000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I would also like to see this through -- I've put off bringing it up until Shanghai was in the rear-view mirror.",
        "created_at": "2023-06-06T01:41:32.185000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We would need to determine if an unlimited stack would impact limited memory execution environments, such as in-browser javascript and whatever the current minimum spec for EL clients is (4/6/8GiB?)  Right now it could be on the order of a 15 million item stack (all PUSH0s in an unrolled loop)",
        "created_at": "2023-06-06T15:30:29.619000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Seems like it would be fine but I would want someone to exercise it first.",
        "created_at": "2023-06-06T15:31:08.246000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "More devious ones would include call stack in that growth plan, on the order of 25000-30000 calls, and something like a 1000 call stack with max operand stack is another case to consicer.",
        "created_at": "2023-06-06T15:33:35.838000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "To be clear, I mean the data stack, not the call stack, not sure if we are confused or not.",
        "created_at": "2023-06-06T15:35:57.574000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I got that, but if we are unlimiting the operand stack why not the call stack too?  Even if we don't, we would want to consider the call stack at max with max unbound operand stack.",
        "created_at": "2023-06-06T15:36:54.233000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think whatever limits we have we need a reasonable standard for where we expecting it to work.  Such as saying that that an \"encapsulated transaction\" (a transaction with all needed external data) should be able to be evaluated in a fairly low-resourced environment, such as a web browser on a $100 chromebook or low end mobile phone, both in under a second.",
        "created_at": "2023-06-06T15:40:01.455000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "On quick re-read I think the proposal handles these issues -- whether you are making EVM calls, writing to EVM memory, or pushing EVM stack you are using  and paying for real memory.  It's not clear to me that it matters in which way you run out of gas.",
        "created_at": "2023-06-06T15:50:42.246000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm a tad bit concerned that the call stack may be more than 100 bytes of overhead per level.  Also, each push can be 32 bytes per push, or 16 gas per byte. Whereas mstore would be charged at 1 byte per gas.  however I think a better grounding is a device definition such as the $100 chromebook definition.  It may not matter here but when we get into discussion about things like vector operations it may matter.",
        "created_at": "2023-06-06T20:33:59.434000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "OK.  I think we can tweak the relevant constants and gas prices to allay some of your concerns.   Are you wanting to be sure that no client on any supported platform will run out of real memory before it runs out of gas?  I don't think we can guarantee that anyway, but yeah, we want it to be rare.\n\nRegardless, I don't yet see that putting a bound on the operand stack helps -- if programmers can't get enough stack they can get around that by (awkwardly) burning gas on memory instead. \n\nBut I suspect I am still not understanding all of your concerns.",
        "created_at": "2023-06-06T23:32:36.699000+00:00",
        "attachments": []
    }
]