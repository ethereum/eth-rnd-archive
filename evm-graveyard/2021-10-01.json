[
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah sorry I think I was thinking of a different proposal: keep a filled slot counter to enforce the rule that only empty-storage contracts can SELFDESTRUCT",
        "created_at": "2021-10-01T00:57:20.787000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My problem with incarnation counters is just that they add complexity and we lose the really nice property that a storage key's location in the tree is fixed",
        "created_at": "2021-10-01T00:58:07.662000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And it's not clear that it has any long-term advantages (as opposed to the mere short-term advantage of avoiding the need to rip off the bandaid)",
        "created_at": "2021-10-01T00:58:37.274000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This was a hypothetical discussion, mind you. The priority solution should still be disabling SELFDESTRUCT completely.",
        "created_at": "2021-10-01T06:14:14.513000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Am I correct in assuming this is motivated by wanting to get rid of both 1: unbounded state clearing and 2: make contact for immutable. Incarnation counters only give us a fix for the first but still allow code to change.?",
        "created_at": "2021-10-01T13:12:49.385000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Incarnation counters trade one complexity for another, it may be net reduction in overall complexity in some cases (I'm not totally convinced of this), but it is a complexity increase compared to just neutering SELFDESTRUCT entirely.",
        "created_at": "2021-10-01T15:11:44.967000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think I've just been looking at it as our best worst option because it isn't clear to me yet that full removal/neutering of SELFDESTRUCT is viable (I'm not saying it isn't, I just haven't seen a path that clearly states that it is).",
        "created_at": "2021-10-01T15:29:58.922000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Am I correct in assuming your concern with neutering SELFDESTRUCT is that it may break some contracts?",
        "created_at": "2021-10-01T15:30:31.716000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "When we say neuter I am assuming we mean SELFDESTRUCT -\u003e UNCONDITIONALSEND?",
        "created_at": "2021-10-01T15:38:47.313000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think the goal is:\n\n- remove the mutability thing around contract code that CREATE2+SELFDESTRUCT introduced\n- remove the unbounded state access (from having to clear the state)",
        "created_at": "2021-10-01T15:40:51.172000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So in the new world, SELFDESTRUCT would just send all ether to the destination address and then stop execution?",
        "created_at": "2021-10-01T15:41:38.383000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't know about stop execution, does SELFDESTRUCT stop execution currently?",
        "created_at": "2021-10-01T15:42:01.297000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\nSELFDESTRUCT(destination)\ntoken.transfer(destination, token.balanceOf(this))\n```\nToday, does that transfer the token balance or not?",
        "created_at": "2021-10-01T15:42:38.626000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "looking at py-evm's implementation, yes, it halts execution",
        "created_at": "2021-10-01T15:43:04.557000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'd actually prefer simply undefining selfdestruct as opcode",
        "created_at": "2021-10-01T16:48:29.800000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Why is unconditional send a good thing to preserve?",
        "created_at": "2021-10-01T16:48:44.730000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Loss of funds for existing contracts that implement self destruct is the main thing that comes to mind.  It might be the only mechanism built into a contract to get the money out.  Maybe worth actually exploring to see if we can find such a contract.",
        "created_at": "2021-10-01T18:08:04.696000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Might be cleaner to add opcode validation to the EOF containers (EIP-3670) and make SELFDESTRUCT an opcode that won't validate, then ratchet it up by requiring EOF deployment.  That way old contrats still function.",
        "created_at": "2021-10-01T18:17:08.490000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This approach is appealing for dropping old functionality, however, forbidding legacy contract deployment might not be viable because some contracts deploy other new contracts... and so forbidding new creation would also have the potential to break existing legacy contracts.",
        "created_at": "2021-10-01T18:18:36.280000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Right, the prohibition would be for \"create\" transactions (no to address). so existing systems would work as well but no new contracts could come online with it.  (would need to extend to creates from EOF contracts too)",
        "created_at": "2021-10-01T18:19:57.760000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "one of the eof EIPS had a compatability table... now I see why it's such a rabbit hole.",
        "created_at": "2021-10-01T18:20:47.431000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, now that I've thought on it for more than a few seconds, I see there is still benefit from putting that restriction in place since it helps discourage new contracts that depend on features we want to remove which allows us to chip away at the ones that would/will/do break upon removal of the feature.",
        "created_at": "2021-10-01T18:21:04.678000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, need to check if there's actually many contracts that will get their Ether stuck w/o SELFDESTRUCT\n\nAlso ample grace period for migration would mitigate this concern, I think",
        "created_at": "2021-10-01T18:38:00.259000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In any case, simply undefining is much better because it doesn't introduce new behaviour, but rather removes previous ones",
        "created_at": "2021-10-01T18:39:01.332000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And from the perspective of use, I think it's a good idea to revisit EIP-2929 with access lists",
        "created_at": "2021-10-01T18:40:28.704000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Last I looked at tx usage, type 1 transactions were a tiny drop in the ocean of legacy and 1559 transactions",
        "created_at": "2021-10-01T18:41:31.685000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For context, my dream would be eradicating SELFDESTRUCT, access lists and state cache from 2200, because that would _greatly_ simplify the layer between EVM and client",
        "created_at": "2021-10-01T18:42:45.831000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's less of a concern for me now because \u003c@583892532644151312\u003e made an amazing job of making a reference Apache-2.0 implementation of execution module in C++, which I ported for Akula\n\nStill, if anyone wants to write client from scratch, dealing with those three is an absolute nightmare of debugging invalid gas metering",
        "created_at": "2021-10-01T18:47:02.998000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Rather than banning what about using the gas schedule to encourage the move?  10% increase at a fork, then 50% increase at each next fork.  Contracts don't entirely break because you can (in theory) throw more gas at the call (unless they gas limit sub-calls).  You could require the sender to pay the penalty, but that quickly devolves into a gas/oil debate again.",
        "created_at": "2021-10-01T18:50:36.340000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I like the idea of using economic incentives to move people away from features we want to deprecate/remove, but I would like to point out that this is only effective towards things that are being actively used and developed.  Consider something like a time lock contract written four years ago that is sitting \"cold\" for years waiting to be unlocked in 2025 which relies on SELFDESTRUCT to send the funds back.  We still have to do our due diligence to find these things because economic incentives can't and won't work for this type of case.",
        "created_at": "2021-10-01T19:17:05.399000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So the incentive should not be on SELFDESTRUCT, but on old container formats deploying from a TX or a CREATE call (or an old CREATE from a EOF container)",
        "created_at": "2021-10-01T19:19:39.885000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "hence mix and match EOF (an EOF contract CREATEing non EOF code) can get expensive, but if the ratchet is declared when the EOF containers deploy people can't be surprised.",
        "created_at": "2021-10-01T19:21:04.712000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Honestly, if someone gets broken by this, it's easier to do DAO-style fork to move the funds than design the whole system around it",
        "created_at": "2021-10-01T19:23:42.072000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh the FUD that would ensue... ðŸ˜¸",
        "created_at": "2021-10-01T19:25:33.781000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But yes, in the right situation, I could be convinced to get onboard with that approach.",
        "created_at": "2021-10-01T19:26:08.761000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Even without the timelock scenario I feel putting the incentive on the deployment directly from the TX and then from CREATEs within EOF contracts solves a lot of problems we won't be able to predict.",
        "created_at": "2021-10-01T19:29:55.380000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Charge an extra 5k gas or so and double it every 1-2 million blocks.  Perhaps step every 100k or 10k blocks (every day to two weeks)",
        "created_at": "2021-10-01T19:31:27.055000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e ... now I see why it's such a rabbit hole\nWe dug way, way down this hole years ago and never found the bottom.",
        "created_at": "2021-10-01T21:52:06.858000+00:00",
        "attachments": null
    }
]