[
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's said that `SELFDESRUCT` is problematic in a \"flat\" db representation. I'm working on a \"flat\" implementation (Nimbus) and it's not obvious to me why `SELFDESTRUCT` is seen as a big problem for the storage layer.\n\nAt the lowest db level it's a key-range deletion as opposed to single-key deletion, and both operations are similarly cheap with a db that supports a key-range delete operation.\n\nIn particular the cost of a key-range delete is _much_ lower than the cost of individually setting many storage slots to zero.  (Akin to O(1) as opposed to O(n), though that's technically incorrect), so the `rmdir` approach would charge too much gas, not reflecting the true cost of storage updates.\n\nAt the level of keeping previous states around until (and if) they are pruned, it's a bit like deleting contract bytecode nothing references any more: Older states refer to it, so it has to be kept around until and unless those states are pruned. I guess keeping track of when to key-range delete is imagined to be the \"incarnation counters\" implementation approach?\n\nThere has to be some implementation complexity, but it seems like a small thing compared with all the other implementation complexity required of a flat-style db with history ðŸ™‚",
        "created_at": "2021-10-14T11:19:23.677000+00:00",
        "attachments": []
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm wondering if I've missed something important, or is the above about right?",
        "created_at": "2021-10-14T11:25:49.032000+00:00",
        "attachments": []
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "the problem was that you have to move all that deleted storage into changesets, and then back if reorg occurs",
        "created_at": "2021-10-14T17:59:54.704000+00:00",
        "attachments": []
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "pretty expensive, so we have incarnation counters which \"mask\" previous versions instead",
        "created_at": "2021-10-14T18:00:24.859000+00:00",
        "attachments": []
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "and what \"other implementation complexity\" for flat-style db are you talking about? the only tricky part is computing state root - which we do in a separate stage - other than that the whole thing is really straightforward",
        "created_at": "2021-10-14T18:01:23.670000+00:00",
        "attachments": []
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, the DB stuff is not the only reason to ban selfdestruct; there's also the fact that it constricts the verkle tree storage layouts we can use and makes the best ones nonviable without ugly workarounds",
        "created_at": "2021-10-14T18:40:54.587000+00:00",
        "attachments": []
    }
]