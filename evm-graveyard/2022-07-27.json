[
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If I understand this proposal the child memory is limited by untouched parent memory, so if my 30m gas call places a byte at memory location 30_000_000 then the child will get zero memory?  And setting that byte to 1 and then to zero still leaves the \"high water mark\" for that frame?",
        "created_at": "2022-07-27T18:53:22.459000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think the concept is just that in order use memory you have to access it, and there no real expansion cost, so just charge a flat rate for access adequate to discourage quadratic attacks.",
        "created_at": "2022-07-27T18:58:04.744000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm digging to see if each child TX gets a fresh new frame of memory, because if so then the potential memory size is quadratic. If the model is that memory that hasn't been accessed is available to children then an impl could allocate 30GB and then move the \"zero\" position per child.  But we may need to zero out used memory on return.  If it's not reused then peak memory is 30m * 30m-114... etc to stack depth.  (this implies standard assumptions like memory isolation across frames)",
        "created_at": "2022-07-27T19:10:36.823000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Aha, I see what you mean.  \u003c@273808422753796097\u003e ?",
        "created_at": "2022-07-27T19:11:23.785000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My take is that each child gets a \"fresh\" frame with as much space left as it can afford.",
        "created_at": "2022-07-27T19:12:23.235000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think what I want is  point 3 of proposal 1 - `In a call, the child call frame gets at most gas - get_callframe_byte_size(parent_callframe) * GAS_PER_MEMORY_BYTE gas` but in all proposals.",
        "created_at": "2022-07-27T19:12:25.610000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Where get_callframe_byte_size(parent_callframe) is \"high-water mark\" of parent?",
        "created_at": "2022-07-27T19:13:03.152000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's in 2 but not 3",
        "created_at": "2022-07-27T19:13:04.388000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes",
        "created_at": "2022-07-27T19:13:07.320000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e ... move the \"zero\" position per child.  But we may need to zero out used memory on return...\nConceptually, each child gets its own memory space.  How that maps to physical RAM is an implementation detail.",
        "created_at": "2022-07-27T19:15:23.579000+00:00",
        "attachments": []
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So yeah -- it the implementation uses one big buffer it might need to zero out as it returns.",
        "created_at": "2022-07-27T19:16:26.432000+00:00",
        "attachments": []
    }
]