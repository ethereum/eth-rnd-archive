[
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You aren't alone in wishing there were more types, particularly hardware native types like 64-bit.",
        "created_at": "2021-03-16T03:39:44.965000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Well, yeah ðŸ™‚ and if there are none, we should scale the types back",
        "created_at": "2021-03-16T03:40:40.982000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There are some EIPs out there that want to constrain some types to 64-bit or 52-bit like gas limit, nonce, etc. (things that will never possibly exceed 52-bits).",
        "created_at": "2021-03-16T03:40:53.303000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "why 52-bit tho?",
        "created_at": "2021-03-16T03:41:16.584000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The largest safe integer that can be exactly stored in a 64-bit floating point.",
        "created_at": "2021-03-16T03:42:15.745000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Meaning, you can count from 0 to 2^52 with a double and not miss any numbers.",
        "created_at": "2021-03-16T03:42:42.147000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "After that you start having holes.",
        "created_at": "2021-03-16T03:42:54.269000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This matters because some languages (JS) only have doubles.",
        "created_at": "2021-03-16T03:43:17.465000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(technically they now also have unbounded size bigints, but the characteristics of them are very different)",
        "created_at": "2021-03-16T03:43:48.250000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And you can only send \"numbers\" over JSON and JS interprets all JSON numbers as doubles.",
        "created_at": "2021-03-16T03:44:15.659000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So... thu more places you can fit things into 52 bits the easier it is for JS integration.",
        "created_at": "2021-03-16T03:44:40.885000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "JSON strikes again",
        "created_at": "2021-03-16T03:53:11.292000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "all the more reason to drop jsonrpc lol",
        "created_at": "2021-03-16T03:53:19+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "GRPC wouldn't solve this particular issue.",
        "created_at": "2021-03-16T04:00:31.124000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "JS still doesn't have integers except for the new `bigint` which is an unbounded size integer and thus different to work with and significantly slower than a 52-bit integer.",
        "created_at": "2021-03-16T04:01:05.131000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The `2^52` is mostly a smile towards JavaScript, but you can safely use `i64` for implementation. But it may have some other limiting properties. E.g. for the current `2^63` gas limit the max call depth is ~1500 (because of the 63/64 rule and the call cost). But maybe with `5^52` the max call depth is \u003c 1024 therefore we don't need strictly enforce the 1024 hard limit.",
        "created_at": "2021-03-16T15:40:17.108000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The 256-bit `ADDMOD` and `MULMOD` is pretty handy for EC crypto stuff.",
        "created_at": "2021-03-16T15:41:10.520000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!329594653097721856\u003e if your concern is implementing `u256` then I have C++ library which can be later ported to Rust. I mostly tune it for LLVM or fix LLVM from the other side, so it should play nice in Rust too.",
        "created_at": "2021-03-16T15:43:17.967000+00:00",
        "attachments": null
    },
    {
        "author": "vorot93",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "we do have U256 and U512 by Parity, but I figured we could move to use native instead",
        "created_at": "2021-03-16T15:44:49.190000+00:00",
        "attachments": null
    }
]