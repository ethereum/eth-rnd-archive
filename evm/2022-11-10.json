[
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think the execution section of 5450 could be a bit clearer on the stack overflow check done during CALLF",
        "created_at": "2022-11-10T00:19:56.093000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "imo it should very explicitly state that the computed `max_stack_height+current_stack_height` must be less that 1024",
        "created_at": "2022-11-10T00:20:48.416000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You mean the `max_stack_height` of the callee?",
        "created_at": "2022-11-10T00:21:36.976000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yep",
        "created_at": "2022-11-10T00:21:46.905000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i'm on the fence about whether it would be better to just expand the type section to include  the `max_stack_height` or to leave it implementation defined",
        "created_at": "2022-11-10T00:23:09.769000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm rather in favor of adding this to the type section. But \"implementation defined\" may work too. The naive version is to store it in DB. But I recently thinking that more robust implementation should re-verify EOF loaded from disk (this should be relatively cheap comparing to IO). This way the values will be recomputed.",
        "created_at": "2022-11-10T00:29:42.318000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This just made me think that maybe we can also infer function types during validation... I'm currently reading about JVM verification algorithms and their biggest struggle are subroutines (a separate pieces of methods).",
        "created_at": "2022-11-10T00:33:20.256000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In terms of \"theoretical minimal amount of data stored\" I think it would be better for the storage to be up to implementations so we can store per code hash (or function hash?), but in reality I'm not sure if we would expand our contract type defn on disk (this was one of the whole reasons for EOF right?) and so instead we'd make a code hash \u003c\u003e max stack heights mapping and that would probably rival just storing in the type section",
        "created_at": "2022-11-10T00:33:36.943000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "why do you think impls should revalidate?",
        "created_at": "2022-11-10T00:34:30.436000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Just to make sure the code in DB is valid (bugs, wrong chain config, etc). EVM will likely crash on invalid EOF.",
        "created_at": "2022-11-10T00:39:52.547000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "that's fair, maybe a good place to start, but i think we'd really like to get to a place where it is truly a one time operation",
        "created_at": "2022-11-10T00:52:07.857000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We probably should design it in a way this is not required.",
        "created_at": "2022-11-10T00:53:58.258000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "how do you mean?",
        "created_at": "2022-11-10T00:54:18.242000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "in this case, include the number in the type section (so you don't need to recompute it or store somewhere else)",
        "created_at": "2022-11-10T01:08:36.286000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "oh i see",
        "created_at": "2022-11-10T01:09:58.654000+00:00",
        "attachments": null
    },
    {
        "author": "gumb00",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Some test vectors for EIP-4200 relative jumps https://github.com/ethereum/tests/issues/1093\n(no consensus tests yet)\ncc \u003c@543900561460822016\u003e",
        "created_at": "2022-11-10T18:09:55.624000+00:00",
        "attachments": null
    },
    {
        "author": "gumb00",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "will make the same for EIP-4750 soon",
        "created_at": "2022-11-10T18:10:19.641000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@543900561460822016\u003e \u003c@420242768875749376\u003e \u003c@403636673914863626\u003e Do you have `+ 3` constant in your `RJUMP` implementation?",
        "created_at": "2022-11-10T18:12:49.700000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "you mean to move pc past the op and it's argument?",
        "created_at": "2022-11-10T18:14:00.820000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "e.g. calculating relative offset from first byte _after_ the arg?",
        "created_at": "2022-11-10T18:14:24.533000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Somewhere there, yes.",
        "created_at": "2022-11-10T18:18:50.495000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i don't have a defined constant, just inline",
        "created_at": "2022-11-10T18:23:13.500000+00:00",
        "attachments": null
    },
    {
        "author": "gumb00",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Some test vectors for EIP-4750 EOF Functions https://github.com/ethereum/tests/issues/1094",
        "created_at": "2022-11-10T19:06:15.498000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That's what a mean. Maybe we should remove the reason for it? I.e. count the offset from the `RJUMP`'s position.",
        "created_at": "2022-11-10T19:11:24.966000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "oh i see - yeah iâ€™m indifferent to either approach, doing that would save a little arithmetic",
        "created_at": "2022-11-10T19:13:07.393000+00:00",
        "attachments": null
    },
    {
        "author": "gumb00",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Having it relative to + 3 provides a seemingly nice property \"valid forward jumps have offset \u003e= 0\"\notherwise it will be \"offset \u003e= 2\"\n\nbut probably not very important",
        "created_at": "2022-11-10T19:46:51.453000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Otherwise \"valid forward jumps have offset \u003e 0\"",
        "created_at": "2022-11-10T19:50:09.573000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hm, actually `RJUMP 0` with the assumption of +3 (as in the current EIP) means it also works as a 3-byte NOP instruction.",
        "created_at": "2022-11-10T20:40:37.202000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Same as `RJUMP 0003` in the other variant.",
        "created_at": "2022-11-10T20:44:57.518000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, but I was wondering if we should actually do `offset = imm + 1`, so be biased for forward jumps (this would remove the nop functionality) ðŸ™‚",
        "created_at": "2022-11-10T20:45:55.674000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i think the main practical difference is which direction are we biased towards",
        "created_at": "2022-11-10T20:46:23.152000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "currently is has bigger range for forward jumps and lower range (by 3 bytes) backwards",
        "created_at": "2022-11-10T20:46:44.863000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e The unsigned bytes branchbyte1 and branchbyte2 are used to construct a signed 16-bit branchoffset, where branchoffset is (branchbyte1 \u003c\u003c 8) | branchbyte2. Execution proceeds at that offset from the address of the opcode of this goto instruction. The target address must be that of an opcode of an instruction within the method that contains this goto instruction. \n\nLOL, I've built JVM.",
        "created_at": "2022-11-10T20:53:15.647000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@403707149043105803\u003e I finally reached to JVM spec and \"Verification by Type Inference\" (aka the old JVM verification algorithm) is what EIP-5450 aims to be. You precisely pointed it out some days ago, but I had a small detour in the whole JVM world. Comparison with JVM was always planned but we started by prototyping it \"intuitively\".\n\nNot sure if the license allows, but I could copy the JVM spec text and just remove the EVM irrelevant parts.\n\ncc \u003c@683653554631868440\u003e \u003c@275684146658148352\u003e \n\nhttps://docs.oracle.com/javase/specs/jvms/se19/html/jvms-4.html#jvms-4.10.2.2",
        "created_at": "2022-11-10T21:25:56.637000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The bit about requiring stack heights to be constant at every position is where I missed the linearity.  Otherwise two loops on two indexes is O^2.",
        "created_at": "2022-11-10T21:38:18.314000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "JVM spec license won't allow it without permission.",
        "created_at": "2022-11-10T21:38:47.226000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://docs.oracle.com/javase/specs/jvms/se19/html/spec-license.html - spec as a whole is licensed.  Remember Sun sued microsoft and oracle sued google, so probably better off not trying to adapt that section.",
        "created_at": "2022-11-10T21:40:56.106000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Are test cases for 5450 written up yet?",
        "created_at": "2022-11-10T21:41:50.729000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "```\n            # Check if stack height (type arity) at given position is the same\n            # for all control flow paths reaching this position.\n            if pos in stack_heights:\n                if stack_height != stack_heights[pos]:\n                    raise ValidationException(\"stack height mismatch for different paths\")\n                else:\n                    break\n            else:\n                stack_heights[pos] = stack_height\n```\nIt's the `break` there that gets you out of the loop in linear time.\n\nThat is, \"If we have been down this path before, don't go down it again.\"",
        "created_at": "2022-11-10T21:57:50.775000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "my thought on the reference implementation is to make it one loop, not two driven by a \"todo\" bucket.  For jumps we would do to branches for forwards and backwards, one to check if the height is consistant and one to set the forward value.  Only jumpdests would need to check the incoming stack height, all other ops just adjsut the current stack heights.",
        "created_at": "2022-11-10T21:59:53.328000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This could be fused with instruction validation",
        "created_at": "2022-11-10T22:00:38.630000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "it should be fused maybe the description is not clear",
        "created_at": "2022-11-10T22:01:11.073000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "All of the validation can share the same inner loop.  The outer loop could also be a recursion.",
        "created_at": "2022-11-10T22:01:52.754000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ah ok, it still has the separate call for clarity and to avoid spec duplication",
        "created_at": "2022-11-10T22:02:06.031000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but you do need to validate instructions to a certain extent upfront for jumps",
        "created_at": "2022-11-10T22:02:55.007000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "At some point I think it might be more clear to put the whole validation function together in one place?",
        "created_at": "2022-11-10T22:03:24.922000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "that's the idea here: https://github.com/ipsilon/eof/pull/13",
        "created_at": "2022-11-10T22:03:48.172000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also of interest is the (surprisingly brief) Wasm validation algorithm https://webassembly.github.io/spec/core/appendix/algorithm.html.",
        "created_at": "2022-11-10T22:14:57.582000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's brief because they leave stuff out\n\n\u003e Various instructions not shown here will additionally require the presence of a validation context for checking uses of indices. That is an easy addition and therefore omitted from this presentation.",
        "created_at": "2022-11-10T23:00:09.734000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes.  It still surprises me -- it's an Appendix to 175 pages of declarative specs.",
        "created_at": "2022-11-10T23:03:06.274000+00:00",
        "attachments": null
    }
]