[
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Stack validation will also probably need a re-write if you haven't gotten it done already since you can drop the work list and do each code section in-order.  (a) the min/max height is a bit different and (b) in-order makes the forward reference easy to check.",
        "created_at": "2024-04-18T02:37:25.278000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Besu agrees with all the tests in https://github.com/ethereum/tests/blob/develop/EIPTests, except they do not have EIP-6110 data in the blockchain tests, so they will fail for reasons unrelated to EOF.",
        "created_at": "2024-04-18T02:52:28.271000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is there a dedicated eof channel? Or where is the best place to ask EOF things?",
        "created_at": "2024-04-18T12:59:57.742000+00:00",
        "attachments": null
    },
    {
        "author": "pdobacz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No dedicated eof channel, so I think here is best",
        "created_at": "2024-04-18T13:14:10.968000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://github.com/ipsilon/eof/blob/main/spec/eof.md#new-behavior",
        "created_at": "2024-04-18T13:21:28.213000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "is this still the best-in-class thought for how contract creation in EOF should work?",
        "created_at": "2024-04-18T13:21:28.964000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e EOFCREATE (0xec) instruction\n\nthis section",
        "created_at": "2024-04-18T13:22:04.615000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Are there other alternatives that have been considered?",
        "created_at": "2024-04-18T13:22:11.621000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Here are some things we are aiming to finalize at the next meeting: https://github.com/ethereum/pm/issues/1020\n* https://eips.ethereum.org/EIPS/eip-7620 is the current proposal\n* Delaying TXCREATE and the Initcode Transaction is one option we may finalize next week\n* There is also a propsoal to use the payload of type 0, 1, and 2 (existing transaction) and calldata for direct creatoin (https://github.com/ipsilon/eof/pull/78)",
        "created_at": "2024-04-18T14:09:54.768000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ok so I have a much simpler counter-proposal:\n\n1. CREATE_COPY: creates a contract with the same code as a contract whose address is passed as input\n2. All *new* codes are uploaded using existing CREATE (or CREATE2) transactions",
        "created_at": "2024-04-18T14:30:41.768000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "are there any significant disadvantages of doing things this way?",
        "created_at": "2024-04-18T14:31:16.307000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "How do we make variable simmutable with CREATE_COPY, such as the pairs in a swap.  Right now those are appended to contract code.",
        "created_at": "2024-04-18T14:31:47.276000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "that would go into initcode, right?",
        "created_at": "2024-04-18T14:32:08.016000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "you could use storage slots; post-verkle that's not even more expensive than contract code anymore",
        "created_at": "2024-04-18T14:32:28.317000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Storage slots are malliable.",
        "created_at": "2024-04-18T14:32:36.963000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Putting the pairs in the data section makes it impossible to change, which is the goal IIRC",
        "created_at": "2024-04-18T14:33:03.447000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "what is the use case for a contract wanting to make its init-time params provably non-malleable?",
        "created_at": "2024-04-18T14:33:39.891000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "DEX swap contracts.",
        "created_at": "2024-04-18T14:33:51.063000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "hmm but if I trust a dex swap contract, I trust it to be non-malleable, and if I don't trust it, it can steal from me in many ways other than self-malleating?",
        "created_at": "2024-04-18T14:34:28.346000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's the auditors you have to persuade, because most people don't read the code and trust the auditors.  Auditors want immutables as an option.",
        "created_at": "2024-04-18T14:35:42.394000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Code never changing is a much easier sell then a memory address will never be written again.",
        "created_at": "2024-04-18T14:37:39.136000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "hmm I see",
        "created_at": "2024-04-18T14:38:21.055000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "for 2, this would prevent us from isolating EOF from legacy creation.  Either we would be required to keep legacy around to bootstrap contracts or we would need to allow CREATE and CREATE2 in EOF.",
        "created_at": "2024-04-18T14:38:26.365000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "and with CREATE/CREATE2 that opens the door to JIT contracts, which is something we were trying to design out.",
        "created_at": "2024-04-18T14:38:46.694000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A precompile could serve that purpose to seed contracts, but that increases the touch surface.",
        "created_at": "2024-04-18T14:39:38.814000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And is distinct from prior create methods.  We were also considering the needs of existing tooling.",
        "created_at": "2024-04-18T14:39:58.716000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "so in your \"ideal world\", a new piece of _code_ to go on chain only very rarely, basically each time a developer makes a new version of some application or wallet piece, and _data_ would go on chain regularly, potentially once per user?",
        "created_at": "2024-04-18T14:40:26.175000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I wouldn't say code is raraly deployed.  In my ideal world a factory only can ever deploy code known at the time the factory arrives on-chain, with extra data (non-code) that can be added.",
        "created_at": "2024-04-18T14:41:37.420000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "L2s can gatekeep and prevent code from entering the system to realize the \"new code is raraly deployed\" by monitoring the transactions w/o to addresses and making sure the contracts exist.",
        "created_at": "2024-04-18T14:42:25.185000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "so one option is enshrined delegatecall forwarders, so there's never any reason to actually \"deploy\" the same code multiple times",
        "created_at": "2024-04-18T14:42:43.289000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But how would we associate the immutable data with these forwared contracts?  You would still have to rely on storage",
        "created_at": "2024-04-18T14:43:21.204000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "we would have to introduce a new storage class.",
        "created_at": "2024-04-18T14:43:27.811000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That's kind of what we do with data, but it's still in the same storage class as the deployed code, just in an accesisble part of that code.",
        "created_at": "2024-04-18T14:43:58.392000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "right",
        "created_at": "2024-04-18T14:44:07.474000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ive been told starknet has an immutable storage class, only writeable when a contract is created.  I'm not sure if they have the same delegatecall model or if the immutable storage \"travels with\" any class of calls.",
        "created_at": "2024-04-18T14:45:30.886000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "btw side question: is there any significant use case for delegatecall other than making lots of copies of contracts with complex logic without having to pay huge amounts of gas to publish each one?",
        "created_at": "2024-04-18T14:46:14.571000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Upgradable proxies is another propular use case.",
        "created_at": "2024-04-18T14:46:41.282000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Diamond pattern could be fixed with larger contracts.  Delegate calling to libraries and treating then like DLLs puts us in the same DLL hell that windows 95/98 was",
        "created_at": "2024-04-18T14:47:29.973000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ah right",
        "created_at": "2024-04-18T14:50:27.989000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "At least for zksync, I don't think they have a delegatecall model exactly. They have strong system separation between code and data. And there is no distinction between initcode and runtime code, just code with a special \"constructor\" function. There is some storage region which is unwriteable after the constructor runs, and the constructor is blocked by the system after it has run once.",
        "created_at": "2024-04-18T20:24:31.563000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If storage is truly the same cost as loading data, we could honestly yea just use storage slots. The compiler already blocks writes to immutable variables; where they are physically stored is an implementation detail",
        "created_at": "2024-04-18T20:27:58.803000+00:00",
        "attachments": null
    }
]