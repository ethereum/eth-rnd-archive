[
    {
        "author": "tayvano_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Maybe Im misunderstanding but by \"doing it right\" do you mean for the chain to instill a one-size-fits-all auth contract instead of the developers of various invoker contracts?",
        "created_at": "2023-12-14T00:13:37.447000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Invokers can still add their own flair.  It would be the union of chain restrictions and invoker restrictions.",
        "created_at": "2023-12-14T00:16:29.945000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For examples, invokers can require their commit to have a time range.  But the auth precompile can also require the commit to not be in a revocation list.",
        "created_at": "2023-12-14T00:18:25.964000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "so it's the union, only commits with a valid time range and that haven't been revoked can be used by that invoker on that chain.",
        "created_at": "2023-12-14T00:18:52.721000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The precompile can also refuse to grant auth to a list of invokers with a similar lookup.",
        "created_at": "2023-12-14T00:19:16.016000+00:00",
        "attachments": null
    },
    {
        "author": "tayvano_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Can the precompile refuse to honor the signature to a list of generic recipients instead of specifically invokers? This would be a very, very  technically elegant way to mitigate the risk of malicious EOAs *and* contracts *and* invokers harming ordinary users............",
        "created_at": "2023-12-14T01:28:50.827000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The precompile can do whatever it wants with whatever context it keeps.  The auth could concievably be conditional to a small set of invokers (who calls the precompile) and receivers (the target of authcall).  It could keep state on-chain or off-chain.  Authorization could be stored in the precompile's transient memory and the implementation of the AUTHCALL could simply look at the transient variable instead of tracking a new auth field.  (the specific slot in the transient storage serves that role).",
        "created_at": "2023-12-14T01:32:00.321000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don’t think it can work within a precompile though? Aren’t they supposed to be along the lines of pure functions (or stateless might be a better word?).",
        "created_at": "2023-12-14T03:45:02.812000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Auth requires playing around in the stack",
        "created_at": "2023-12-14T03:45:35.315000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "L2s have a lot of \"system\" contracts, and the new beacon chain contract also breaks that.  Precompile has a mixed meaning in that regrard, between a \"pure\" and system contract.",
        "created_at": "2023-12-14T04:55:29.681000+00:00",
        "attachments": null
    }
]