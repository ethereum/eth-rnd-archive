[
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm slowly sending state tests for MCOPY: https://github.com/ethereum/tests/pull/1229",
        "created_at": "2023-06-20T09:05:13.130000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Actually, just finished with this. Waiting for cross-checking and reviews",
        "created_at": "2023-06-20T11:51:56.536000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "While browsing Python 3.13 news I've found copy-and-patch JIT architecture. Looks interesting. https://fredrikbk.com/publications/copy-and-patch.pdf\n\ncc \u003c@683653554631868440\u003e \u003c@570268431522201601\u003e",
        "created_at": "2023-06-20T11:55:55.637000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes I'm aware of this one, never found time to play with it though",
        "created_at": "2023-06-20T12:42:10.413000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sorry, I was out on vacation last week, just now spinning back into work.\n\nI think there is a vialble Strategy 3 that needs to be considered.  We also need to consider the possiblit of EOF only Layer 2s and appchains. \n\nStrategy 3 w/o legacy EVM and Data Copy:\nA standard solidity interface is developed that will retrieve the data for a contracts own storage and return it via returndata copy.  Instead of relying on 20 byte preamble data the contracts can be inspected with ERC-165 `supportsInterface` calls.  A single reference implementation can be used and EOF's CREATE3 and CREATE4 can then be used to add arbitrary data into the standard contract.",
        "created_at": "2023-06-20T14:13:29.693000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, you can only DATACOPY from the contract you are calling it in.  This (and code/data separation and code validation) have huge positive implications for ZK and cross compiled systems.  It encapsulates the handling of data inside the contract and thus bytecode or data segments do not need to be part of the universal set of data.",
        "created_at": "2023-06-20T14:15:41.895000+00:00",
        "attachments": null
    },
    {
        "author": "purplehat.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I see I see – so contracts who want to read the stored bytes of other contracts will need to do so by calling a method into said storage contract that exposes the bytes for reading via itself calling `DATACOPY` internally?",
        "created_at": "2023-06-20T17:53:35.746000+00:00",
        "attachments": null
    },
    {
        "author": "purplehat.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Curious why this wouldn't just be exposed via a standard pattern at the EVM layer rather than needing to be determined by way of convention.",
        "created_at": "2023-06-20T17:54:15.632000+00:00",
        "attachments": null
    },
    {
        "author": "zcstarr",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "and the strategy here to follow up with \u003c@505624166175735818\u003e  , is that we'd create some standard contract that would have a function called  arbi `readDataContract()`  and this code would call datacopy, and then we'd use create3 to store the arbitrary data in the data segment ? Create3 would then handle all the 20 byte preamble stuff etc.. under the hood ? \n\nThe standardization part required would be figuring out what interface name for reading data from the contract would be. The data segment write cost,  would it be immutable or equivalent in cost as the current write cost of creating a data contract ?",
        "created_at": "2023-06-20T18:08:49.638000+00:00",
        "attachments": null
    },
    {
        "author": "purplehat.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That sounds correct to me, IIUC.",
        "created_at": "2023-06-20T18:21:03.497000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "erc5202 (which vyper uses) depends on extcodecopy",
        "created_at": "2023-06-20T20:19:47.118000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "without extcodecopy afaict there is no way of executing initcode outside of having the initcode embedded in the contract itself?",
        "created_at": "2023-06-20T20:20:20.363000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "CREATE4 allows you to reference code in transaction data.",
        "created_at": "2023-06-20T20:21:06.429000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "uh sorry so looking at https://notes.ethereum.org/ZOEv9yyHQdmxTVaYiJmy9Q, can create3/create4 reference the code of another contract?",
        "created_at": "2023-06-20T20:23:18.351000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e 7.4 Copy-and-Patch Scalability As a baseline compiler, the copy-and-patch algorithm runs in linear time, requiring only two traversals of the AST and one traversal of the CPS call graph. Optimizing compilers like LLVM, on the other hand, contain non-linear algorithms. Figure 26 shows how the LLVM optimization levels scale as the input program size grows, on a synthetic function containing a sequence of statements that increment a variable by another variable. The performance of LLVM -O0 bogs down in instruction selection, while the higher optimization levels spend their time collapsing the increments into a single resulting statement. In both cases, however, LLVM compilation is increasingly slow compared to copy-and-patch as the source code size increases",
        "created_at": "2023-06-20T21:55:10.453000+00:00",
        "attachments": [
            {
                "type": "image/png",
                "origin_name": "image.png",
                "content": "e9d848a828b58d6bd4cd515a94fec548f172487d8fc569fe16cdeb1aa7787755"
            }
        ]
    }
]