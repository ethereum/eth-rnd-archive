[
    {
        "author": "bobsummerwill",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "comment - EOF Breakout Meeting 2 shows as Oct 18, not Nov 18.\nI don't have edit rights.  I am bobsummerwill on Github.",
        "created_at": "2022-11-24T08:44:48.249000+00:00",
        "attachments": null
    },
    {
        "author": "bobsummerwill",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hey \u003c@892053833121923094\u003e!\nIn the Breakout 2 call it was mentioned at the very end that you were working on some cross-client tests and that a link to that would be dropped in here?   Best wishes!",
        "created_at": "2022-11-24T08:59:06.313000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Both dates were wrong. The edit right is for everyone signed-in. But this may mean EF only.",
        "created_at": "2022-11-24T10:19:39.191000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There are two hard decisions to make about EOF.",
        "created_at": "2022-11-24T11:48:56.416000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "1Ô∏è‚É£ Gas costs for new instructions. I proposed one set of values based on analyzing what an instructions is suppose to do and comparing this with existing instructions. This makes new costs \"consistent\" with other instructions although the current gas schedule is far from ideal. See the checklist (at the bottom)",
        "created_at": "2022-11-24T11:52:48.139000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Solidity is concerned that JUMP/JUMPI replacement patterns not to be more expensive. But I have some reservations to this argument.",
        "created_at": "2022-11-24T11:54:10.106000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "2Ô∏è‚É£ If EIP-5450 Stack Validation goes in. I'm very much in favor. Some list of arguments in: https://github.com/ethereum/EIPs/blob/c98ba59b258407fc0116385a57c5862815c26422/EIPS/eip-5450.md#motivation",
        "created_at": "2022-11-24T11:56:42.343000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'd like also incorporate arguments from \u003c@403707149043105803\u003e and \u003c@683653554631868440\u003e: \"improves the feasabiliy of Ahead-Of-Time and Just-In-Time compilation of EVM code\". I agree with it intuitively and from EVMJIT project experience. But having an paper describing why and how this is better would be even... better.",
        "created_at": "2022-11-24T12:02:12.525000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We can also list all bytecodes doing it (what means pretty much everyone): JVM, WebAssembly, CPython, ... Although there is a difference between them and EVM. EVM doesn't have locals.",
        "created_at": "2022-11-24T12:04:59.991000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Although I'm spamming here regularly, it looks EOF has lost most of the attention.",
        "created_at": "2022-11-24T12:17:30.678000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Update to EIP-3860: Limit and meter initcode: Clarification when exactly the checks should happen in relation to caller nonce bump. https://github.com/ethereum/EIPs/pull/6040\ncc \u003c@211091239112671234\u003e \u003c@275684146658148352\u003e \u003c@583892532644151312\u003e",
        "created_at": "2022-11-24T12:31:31.452000+00:00",
        "attachments": null
    },
    {
        "author": "crypdough.eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We got this! (I've been keeping up with issues / spec and trying to hop in where appropriate for EOF) ü´°",
        "created_at": "2022-11-24T13:36:04.477000+00:00",
        "attachments": null
    },
    {
        "author": "marioevz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes sure, \u003c@543900561460822016\u003e and I have been working on an alternative framework to fill execution client blockchain tests using python: https://github.com/ethereum/execution-spec-tests\n\nI'm working on EOF test cases using this framework, but at the moment it's a draft (https://github.com/marioevz/execution-spec-tests/blob/eof-tests/fillers/eof/v1.py). The idea is that the `execution-spec-tests` repo should contain full EOF tests too, but at the moment it should not be considered a replacement for `ethereum/tests`",
        "created_at": "2022-11-24T14:16:04.604000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Validation is so important to me that I'm (almost) not sure I can support the rest of the EOF proposal without it.  I've tried to explain why in various proposals and discussions many times over the last 6 years, without much luck.  It seems to be completely obvious to most experts in the field, and very difficult to explain to non-experts, or to experts who don't understand the performance and security challenges of the EVM environment.  I'm currently surrounded by screaming children üôÇ as we celebrate American Thanksgiving here, so it will be a little while before I give it another try üòâ\n\nSo I'll just leave it to these thoughts -- The Java and Wasm teams went to a lot of effort to design VMs whose code can be validated in the ways that EOF is proposing, and can be validated in linear time.  Those same constraints make it possible to compile their code to machine code in linear time.  These are very successful VMs, and their designers know what they are doing.",
        "created_at": "2022-11-24T14:50:42.935000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm sorry I forgot about thanksgiving and ping many people these days.",
        "created_at": "2022-11-24T14:52:52.910000+00:00",
        "attachments": null
    },
    {
        "author": "0xsadcat",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "why not replace selfdestruct with deployment of a minimum self delegate proxy that uses a storage address for target (set to 0 during selfdestruct), and then new create2 instead deploys code to a new address + changes the target address in state?\nit would be constant code for all 'destructed' account, so still a special case, but should be easier to handle than infinite upgrades (a bool flag for 'destructed contract' instead of new code). it wouldn't be 100% compatible (esp. codehash, codesize) but should prevent bricking in all practical cases.\n\nas it is now, removing selfdestruct is virtually guaranteed to brick some unknown contracts. then those people will find about the fact slowly after the fork. then what, special-case eips to unbrick individual contracts? tell people 'sorry you're rekt'?",
        "created_at": "2022-11-24T18:23:31.927000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e The Java and Wasm teams went to a lot of effort to design VMs whose code can be validated in the ways that EOF is proposing, and can be validated in linear time.\nI agree, it is certainly worth understanding why exactly those designers picked those constraints, when designing or improving a modern VM.",
        "created_at": "2022-11-24T18:31:43.900000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Those same constraints make it possible to compile their code to machine code in linear time.\nAny program can be compiled to machine code in linear time in its size, regardless of constraints or even language. Clearly you mean something more sophisticated about generating _partially optimised_ machine code under some assumptions. Yet not fully optimised, because even the EOF validation and JVM/Wasm constraints aren't enough for linear time code generation above a certain level of standard optimisations. Thus their hotspot approach. There's a sweet spot in the middle where it's linear to generate and reasonably fast to run, but not as fast as it could be.",
        "created_at": "2022-11-24T18:33:26.835000+00:00",
        "attachments": null
    },
    {
        "author": "bobsummerwill",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Looks like you need ___@ethereum.org, yes.",
        "created_at": "2022-11-24T19:07:45.181000+00:00",
        "attachments": null
    },
    {
        "author": "bobsummerwill",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Aha - that is you?  Great.\nI watched all the sessions at DEVCON on that topic.   Looks like a great approach to me.\nThanks for the update.\n\nAt the ETC Cooperative we are also working directly with Dmitry Kholkov (\u003c@393119312350543872\u003e) on ethereum/tests.  Hopefully he can get some EOF tests up there soon too.",
        "created_at": "2022-11-24T19:11:18.912000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Each contract having a \"storage target\" which is a bit of state changed by selfdestruct is what implementations do already.  E.g. the account `incarnation` field in Erigon's database. It's just a number, which increments after each selfdestruct and account reuse to cheaply separate the storage address spaces under that account number.  It's simple and efficient.\n\nUnfortunately, selfdestruct complicates the timing of state history pruning (as does your idea) on databases without efficient range-delete.  (Some have it, some don't).  But I don't see how forcing the data to be kept around forever (by removing selfdestruct) is better, compared with implementations having the _option_ to prune it which they currently have.  So I've never understood the strength of motivation for removing selfdestruct, given how simple it is to implement aside from pruning, and selfdestruct pruning being a kind of optional optimisation which the change's main purposes is to prevent.",
        "created_at": "2022-11-24T19:26:56.998000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I tried to look for some rationale in WebAssembly design doc but having verification seems obvious  for a VM having types. The EOF stack validation is type checking with single primitive type.",
        "created_at": "2022-11-24T19:37:01.366000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e WebAssembly aims to execute at native speed by taking advantage of common hardware capabilities available on a wide range of platforms\n\nIn other words, it would non-starter for WebAssembly to do type checking at runtime. Then they have verification. EVM is doing type checking at runtime.",
        "created_at": "2022-11-24T19:41:27.561000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I've often thought the EVM would get a good optimisation improvement by detecting value ranges that fit in 32 or 64 bits, so that ops don't need to perform full 256-bit arithmetic, copying and checking.  Do you know if there's been any study of such optimisations?",
        "created_at": "2022-11-24T19:51:27.410000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't think so.",
        "created_at": "2022-11-24T19:52:52.884000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@403707149043105803\u003e \u003c@275684146658148352\u003e I believe I have figured out stack validation done in single pass, but instructions are not checked in order (although unordered inspection should be rare as forward unconditional jumps are rare). Does it help?",
        "created_at": "2022-11-24T20:05:38.871000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "How do you ensure you are not jumping into an immediate instruction?  How do you ensure dead code is valid?",
        "created_at": "2022-11-24T20:21:44.335000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'd have to see the algo but immediate code implies linear checks, unless we change what valid code means.",
        "created_at": "2022-11-24T20:23:07.076000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i need some time to write it...",
        "created_at": "2022-11-24T20:26:47.251000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I suppose if you left a \"to check\" list after you handle a terminal and do a dead code check at the end.",
        "created_at": "2022-11-24T20:32:54.380000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think there's an elephant in that room, or else I'm just misunderstanding something... The validator reference implementation ends with \n```\n   return max_stack_height\n```\nSo... What on earth do I do with that return value? Does it implicitly mean \"stash it somewhere (but not in state)\"? Because if it does, I think that's really bad. After a sync, every contract execution will have to do a full verification of every eof-contract it encounters, and store those `max`:s \"somewhere\". Which is a non-trivial resource expenditure too. \n\nIf we do store it in state, as part of the EOF format, then it becomes part of the sync-data. It adds a bit of overhead to the stored code. I don't know how much, but that _seems_ preferrable to me (Although, personally I still don't agree that it's worth it)",
        "created_at": "2022-11-24T20:45:17.493000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I also don't understand why these concerns are not listed in \"disadvantages\". I guess I must have misunderstood something again üôÇ",
        "created_at": "2022-11-24T20:48:03.936000+00:00",
        "attachments": null
    },
    {
        "author": "dimitry8570",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Some Eof tests already there, checkout releases",
        "created_at": "2022-11-24T21:21:17.287000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We are thinking about having the next breakout room on Friday 2nd Dec 2pm UTC.\n\nAny other time proposals?",
        "created_at": "2022-11-24T21:27:33.949000+00:00",
        "attachments": null
    },
    {
        "author": "bobsummerwill",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And hour later (or two hours later) would be great for those of us on the West Coast.  2pm UTC is 6am here.",
        "created_at": "2022-11-24T21:29:54.205000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We will stick it into the function type section. This is on the checklist with **NEW** tag. It wasn't there for longer. I sometimes miss a thing I was thinking some months ago. But not the list seems complete.",
        "created_at": "2022-11-24T21:33:39.385000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm in favor of having stack validation. The cost of not having it and being wrong is higher than the cost of having it and being wrong. We can always remove it in backward compatible manner.",
        "created_at": "2022-11-24T21:37:53.911000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But having 2 more bytes per function in the type section is disadvantage. I will add it to the list.",
        "created_at": "2022-11-24T21:38:40.859000+00:00",
        "attachments": null
    }
]