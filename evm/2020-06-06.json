[
    {
        "author": "holiman",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Went another route.. Iterate through the instructions, and if the op before a JUMP/JUMPI is a PUSHX, I store that. Then I keep a counter on what the 'highest' jump is. If we hit a RETURN lower than the (so far) highest jump dest, the the contract is safe. If we hit a BEGINSUB, then it's bad. \n\nA bit hacky so far, but this narroed it down to 50:ish contracts. The bulk of them seem to have failed due to non-PUSHX before JUMP, typically a pop, dup or swap, which makes my blunt approach fail.",
        "created_at": "2020-06-06T07:42:09.473000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I've also looked at the code a bit, and they appear to be data-storage contracts. I guess you'd delegatecall into them, and they would fill memory with a chunk of data. So it's for storing readonly data on chain",
        "created_at": "2020-06-06T07:43:10.266000+00:00",
        "attachments": null
    },
    {
        "author": "holiman",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So they're written in solidity, but portions of assembly probably make up the loading + data parts. I guess the use of assembly has prevented the optimizer from replacing PUSHX with something else in most cases - so for the most part they're pretty easy to analyze",
        "created_at": "2020-06-06T07:44:32.746000+00:00",
        "attachments": null
    }
]