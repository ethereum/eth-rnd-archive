[
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The numbers were assigned years ago based on not very good benchmarks. This can be improved and there is some work on this. But I would not compare KECCAK256 with ADD as they are in different categories. KECCAK256 is almost underpriced by design to be useful to contracts.",
        "created_at": "2022-07-21T09:40:10.216000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Your Add benchmark is probably wrong as it runs with almost infinite speed.",
        "created_at": "2022-07-21T09:41:31.442000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "KECCAK should be made massively more expensive at some point imo",
        "created_at": "2022-07-21T11:36:29.149000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Especially once we start needing to zk prove the EVM",
        "created_at": "2022-07-21T11:36:41.707000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Good catch the call was being elided since I wasn't using the result externally.  Will update the gist but new timing is:\n\n```\nBenchmarkRawAdd-8       62954121            17.33 ns/op\n```\n\nSo 20x instead of 1000x.\n\nedit: Also this shows that the EVM actually has very little overhead, as the `BenchmarkOpAdd256` that this benchmark was based on gets `BenchmarkOpAdd256-8       83738458            14.28 ns/op`.  Would be interesting to benchmark non-Go implementations but I'm not setup to do that quickly.",
        "created_at": "2022-07-21T14:48:56.830000+00:00",
        "attachments": null
    },
    {
        "author": "ryanleeschneider",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e But I would not compare KECCAK256 with ADD as they are in different categories.\n\nFWIW what got me started on this was thinking that w/ a 256bit word and 160bit addresses it might make more sense to use `address + some_constant_offset` for token balance lookup storage keys rather than a mapping since I assumed the hashing involved in a solidity mapping would be way more expensive than the add op, that's why I was comparing those two opcodes.  But what I found was that the gas savings wasn't as high as I expected, which led me to trying to find the rationale for the assigned gas costs.\n\nBut I disagree somewhat that they shouldn't be compared, since they are by definition comparable given the fact they are both assigned a gas cost. ðŸ™‚",
        "created_at": "2022-07-21T15:07:46.328000+00:00",
        "attachments": null
    },
    {
        "author": "treyzania",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "you could also do a EXP with a prime if you wanted the lookup to be more random, using a fixed offset could make certain attacks easier",
        "created_at": "2022-07-21T15:30:46.929000+00:00",
        "attachments": null
    },
    {
        "author": "treyzania",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "like if you have two mappings with different offsets you can trivially compute a key for one mapping that corresponds with the storage for another key in a different mapping and then use that to exploit type confusion\n\nedit: wait you could still do this for the prime exp trick",
        "created_at": "2022-07-21T15:32:29.540000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Keeping count of storage used by account doesn't seem particularly difficult.  All clients already have to track when storage slots transition between used and unused (zero) for calculating costs.  Though the count field would take up some space, for nearly all accounts it's a very small number.",
        "created_at": "2022-07-21T18:48:24.514000+00:00",
        "attachments": null
    }
]