[
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't see what is so simple here.  The multiple stages of swallowing up the EVM with RISC-V look none too easy to pull off, and the final architecture is none too simple either.  The RISC-V specification itself is hundreds of pages.  The absolute minimum integer core is \"only\" 40 very dense pages, but I don't know how much of the extended operations we will need.  Choosing and maintaining an appropriate subset of RISC-V and adapting it to run in the Ethereum environment is a piece of work in itself.  We went through all of this with eWasm.  And if gas counting is carried through to programs in the integer core the counting will overwhelm the computation.",
        "created_at": "2025-05-04T02:26:06.242000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And worst of all, we would be at the mercy of the RISC-V process, which will not be at all driven by our needs.  And we would be locked in to RISC-V, which is really just one of many attractive backends.",
        "created_at": "2025-05-04T02:26:52.548000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Much simpler, to my taste, is to retain the EVM (suitably extended) as our front end, with compilation of EVM code to RISC-V or other backends as needed.",
        "created_at": "2025-05-04T02:35:58.631000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The zkVM providers will likely drive that outcome.  Right now it appears RV32IM and RV64IM are the front runners, but it could be another zkVM if the space develops in a different direction.  We are not locking in today what that is.",
        "created_at": "2025-05-04T02:37:21.024000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One advantage of RISC-V of the front end is we can greatly simplify the gas schedule, and just count instructions or cycles (whichever makes things easier for zk). If \"precompiles\" are expressed in RISC-V and gassed based on cycle count we don't need to worry about degenerate performance cases.",
        "created_at": "2025-05-04T02:39:31.291000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I may not understand, but I'm not seeing the gas benefits outside of the zk context.",
        "created_at": "2025-05-04T02:49:39.714000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And I still submit that it is not only the ZK context that matters, and that we cannot assume that RISC-V will remain the base layer for ZK indefinitely, or that RISC-V itself will even remain supported indefinitely.",
        "created_at": "2025-05-04T02:56:58.384000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "OK.  The process and architecture here https://notes.ethereum.org/@ipsilon/eof-ethereums-gateway-to-risc-v  are much closer to what I have in mind.  The *RISC-V Backend, EVM or RISC-V Front End (2027-2029)* phase would likely start out with an *EVM Front End RISC-V Backend* as a product of the work on *EOF Adoption and Transpiler Maturation (2025-2027)*.   And 2029 is far enough into the future to leave us plenty of time to adapt to changes in the VM and ZK landscape.\n\nThe general architecture is the simple and familiar\n\n    HLL-\u003e Translator-\u003e EVM-\u003e Translator-\u003e Backend\n\nWhere a *Translator* can be any sort of interpreter or compiler.  We are not tied to any particular *Backend* or *Translator*, and can directly expose as much or as little of any *Backend* as we want. \n\n    HLL-\u003e Translator-\u003e EVM-\u003e Translator-\u003e | \n                                                                                 | -\u003e Backend\n    HLL-\u003e Translator----------------------\u003e |\n\nThe EVM will of course need at least some amount of change to enable effective, linear-time translation to RISC-V.",
        "created_at": "2025-05-04T04:27:53.415000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e the silence on introspection is notable, when we emulate EVM into RiscV, I assume we still allow gas and code introspection?\n\nIndeed.  I wonder how much of the \"ugliness\" we want to be rid of is intrinsic to the Ethereum environment,  which will need to be exposed to a RISC-V VM regardless.  And I don't know where the big speedup claims come from -- \"Data from Succinct shows a potential 100x+ performance improvement in many cases\"  -- link please?  I suspect that is just what you get for contracts written directly in RISC-V code instead of embedding an EVM interpreter.  Which is also what you'd get if you compiled EVM code to RiSC-V.  And I find it odd that objections to EOF included the work needed to both maintain client code and tooling for the old EVM and create new clients and tooling for the new VM -- even though the two VMs are very similar.  RISC-V makes that problem much worse.",
        "created_at": "2025-05-04T18:07:30.343000+00:00",
        "attachments": null
    }
]