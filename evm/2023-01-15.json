[
    {
        "author": "daniel.kirchner",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "To be clear, EOF for us generally still improves on code size in real-world scenarios, since it also brings a lot of savings in that JUMPDESTs vanish and jumps as well as function calls require a bit less code - but it's still unfortunate that we loose some means for deduplication, so restoring as much of that as possible would be nice. But yeah, since it's still a net win, and the relaxation of validation can be done later, it's not a showstopper for us.",
        "created_at": "2023-01-15T00:46:58.598000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The main advantage of the stack validation I see is the ability to do easy register based mappings on code transformations, to say something like MIPS that has a large number of registers. I see that as being a significant value add to future developments of the EVM.",
        "created_at": "2023-01-15T00:49:42.192000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Do we have stats about how much more code size can be reduced by softening the stack validation rules to allow what is desired for deduplication?",
        "created_at": "2023-01-15T00:50:16.924000+00:00",
        "attachments": null
    },
    {
        "author": "daniel.kirchner",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is that impossible with a weaker version? Note that I'm not asking to drop stack validation, but to change the algorithm to be more permissive.",
        "created_at": "2023-01-15T00:50:18.778000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It depends on how it is weakened.",
        "created_at": "2023-01-15T00:50:30.696000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "As it is currently written it makes it easy to do register mappings so that swap and dup operations are not actually written into translation to register based machines.",
        "created_at": "2023-01-15T00:51:10.202000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "By instruction count dup/swap is nearly 30% of executed bytecode.",
        "created_at": "2023-01-15T00:52:19.585000+00:00",
        "attachments": null
    },
    {
        "author": "daniel.kirchner",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No stack size increase/decrease on loops; validation of stack heights in the worst code path (implying all others to be valid). But there can be code paths that can be jumped to from different stack heights. I guess that *does* have implications for register mapping, but would be good to be clear on the implications. Might be easier once we'd have a concrete alternate algorithm.",
        "created_at": "2023-01-15T00:52:59.424000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "CALLF provides the most useful abstraction I think.  Would adding JUMPF help enough to make a measurable difference?",
        "created_at": "2023-01-15T00:53:37.290000+00:00",
        "attachments": null
    },
    {
        "author": "daniel.kirchner",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Depends on the case, in some cases JUMPF decreases the outlining cost, but it's never zero like for jump target deduplication.",
        "created_at": "2023-01-15T00:54:36.582000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One transpiling option is to deduplicate when stacks don't match.",
        "created_at": "2023-01-15T00:57:07.805000+00:00",
        "attachments": null
    },
    {
        "author": "daniel.kirchner",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You mean to (re)duplicate, right? As in assuming a weakened validation algorithm that allows deduplication here, transpilation could just reduplicate to something that'd pass the stricter algorithm? Sounds right.",
        "created_at": "2023-01-15T00:58:31.988000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yea, reduplicate.",
        "created_at": "2023-01-15T00:58:51.915000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I know Java requires this kind of stack validation, does dotnet and wasm have similar stack rules?",
        "created_at": "2023-01-15T00:58:58.491000+00:00",
        "attachments": null
    },
    {
        "author": "demiurgos_23",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think CIL does as well, not sure about wasm",
        "created_at": "2023-01-15T11:10:00.477000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Note this is also a function of how efficiently compilers perform stack scheduling. Optimal stack scheduling probably produces 30-50% fewer swap/dup/pop instructions.",
        "created_at": "2023-01-15T19:32:10.784000+00:00",
        "attachments": null
    }
]