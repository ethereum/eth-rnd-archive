[
    {
        "author": "frangio_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "proposal to change the definition of `m` in `EXCHANGE` to a more intuitive one,  as discussed in yesterday's call\n\nhttps://github.com/ipsilon/eof/pull/174",
        "created_at": "2024-12-12T13:17:01.432000+00:00",
        "attachments": null
    },
    {
        "author": "frangio_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "i assume this should be reflected in the EIP but wanted to discuss the change here first. let me know if you agree with the proposal",
        "created_at": "2024-12-12T13:17:35.139000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Disagree.  The m+n forulation was chosen for three reasons: \n\n(1) Increase the maximum reach.  Even though not all items within depth can be swapped equally it includes more items that would instead require multiple swaps.\n(2) Eliminate useless exchange points.  EXCHANGE[3,3] would be a no-op with absolute indexes\n(3) Eliminate redundant code point expressions.  EXCHANGE[2,3] and EXCHANGE[3,2] are the same exchange.\n\nThe delta formulation has 256 meaningful expressions.  The absolute has only 112 meaningful expressions. While assemblers may have a bit more work to make it human grokable, in the end reducing wasted space is important for a 1 byte immediate.",
        "created_at": "2024-12-12T14:04:49.714000+00:00",
        "attachments": null
    },
    {
        "author": "frangio_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "please note i am not suggesting changing the opcode encoding, just the conceptual `m` parameter and by implication the textual representation (this is in the pr description)",
        "created_at": "2024-12-12T14:09:32.979000+00:00",
        "attachments": null
    },
    {
        "author": "frangio_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "there's already a distance between `n`,`m` and the actual `imm` in bytecode (which currently contains `n-1` and `m-1` as nibbles). this pr is suggesting a different definition of `m` that seems more natural, without changing `imm` in any way",
        "created_at": "2024-12-12T14:17:38.974000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This way obscures a bit that m is a nybble.  and we still have n+1 and m+1.",
        "created_at": "2024-12-12T14:22:41.374000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "perhaps an intermediate i and j variable?",
        "created_at": "2024-12-12T14:23:02.815000+00:00",
        "attachments": null
    },
    {
        "author": "frangio_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ok, let me rewrite using those intermediate variables\n\nto be clear my only goal here is to make sure assemblers have consistent notation with the properties i laid out:\n- `EXCHANGE n m` = `EXCHANGE m n`\n- `EXCHANGE n m` = `SWAPN n SWAPN m SWAPN n`\ni think doing it directly in the spec will be the best way to achieve that",
        "created_at": "2024-12-12T14:25:23.701000+00:00",
        "attachments": null
    },
    {
        "author": "frangio_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ok updated the PR to match what i understood of this suggestion",
        "created_at": "2024-12-12T14:29:10.906000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think it's totally fine for the assembler to obscure what the encoding is.  Perhaps an escape sequence to hard-encode immediates?  EXCHANGE !0x45, RJUMP !0xfffd, etc.",
        "created_at": "2024-12-12T14:43:26.661000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "not sure if there are existing \"literal\" puncuation in assemblers.",
        "created_at": "2024-12-12T14:43:44.823000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My suggestion is I think it's going to save a lot of headache if the assembler doesn't do any encoding magic here. It should look transparent",
        "created_at": "2024-12-12T21:40:14.037000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If you really want a \"high level\" opcode, maybe represent it as \"SWAP N M\" so there is no confusion. And the assembler compiles that to EXCHANGE under the hood if it's more optimal",
        "created_at": "2024-12-12T21:40:32.914000+00:00",
        "attachments": null
    },
    {
        "author": "big_tech_sux",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm thinking about the \"pain index\" of somebody who is reading disassembled code vs bytecode. If there is a discrepancy, they need to memorize two rules: how it is represented in the assembly and how that is translated in the bytecode. So they need two mental models. If there is minimal translation, they just need one rule.",
        "created_at": "2024-12-12T21:42:15.714000+00:00",
        "attachments": null
    },
    {
        "author": "frangio_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "imo reading bytecode should not be the thing to optimize for, especially now that we'll have immediates all over the place (at least one of variable length), so we should optimize for reading assembly, and minimize differences between different flavors of assembly rather than between assembly and bytecode",
        "created_at": "2024-12-12T23:48:38.089000+00:00",
        "attachments": null
    },
    {
        "author": "frangio_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "note that eof code is 100% disassemblable, unlike legacy bytecode which doesn't distinguish data and code",
        "created_at": "2024-12-12T23:49:51.643000+00:00",
        "attachments": null
    }
]