[
    {
        "author": "albusdompeldorius",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is anyone aware of discussion / write-ups on how to simplify the execution layer once zk-EVMs become mature? I have some ideas about making the execution layer just be a zk-proof aggregation layer for several zk-rollups. This would simplify the core protocol in several ways, such as simpler gas metering, an upper bound on L1 state (each rollup has a fixed small state, and we could require each rollup to have at least 32 ETH balance, thus limiting the number of rollups).",
        "created_at": "2022-09-21T09:48:03.386000+00:00",
        "attachments": null
    },
    {
        "author": "albusdompeldorius",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm working on a write-up of the idea now, but would be great to know if there is already something written on this topic.",
        "created_at": "2022-09-21T09:49:17.475000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The challenge with a pure ZK blockchain is shared state.  For example, Uniswap gets multiple transactions in a block and their execution is dependent on current state and the current state changes with every transaction.",
        "created_at": "2022-09-21T13:18:49.009000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Since you have to generate a proof before you can craft/sign your transaction, you would constantly run into races when using something with shared state and high transaction frequency like Uniswap.",
        "created_at": "2022-09-21T13:20:00.885000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For non-standard state (e.g., ETH/token balances and transfers), this isn't a problem because the owner(s) of some bit of data can coordinate with themselves prior to generating proofs.",
        "created_at": "2022-09-21T13:20:45.689000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My guess is that you would want some sort of mixed mode, or you would need block builders to generate a whole-block proof, rather than per transaction proofs.",
        "created_at": "2022-09-21T13:21:25.826000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Disadvantage of whole block is that you don't get transaction/state privacy like you do with per-transaction proofs.",
        "created_at": "2022-09-21T13:22:12.529000+00:00",
        "attachments": null
    },
    {
        "author": "albusdompeldorius",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I was thinking one proof per batch of transactions, like in existing rollups.",
        "created_at": "2022-09-21T13:25:45.858000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Block builders generating ZK proofs would allow trustless light clients who don't execute the block.  With recursive proofs, you can even skip executing *any* blocks and validate whole chain with a single proof verification.",
        "created_at": "2022-09-21T13:26:42.975000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Again though, no privacy in this model which makes me sad.",
        "created_at": "2022-09-21T13:27:14.936000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(I'm assuming by \"batch\" you mean \"block\", as introducing some kind of sub-block batching would be unnecessarily complex)",
        "created_at": "2022-09-21T13:27:54.245000+00:00",
        "attachments": null
    },
    {
        "author": "albusdompeldorius",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Right, but it's not worse than what we currently have. I'd imagine you could build privacy rollups on higher layers.",
        "created_at": "2022-09-21T13:28:23.125000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm coming around to base layer privacy being critical.",
        "created_at": "2022-09-21T13:28:48.682000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Privacy by default, and people can drop privacy at higher layers if they want.",
        "created_at": "2022-09-21T13:29:16.215000+00:00",
        "attachments": null
    },
    {
        "author": "albusdompeldorius",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That would impose high storage requirements for the block builders right? Because they would need the state of every rollup. I was thinking a hierarchical system with individual proofs per rollup, and the block producer generates an aggregate proof for each block.",
        "created_at": "2022-09-21T13:36:55.620000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This would be just for L1, so storage would be \"similar\" to now.",
        "created_at": "2022-09-21T13:37:19.044000+00:00",
        "attachments": null
    },
    {
        "author": "albusdompeldorius",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ahh, I'm not suggesting merely enshrining a zk-EVM at layer 1. I'm suggesting allowing multiple zk-rollups in parallel at layer 1, where the proofs of them are aggregated into one proof in each block. One of these rollups could be a zk-EVM, but you could create others with different execution logic.",
        "created_at": "2022-09-21T13:43:27.370000+00:00",
        "attachments": null
    },
    {
        "author": "3xmd1559sporebraytondingo",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Is the text of EIP-3541 out of date, such as the 'Backwards Compatibility' section not mentioning the three superficial contracts (two single byte contracts and 0age's \"farewell\" message)?\n\nHowever it mentions:\n\u003e While this means no currently executable contract is affected, it does reject**s** deployment of new data contracts starting with the 0xEF byte.\n\nAs it stands I don't know if we went for an ISC or rejecting contracts starting with 0xEF or 0xEFF0 or 0xEF00 or so on.\n\nIn the 'Abstract' section it states:\n\u003e Code already existing in the account trie starting with 0xEF byte is not affected semantically by this change.\n\nWhile I'm not an author, I'd love if the existing text in the 'Rationale' section could be preserved, e.g. \"The `0xEF` byte was chosen because... Analysis in May 2021...\" sentences.",
        "created_at": "2022-09-21T14:33:29.700000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hard no on the ISC",
        "created_at": "2022-09-21T21:55:11.874000+00:00",
        "attachments": null
    }
]