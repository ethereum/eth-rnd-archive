[
    {
        "author": "zemse",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hey guys, can someone please help me with understanding the rationale behind the contract nonces to start with 1 (instead of keeping it as 0) \nEIP link: https://eips.ethereum.org/EIPS/eip-161.\nI guess it could be to prevent creation of empty accounts, but wanted to understand the harm in letting someone pay gas to create a contract with no code, zero balance (and zero nonce) which would get cleared at end of the transaction. (edit: but I think this guess is wrong because EVM doesn't seem to be able to tell the difference between contract with no code (nonce:1) and non existent account)\nThanks in advance!",
        "created_at": "2022-09-23T14:12:29.798000+00:00",
        "attachments": null
    },
    {
        "author": "paperliss",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Was looking at the gas prices of OP codes, noticed that ADD cost 3 and MUL cost 5 based on what I learned from the hardware classes I took and the fact that the EVM has 256 bit words shouldn't it make more scene to make MUL cost (256*ADD)?",
        "created_at": "2022-09-23T18:58:29.172000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The cost of doing the 256-bit arithmetic for MUL is not that high compared with ADD.  On a 64-bit CPU, typically 64x64-\u003e128 mul is almost as fast as 64+64-\u003e64 add/adc.   (It uses more energy and a lot more gates, which is maybe where you get 256*ADD from, but mul's latency in hardware is determined by the critical carry chain, and is actually not much different from add; also it can be pipelined).  A 256x256 mul uses 16 64x64-\u003e128 muls, then a bunch of 64+64-\u003e64 add/adcs to get the result.  Although that does make MUL more expensive than ADD which uses 4 64+64-\u003e64 add/adcs. it's still relatively little work as EVM opcodes go.  There's still the stack checking, bytecode switch, fetching operands and storing result as done with every opcode, which takes more time than the underlying arithmetic for these small opcodes and is why ADD doesn't cost 1 gas.  In the end, MUL works out similar cost on a modern CPU with fast multiply instruction.",
        "created_at": "2022-09-23T22:27:22.459000+00:00",
        "attachments": null
    }
]