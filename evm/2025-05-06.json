[
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Since they using a Rust EVM the easiest way get from EVM to RISC-V might be to transpile the EVM bytecode to Rust and compile that to RISC-V. That way the transpiler could reuse revm's implementation of each bytecode.  If the bigint library is pure Rust and the compiler is good it might just generate pretty good code, given it can see the entire program down into the libraries.  Not that I'm volunteering üòâ",
        "created_at": "2025-05-06T08:30:03.115000+00:00",
        "attachments": null
    },
    {
        "author": "ben_a_adams",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Really you want to do bigint as a \"syscall\" since won't be running RISC-V in any circumstances on actual RISC-V hardware (either x64 or ARM, or zk prover maths); and can do it better in Avx512 or even vanilla x64 (has 64bit -\u003e 128bit multiplies) than you can on Risc64 and then emulate on x64",
        "created_at": "2025-05-06T10:02:49.226000+00:00",
        "attachments": null
    },
    {
        "author": "ben_a_adams",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The only way RISC-V makes sense is mitigating some of the performance impact from zk; doesn't make sense from the point of view of actually executing the block (where it would be actually slower)",
        "created_at": "2025-05-06T10:06:03.453000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We are still talking about rv32im for Ethereum?",
        "created_at": "2025-05-06T10:25:24.371000+00:00",
        "attachments": null
    },
    {
        "author": "ben_a_adams",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think vibes have shifted to rv64im; since Polygon released their 64bit zk, and 64bit is more supported in upstream languages/runtimes",
        "created_at": "2025-05-06T10:26:45.013000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "üôè",
        "created_at": "2025-05-06T10:27:32.863000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You can lower EVM to LLVM IR or LLVM MLIR which is also used by rust. It also supports `i256` types out of the box. However, the main blocker is constructing CFG for EVM programs.",
        "created_at": "2025-05-06T10:33:34.226000+00:00",
        "attachments": null
    },
    {
        "author": "daniellehrner",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What I still don't understand is that RISC-V is a CPU instruction set and we want to replace the EVM with it. But we will still need to add a lot of custom instructions for SSTORE, SLOAD, COINBASE, etc. So in the end it wouldn't be a standard instruction set anyways and you couldn't run it natively on RISC-V CPUs because we need non-standard instructions. Am I missing something here? If not why not use an existing VM?",
        "created_at": "2025-05-06T12:55:37.886000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Those instructions would become system calls instead of opcodes.",
        "created_at": "2025-05-06T13:04:33.128000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You could provide a \"stub\" for the system calls that would provide the values at a certian point in the block and where the changeset could be extracted post-execution.",
        "created_at": "2025-05-06T13:05:26.144000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Most opcodes in the 0x30 and 0x40 series should probably not be opcodes anyway.",
        "created_at": "2025-05-06T13:06:33.874000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A lot fo stuff in he 0xf0 series as well would move to system calls.",
        "created_at": "2025-05-06T13:08:07.830000+00:00",
        "attachments": null
    },
    {
        "author": "ben_a_adams",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For risc-v probably 0x01 to 0x20 would be system calls also üòÖ",
        "created_at": "2025-05-06T13:20:46.314000+00:00",
        "attachments": null
    },
    {
        "author": "felix314159_",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://media.discordapp.net/attachments/1337018504141864963/1369313645829296139/8nc2fz.gif?ex=681b6835\u0026is=681a16b5\u0026hm=e569b6fa74140fe8b8fe21889b11fa3c98d4b5d92fb05ff051533d627260e03c\u0026=\u0026width=432\u0026height=242",
        "created_at": "2025-05-06T14:05:15.131000+00:00",
        "attachments": null
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Only half of them.  We will lose combo operations and the exotic operations like EXP, DIV, and SUB. üòâ",
        "created_at": "2025-05-06T15:22:01.762000+00:00",
        "attachments": null
    }
]