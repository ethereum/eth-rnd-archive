[
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I thought the point with ZK-provable code was that you don't have to run it on-chain. You run it off-chain and just post a proof that the outputs resulted from the inputs.",
        "created_at": "2022-03-14T12:58:34.913000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This is correct.  But if we want to slowly migrate to a ZK provable chain (or at least partially provable), then there will be a transitionary phase where code needs to both be executable by the EVM *and* executable by some separate ZK prover system.",
        "created_at": "2022-03-14T12:59:53.015000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My first reaction isn't good.  When ZK-stuff is up to snuff it doesn't have to wait.  You put up an EVM program with the proof as data.  When you run the program it inspects the proof.",
        "created_at": "2022-03-14T13:01:55.268000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "How is this different to 4750?",
        "created_at": "2022-03-14T13:02:10.015000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Instead of one entry point per code section there are several.",
        "created_at": "2022-03-14T13:02:46.165000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Why?",
        "created_at": "2022-03-14T13:03:03.633000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "First, because I'd already done it that way, so decided to put it out there.  I did it that way because I liked have code sections serve as modules rather than functions, and because I liked that the procedures within a module could share highly optimized private subroutines.",
        "created_at": "2022-03-14T13:05:30.708000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "With multiple entry points it seems to become increasingly complicated to validate stack heights at each possible entry point.",
        "created_at": "2022-03-14T13:07:02.558000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Especially as every single PC is a possible entry point based on the hackmd",
        "created_at": "2022-03-14T13:07:28.153000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't think it does -- I'm working with a mathematician on that now,",
        "created_at": "2022-03-14T13:07:31.419000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You start at the entry to the program and follow the control flow, so not every possible path will get followed that way.",
        "created_at": "2022-03-14T13:08:39.009000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That is, the control flow graph for the program looks the same  no matter how EOF partitions the code.",
        "created_at": "2022-03-14T13:09:48.578000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In some other place you stated to do this at deployment time. Are you suggesting to validate each function section by creating a CFG from every single PC?",
        "created_at": "2022-03-14T13:10:59.087000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, you traverse the CFG at validation time.  I've been proposing this for a while now.\nhttps://eips.ethereum.org/EIPS/eip-3779",
        "created_at": "2022-03-14T13:12:30.477000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "On a related note, some code storage is used only to hold subroutines called from other code, addressed by account number. This indirection takes up an account slot in the account Merkle trie that is perhaps redundant overhead: Larger trie to store, more hashes to store. If such calls could be made directly to code by its hash (or rather truncated hash), the accounts trie and history would be smaller, and the balance of storage optimisation might favour storing larger numbers of small code sequences as subroutines.",
        "created_at": "2022-03-14T13:12:44.117000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But here you have a very large number of entry points -- one would need to charge quite a bit of gas for validating all possible paths.",
        "created_at": "2022-03-14T13:13:05.224000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You don't validate all possible paths.  You validate the program.",
        "created_at": "2022-03-14T13:13:46.217000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That is, the CFG rooted at the first instruction of the first section.",
        "created_at": "2022-03-14T13:14:33.898000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Given all jumps and calls are static you can traverse the CFG in time and space linear in the length of the code.",
        "created_at": "2022-03-14T13:15:32.216000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I am talking about validating a function section in isolation. I think what you are saying is that it won't be done that way, rather traversing from some \"main function\" (if so that is similar again to 4750 where `code[0]` is special).",
        "created_at": "2022-03-14T13:18:25.291000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Exactly.",
        "created_at": "2022-03-14T13:18:49.840000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You could partially validate those sections, one procedure at a time, but that would be an offline thing.",
        "created_at": "2022-03-14T13:19:40.407000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e from some \"main function\" \nI 'm assuming EOF somehow has a single place where the contract starts running.",
        "created_at": "2022-03-14T13:21:23.041000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "btw I think it would be less confusing for the outside observer to provide change suggestions as opposed to creating competing proposals when the difference is a single thing: entry point to function is variable :)",
        "created_at": "2022-03-14T13:22:54.187000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Correct me if this assessment is wrong",
        "created_at": "2022-03-14T13:23:10.836000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sorry also need to be off for food, but will come back after",
        "created_at": "2022-03-14T13:23:40.042000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I agree.  It was easier for me to copy-and-paste the two docs together in hakmd.",
        "created_at": "2022-03-14T13:23:59.487000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If I decide they are worth moving forward with I can generate a diff and a PR.",
        "created_at": "2022-03-14T13:24:43.949000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(Breakfast time for me.)",
        "created_at": "2022-03-14T13:25:13.818000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I've just read EIP-3779.  The idea seems sound, though I felt \"Unsafe contracts are exploits waiting to happen\" could do with a rationale or examples of actual exploits which are prevented, since \"unsafe\" is a technical term here. It's not obvious that exceptional halts are a problem, nor is it obvious that some types of halts are a fine and others are not.",
        "created_at": "2022-03-14T13:29:07.948000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The problem is that exceptional halts are almost never intended by the program author.  But they can be discovered by an attacker.",
        "created_at": "2022-03-14T13:30:45.585000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That sounds like it would be good if the EVM compiler did the analysis and warned the author.  Or in cases like unbalanced stack leading to underflow, just didn't generate that code.",
        "created_at": "2022-03-14T13:32:29.668000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, a quality compiler can assure that.  This is a layer of self-defense.",
        "created_at": "2022-03-14T13:33:18.752000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's suddenly tempting to perform the analysis on all the existing code and see what turns up \\:)",
        "created_at": "2022-03-14T13:35:18.458000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, very tempting.  It could easily take a month of my  (uncompensated) time ðŸ˜‰",
        "created_at": "2022-03-14T13:36:24.528000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Given the other advantages of clean control flow I've figured that not being allowed to load programs that can crash would be a good thing, regardless.  I've thought that since 2015.",
        "created_at": "2022-03-14T13:39:47.043000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e could easily take a month \nActually, once EOF is integrated into a client and I have this integrated into that client it shouldn't be that hard.",
        "created_at": "2022-03-14T13:42:07.945000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Just sync a node with validation running on all code.",
        "created_at": "2022-03-14T13:43:16.184000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I neither agree nor disagree (because crashing can still happen, there's some analysis cost, its adds to EL complexity, and the constraints of EIP-3779 restrict some valid and useful code patterns, i.e. jump table things).  But my suggestion about the rationale/examples is because it would make the EIP more compelling for adoption if it showed with data that it would have prevented some exploits, or serious exploit potential in future.  Presumably, past contracts will have to remain in the system with their issues.",
        "created_at": "2022-03-14T13:47:04.925000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Better rationale always helps, thanks.",
        "created_at": "2022-03-14T13:47:57.438000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'd expect some perfectly good programs to fail because, as you point out, they use patterns that I'm disallowing in order to keep the analysis tractable.",
        "created_at": "2022-03-14T13:49:23.062000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I would expect that, in most cases, the analysis could be refined to allow those good programs.  Jump tables tend to follow simple patterns, which can be pattern matched or recognised with simple, linear-time dataflow and range analysis.",
        "created_at": "2022-03-14T13:50:42.545000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think we'd all like jumptable instructions, just wanted to put them off.  They aren't much used in practice, and can be done with if-else chains.",
        "created_at": "2022-03-14T13:51:53.572000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And yes, a more powerful analysis could detect a larger set of valid programs.  I'd start with what Solidity generates to see if those patterns could be handled.  But it's likely easier to just deprecate JUMP and JUMPI.",
        "created_at": "2022-03-14T13:53:47.322000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think there would be more value in an analysis that accepts nearly all _past_ contracts that will have to stay in the chain for foreseeable future executions, so does not rely on new opcodes; but only if the analysis is still reasonably easy to explain and implement.",
        "created_at": "2022-03-14T14:06:44.409000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That would be valuable, but I think fairly difficult.",
        "created_at": "2022-03-14T14:07:41.029000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It sounds almost like thesis-level research -- taking a formal specification of contract correctness and applying to entire the blockchain, with a lot of tweaking of the formal spec and the toolchain.",
        "created_at": "2022-03-14T14:09:18.033000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Easier might be to look at the versions of Solidity that generated most of that code to see if they had bugs that could emit bad code.",
        "created_at": "2022-03-14T14:10:16.125000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But I'm happy enough to fend off future demons.",
        "created_at": "2022-03-14T14:10:41.113000+00:00",
        "attachments": null
    },
    {
        "author": "jlokier",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't think so, in this case. The contract code is in the db of every implementation to easily iterate over, and the kinds of analysis we're talking about are fairly simple to implement, as you've shown in the pseudo-code in the EIP. The goal isn't to provide a proof that Solidity code never trips the analyser, it's to show that existing code rarely trips the analyser. Analysing all versions of Solidity to find codegen bugs seems like a much harder problem!",
        "created_at": "2022-03-14T14:13:24.435000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's only simple because I've constrained the code to keep it that way.  For arbitrary code with dynamic jumps the complexity is quadratic.",
        "created_at": "2022-03-14T14:14:56.875000+00:00",
        "attachments": null
    },
    {
        "author": "gcolvin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Analysing all versions of Solidity to find codegen bugs seems like a much harder problem!\nExcept that the team has already done that sort of quality control ðŸ™‚",
        "created_at": "2022-03-14T14:16:07.280000+00:00",
        "attachments": null
    }
]