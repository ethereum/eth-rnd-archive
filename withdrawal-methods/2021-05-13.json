[
    {
        "author": "dmitriishmatko",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I have tried to implement rewards withdrawal on the top of exit withdrawals proposal, please take a look, any feedback appreciated\nhttps://hackmd.io/@zilm/withdrawal-spec\nLink to rewards withdrawal section:\nhttps://hackmd.io/@zilm/withdrawal-spec#Partial-withdrawals-",
        "created_at": "2021-05-13T13:24:35.476000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "General question about the withdrawal process set in the doc: the restriction for only having a single withdrawal makes life difficult in user error situations.  It seems to me that it should be possible for partial withdrawals from active validators to be made easier (as well as full automatic withdrawals) if there was additional data in the `Block` structure.\n\nPartial withdrawals would be operations, similar to how exits are today.  Withdrawal requests would be signed by the *validator* key (as the withdrawal credentials may be an ETH1 smart contract, and this is analogous to exits).\n\nWhen the beacon chain calls the execution engine to generate an ETH1 block it also provides the list of operations that are active this block.  The operations are the explicit ones (partial withdrawals as above) and implicit ones (the automatic withdrawals as per the document).  The execution engine alters the balances of the ETH1 addresses as per the list of operations as part of its block processing.\n\nThis seems to be cleaner in a number of ways.  First, we aren't adding additional data to the beacon chain (outside of the list of withdrawal transactions in the beacon blocks).  Second, it unifies partial and total withdrawals.  Third, it allows for the situation where a user of a withdrawn validator accidentally deposits again to the validator (they can withdraw with an additional operation).\n\nAny thoughts on this as a flow?",
        "created_at": "2021-05-13T14:32:38.814000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Have you considered a design where we don't add a withdrawal registry? I'm wondering, why is it necessary to maintain a historical registry of withdrawals. We don't do this for deposits, is it really necessary for withdrawals?",
        "created_at": "2021-05-13T14:35:01.007000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "you need a merkle root for the execution layer to consume things from. You could dynamically build a root by maintaining the right-most branch of the tree like the deposit contract does but at the cost of complexity",
        "created_at": "2021-05-13T14:36:13.062000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The complexity trade off may be worth it to pay this tech debt now rather than later imo. I'd be interested in hearing more about this approach",
        "created_at": "2021-05-13T14:37:42.353000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "what is the technical debt you are trying to avoid? beacon state growth?",
        "created_at": "2021-05-13T14:38:47.850000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "there are other alternatives. Like a double-batch merkle accumulator",
        "created_at": "2021-05-13T14:39:01.017000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "like we do with historic roots",
        "created_at": "2021-05-13T14:39:05.302000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yes, another long list that is maintained in the state is what i am concerned about",
        "created_at": "2021-05-13T14:39:17.530000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "essentially, do a list of withdrawals per time period, then merklize that and put it in it's own list",
        "created_at": "2021-05-13T14:39:24.243000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "this bounds growth nicely and allows you to use ssz hash tree root out of the box",
        "created_at": "2021-05-13T14:40:08.587000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "right, like pending withdrawals or unclaimed withdrawals then moved into another structure or an updated root container?",
        "created_at": "2021-05-13T14:40:49.576000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Why do you need a merkle root for the execution layer?  As long as the beacon chain keeps its accounting correct, it should be possible for the beacon chain to provide the execution engine with a list of \"and do these transfers\" when it asks the execution engine for an ETH1 block, and the execution engine include said transactions.  Although the transactions could be invalid (e.g. \"give me all the money\"), that should make the beacon block invalid, relieving the burden on the execution engine.",
        "created_at": "2021-05-13T14:43:33.219000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "would it be inconvenient to use historical batch roots to get proofs of withdrawals that have been cleaned up from the state? do we need an extra accumulator for this specific thing?",
        "created_at": "2021-05-13T14:44:14.716000+00:00",
        "attachments": []
    },
    {
        "author": "dkdkdkdkdkdk",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I might be missing something obvious, but would it not be possible to just add a field to the beacon block with a list of \"eth2-\u003eeth1\" transfers that would get passed to the execution client together with the execution block?",
        "created_at": "2021-05-13T15:45:26.823000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "if you let the caller consume a merkleized receipt, questions of who pays for gas / metering are answered pretty nicely",
        "created_at": "2021-05-13T21:00:42.153000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "this becomes even more important as we move to smart contract withdrawals etc",
        "created_at": "2021-05-13T21:01:06.328000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "haven't looked at details so may be off on intuition here but if (pending) withdrawals are large relative to how frequently we batch a state root into the historical accumulator, it may be worth our while to have a separate mechanism",
        "created_at": "2021-05-13T21:02:47.340000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Who is the \"caller\" in the case of a withdrawal transaction?  Especially if the withdrawal is automatic, it seems like it's a call by the network rather than by a particular account on it.",
        "created_at": "2021-05-13T21:03:26.435000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "i haven't looked at the automatic withdrawals, let me go see",
        "created_at": "2021-05-13T21:04:12.472000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "i see -- yeah we could treat this w/ a gas subsidy like when you make a call in the EVM today",
        "created_at": "2021-05-13T21:11:36.080000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "for \"automatic withdrawals\" that is",
        "created_at": "2021-05-13T21:13:28.437000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "seems like if you  have a concrete withdrawal transaction you would need to specify an execution layer address to pay some gas, if only to move the ETH from consensus space to execution space",
        "created_at": "2021-05-13T21:14:29.490000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "so the way i'm thinking about it right now is that when sufficient conditions are met, some withdrawal record is stored in the beacon state",
        "created_at": "2021-05-13T21:15:43.906000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "then, some later time, a proof can be made in the EVM against the state root and it moves ether into the EVM",
        "created_at": "2021-05-13T21:16:16.049000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "looks like the \"system contract\" idea in this doc",
        "created_at": "2021-05-13T21:16:54.364000+00:00",
        "attachments": []
    }
]