[
    {
        "author": "ghosts_in_the_code",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "you are @technocrypto from the github, right?",
        "created_at": "2020-11-21T09:26:44.911000+00:00",
        "attachments": null
    },
    {
        "author": "ghosts_in_the_code",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "i didnt get how your proposal makes things any more feature-rich than just specifying a one-time withdrawal address",
        "created_at": "2020-11-21T09:27:12.749000+00:00",
        "attachments": null
    },
    {
        "author": "ghosts_in_the_code",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "this withdrawal address could be a smart contract which implements logic such as a changeable address for for further withdrawal, or an is_final bit",
        "created_at": "2020-11-21T09:27:47.157000+00:00",
        "attachments": null
    },
    {
        "author": "ghosts_in_the_code",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "as for backwards compatibility, people who have already deposited could also have the option (or mandate) to specify a withdrawal address now. Once specified it doesn't have to be changeable.",
        "created_at": "2020-11-21T09:28:41.855000+00:00",
        "attachments": null
    },
    {
        "author": "ghosts_in_the_code",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@!273808422753796097\u003e suggestion seems to be going for minimalism, whereas you are going in the opposite direction for a \"future meta-data rich standard\"",
        "created_at": "2020-11-21T09:30:03.916000+00:00",
        "attachments": null
    },
    {
        "author": "ghosts_in_the_code",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "so maybe we need consensus on that too, which direction is better",
        "created_at": "2020-11-21T09:30:17.783000+00:00",
        "attachments": null
    },
    {
        "author": "emansipater",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yep that's me!",
        "created_at": "2020-11-21T09:53:26.952000+00:00",
        "attachments": null
    },
    {
        "author": "emansipater",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The goal of DSWC is not \"feature rich\", it is to provide the fastest path possible to getting the most important features so that trustless pools will not be delayed any further.  Yes, you could do everything DSWC does in your own custom smart contract.  But if you were to actually write the logic to handle all of that it will take you much longer to finalise, audit, and deploy.  By contrast the DSWC could be done in less than a month even with third party audits, because of the simplicity of the proposal.  And nothing in the design would preclude adding more complex metadata later, which some people certainly do want.  But DSWC doesn't require any of that, it just doesn't preclude it either.",
        "created_at": "2020-11-21T09:56:16.692000+00:00",
        "attachments": null
    },
    {
        "author": "emansipater",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003e as for backwards compatibility, people who have already deposited could also have the option (or mandate) to specify a withdrawal address now. Once specified it doesn't have to be changeable.\nFirst of all, you still have design a way for them to do that, and it will end up looking very much like the DSWC.  So that's why I think DSWC is close to the minimal version we can deploy.\nSecond there are many good reasons to take advantage of the built-in features of BLS signatures for withdrawal keys (and some tools that have already been built are doing this so we don't want to lose support for that).  However right now there is no BLS support in the EVM, so it would not be possible yet to support these use cases via a contract, that would have to wait for a future hard fork.  Example:  one BLS key can be split into multiple parts, so that only when all parties agree, or a sufficient threshold of them, can they update the withdrawal address.  By not making all possible address assignments final we allow for this possibility.  By contrast, if there was no way to set any withdrawal contract at all, there would be no safe way to start sharing the validator status.  But as long as there is some contract set, every party is safe even if the others disappear. However they can update to any future contracts which are released to allow, e.g. tokenisation of exited funds or something like that.  So there are a large number of use cases supported at a very tiny additional complexity by allowing the is_final bit to determine whether an address is final or not.",
        "created_at": "2020-11-21T10:05:45.203000+00:00",
        "attachments": null
    },
    {
        "author": "ghosts_in_the_code",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "i dont really understand how BLS keys work well enough to answer, sorry, i think ill have to read up first. thanks for the detailed reply though",
        "created_at": "2020-11-21T11:39:32.004000+00:00",
        "attachments": null
    }
]