[
    {
        "author": "gezero",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "sorry for bothering you here with this. What is the agreement on the EL forking on timestamp vs on block number for shanghai?",
        "created_at": "2022-11-14T17:18:42.130000+00:00",
        "attachments": []
    },
    {
        "author": "gezero",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "how does it get mentioned in the genesis file?",
        "created_at": "2022-11-14T17:19:30.185000+00:00",
        "attachments": []
    },
    {
        "author": "barnabasbusa",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Nethermind has a flag `\"eip4895TransitionTimestamp\": \"0x63724b60\"`, which is basically epoch time converted to hex. Geth has `\"shanghaiBlock\": 1668434784`, which is also refers to actual epoch time and not a block (even tho the name has block in it, its more of a requirement of geth to use a \"block\" name.",
        "created_at": "2022-11-14T17:54:31.981000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So I'm lookin at the `EngineAPI` change. Particularly this comment:\nhttps://github.com/ethereum/execution-apis/blob/main/src/engine/specification.md#specification-3\n\n\u003e If withdrawal functionality is activated, client software **MUST** return error `-38003: Invalid payload attributes` if `payloadAttributes.withdrawals` is `null`. Similarly, if the functionality is not activated, client software **MUST** return `error -38003: Invalid payload attributes` if `payloadAttributes.withdrawals` is not `null`. Blocks without withdrawals **MUST** be expressed with an explicit empty list `[]` value.\n\nI'm interpreting this to mean that before the `Capella` fork, we must set `payloadAttributes.withdrawals` to `null` and after it must be a list, which may be empty",
        "created_at": "2022-11-14T21:14:06.395000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Is that a correct interpretation?",
        "created_at": "2022-11-14T21:16:56.745000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I ask because if this is a correct interpretation, this implies that we're basically replacing `engine_forkchoiceUpdatedV1` with `engine_forkchoiceUpdatedV2` even before the `Capella` fork.\n\nThere's some coordination around doing that.. we'd need to ensure all the execution clients support `engine_forkchoiceUpdatedV2` before the consensus clients could start using it..",
        "created_at": "2022-11-14T21:20:59.720000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The idea is that you can indeed replace it like that. The piece that's currently missing is that there will be a new method you can call to get a list of supported engine APIs and so you can easily check if V2 is supported or not before enabling it (you can do the same thing by detecting a method not found kind of error as well without it).  Of course you'll want to know that method exists etc...\n\nFor now in Teku we're planning to use V1 on any network where Capella isn't scheduled and V2 on any where it is. That way all the existing networks keep using V1 but Capella testnets will use V2 even before Capella actually activates so that functionality is tested.  We may need to tweak that before we start scheduling Capella on long lived testnets to avoid issues if people upgrade Teku before their EL but it depends a bit on how the EL support landscape looks at the time.",
        "created_at": "2022-11-14T21:40:02.534000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "ah perfect, thank you!",
        "created_at": "2022-11-14T21:41:16.969000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Petition to make the\n\u003e new method you can call to get a list of supported engine APIs\nsuper simple.\n\nLike can we just make it return a version number and not have to enumerate every supported method explicitly?\n\nIf you say you support version `N` that means you support ALL the `VN` methods; you don't have some weird situation where you support `engine_forkchoiceUpdatedV2` but you don't support `engine_newPayloadV2`..",
        "created_at": "2022-11-14T22:58:39.968000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "In discussions at devcon we settled on listing the specific supported methods. You can always map that to a simple value (ie if you don't support V2 of everything just use V1 everywhere) or you can be more selective (forkchoiceUpdatedV2 is really important to me but I just use newPayloadV1 all the time).  For Capella either approach works out the same really, but when there are non-hard-fork related changes (eg returning the amount of tips in a new block) the additional selectiveness of listing each method can be quite useful.\n\nPlus it avoids a lot of the messiness that happens with things like the eth sub-protocol where only a version is specified and then every change has to be supported in order and all at once which doesn't always fit well.",
        "created_at": "2022-11-14T23:02:23.615000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The other factor is that EL's largely already have a way of listing the methods they support - it's used by things like `geth attach` to provide autocompletion. Just not currently available on the engine API as far as I know.",
        "created_at": "2022-11-14T23:04:05.670000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003e EL's largely already have a way of listing the methods they support\nthis is the `rpc_modules` method and the response from this method looks like:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": {\n    \"admin\": \"1.0\",\n    \"eth\": \"1.0\",\n    \"net\": \"1.0\",\n    \"rpc\": \"1.0\",\n    \"web3\": \"1.0\"\n  }\n}\n```\nSo even in this case, the different modules represent a collection of methods that are all implemented and the version numbers represent methods updated to their latest version as well",
        "created_at": "2022-11-14T23:09:10.187000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "they don't explicitly enumerate every method and every version of every method",
        "created_at": "2022-11-14T23:09:49.694000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "hmm, interesting. I thought it was more detailed than that but I must have misremembered.",
        "created_at": "2022-11-14T23:10:34.868000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I'm not particularly strongly opinionated about which way the api should be designed to be honest. But I lean towards providing more information since it increases flexibility and you can still easily emulate a lower-resolution version (ie by considering \"V2\" supported only if all V2 methods are listed).",
        "created_at": "2022-11-14T23:12:03.434000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Let's define this question better.. the question is:\n\nDo we want to create a concept of a group of methods?\n\nIf we do, then the supported API can be expressed by enumerating the supported groups instead of enumerating every supported method.\n\nEither answer is maximally flexible and can express any API since the group case can emulate the non-group case by having every method be alone in its own group.",
        "created_at": "2022-11-14T23:24:06.032000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So far, the API methods we've got are conducive to groups. But as you said:\n\u003e when there are non-hard-fork related changes (eg returning the amount of tips in a new block)\nIf we support grouping by version number, then this change might be alone in its own version number (e.g. `engine_getPayloadV4`).",
        "created_at": "2022-11-14T23:28:44.671000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "and the `engine_supportedVersionsV5` response might be something like:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": [1, 2, 3, 4, 5]\n}\n```",
        "created_at": "2022-11-14T23:33:24.313000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Well it's only maximally flexible if the set of APIs in a group are what you actually want and they are all supported together.",
        "created_at": "2022-11-14T23:34:41.650000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "And currently we're versioning each method independently so saying \"2\" is supported doesn't provide enough info because there may be new V2 methods added later.",
        "created_at": "2022-11-14T23:34:42.841000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Wouldn't we have not made that decision yet? We've never added additional `V1` methods and we have now added `V2` methods for the first time. Since we haven't shipped `V2` yet we could still add methods to it, but if we did ship and we adopted this understanding of version numbers, then we would enforce that new methods be added as `V3`",
        "created_at": "2022-11-14T23:38:05.603000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I mean we could require adding a new version of every method for every change we make but it seems like an overly disruptive approach that generates a heap of extra code just to get a \"simpler\" versioning scheme.  I'm not really seeing what it would buy us.",
        "created_at": "2022-11-14T23:41:29.025000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "We could tag the engine API at a certain point and give it a release number which would enable that kind of versioning though without necessarily needing to move every API to V2 at the same time.",
        "created_at": "2022-11-14T23:55:37.400000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Overlap in overall version and method specific version numbers could create confusion but we could always use letter for the overall version or something like that.",
        "created_at": "2022-11-14T23:56:25.582000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I'm using version numbers as our concept of groups. The Ethereum RPC API has `modules` for their concept of groups.\n\nIt would not require \"a new version of every method for every change\"\nWe are still going to be using `engine_exchangeTransitionConfigurationV1` even after the engine API has reported that it supports `V2`, because that method didn't change in `V2`\n\nIt would only require a new version number when the engine API changes. Whether that change adds a single method or a bunch of new methods. I also think this lends itself naturally to splitting up the `specification.md` file into versions the same way we split the spec up into forks.\n\n\u003e I'm not really seeing what it would buy us.\nSo if we take that approach, the response to `engine_supportedAPIVersions` could be:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": [1, 2]\n}\n```\ninstead of:\n```\n{\n  \"jsonrpc\": \"2.0\",\n  \"id\": 1,\n  \"result\": [\n    `engine_newPayloadV1`,\n    `engine_newPayloadV2`,\n    `engine_forkchoiceUpdatedV1`,\n    `engine_forkchoiceUpdatedV2`,\n    `engine_getPayloadV1`,\n    `engine_getPayloadV2`,\n    `engine_exchangeTransitionConfigurationV1`\n}\n```",
        "created_at": "2022-11-14T23:57:38.237000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The second response seems a lot better to me though. It provides more accurate information and is self describing.  We don't have a reason to minimise data here and don't expect the supported method list to become particularly big.",
        "created_at": "2022-11-14T23:58:49.813000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "the second response gets longer and longer as we add changes",
        "created_at": "2022-11-14T23:58:54.114000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "You'd be dropping support for old versions of methods though.",
        "created_at": "2022-11-14T23:59:09.137000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "no because it reported that it supports the old version",
        "created_at": "2022-11-14T23:59:26.750000+00:00",
        "attachments": []
    },
    {
        "author": "ethdreamer",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "but it does allow the engine to drop the old version if it wants",
        "created_at": "2022-11-14T23:59:38.217000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "But you wouldn't support all old versions in practice. Particularly since in many cases they wouldn't work with new forks.",
        "created_at": "2022-11-14T23:59:48.838000+00:00",
        "attachments": []
    }
]