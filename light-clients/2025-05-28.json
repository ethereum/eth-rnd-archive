[
    {
        "author": "0xunclebill",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "came across a bit of an edge case w/ the light client header. pre-cappela the light client header is fixed ssz len, while capella and later its variable length. this causes a bit of an issue when ssz decoding in lighthouse. we don't know the variant of the light client header (in the case of the finalized header for example), without first decoding its `finalized_header.beacon.slot` but in order to register the type for decoding we need to know if its fixed len or variable len beforehand. i'm wondering if anyone else has come across a similar situation, or if this is maybe just a quirk of our ssz library",
        "created_at": "2025-05-28T20:10:42.448000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003cetan_status\u003e the variant is provided by context metadata.\n\nif you use libp2p, it comes in form of the ForkDigest-context.\n\nif you use JSON beacon-API it is next to the `data` field\n\nis you use SSZ beacon-API it is in the HTTP header",
        "created_at": "2025-05-28T20:27:56.477000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003cetan_status\u003e to properly check, the flow is:\n\n1. infer the fork from metadata (e.g., the gossip-topic contains the fork as part of the topic string. and for req/resp there is a wrapper around the SSZ payload that contains ForkDigest)\n\n2. parse the data according to the inferred fork\n\n3. check that attested_header.beacon.slot actually uses that fork (consistency check), as in, the data should actually be assigned to this fork and does not just randomly parse correctly",
        "created_at": "2025-05-28T20:29:53.760000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003cetan_status\u003e finalized_header does not determine the fork btw, the entire object is based on attested_header.beacon.slot",
        "created_at": "2025-05-28T20:31:23.249000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003cetan_status\u003e possibly with zero padding (if the newer fork added extra fields for execution_payload for example, you have to convert back to the object from the old fork).",
        "created_at": "2025-05-28T20:31:52.136000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003cetan_status\u003e there are tests in consensus-spec-tests that cover fork transitions, btw. there is a meta.yaml / steps.yaml that contains all the fork information",
        "created_at": "2025-05-28T20:32:16.747000+00:00",
        "attachments": null
    }
]