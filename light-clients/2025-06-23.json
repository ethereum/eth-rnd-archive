[
    {
        "author": "radekkapka",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I don't really care that much which version we return, so I am OK with returning the attested header's version, but it's not aligned with how the rest of the Beacon API works.\n\nThe description of `Eth-Consensus-Version` is \"The active consensus version to which the data belongs\" (and the `version` field must have the same value as this header). The light client update object contains more things than just the attested header, most importantly it contains a sync aggregate which is taken from the *incoming block which is always in the current fork*. Theoretically, if the sync aggregate object changes in a future fork, the version will be misleading in case the attested header is still before the change, and the client can have trouble unmarshalling the response. Similarly if any field is added/modified/removed from any of the returned objects. More generally, that's how all Beacon API endpoints work. If you consider https://ethereum.github.io/beacon-APIs/?urls.primaryName=dev#/Beacon/getBlockAttestationsV2, the attestation type did not change between Phase0 and Deneb, but the version is the version of the block because this data comes from the block. For attestations we take them directly from the block. For light client updates, we take some data from the block directly (e.g. sync aggregate) and create the rest indirectly (taking the parent root of the incoming block as the attested block etc), but the data still originates in the incoming block.",
        "created_at": "2025-06-23T11:22:47.660000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "it's a matter of perspective; it is true that the LC updates are unique in being spread across multiple data types. for attestations they never bothered to include phase0 attestations in electra data structures, we can't do that here though because there is only one aggregate signature per slot. \n\nkeep in mind, the signature_slot is not being signed over and only serves as a hint; there are also approaches that try to further reduce LC latency by fetching an early sync_aggregate _during_ the attested_header.beacon.slot (before a canonical sync_aggregate gets included in the next block). the model essentially being that slot N is the attested_header.beacon.slot, with signature possibly included in N+1 or later, and finalized pointing to an earlier slot (except genesis where it's same)\n\npractically, the Eth-Consensus-Version is used by clients to determine how to parse the object. as the signature is produced during attested_header.beaacon.slot and the data being signed is also from attested_header.beacon.slot, one can also argue for \"the data belongs\" being the attested_header.",
        "created_at": "2025-06-23T11:35:41.977000+00:00",
        "attachments": null
    },
    {
        "author": "radekkapka",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Sure, let's keep it as is, your reasoning makes perfect sense. Both approaches work similarly after all:\n- if we take the version from the incoming block, the client has to inspect `attested_header.beacon.slot` to know the exact structure of the attested header\n- if we take the version from the attested header, the client has to inspect `signature_slot` to know the exact structure of the update",
        "created_at": "2025-06-23T11:51:20.419000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yep, either works. it's just a matter of which one is considered to be the primary one",
        "created_at": "2025-06-23T11:53:57.426000+00:00",
        "attachments": null
    }
]