[
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Re 1, some reasons to not send the finalized header are extended non-finality periods where the `finalized_header` could be very old, in which case you want to leave it out to allow updating `next_sync_committee` (which is based on `finalized_header` if present). The protocol must still work even in those situations. Also, you may have clients using checkpoint sync that simply don't have access to a finalized header for historic data.",
        "created_at": "2022-04-05T14:18:58.559000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I don't get the point that how does the sync committee sign the finalized header? They can only sign the block from the last slot",
        "created_at": "2022-04-05T14:20:43.168000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "There is a mention of the case where finalized_header is not defined which implies that the attested_header is finalised header",
        "created_at": "2022-04-05T14:21:31.241000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I don't see how that can happen",
        "created_at": "2022-04-05T14:21:41.906000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Exactly. Having a specific validator be part of the sync committee is a very rare occurrence, and due to the light client not being able to verify the current slashing status of signers, adding a new kind of slashing condition would not protect historic data where a rogue validator was already selected in the past. They can keep making signatures for those periods even when they have been slashed. So, the slashing would not primarily help the light client or network security in general; it is weaker than the existing attestation and proposer violations.",
        "created_at": "2022-04-05T14:23:21.614000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "`finalized_header` in `LightClientStore` is not the same concept as the regular `finalized_header`. \nIt just means that the light client will not revert to data preceding it, i.e. that it now trusts the `next_sync_committee` and will no longer switch to a different one for that period.\n\nThe finalized header is not signed, it is included as a merkle proof.\n`BeaconState` contains a field called `finalized_checkpoint` and that one has a `root` and `epoch`. The `root` is referring to the `finalized_header` that is included with the `LightClientUpdate`. The signature is always for `attested_header`.",
        "created_at": "2022-04-05T14:27:05.652000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Like, you hash the `finalized_header` to determine its block `root`, and then verify that this `root` is inside the `finalized_checkpoint.root` field of `attested_header` using `finality_proof`.",
        "created_at": "2022-04-05T14:29:50.686000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I am checking the annoted doc by vitalik https://github.com/ethereum/annotated-spec/blob/master/altair/sync-protocol.md\nIt says `finality_header: if nonempty, the header whose signature is being verified (if empty, the signature of the header itself is being verified)` \nThis phrase confuses me. As per my understanding the sync committee always signs `header` which is the last block and they can always include the last `finality_header`. They will never sign the `finality_header` itself",
        "created_at": "2022-04-05T14:37:50.901000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The annotated spec is not up-to-date w.r.t. the latest spec additions. The fields have been renamed and the logic has become easier:\nhttps://github.com/ethereum/consensus-specs/blob/v1.1.10/specs/altair/sync-protocol.md",
        "created_at": "2022-04-05T14:40:00.539000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "In the old version, `finality_header` was indeed the one being signed (but this was not the finalized_header actually, but instead the attested header that contains the `header` as its `finality_proof` – so `header` would now be the `finalized_header`, and `finality_header` would be named `attested_header` now ). It was a confusing naming. If there was no `finality_header`, the one being signed was `header` itself.\n\nIn the new version, `attested_header` is the always the one being signed, and `finalized_header` is the finalized_header, if supplied.",
        "created_at": "2022-04-05T14:41:42.470000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Non-finalized `LightClientUpdate`:\n– Old spec: `header` / New spec: `attested_header` – `next_sync_committee` is rooted in this blockheader\n\nFinalized `LightClientUpdate`:\n– Old spec: `finality_header` / New spec: `attested_header`\n– Old spec: `header` / New spec: `finalized_header` – `next_sync_committee` is rooted in this blockheader",
        "created_at": "2022-04-05T14:45:49.751000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@!881905303011086387\u003e thanks for the clarification! This really made things better for me. Can you explain what is the `finalized_header` in the new spec? I was assuming it is the last `finalised_header` in the beacon chain as per the Casper FFG?",
        "created_at": "2022-04-05T14:51:16.814000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "As part of `LightClientUpdate`, it is the same as in Casper FFG (as in, it IS the same one referred to in the block's post-`BeaconState`'s `finalized_checkpoint.root`)\nAs part of `LightClientStore`, it just means that the light client considers it finalized and will not revert before it.\n\nThere are a couple conditions where the `LightClientStore`'s `finalized_header` may be updated irregularly:\n– In period of extended non-finality spanning more than a sync committee period (~1 day), verifying the update would not be possible with just the `next_sync_committee`. An even later sync committee would be required to verify.\n– When sync committee participation is low, there is not sufficient support to deem a `LightClientUpdate` safe.\n\nIn both of these situations, the light client is still expected to proceed / it must not become randomly stuck. The `best_update` may be applied as the next `finalized_header`, even when the light client could not determine safely that it was a finalized.\n\nBoth of the conditions are edge cases, so in normal operation, `finalized_header` is the same as for a full node.\nIn edge case, the `LightClientStore`'s `finalized_header` is a best-effort approximation of it.",
        "created_at": "2022-04-05T14:58:50.128000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@!881905303011086387\u003e I will re read the specs with those points in mind. Just confirming: in `LightClientUpdate` the `Finalized_Header` is always present as the last finalised block is always defined?",
        "created_at": "2022-04-05T15:04:29.017000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "– If `LightClientUpdate` includes a non-zero `finalized_header`, it always corresponds to the `finaliezd_checkpoint.root` at the time of `attested_header`'s post-state.\n– It may still be omitted for two reasons:\n   – The `finalized_header` is very old. In this case, including it would require knowledge of a far future `next_sync_committee` which the light client cannot access, to validate the `attested_header`. In this case it makes sense to omit the `finalized_header` as a server so the light client can at least follow along with `next_sync_committee` (which is rooted in `attested_header` if no `finalized_header` is included).\n   – The server does not have access to the `finalized_header` or its `finality_proof` for some reason. Examples:\n      –  `finalized_header` could be missing because the server is not in sync (checkpoint sync, doing backfill)\n      – `finality_proof` could be unavailable because it may require rewinding to old state to compute the proof, which is a costly operation that server may not be willing to do.",
        "created_at": "2022-04-05T15:10:32.417000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Updates without `finalized_header` are still useful, as a fallback for a delayed update using the `best_update` mechanism, and to update the `optimistic_header` in `LightClientStore`.",
        "created_at": "2022-04-05T15:15:36.931000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Hey guys! I think I found a vulnerability in the sync protocol. \n\nLet's suppose I have one participation in the sync committee and I control which network packets arrive at the light client. I wait for one slot update which has a 2/3 majority and is a finality update. Once the light client has accepted this (best_valid_update is none). Now I make sure no more network packets are being sent to the light client. I sign a false slot as I am in the current sync committee. I send this update to the light client (my update is the best_valid_update). After 24 hrs the light client will simply force update and consider my false update as the reality! Hacked?",
        "created_at": "2022-04-05T22:23:04.796000+00:00",
        "attachments": null
    }
]