[
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Thanks a lot for making a summary! I would prefer option (1) and EL block header instead of a few fields, cleaner spec and implementation and payload header data might be still relevant in the future when applications learn how to prove transaction inclusion with SSZ proofs.\n\nAs for LC architecture. I think it is more native way if CL light client drives EL light client and EL client uses parts of LES client protocol to request data from EL network when needed. But this won't be LES protocol as it used to be before, if my conclusion from what \u003c@202397237962211328\u003e has said above is correct",
        "created_at": "2022-11-25T11:30:09.871000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "so, a combination of (D) and one of (A), (B), (C)? EL block header needs one of A/B/C (or extra network request, as part of D",
        "created_at": "2022-11-25T11:32:01.966000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I would vote for (D). I am curious how do applications obtain EL payload header? via JSON RPC API?",
        "created_at": "2022-11-25T11:39:04.280000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I guess it's application dependent. For `nimbus_light_client`, we are decentralized so subscribe to full blocks gossip. But the EL payload header can be added to LC gossip easily. Problems arise when one wants to obtain the EL block header (not just payload header).",
        "created_at": "2022-11-25T11:46:24.881000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "But ultimately, the three transports for EL block  header are devp2p, JSON RPC, or portal. or some of the other decentralized options like POKT or Geth LES",
        "created_at": "2022-11-25T11:47:20.985000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Probably I have a misconception of LC design in my head. EL light node servers JSON-RPC requests for external applications as full EL node would do but with a limited functionality -- this is my mental model. It turns out that applications do implement EL light client and doesn't run EL nodes at all",
        "created_at": "2022-11-25T11:59:42.198000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "If the latter piece of my revisited understanding is true, then light client post merge should use CL only and can obtain EL payload header. It would be great if in this case an application would be able to work with SSZ proofs for transaction inclusion, and there would be a server that provided these proofs",
        "created_at": "2022-11-25T12:26:04.804000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "LC spans a broad class of use cases. Not all of them need the same data.\n\n‚Äì Wallets / Validating RPC proxys / Embedded devices / Smart contracts ==\u003e these solely consume data. They follow the chain, and ask other services for proofs that they can then validate against what they have. Currently, proof validation mostly uses `stateRoot` and `blockHash`. In case of wallets,  `logsBloom` is useful as well, and `transactionsRoot` / `withdrawalsRoot` would be useful to verify tx / withdrawal inclusion proofs. The other execution data proofs are all produced by the EL, and the EL doesn't know SSZ roots unless (C) is adopted, or another copy of the full EL block header is obtained (that includes the RLP trie root), via (A) or (B).\n\n‚Äì Full node ELs driven by light client CL ==\u003e this can be used to have the EL sync without a connected CL, or in a mixed design where the EL is given the latest block hash via light client protocol, while a full node CL is still syncing itself. These need `blockHash`, `blockNumber` and `parentHash` as part of engine API. Passing full EL block header would allow the EL to optimize some more, but is not strictly needed. Anything between the minimal three items, and the full EL block header, is not useful for the full node EL. If light client would pass SSZ txRoot, the EL would just toss that away and still needs to obtain the full block header.\n\n‚Äì Designs such as Geth LES ==\u003e these bridge the CL light client data into their own network, and have their own mechanism to syncing. I _think_ that they serve JSON-RPC requests as well, but they sync autonomously without engine API. For these, the current LC design seems to be perfectly fine.",
        "created_at": "2022-11-25T12:30:15.110000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "If \"a server that provided these proofs\" is the same server that provides the other execution data and proofs (`eth_getProof`, `eth_getBalance`, `eth_getStorageAt`, `eth_getTransactionCount`, `eth_getCode`, `eth_call` etc), that would essentially be (C), as in, just use SSZ in the EL side as well, for the withdrawals (and potentially the txRoot).",
        "created_at": "2022-11-25T12:32:21.629000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "And yes, anything beside withdrawals / transactions, is fine to use for the wallets, based on just the EL payload header. No need for full EL block header to do those",
        "created_at": "2022-11-25T12:33:14.465000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Without the `withdrawalsRoot` / `txRoot` in SSZ form on EL, not sure if you could make a compact proof inside EL. The SSZ roots are not hashed into EL block hash. So, without (C), would need to use separate server for withdrawals / tx inclusion proofs, that uses the CL format.",
        "created_at": "2022-11-25T12:35:03.177000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I am curious how a light client understands which exact transaction it want to ask a server for? Is this selection based on `logsBloom` magic?",
        "created_at": "2022-11-25T12:39:15.414000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I think if we moved to SSZ with proving transaction inclusion then CL would be the best part to ask for a proof",
        "created_at": "2022-11-25T12:40:24.089000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@783601578779082753\u003e \u003c@563394111214714881\u003e maybe you know more about this.",
        "created_at": "2022-11-25T12:41:57.791000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "could that interfere with tx/withdrawal proofing within smart contracts? Or would they use a different format based on RLP? Not sure if they can even access txRoot currently",
        "created_at": "2022-11-25T12:42:51.496000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Can you explain the problem? I am lost in so many messages before?",
        "created_at": "2022-11-25T12:43:25.941000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Sure, basically we are exploring how `transactionsRoot` and `withdrawalsRoot` can be used by a light client.\nFor transactions root, the obvious use case is proof of inclusion for a tx, e.g., knowing when it is confirmed and when it is finalized.\nBut, how does the light client obtain the transaction hashes for which it should collect proofs? The ones sent by the wallet are obvious, but for the ones received by the local wallet, how does it follow them? logsBloom, then download receipts, then obtain tx hash from there? different?",
        "created_at": "2022-11-25T12:45:28.075000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "It would have to be a different schema, I believe with current subset of block data exposed at the EVM level the only way to prove anything included into a block is by utilising BLOCKHASH operation which implies having deal with RLP and full EL block header. But I do believe smart contracts and light clients that rely on API may use different approaches. The case in which this mixed approach won't work is when light client have to obtain transaction with a proof and supply it to one of the smart contracts it interacts with.",
        "created_at": "2022-11-25T12:46:07.290000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "That is, assuming an SSZ tx proof? With RLP tx proof it should work, by using BLOCKHASH operation, supplying full block header, and the RLP proof",
        "created_at": "2022-11-25T12:48:07.150000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yes, assuming SSZ proof is used",
        "created_at": "2022-11-25T12:48:33.481000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I am trying to realize the cost of moving from RLP to SSZ in this particular context",
        "created_at": "2022-11-25T12:48:55.295000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The scope is essentially:\n‚Äì Withdrawal (the object itself. also, the EL currently uses wei, and the CL uses Gwei)\n‚Äì¬†withdrawalsRoot (inside the block header)\n‚Äì transactionsRoot (inside the block header)\nNotably, the individual transactions are also RLP encoded in CL, so they would not be affected",
        "created_at": "2022-11-25T12:50:13.931000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Do you mean `withdrawalRoot` in the consensus header?  \nThe `transactionsRoot` can be used to proof inclusion of your Tx into chain.  For any tx received by the user in native ETH there is no way to get the txs. You can only check and prove your current balance",
        "created_at": "2022-11-25T12:51:20.680000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Won't `logsBloom` tell you when someone sent you a tx inside a block?",
        "created_at": "2022-11-25T12:52:10.474000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Afaik `logsBloom` is only for events emitted by a contract?",
        "created_at": "2022-11-25T12:52:54.858000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Checking again `logsBloom`",
        "created_at": "2022-11-25T12:53:22.054000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "ETH transfers doesn't emit logs, they aren't factored in `logsBloom`. What about transactions that emit events? How do one decided that there is a relevant transaction in a block, and how one requests this transaction in a light client scenario?",
        "created_at": "2022-11-25T12:53:31.531000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Also, `logsBloom` has false positive signals",
        "created_at": "2022-11-25T12:54:34.820000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I don't think `logsBloom` is useful. You need to know the exact transaction where you received tokens (not native). Then you can ask for a receipt for the tx and prove the inclusion",
        "created_at": "2022-11-25T12:57:07.250000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Potentially you can ask any centralised block explorer for a list of tx where you received tokens and prove that list is correct using inclusion proofs",
        "created_at": "2022-11-25T12:58:22.249000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "This doesn't guarantee completeness! A malicious explorer can still hide some txs",
        "created_at": "2022-11-25T12:59:25.083000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "One have sent transaction to the network and using it's light client wants to get a proof of this transaction included on chain. For this to become possible one would need to send transaction hash to a full node and if transaction was already included a full node would be able to respond with the corresponding proof",
        "created_at": "2022-11-25T13:02:56.437000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "What are you trying to build?",
        "created_at": "2022-11-25T13:04:12.483000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I am trying to understand how light clients are utilised by apps",
        "created_at": "2022-11-25T13:04:43.028000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Have you checked out https://github.com/lightclients/kevlar",
        "created_at": "2022-11-25T13:05:12.543000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Basically currently apps use RPC so as long as we can expose the RPC out of a LC we should be fine",
        "created_at": "2022-11-25T13:05:36.846000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "This understanding might be important when we try to understand how possible it is to replace Hex trie roots with binary tree roots in a block header and how LC use cases would be impacted by this replacement",
        "created_at": "2022-11-25T13:06:35.668000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I don't get `replace Hex trie roots with binary tree roots`",
        "created_at": "2022-11-25T13:07:32.093000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "aah we are changing the trie data structure to be binary?",
        "created_at": "2022-11-25T13:07:53.436000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "instead of hex tries?",
        "created_at": "2022-11-25T13:07:59.361000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Not yet üòÑ CL uses binary trees, and `ExecutionPayloadHeader.transactionsRoot` is a binary tree root, this data structure doesn't contain old fashioned RLP Hex trie roots. The main question is, If CL light client does not supply a hexary `transactionsRoot` would it still be useful for applications?",
        "created_at": "2022-11-25T13:10:04.905000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Which header is kevlar currently using?\n‚Äì¬†EL block header \n‚Äì¬†CL `ExecutionPayloadHeader`",
        "created_at": "2022-11-25T13:10:44.602000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So let me explain how Kevlar currently works:\n\nLets assume that we have synced and know the latest `SyncCommittee` . Then we first fetch and verify `/eth/v1/beacon/light_client/optimistic_update` to the `block_root` from there. Then call `/eth/v2/beacon/blocks/${slot}` to fetch the block using the root. From there we get the execution block_hash and block_number. The execution block_hash and block_number is used by Patronum (https://github.com/lightclients/patronum) to expose the RPC endpoints. \n\nSo if you want to do `eth_getBalance` patronum would first fetch the block using `eth_getBlockByHash` , check if the hash matches the hash of the block, and take the state root from there. Then patronum does `eth_getProof` to get the proof of account and verify agains the state root.",
        "created_at": "2022-11-25T13:24:30.727000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Similarly if you want to do `eth_getTransactionReceipt`, first fetch and verify the block, verify the transaction in the transaction root of the block, verify the receipt in the recipt root, and then return",
        "created_at": "2022-11-25T13:25:46.354000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The `/eth/v2/beacon/blocks/${slot}` will not be necessary anymore regardless of the chosen design, the EL `block_hash`, `block_number` and `parent_hash` you will get directly via `LightClientUpdate` in the future üôÇ",
        "created_at": "2022-11-25T13:26:59.130000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Currently only the Tx root from the EL is being used",
        "created_at": "2022-11-25T13:27:10.654000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Both of these proofs can be done with `ExecutionPayloadHeader` as it contains `stateRoot` and `receiptsRoot`",
        "created_at": "2022-11-25T13:27:18.088000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yes this will be great",
        "created_at": "2022-11-25T13:27:25.324000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "That will be helpful as well as you might not have to download the block",
        "created_at": "2022-11-25T13:28:05.242000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I still see a value in providing a full payload header, LC may utilise `stateRoot` and `receiptsRoot` taken from it",
        "created_at": "2022-11-25T13:28:06.775000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yes, exactly, you will not just get `block_hash`, `block_number` and `parent_hash`, but instead the full CL `ExecutionPayloadHeader`.\nBut, as I understand, this would not be enough to kill the `eth_getBlockByHash` for your use case, because you are also using the EL block header's hex `transactionsRoot` to do transaction inclusion proofs?",
        "created_at": "2022-11-25T13:29:04.415000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "(It would help with the popular `stateRoot` and `receiptsRoot` use cases though ; for these, including the full payload header today would already kill the `eth_getBlockByHash` call)",
        "created_at": "2022-11-25T13:29:42.420000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "The main bottle neck for LC at the moment are `eth_call` and `eth_getLogs`. Both of them currently need multiple RPC calls get the result. We are planning to create a PR to Execution API repo for `eth_getReceiptProof` and `eth_getCallProofs`",
        "created_at": "2022-11-25T13:30:02.154000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Echoing, what you can't do with `ExecutionPayloadHeader` is to prove transaction inclusion. How important this capability is according to your observation?",
        "created_at": "2022-11-25T13:30:03.859000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yaah",
        "created_at": "2022-11-25T13:30:43.411000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@881905303011086387\u003e I think there should be a light client specification which should exactly explain how to verify each RPC after a successful light client sync",
        "created_at": "2022-11-25T13:34:54.432000+00:00",
        "attachments": null
    },
    {
        "author": "shresth",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "This will make sure that people are not reinventing the wheel",
        "created_at": "2022-11-25T13:35:43.493000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Not sure about the popularity of the transaction / withdrawal inclusion usecases, personally, sadly. My goal is to cover them as broadly as possible. \nBut if it is not that important, adjusting the EL format to match the CL format should not get much pushback?\nAnd if it is an important use case, having a consistent format seems rather key, also re smart contract based verifiers.\n\nPersonally I think at the very least, we should not repeat the problem with the withdrawals. Having different hashes for the same info is confusing at best.\nIt is actually worse for withdrawals, because there, the actual data itself is duplicated in RLP and SSZ formats (it is not just the root hash, and it also has the Gwei vs wei thing).\n\nFor the txRoot, if there is pushback, we could just treat it as a one-time exception, and track the RLP root as part of the executionpayload as well. \nugly, but beats injecting hex trie support into the CL (which is a push into the wrong direction, imo, as the CL managed to stay free of hex tries so far).\nThis way, the EL could proof _all_ execution data (pre-capella data in hex form, and withdrawals in SSZ form).\n\nBut, I can defend all the four approaches, including option D that essentially covers the use cases with exception of the tx/withdrawals root.\nIf we push those use cases to the future, at the very least we should have a plan on when / how to address it.\nUltimately, community should decide, based on all use cases. And, granted, the tx use cases seem to be a minority from my limited observation in this chat, compared to state proofs that provide obvious benefits. But, again, I'm looking for a generic solution here, not just a stopgap that only works because tx / withdrawals specifically happen to be not too crazily useful. The next field will come sometime üôÇ",
        "created_at": "2022-11-25T13:43:32.801000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Appreciate the feedback. Obviously, this is a new class of products, so we are all prototyping. Standardizing a way to obtain `ExecutionPayloadHeader` will be the next step towards unifying the wheels üôÇ",
        "created_at": "2022-11-25T13:44:23.662000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "What I'd also like to see, is actual opposition to use SSZ for `txRoot` inside the EL with Shanghai onward. \nSSZ libraries should exist for all the programming languages, and SSZ seems to be generally regarded as \"better\" than hex tries (again, welcome for counter args)",
        "created_at": "2022-11-25T13:48:32.116000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I think we will have to deal with a burden of different encoding schemes between the layers. We can try to ask EL client devs to use SSZ for withdrawals, I don't want to guess how successful this ask will be üôÇ\n\nMy conclusion is that we should add `newPayloadHeader` call because `ExecutionPayloadHeader` appears to be useful in a several cases. And we shouldn't add Hexary trie roots as currently there is no scenario where having this information is a must. For `transactionsRoot` I feel like we will stay with falling back to `eth_getBlockByHash`, an alternative would be `eth_getBlockHeaderByHash` -- a more lightweight version of the previous call if having a light weight version is anyhow beneficial.",
        "created_at": "2022-11-25T13:55:51.800000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I very much appreciate this fruitful conversation during which I learned a lot about LC. Thanks a lot for that!",
        "created_at": "2022-11-25T13:56:20.673000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "In ideal world we're getting rid of EL blockchain and using EL clients as EL state transition function providers, then different representations of the same thing will go away in a natural way",
        "created_at": "2022-11-25T13:59:38.519000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "re `newPayloadHeader` on engine API, I think that it would be better to use just the minimal `block_hash`, `block_number` and `parent_hash` there, and to replace it with the full header once it is possible to derive the full EL block header from the payload header.\n\nRationale being that the EL currently has no way to verify the SSZ roots if we pass the full payload, so it cannot issue `VALID` / `INVALID` verdicts, even on blocks that it already knows (duplicates). Without providing the full EL block header, the EL will still need to obtain the full EL block header (and in case of a full node EL, the full EL block), that would just include the data anyway that we would pass via engine.",
        "created_at": "2022-11-25T13:59:57.433000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "If the SSZ for withdrawals transition proves fruitful, the situation is different again (as then, it is really just the txRoot that still differs, and nothing else, including in the future). But without that going, I think just the three fields for engine is good enough (but keep full payload in the LightClientUpdate)",
        "created_at": "2022-11-25T14:01:01.298000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "CL ---\u003e full payload in LightClientUpdate ---\u003e LC --\u003e hash/number/parent --\u003e EL",
        "created_at": "2022-11-25T14:01:33.586000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "But full payload is heavy, right? Why would it be valuable to have it?",
        "created_at": "2022-11-25T14:02:27.201000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "sorry, payloadheader",
        "created_at": "2022-11-25T14:02:41.349000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "CL ---\u003e full ExecuionPayloadHeader in LightClientUpdate ---\u003e LC --\u003e hash/number/parent --\u003e EL",
        "created_at": "2022-11-25T14:02:53.136000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "it would enable the wallet use cases, for example \u003c@563394111214714881\u003e 's kevlar, with the exception of tx/withdrawal proofs",
        "created_at": "2022-11-25T14:03:26.464000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I see, I still vote for full `ExecutionPayloadHeader` in the second step (sent to EL) because of simplicity and use cases utilising `stateRoot` and `receiptsRoot`",
        "created_at": "2022-11-25T14:03:42.771000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "that one is just for engine API",
        "created_at": "2022-11-25T14:04:01.318000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Got it",
        "created_at": "2022-11-25T14:04:18.762000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "a wallet / validating proxy does not use an EL",
        "created_at": "2022-11-25T14:04:21.404000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "it is an integrated solution, that only operates with remote services to obtain proofs",
        "created_at": "2022-11-25T14:04:32.053000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Can we extend forkchoiceUpdated with these handful of fields? Particularly, with two more fields",
        "created_at": "2022-11-25T14:05:16.420000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Was thinking about it, but would rather not, as you may want to update finality without repeating the new head each time, and as you may want to supply headers without requesting fork choice to update",
        "created_at": "2022-11-25T14:05:56.131000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Like add `headBlockNumber`, `headParentBlockHash`",
        "created_at": "2022-11-25T14:05:59.527000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "ah, you mean, only for the head not for the finality",
        "created_at": "2022-11-25T14:07:03.171000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "but would still rather not. it would require fork choice stores to keep those values in memory all the time",
        "created_at": "2022-11-25T14:07:50.249000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "the `newPayloadHeader` / `newPayloadMetadata` whatever it's called has the advantage that you can call it once when obtaining the new `ExecutionPayloadHeader`, and then just discard it",
        "created_at": "2022-11-25T14:08:23.449000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "fork choice only needs to remember the block hash",
        "created_at": "2022-11-25T14:08:35.468000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "(and `forkchoiceUpdated` is not just used by the light client, but also by full nodes)",
        "created_at": "2022-11-25T14:08:54.876000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Very good point üëç",
        "created_at": "2022-11-25T14:12:51.554000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I still feel like using `ExecutionPayloadHeader` is cleaner in terms of the spec and implementation, might be useful in the future, and the overhead seems negligible",
        "created_at": "2022-11-25T14:43:49.666000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Tho, metadata required for sync won't change if payload header structure has been updated, so, it's gonna be pretty stable endpoint throughout forks",
        "created_at": "2022-11-25T14:44:40.276000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So, I do see pros and cons for both approaches but don't have a super strong opinion to argue in favour of any of these two",
        "created_at": "2022-11-25T14:54:00.965000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "For the CL light client protocol, yes, full header is fine.\n\nFor the engine API, there are three levels of usefulness:\n1. `block_hash`, `block_number` and `parent_hash` --\u003e allows syncing\n2. full EL block header --\u003e allows optimizing away a couple redundant network requests\n3. full EL block --\u003e eliminates network requirements completely for the purpose of following the chain\n\nSince EL needs to obtain the EL block header anyway, and given that it lacks any SSZ support and cannot easily judge validity of `ExecutionPayloadHeader`, I think sticking to the minimal form seems the most honest (w.r.t. current practical reality). If we see the `withdrawals` functionality being moved to SSZ, then the gap to pass full EL block header shrinks dramatically, and agree that full EL block header would be better.\n\nPassing full payload via engine would be useful, though, in allowing the EL to transition to SSZ roots autonomously, without requiring an engine API bump. However, until that is the case, it would not be possible to validate consistency of the provided payload header within the EL (early reject logic), as the `block_hash` cannot be validated without obtaining the RLP block header. So, basically, would make it tricky to properly issue `VALID` verdict to duplicate headers.\n\nAgree that there are valid arguments for both strategies.\n\nRegarding \"stable endpoint\", not entirely true, because the engine API uses yet another serialization in form of JSON, so needs periodic updating to cover newly added fields. Also, it is kinda unique in a way because it uses a single endpoint for representing any spec fork's `ExecutionPayloadHeader` - you can use the V2 endpoint for both pre-Capella as well as post-Capella payloads.\n\nPersonally, would go for minimum to start, and, if we see the change to SSZ happening, update the API to full header. If there is pushback, keep it at minimum.\nChange to SSZ should be adopted for withdrawals / txroot regardless of light client protocol.",
        "created_at": "2022-11-25T15:27:37.322000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Regarding `VALID` verdict, maybe is also alright to just to `ACCEPTED`. The light client does not benefit in knowing that it's valid, I think. But still, kinda pointless to push the SSZ roots",
        "created_at": "2022-11-25T15:31:59.936000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "I guess it really depends about the willingness to _eventually_ move those to SSZ. If we already know that it will never happen, full header is a bit meh",
        "created_at": "2022-11-25T15:32:48.786000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yeah, not sure. at least Besu right now, from what I observe, they usually process the entire block in `newPayload` then return `VALID` there. \nIdeally, the `newPayloadHeader` would follow same behaviour, and requiring the SSZ would require SSZ validation of the tx (once obtained) to match behaviour.\n\nNot sure how big of a deal that would be though. Realistically, as `newPayloadHeader` by design will require network access to obtain body / tx (unless trivial cases like early reject INVALID due to cache or inconsistency, or early VALID due to duplicate), we should probably expect `SYNCING` from those clients as well.\n\nThere is another aspect though, namely, pessimistic sync CL. They depend on `newPayload` eventually providing a final verdict (periodic retries), and refuse to optimistically import a block and then later check it with `forkchocieUpdated`. Also sort of a niche, but I think putting stones in a way for `newPayloadHeader` to match that behaviour by requiring SSZ may hurt that case.\n\nSo, yeah, if there is willingness to eventually move certain things in EL to SSZ, I think it's alright. But if there is not, I'd stick to the minimal hash+number+parent combo for now, so that duplicate block can be reported as `VALID` without adding SSZ dependency to the EL.",
        "created_at": "2022-11-25T15:48:06.617000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@654267572107083777\u003e maybe related to pessimistic sync.",
        "created_at": "2022-11-25T15:48:22.222000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Also, given that light client delegates fork choice to the sync committee, not sure how relevant pessimistic sync actually would for that endpoint. The sync will be optimistic anyway. Pessimistic sync imo makes sense only for a node that fully validates consensus (has access to full blocks and full beaconstate).",
        "created_at": "2022-11-25T15:53:43.722000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "And, \u003c@539495253418180618\u003e , how feasible would it be to convert withdrawals to SSZ also in the EL? \nSo that `ExecutionPayloadHeader.withdrawals_root` matches `ELBlockHeader.withdrawals_root`.\nSee https://ethereum-magicians.org/t/eip-4895-beacon-chain-withdrawals-as-system-level-operations/8568/28?u=etan-status",
        "created_at": "2022-11-25T15:59:46.165000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yeah, agree on those points. would be useful for this element of the protocol not to add barriers to this",
        "created_at": "2022-11-25T18:33:43.038000+00:00",
        "attachments": null
    },
    {
        "author": "uink45",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So I am just trying to confirm: Will a consensus layer light client be able to verify transaction inclusion simply by downloading `LightClientUpdate` from the Libp2p network, rather than relying on a local RPC?",
        "created_at": "2022-11-25T22:30:55.587000+00:00",
        "attachments": null
    },
    {
        "author": "uink45",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Based on the current specs, it seems like `LighClientUpdate` does not contain either `ExecutionPayloadHeader` or `ExecutionPayload` because that is included as a Merkle root in the `body_root` of `BeaconBlockHeader`.",
        "created_at": "2022-11-25T22:34:49.045000+00:00",
        "attachments": null
    },
    {
        "author": "uink45",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "After catching up on the discussions above, it seems like `ExecutionPayloadHeaded` will be included in `LightClientUpdate`? If that is the case, then that would be great because to prove inclusion of a transaction, you would able to fetch the Merkle proof of transactions from the Portal Network and verify if  `transactions_root` in `ExecutionPayloadHeader` is valid.",
        "created_at": "2022-11-25T22:50:52.717000+00:00",
        "attachments": null
    }
]