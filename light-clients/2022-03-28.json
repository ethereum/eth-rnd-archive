[
    {
        "author": "dapplion",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@!539495253418180618\u003e I was wondering why it was ultimately decided not to add slashing for sync committee double voting. The nothing at stake problem applies for sync committee making their security weaker. Vitalik's ideas for tracking participation and detecting low participation as a indication of a minority fork does not apply if sync committee members just sign all forks",
        "created_at": "2022-03-28T05:26:32.021000+00:00",
        "attachments": null
    },
    {
        "author": "dapplion",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Complexity doesn't seem to hard just copy paste the ProposerSlashing infrastructure. It's also a cheap condition to check in the slashing db. Besides faulty operators signing two heads as a sync committee member is a serious attack that justifies slashing. The problem tho is that attackers would remain in the sync committee until the next shuffling but still having a deterrence is better than none",
        "created_at": "2022-03-28T05:35:50.714000+00:00",
        "attachments": null
    },
    {
        "author": "etan_status",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yes, if a supermajority of a sync committee goes rogue, it can direct light clients to arbitrary chains. For the \"drop in participation\", it is important to try and obtain better data. On Nimbus we try obtaining better data for a while, and only accept data without supermajority participation if we receive a lot of copies of it over a longer time period. \nhttps://github.com/status-im/nimbus-eth2/blob/unstable/beacon_chain/gossip_processing/light_client_processor.nim#L187-L217\n\nSlashing does not solve the issue for historic data. Even slashed sync committee members may sign arbitrary messages, the light client cannot verify that the signers are not slashed. However, at least future data could be protected by introducing slashing conditions for validators signing invalid finalized headers.",
        "created_at": "2022-03-28T06:37:41.802000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "yeah, ultimately it is a feature set to complexity ratio argument\n\nthe security of the sync committee construction comes down to the strength of the shuffling and the frequency of rotation of the shuffling\n\nas long as a majority of the sync committee is honest then you can follow the head of the chain\n\nnote: you would need corruption of the wider validator set to produce two conflicting finalizing updates",
        "created_at": "2022-03-28T14:52:52.572000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "so even if a sync committee went rogue, they couldn't convince you that something was incorrectly finalized (w/o bigger problems on our hands)",
        "created_at": "2022-03-28T14:53:32.769000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "the current sync committee spec is definitely optimized for the finality case and i do think there is room to consider more sophisticated alternatives when designing light clients that can safely follow the head",
        "created_at": "2022-03-28T14:54:28.691000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "what \u003c@!881905303011086387\u003e is describing with a more heuristic approach sounds pretty interesting",
        "created_at": "2022-03-28T14:54:42.223000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "fleshing out the unfinalized following algorithm could be a great topic for the light client summit btw",
        "created_at": "2022-03-28T14:55:51.947000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "there could be interesting overlap with \u003c@!555483069038198827\u003e 's  work on defining a \"safe head\" algo",
        "created_at": "2022-03-28T14:56:17.953000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Yeah, it's features vs complexity",
        "created_at": "2022-03-28T15:48:21.666000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Remember that this slashing would be an aggregate signature intersection slashing",
        "created_at": "2022-03-28T15:49:29.325000+00:00",
        "attachments": null
    }
]