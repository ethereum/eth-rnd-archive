[
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The potential issue is the incentive to migrate to long addresses. People don't want to make long addresses because contracts are not compatible. Because people don't have long addresses, project are in no hurry to upgrade.\n\nOnly the extra cost of state resurrection could convince people to migrate. But in the proposed scheme this only kicks in after two years IIRC. At which point creating new state becomes costly because a proof of absence needs to be provided. But anyway my best guess is that by then most project will have upgraded - but the point is that it may take a while until long addresses see pervasive adoption.\n\nConsider also for instance that Uniswap v2 \u0026 v3 can't be upgraded (you'd need uniswap v4).",
        "created_at": "2021-08-04T00:12:34.366000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's possible to interact with old projects by roundtripping funds to a legacy address, but it's inconvenient \u0026 expensive.",
        "created_at": "2021-08-04T00:14:14.361000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(To be clear, I'm not particularly for/against the translation map. Avoiding it might be the better long term solution.)",
        "created_at": "2021-08-04T00:15:37.329000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Assuming that\ntransfers short --\u003e long  are possible and \nLong address contracts can interact with short addresses. It does seem like the main issue would be the incentive to migrate, but for contract writers is already there since their contracts can only save gas and interact with long addresses if they do. Short addresses can be deprecated after some period. I don't think round tripping would be an issue since there shouldn't be transfers long --\u003e short. There may be convoluted ways of keeping earnings associated to short addresses by using a long contract interacting with those addresses, but to effectively withdrawing to an EOA would only be possible to a long address",
        "created_at": "2021-08-04T10:01:09.884000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e for contract writers is already there since their contracts can only save gas and interact with long addresses if they do\n- they save gas in two years\n- you start from a point where nobody has a long address, and nobody wants to have one because they can't interact with any contract\nAlso, deploying a contract costs money and you need to make user migrates.\nIt's clearly something projects want to avoid because you fragment your userbase for a least some amount of time.\n\n\u003e there shouldn't be transfers long --\u003e short\nIf you don't add those (talking about simple transfers, not contract calls), it becomes even more unattractive for users to migrate to long addresses. You're essentially creating a new separate blockchain that legacy users have to migrate to. Imho that's unrealistic.",
        "created_at": "2021-08-04T13:18:11.576000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e If you don't add those (talking about simple transfers, not contract calls), it becomes even more unattractive for users to migrate to long addresses. You're essentially creating a new separate blockchain that legacy users have to migrate to. Imho that's unrealistic.\nWith this I agree, but adding the long addresses without the benefit of the added security and with all the hassles and extra bloat of either a translation table or complicated logic and bug-prone traps like the Edict that coders will surely fail to obey from time to time, and without any reasonable timeframe to deprecate short addresses, seems like it's more harmful to the network that just staying the way we are or simply forking and hoping most validators move to the new system.",
        "created_at": "2021-08-04T14:42:32.283000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Why would you miss on added security if you do this?\n\nCorrect me if I'm wrong but the tradeoff is either:\n- translation map, then users can start using long addresses immediately, but storage requirements + some gotchas\n- bridge contracts, which doesn't have as many problems, but it will take a long time for everyone to migrate",
        "created_at": "2021-08-04T14:45:24.697000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(in both case you'd preserve the security benefits of using a long address)",
        "created_at": "2021-08-04T14:45:39.390000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I thought all methods of allowing mappings from long to short addresses would require bits to encode the image of the short address space in the large address space. Depending on how much collision are you willing to accept the more bits you need. Those are lost bits compared to a \"pure 32 bytes\" address space",
        "created_at": "2021-08-04T14:50:06.637000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No that's not how it works.\nCurrent proposal does put bytes in the address (version, epoch for state expiry, potentially shard ID), but these do not \"encode the image\" (which is simply computed via some hashing scheme).\nYou could have a long -\u003e short scheme without the extra stuffed data that would be a pure 32 bytes.\nBut anyway, these are only like 5 bytes, so 27 bytes are much better than 20 bytes already.",
        "created_at": "2021-08-04T14:53:35.775000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If we had the ability to partition the current 20 byte address and carve out a silo for pointers to long addresses we could do away with The Edict. The problem is that there is no unoccupied space because addresses are just random hashes and if we try something clever to fix that the entropy reduces enough that the collision attack goes from \"thing that people who would probably be better off 51% attacking Bitcoin can do\" to \"thing guy with large GPU farm can do\".",
        "created_at": "2021-08-04T14:57:14.948000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The fact that compress exists as a projection is putting some bits away to encode the image.  Or at least any way I can imagine does this. I think I should see an explicit implementation of a protection",
        "created_at": "2021-08-04T15:07:59.972000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We currently have 3 choices:\n1. Do nothing and suffer the technical debt of 160 bit addresses for ever (this is considered unacceptable).\n2. Have a translation map compatibility layer between long and short addresses and suffer The Edict and related compatibility unpleasantness.\n3. Go with Bridge Contracts and basically partition Ethereum into two spaces that can't talk to each other as effectively as we would like.\nAll of these options are terrible, but it isn't clear that there are any better ones.",
        "created_at": "2021-08-04T15:08:18.099000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I might be misunderstanding what you mean by \"putting some bits away to encode the image\".\nAnyhow, check here https://notes.ethereum.org/@ipsilon/address-space-extension-exploration\n```python\n# This helper compresses a LongAddress\ndef compress(address: LongAddress) -\u003e ShortAddress:\n    return keccak256(keccak256(DOMAIN + address))[12:]\n```",
        "created_at": "2021-08-04T15:10:46.737000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ok that's just hashing and allowing any collision.",
        "created_at": "2021-08-04T15:12:12.524000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That's an extreme of the above",
        "created_at": "2021-08-04T15:13:14.743000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "say you don't stuff data, this gives you the full 128 bit collision resistance",
        "created_at": "2021-08-04T15:14:22.643000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "because if you find a collision such that  `compress(long_address) == found_legacy_address`  (80 bit collision resistance), that will be useless â€” the client will check if `found_legacy_address`  is a compressed address by looking in the translation map, and when it finds it is, will reject the signature",
        "created_at": "2021-08-04T15:16:21.028000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So, correct me if this is not an abstraction of the problem you want to solve. We have a small set of addresses, say s, and a large set of addresses, say S.\n1. We can find an injection s --\u003e S.\nThe next step is a little stronger, but let's assume we can find a section of that injection (the \"compress\")\n2. S --\u003e s (so that the composition s --\u003e S --\u003e s is the identity). \n3. We have contracts that take elements of s as imputs and do stuff. Their consequences alter the status of some elements in the set s (say account balances).  We do not need to do anything to allow these contracts to continue taking inputs from s and alter the elements of S that are in the image of the injection s--\u003eS since indeed we can treat s as a proper subset of S. \n4. Now we will have new contracts that take elements from S as inputs and alter the status of elements from S. These contracts can alter the status of elements from s without trouble, since s \\subset S. \n\nThe only problem is when we want to have \n5. The old contracts that could only take as inputs elements from s, we would want them to somehow take as inputs arbitrary elements from S. \nThis is the only place were the projection S --\u003e s actually plays any role. \n\nIs this correct?",
        "created_at": "2021-08-04T15:22:25.597000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "if that's the case, I don't understand why not just simply get rid of the requirement of having 5. Users with new addresses from S can simply transfer in S address space to an address in the image of s, and continue interacting with the contract. And developers do not need to do absolutely anything to upgrade their contracts since the EVM should treat all addresses as in S, and do transparent translation s---\u003eS",
        "created_at": "2021-08-04T15:23:57.324000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So I see why contracts that already exist will continue living in s address space, but every new contract will be in S, and I don't see any problem with this. The network will eventually upgrade entirely. Or people still play with cats?",
        "created_at": "2021-08-04T15:24:58.383000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So I'd say to get rid of the section 2 and entirely of the requirement 5. But it seems that consensus is not to do this",
        "created_at": "2021-08-04T15:25:59.308000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This might be a bit too abstract for me. And I think it might miss some important practical details.\nBut anyway, I'm already struggling here:\n\u003e 1. We can find an injection s --\u003e S.\n\u003e The next step is a little stronger, but let's assume we can find a section of that injection (the \"compress\")\n\u003e 2. S --\u003e s (so that the composition s --\u003e S --\u003e s is the identity). \nSince `S ðŸ¡¢ s`  (compress) is a hash function, aren't you essentially asserting in (1) that you can invert the hash function?",
        "created_at": "2021-08-04T15:29:56.112000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Users with new addresses from S can simply transfer in S address space to an address in the image of s, and continue interacting with the contract. And developers do not need to do absolutely anything to upgrade their contracts since the EVM should treat all addresses as in S, and do transparent translation s---\u003eS\nSo `s`  are 20-byte addresses\nand `S`  are 32-byte addresses\nIf developers don't update the contracts, it means we're stuck with 20 byte addresses forever? (or sure you can map them to 32 bytes, but you can still find a 20-bytes collision which is what we're trying to avoid)",
        "created_at": "2021-08-04T15:34:46.216000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Since S ðŸ¡¢ s  (compress) is a hash function, aren't you essentially asserting in (1) that you can invert the hash function?\nNo, this is just the statement `compress(encode(legacy_address)) == legacy_address` in \u003c@!243183686562873344\u003e' s file\n\u003e If developers don't update the contracts, it means we're stuck with 20 byte addresses forever? \nDevelopers do not need to update anything: all new contracts are on address space S, and contracts are being created all the time. Eventually old contracts will die naturally since newer contracts will be better performing. Just as everything else in technology.",
        "created_at": "2021-08-04T15:44:33.059000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ok! but note that in that case `S ðŸ¡¢ s`  is defined to explicitly work differently on elements of `s`  that were mapped to `S`  via `s ðŸ¡¢ S` \n(`encode` will 0-extend, and `compress`  will 0-strip if the address starting with 12 leading 0 bytes)\n(the `compress` in Peter's document is not the same as the one I copied above!)\n\n\u003e Developers do not need to update anything: all new contracts are on address space S, and contracts are being created all the time. Eventually old contracts will die naturally since newer contracts will be better performing. Just as everything else in technology.\n\nsure, that's the thinking behind the bridge idea, that we can just afford to wait\n(you do need the bridge contracts though, otherwise you'd have no way to migrate your ERC20 tokens to new contracts/long addresses for instance)",
        "created_at": "2021-08-04T15:50:17.809000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "and re-reading your message, yes I think you get things right\nit's all about preserving backwards compatibility with existing contracts or not\nwhich is to say it's all about how fast we want people to adopt these new long addresses",
        "created_at": "2021-08-04T15:51:47.892000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For me it's easier to try to think a problem if I understand the abstract essence of it. And if the above is correct then what worries me is that having a section, although not the same, is close to expressing S as a product s x e for another set e (12 byte addresses) so we may as well simply expressing addresses as pairs of addresses one in s, one in e, and the translation table that Peter is talking about is simply a function s--\u003ee if I'm getting this right",
        "created_at": "2021-08-04T15:55:42.819000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "you mean \"section\" as \"subset\", right?",
        "created_at": "2021-08-04T15:58:33.168000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's a technical math term https://en.wikipedia.org/wiki/Section_(category_theory)",
        "created_at": "2021-08-04T15:59:14.691000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "`g` is a section of `f` if `f(g(x)) = x`",
        "created_at": "2021-08-04T16:00:51.898000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Does it says anything about `f`  and `g` being total?",
        "created_at": "2021-08-04T16:03:27.176000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "because if not you don't have a section here (since if `f` == `encode` and `g` == `compress`, either the property does not hold, or it holds only if you restrict the domain of `compress` to the subset of `S` that is the image of `encode`  (addresses with 12 0 bytes in front)",
        "created_at": "2021-08-04T16:05:17.388000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Suppose you have a set `A` and a set `B` and a function `f: A -\u003e B`, `g` is a section of `f` if for every element of `B` it picks a member `a` of `A` such that `f(a) = b`.",
        "created_at": "2021-08-04T16:05:30.243000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In our context `DECOMPRESS` is a section of `COMPRESS` because it picks a long address (out of a lot of long addresses) for the short address to correspond to.",
        "created_at": "2021-08-04T16:06:55.029000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "okay, that makes sense",
        "created_at": "2021-08-04T16:09:46.573000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "this is still very obscure\nlike, so what - what's the bad thing that we can do here?",
        "created_at": "2021-08-04T16:11:25.500000+00:00",
        "attachments": null
    },
    {
        "author": "peter.davies",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The problem is that `DECOMPRESS` is not well defined. Until you use a legacy address or add a translation, you don't know what `DECOMPRESS` should return. The Edict basically says you promise not to use `COMPRESS(long_address)` until you have added `long_address` to the translation table, causing `DECOMPRESS` to become well defined at `long_address`.",
        "created_at": "2021-08-04T16:12:13.372000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not saying anything is bad, just trying to understand the problem. For starters it would make things transparent and I suspect simpler from the implementation perspective to have pairs of addresses and a (partially defined) function.",
        "created_at": "2021-08-04T16:16:21.728000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Indeed, I agree with this. But since you want to support all addresses this statement is just an implementation detail more than a feature",
        "created_at": "2021-08-04T16:17:25.574000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hhm, it's hard to understand why if you don't share the explicit reasoning. Clearly we have very different ways of thinking ðŸ™‚ (which is cool)\nFor me, intuitively I have a hard time sharing your intuition because\n1. The currently proposed map implementaiton is simplistic already\n2. We want to have hashing in there to avoid collision, and splitting in the way you propose seem to make finding some kind of collision more likely? (Sorry if I'm off, but I don't understand the implications fully)",
        "created_at": "2021-08-04T16:20:03.631000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "btw just posted https://ethereum-magicians.org/t/thoughts-on-address-space-extension-ase/6779 with some thoughts on this stuff",
        "created_at": "2021-08-04T16:20:19.307000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think by collision you mean having two long addresses that \"compress\" to the same short address.  The way I'm thinking about this is that a long address is a pair of a short address and a shorter address (of 12 bytes). If you have a short address and want to use it in long address space then just generate a 12 byte key and publish it signed with your 20 byte key. Now that is the only long address that corresponds to that short address. If you generate a long address then automatically you have a short one (the first factor). Everything works just as in your proposal it seems. The edict corresponds to sending the signed 12 byte address before using the pair. Is that right \u003c@243183686562873344\u003e ?",
        "created_at": "2021-08-04T16:39:07.451000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Implementing it like this anyone with a short address will want to add a long address associated to it so as to protect preemptively from collision and there's no hashing needed in translations",
        "created_at": "2021-08-04T16:42:02.371000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Are there other benefits to this scheme besides avoiding the hashes?",
        "created_at": "2021-08-04T17:04:29.286000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also the edict is the opposite, if you generate a new long address, it's sending the 20 bytes short address before initializing the full 32 byte address.",
        "created_at": "2021-08-04T17:07:59.764000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That's equivalent",
        "created_at": "2021-08-04T17:08:17.683000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And also, you can't \"generate a 12 byte key\" to add to you 20 bytes key. These 12 bytes must absolutely be the 12 bytes that precede the last 20 in your public key.",
        "created_at": "2021-08-04T17:08:30.520000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Why?",
        "created_at": "2021-08-04T17:08:45.089000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This I didn't understand",
        "created_at": "2021-08-04T17:08:51.399000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not talking implementation again, I want to understand the underlying problem. And when you say 32 bytes y read 20 x 12",
        "created_at": "2021-08-04T17:09:43.023000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And don't see any difference",
        "created_at": "2021-08-04T17:09:53.760000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, one of the two issues that the edict solves is sending funds to the encoded version  of the compressed address before the long/compressed pair has been added to the translation map.\n\nSo if your compressed addressed is 0x.....123, accidentally sending funds to 0x000000....123.\nIf you only have 12 bytes, that's not a valid short address, you can't do anything useful with that.\n(whereas the 20 bytes compressed address, you could use as a parameter for an legacy ERC20 transfer for instance... but if that ERC20 contract is extended-mode and not legacy, suddenly you've lost your funds)",
        "created_at": "2021-08-04T17:12:52.405000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And how is that different than sending the 12 bytes corresponding to the 20 bytes short address? I'm not understanding anything it seems",
        "created_at": "2021-08-04T17:14:53.748000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You are assuming a scheme where 20 bytes are zero extended",
        "created_at": "2021-08-04T17:16:50.207000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not",
        "created_at": "2021-08-04T17:16:52.141000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm saying: a long address by definition is a pair, of an address of 12 and another of 20",
        "created_at": "2021-08-04T17:17:19.250000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Because of the collision issue. The base assumption is \"it's possible to find two private keys that control the same 20-byte address\"\n\nIf you just add 12 arbitrary bytes, and you don't change the private key you use to sign your transactions somehow (you still use the private key that generated the 20-byte key), then these 12 bytes don't help you at all. The chain does not know your public key, so it can only verify that last 20 bytes of the recovered public key matches the 20 bytes address.\n\nIf the 12 bytes are those that precede the 20 last bytes of the (hash of) the public key however, now, without changing your private key, the chain will verify that the signature matches the full 32 bytes address.",
        "created_at": "2021-08-04T17:17:29.633000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Perhaps that definition is already wrong but I don't see how",
        "created_at": "2021-08-04T17:17:36.215000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "How would you recover the 20 bytes from the 12 bytes?\nUnless you send a signature with it, then it is possible indeed.",
        "created_at": "2021-08-04T17:18:19.791000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes they do: to sign a transaction as a long address you need to sign with the pair 20 + 12",
        "created_at": "2021-08-04T17:18:34.971000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I have no idea how you came to that conclusion, but that is not what I am assuming.",
        "created_at": "2021-08-04T17:18:37.848000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "To sign in legacy space you need only the 20",
        "created_at": "2021-08-04T17:18:45.499000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ok!",
        "created_at": "2021-08-04T17:18:49.336000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And there's no collision",
        "created_at": "2021-08-04T17:18:53.504000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Since you posted the 12",
        "created_at": "2021-08-04T17:19:04.887000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Then I agree, but that counts as \"changing your private key\" (or equivalently, adding a second private key on top).",
        "created_at": "2021-08-04T17:19:09.720000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes and that's extending to 32",
        "created_at": "2021-08-04T17:19:25.763000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That's potentially dangerous if you allow NEW long address to sign in legacy space using their short version.",
        "created_at": "2021-08-04T17:20:00.735000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And you don't recover the 20 from the 12",
        "created_at": "2021-08-04T17:20:01.324000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The proposed scheme does not have that issue.",
        "created_at": "2021-08-04T17:20:11.493000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What issue? If you want to have old users of 20 bytes addresses continue to work signing with only 20 bytes signatures, then  that's unavoidable: someone that does revert 20 bytes hash has access to that",
        "created_at": "2021-08-04T17:22:24.271000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "New long addresses will have to crack the 20 bytes still",
        "created_at": "2021-08-04T17:22:50.778000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't see any difference between this approach and the hash approach.",
        "created_at": "2021-08-04T17:23:32.487000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If there is a difference it means that I conceptually didn't understand the problem which is quite likely",
        "created_at": "2021-08-04T17:24:10.235000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So when you use the short version of a newly generated long address in legacy space, you can just use the private key of the 20 short version?",
        "created_at": "2021-08-04T17:26:18.278000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes",
        "created_at": "2021-08-04T17:27:27.258000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There's actually no reason to impose that constraint I think (except perhaps to simplify verifying transactions of legacy addresses)",
        "created_at": "2021-08-04T17:27:33.205000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This is no constraint if legacy space is supposed to work as it worked before. You cannot have more than those 20 bytes security in that legacy space",
        "created_at": "2021-08-04T17:28:52.320000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm not defending that legacy space should be able to interact with long space, but it seems to me that the hash extension is (almost) equivalent to this",
        "created_at": "2021-08-04T17:29:44.978000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, you can. This is because signatures are checked by the client, not by smart contracts.\nAnd the client when it verifies the signature, recovers a public key, from which it derives an address.\nThat's the key difference.",
        "created_at": "2021-08-04T17:29:47.702000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't understand",
        "created_at": "2021-08-04T17:30:16.782000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In the proposed scheme, you have `long_address`  and `compressed(long_address)` \nYou cannot sign your transactions with `comrpessed(long_address)` , only with `long_address` .",
        "created_at": "2021-08-04T17:30:38.939000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No matter if the target contract is legacy or extended.",
        "created_at": "2021-08-04T17:30:49.261000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Suppose you are a legacy address",
        "created_at": "2021-08-04T17:31:42.829000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Transferring to a legacy contract",
        "created_at": "2021-08-04T17:31:53.566000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "How do you sign",
        "created_at": "2021-08-04T17:31:58.708000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm only talking about NEW long addresses.",
        "created_at": "2021-08-04T17:32:13.197000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Left a comment on this regarding bridge contracts and the general problem with the ABI: https://ethereum-magicians.org/t/thoughts-on-address-space-extension-ase/6779/2",
        "created_at": "2021-08-04T17:32:14.954000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My point is that you cannot distinguish between new addresses interacting with legacy contracts and compress(new address) interacting with legacy contract",
        "created_at": "2021-08-04T17:33:25.040000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh wait I think I understood your comment above",
        "created_at": "2021-08-04T17:36:08.588000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The client can, when it receives the transaction, it recovers the public key from the transaction.\nPossible scenarios (assuming the transaction is cryptographically valid):\n- hash(pubkey) ends with known long address ðŸ¡¢ ok\n- hash(pubkey) ends with known legacy address ðŸ¡¢ ok\n- hash(pubkey) ends with compressed(known long address) ðŸ¡¢ reject",
        "created_at": "2021-08-04T17:36:13.445000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You meant that the execution client will check the signature of 32",
        "created_at": "2021-08-04T17:36:26.317000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah ok, that's fair, but it's equally enforceable with the scheme of a pair of keys",
        "created_at": "2021-08-04T17:37:18.667000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If you sign with pair of known keys, ok\nSign with one legacy, ok\nSign with a legacy that published the 12 pair, reject",
        "created_at": "2021-08-04T17:38:21.353000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But I agree that this is enforceable at the client level",
        "created_at": "2021-08-04T17:38:58.286000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, I agree",
        "created_at": "2021-08-04T17:38:59.954000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Still, although mathematically is not strictly the same as expressing the address space as a product, having compress is just about it, and having as a pair of keys seems easier at least to me to both implement and understand",
        "created_at": "2021-08-04T17:40:11.136000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also having a pair makes it transparent when a legacy address wants to claim a long address (or viceversa) in that you need to publish 12 bytes instead of the whole address. I think the translation table just becomes much smaller all of the sudden",
        "created_at": "2021-08-04T17:43:35.083000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The size reduction is nice, but the impact on tooling for doing two signatures is really annoying imho.",
        "created_at": "2021-08-04T17:48:02.712000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't see how that should be harder or any different that one larger signature",
        "created_at": "2021-08-04T17:49:06.809000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But yeah, I've already spent weeks with SHA Assembly, won't waste more on that ðŸ˜‚",
        "created_at": "2021-08-04T17:49:40.342000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "As for size it seems that it's half",
        "created_at": "2021-08-04T17:50:07.873000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You need to add 12 bytes for any address that wants to claim a long version",
        "created_at": "2021-08-04T17:50:48.438000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Can anyone summarise this scheme?",
        "created_at": "2021-08-04T17:53:19.791000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@!755590043632140352\u003e you should write it up\nmaybe post it to the thread I made before (or make your own)",
        "created_at": "2021-08-04T17:53:50.048000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A new long address is a pair of a 20 byte address and a 12 byte address. If you hold a legacy address and want to protect it from collision in long address space, you generate a 12 byte address and sign it with the 20 byte one and publish that",
        "created_at": "2021-08-04T17:55:30.748000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "We only thought about this for like 5 minutes",
        "created_at": "2021-08-04T17:55:51.663000+00:00",
        "attachments": null
    },
    {
        "author": "jacknelson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "huh",
        "created_at": "2021-08-04T17:55:58.482000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "it was way longer",
        "created_at": "2021-08-04T17:55:59.872000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Let's give it some time before writing",
        "created_at": "2021-08-04T17:56:01.838000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but is is probably full of holes",
        "created_at": "2021-08-04T17:56:09.974000+00:00",
        "attachments": null
    },
    {
        "author": "jacknelson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "wait so why does it need to be extended?",
        "created_at": "2021-08-04T17:56:13.135000+00:00",
        "attachments": null
    },
    {
        "author": "jacknelson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "im new here btw",
        "created_at": "2021-08-04T17:56:20.588000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "already a signature matching a 12 bytes address does not seem very useful",
        "created_at": "2021-08-04T17:56:24.716000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In case we are talking about a fresh long address account, do you just split the 32-bytes into the first 12-bytes and the second 20-bytes?",
        "created_at": "2021-08-04T17:56:27.338000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A new address is just a pair of addresses",
        "created_at": "2021-08-04T17:56:50.318000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e if you hold a legacy address and want to protect it from collision in long address space\nand this is not really a goal at all (just make a new address!)\nit does avoid you some transfer costs I guess",
        "created_at": "2021-08-04T17:57:03.327000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "A pair where?",
        "created_at": "2021-08-04T17:57:21.582000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "like the security of a 20-bytes address + a 12 bytes address is much less than a single 32-bytes address because you can so easily find collisions on the 12 bytes address",
        "created_at": "2021-08-04T17:57:43.948000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It is, in the current approach if you generate a 32 long address you compress it to 20, and publish it before using this compressed form.\nThe analog of this is the following: you generate a pair 20+12, you publish the pair before using it",
        "created_at": "2021-08-04T17:58:44.258000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "noooooo, it's not like that",
        "created_at": "2021-08-04T17:59:07.320000+00:00",
        "attachments": null
    },
    {
        "author": "jacknelson",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "that sounds insecure",
        "created_at": "2021-08-04T17:59:29.586000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but don't have the time to chat anymore, have to run ðŸ˜…",
        "created_at": "2021-08-04T17:59:32.074000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think one of the goals is that long addresses is what we want to make native for the next decade.  Support for legacy addresses is driven by a  migration perspective.",
        "created_at": "2021-08-04T17:59:41.891000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Especially looking at the projections, such as 150M, 300M, etc. new addresses, it suggests that if the incentives are done correctly, soon there would be more long addresses than legacy ones.",
        "created_at": "2021-08-04T18:02:12.376000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah, I'm not entirely sure what the point of it all is\nbut if I had to give a strongman of why it might be worth thinking about this is that **a scheme where we can compress the translation map could be useful**\nin the scheme proposed by potuz, if you generate a new long address, you can get a compressed address just by truncating\nhence to check if a short address is a compressed address, you read into the map and there you can only store the remaining 12 bytes\n\nI think you can change all the other details, I'm not too convinced by the two keys idea for instance",
        "created_at": "2021-08-04T18:02:22.110000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah so most of the argument is about how to derive compressed addresses, and how to store them in the map ðŸ™‚",
        "created_at": "2021-08-04T18:03:38.989000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "well the argument did not start there, but that's the interesting thing that came out of it (according to me at least!)",
        "created_at": "2021-08-04T18:04:02.348000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My point was that the existence of the compress map is essentially equivalent to writing the 32 address space as a product of a 20 bytes times a 12 bytes address space. And as such then a few things become more transparent",
        "created_at": "2021-08-04T18:06:50.039000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not arguing that a translation table is a good thing, actually not arguing anything since I haven't thought about ASE at all. But just noticing that the approach with a compress map, then the translation table is equivalent (mathematically) to a function from a 20 bytes address space to a 12 bytes address space",
        "created_at": "2021-08-04T18:08:46.697000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "There were some discussions about making the \"compressed address\" just the lower 20-bytes of a long address.  Can't remember where that discussion ended up at. There was no clarity about best approach of deriving the compressed address.\n\nIf I understand correctly that's what you are suggesting, and if so, the map can be made into `address20 -\u003e bytes12`, where `address32 = bytes12 || address20`. \n\nIt helps with data requirements, but likely doesn't make any difference for the other questions previously discussed?",
        "created_at": "2021-08-04T18:13:54.319000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That's essentially correct.",
        "created_at": "2021-08-04T18:15:41.882000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Left some more arguments on this thread, may be relevant to the discussion here.",
        "created_at": "2021-08-04T18:17:24.328000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ok so I'm being convinced that there's no effective way of extending a given legacy address",
        "created_at": "2021-08-04T18:23:27.695000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "To live in 32 bytes address space, in a cheap way",
        "created_at": "2021-08-04T18:23:49.958000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(meaning just adding 12 bytes of data)",
        "created_at": "2021-08-04T18:24:03.455000+00:00",
        "attachments": null
    },
    {
        "author": "axic3354",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Spinning this a bit further, if the we truncate the public key the same direction (last 20-bytes), then the \"compressed address\" and the \"short address\" of the same EOA public key is identical.  That means it won't be possible to distinguish whether the transaction goes to the short version of the same EOA or the compressed/long version of it.",
        "created_at": "2021-08-04T18:24:57.963000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Alright thanks for all the help \u003c@218397452309495809\u003e  I think I had misunderstood the problem all along. We need to encode a partial map 20--\u003e32 which is a left inverse to any chosen form of compress, and this is independent of implementation. Thanks, read at least the forum an ipsilon's articles today.",
        "created_at": "2021-08-04T20:42:03.381000+00:00",
        "attachments": null
    }
]