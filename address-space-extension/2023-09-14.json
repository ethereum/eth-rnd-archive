[
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "EOA?  You mean EOF?",
        "created_at": "2023-09-14T17:07:00.652000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If the change were made it is compatible, just not identical.  Currently the high 12 bytes of all operations that pop an address off the stack are trimmed off and only 20 bytes are used to identify account addresses.  The change would be to require the top 12 bytes be zero to access accounts as they were accessed before.  This is the most common case as PUSH20 will leave the top 12 bytes zero.",
        "created_at": "2023-09-14T17:09:19.299000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "What changes would be ~~lazy~~ gas efficient packed ABI decoding.  Under current rules the entire 32 bytes around an address could be used without anding it against an appropriate 20 byte mask. Also unvalidated ABI calls that don't verify the high 12 bytes of an unpacked ABI are, in fact, zero.",
        "created_at": "2023-09-14T17:11:21.705000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "My expectation is that anyone who has not read the ABI spec and is not enfranchised in gas hacks would expect that an address with a high bit set is distinct from an address without the high bit set.  Because they look like different numbers.",
        "created_at": "2023-09-14T17:12:13.958000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I make heavy usage of contracts that use the modulo to reduce calldatasize. Ambushing those contracts with this change breaks them in a terrible way.",
        "created_at": "2023-09-14T17:24:38.834000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Instead of modifying the behavior of CALL, support the ASE only in new CALL opcodes that never do the modulo",
        "created_at": "2023-09-14T17:26:16.164000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But the main incompatibility between EVM and EOF I was referring to was how one was not allowed to create/call into the other.",
        "created_at": "2023-09-14T17:35:16.938000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "eg 7069",
        "created_at": "2023-09-14T17:39:05.530000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think sload and calldataload are more common than push20, which would only be used for a “constant” address target in newer versions of solidity.",
        "created_at": "2023-09-14T17:43:53.648000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You can call from legacy into EOF just fine.  The only restriction is that EOF cannot delegatecall into legacy.  This is to prevent an end run around disabled features like SELFDESTRUCT",
        "created_at": "2023-09-14T17:45:51.858000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "EOF can call and staticcall into legacy.",
        "created_at": "2023-09-14T17:46:09.434000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Unless you are packing your slots, SLOADs should be fairly easy to keep clean.  and the calldataload is what I was referring to with ABI unpacking.  If your calldata is packed you would need to do masking, or use CALLDATACOPY.",
        "created_at": "2023-09-14T17:47:48.698000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ok but the code is immutable",
        "created_at": "2023-09-14T17:48:46.017000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "and hard forks shouldn’t break contracts",
        "created_at": "2023-09-14T17:48:58.031000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If it's legacy code it won't execute in an EOF context.",
        "created_at": "2023-09-14T17:48:58.978000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "All legacy contracts will be executed per legacy rules.",
        "created_at": "2023-09-14T17:49:21.554000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ok so I think I understand now: the modulo remains unless we’re in an EOF context",
        "created_at": "2023-09-14T17:50:04.082000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This is why it's interesting for EOF, there are a set of planned breaks (SELFDESTRUCT, code observability, gas observability) and ASE fits in that theme.",
        "created_at": "2023-09-14T17:50:17.157000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And CALL2/DELEGATECALL2/STATICCALL2 are planned to be exposed to legacy.  The idea of making them fullwidth in either context is worth considering.",
        "created_at": "2023-09-14T17:51:25.949000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Another consideration could be that it is possible that for a 32byte address the first twelve bytes are zeros by intent or by chance",
        "created_at": "2023-09-14T17:57:24.260000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Until there is a spec to add meaning to the top 12 bytes we should presume they are always zero and any nozero set does not correspond to an account.",
        "created_at": "2023-09-14T17:58:16.889000+00:00",
        "attachments": []
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ok so they are not going to be more hash bytes but instead they would indicate configuration/version",
        "created_at": "2023-09-14T17:59:19.790000+00:00",
        "attachments": []
    },
    {
        "author": "_shemnon",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "All address schemes (including CREATE3 and CREATE4) currently specify only 160 bits, so we would keep that.  The proposals I've seen would encode some sort of time signature of first creation in the high bits.",
        "created_at": "2023-09-14T18:34:38.231000+00:00",
        "attachments": []
    }
]