[
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The linked markdown document has accumulated a large amount of brain dumping over the last few days.  It's not optimized for consumption at this stage but there's a lot more detailed theory about how the network would operate with respect to advertising content and content transmission.  I'm hoping to re-write it sometime within the next 1.5 weeks to be more consumable and logically organized.",
        "created_at": "2020-09-10T14:49:56.104000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!296630428754771968\u003e in working on re-working the Alexandria spec, I realized that the key scheme I've been using for content can probably be reformed to reduce the size of our advertisement payloads.  Currently I've been operating using something like `/eth1/\u003cchain_id\u003e/header/\u003chash\u003e`  I realize that this data structure is overly generic as well as human readable, both of which are not neccessary.",
        "created_at": "2020-09-10T22:28:49.507000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Right now I'm thinking that we can do something much more compressed like `\u003cfork-id\u003e\u003ccontent-id\u003e\u003ccontent-specific-data\u003e`.  The `content-id` is to replace the `/header/` part, reducing it to a single byte.  Supposing the content-id for headers was `0x01` then a key for a header would be: `FORK_ID || 0x01 || HEADER_HASH`.  This saves ~11 bytes.  For some of the other keys schemes the savings will be higher.  Given the number of advertisements we expect to flow through the network... the savings here likely make sense.",
        "created_at": "2020-09-10T22:36:07.720000+00:00",
        "attachments": null
    },
    {
        "author": "__lithp__",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah, that makes sense to me. I know DEFLATE supports using a pre-built dictionary, we could use that to allow the names to be human-readable while still getting good compression, but it looks like SNAPPY wouldn't support that without a fair amount of custom work. Making it a bit smaller with these substitutions and then letting snappy do the rest makes sense to me. For now I've been assuming the names are 32-byte hashes",
        "created_at": "2020-09-10T23:54:16.393000+00:00",
        "attachments": null
    }
]