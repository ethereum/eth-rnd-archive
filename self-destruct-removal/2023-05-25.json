[
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I have some concerns about SETCODE.  I won't be able to join the call tomorrow so I'll paste them here:\nhttps://notes.ethereum.org/@yoav/SETCODE-security-considerations\n\nAs for the reasoning that certain sophisticated trading strategies become too expensive if they can't mutate their code and have to implement an upgrade mechanism, I'd argue that they abuse a current unintended consequence (SELFDESTRUCT+CREATE2 allowing metamorphic contracts).  IMHO breaking many other things (as I detailed in the note above: user expectations of existing contracts, account abstraction, storage pricing...) in order to preserve that oversight, may not be the best trade off.\n\nWhen Intel released 386, I recall arguments against the use of MMU features (memory protection) in operating systems because it broke self-modifying code which was used by some optimized games (but mostly by viruses for anti-debugging tricks).  Eliminating self-modifying code was a good call then and improved security and stability.  Eliminating it in Ethereum now makes equal sense.",
        "created_at": "2023-05-25T03:07:25.756000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "x86 has self-modifying code. That's how JITs work.",
        "created_at": "2023-05-25T03:56:24.029000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Code read is cheap, storage is expensive, for a good reason.\nCode is stored sequentially; storage is random-access.",
        "created_at": "2023-05-25T04:09:05.744000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Of course it does. But it requires mprotect to make it writable so it broke legacy games.",
        "created_at": "2023-05-25T04:09:29.790000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Btw, platforms like iOS prevent it altogether. Only safari has the jit entitlement. Other apps can't self modify",
        "created_at": "2023-05-25T04:10:30.324000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In many cases it's still cheaper to read sequentially from code and then access it in memory. The cost of memory expansion is lower than sload",
        "created_at": "2023-05-25T04:11:47.945000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This reflects how it is actually cheaper to read sequentially than random-access",
        "created_at": "2023-05-25T04:13:04.486000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I should have also started, I think setcode is a really elegant way to preserve the functionality. I'm just concerned that preserving that functionality in any way will have negative implications",
        "created_at": "2023-05-25T04:13:45.972000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sequential access is indeed cheaper, but is it so much cheaper that we should price it at 3 gas while random access costs 2100 per word?",
        "created_at": "2023-05-25T04:16:13.880000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's actually 100 if you're comparing warm to warm",
        "created_at": "2023-05-25T04:16:37.444000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "100 for warm SLOAD is probably too high but that's another discussion",
        "created_at": "2023-05-25T04:16:59.754000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "100:3 is still quite a ratio. But I don't have the tools to calculate the true cost difference. With mechanical drives it probably made sense. With flash, not as much",
        "created_at": "2023-05-25T04:17:43.053000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But my bigger concerns are not about the price. It's about breaking immutability for non proxy contacts, and about breaking account abstraction",
        "created_at": "2023-05-25T04:18:53.362000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I don't understand your DoS argument regarding account abstraction. How is code changing fundamentally different than storage changing in the static analysis? The supposed library can branch on storage.",
        "created_at": "2023-05-25T04:18:55.855000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "See the storage rules in ERC 4337. During validation, nodes only allow access to the account's own storage, and to 3rd party contracts if the slot is a keccak of the account (the way mapping works). So a single slot can invalidate a single account's transaction. We don't have an equivalent with contracts",
        "created_at": "2023-05-25T04:21:17.644000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Btw, to continue the self modifying code, Ethereum will also still have self modifying code after 6780. You'll be able to generate code, execute it and selfdestruct within the same transaction. It just won't work across transactions.",
        "created_at": "2023-05-25T04:22:44.681000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So, to restate this point, ERC4337 only allows accessing a subset of account's storage so that transactions are guaranteed to be independent. This might explain why ERC4337 is not adopted, since you would only be able to do actions that do not interact with other accounts. You could not, for example, do any kind of DEX trade. Perhaps I am not understanding correctly though.",
        "created_at": "2023-05-25T04:27:43.231000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I guess you're not familiar with the ERC, nor with the current level of its ecosystem. So:\n1. The limitations are only during validation. It's where you're supposed to validate the signature. During execution you can do whatever you like. Rollups like zksync also adopted it and apply the same rules for the same reason.\n2. Re adoption, you're welcome to join the \"4337 mafia\" group with over 900 active developers or watch the entrypoint contract on networks like polygon (over 10k transactions in the past month)",
        "created_at": "2023-05-25T04:31:23.633000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Aside from security, at the intent level, weren't smart contacts meant to be immutable by design?",
        "created_at": "2023-05-25T04:31:39.554000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "4337 aside, I'd argue that it is impossible to have a decentralized mempool for account abstraction with code mutability. Previous AA proposals also applied such validation rules",
        "created_at": "2023-05-25T04:35:47.434000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "That people are using mutable code even when it requires some downtime between transactions signals its value. The advantage of not having to migrate your entire identity between addresses is substantial.",
        "created_at": "2023-05-25T04:36:05.092000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Can you suggest a way to prevent mass invalidation without giving up on code mutability?",
        "created_at": "2023-05-25T04:36:29.451000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I'm playing DnD rn but I'll read up on AA before ACD",
        "created_at": "2023-05-25T04:36:56.363000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Any proxy achieves that",
        "created_at": "2023-05-25T04:37:11.913000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not if the proxy must be competitive at DEX trading",
        "created_at": "2023-05-25T04:37:28.896000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If we want regular users to use smart contract wallets and be competitive at DEX trading we want mutable code",
        "created_at": "2023-05-25T04:38:00.594000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hence my point about the trade off. If we have to give up on account abstraction, security guarantees, etc. in order to make some trading strategies cheaper, is it a good trade off?",
        "created_at": "2023-05-25T04:38:43.107000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not cheaper, available really. If you're not cheap enough to compete you're not trading at all.",
        "created_at": "2023-05-25T04:39:38.292000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The playing field is level. Others also have to play by the same rules",
        "created_at": "2023-05-25T04:40:13.369000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think I understand the issue now. Mutable code makes static analysis more difficult for account abstraction by making code like storage. ERC-4337 bundling prevents overlapping mutable accesses, so mutable code would prevent accounts in the same bundle from interacting with the same code, not just the same storage.\n\nStatic analysis could trivially detect mutable code by finding SETCODE if not for DELEGATECALL. So the presence of either DELEGATECALL or SETCODE in a contract should mean the contract is treated as mutable storage for the purpose of determining exclusivity. Other contracts can be treated as immutable and be accessed by all senders in the bundle.",
        "created_at": "2023-05-25T05:34:00.824000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, the issue is a change in code between the first simulation (when the op is added to mempool) and the 2nd simulation (at the time of inclusion). The setcode could happen in some block in between.\n\nExcluding any contract that has delegatecall will render AA useless. Almost all accounts are proxies so they always delegatecall. And static analysis at the time of 1st simulation doesn't help if the code can change between the simulations",
        "created_at": "2023-05-25T05:37:09.406000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's not just about overlap inside the current bundle. It's about overlap in the entire mempool.",
        "created_at": "2023-05-25T05:38:12.933000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Can they not overlap with the mempool with respect to storage?",
        "created_at": "2023-05-25T05:40:20.176000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Think about it like the flashbots relay, but without the include-in-block-N-or-never. The relay spends CPU simulating many transactions and guarantees non revert (like flashbots protect). But the state can change, and invalidate a large number of transactions already simulated by the relay.\n\nSo something like this, but decentralized.",
        "created_at": "2023-05-25T05:41:45.041000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Not during validation. They can overlap in execution though",
        "created_at": "2023-05-25T05:42:11.022000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I guess I don't understand this distinction.",
        "created_at": "2023-05-25T05:43:34.020000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Flashbots relay can defend itself against DoS (where someone sends valid transactions and then frontruns them to invalidate them) because it's centralized. So it can throttle by IP, use an API key, etc. But a mempool can't do that. So it needs to protect itself against mass invalidation without throttling specific senders.",
        "created_at": "2023-05-25T05:45:20.620000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(Flashbots uses a reputation system)",
        "created_at": "2023-05-25T05:46:09.021000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Consider how an eoa works. You have a validation stage, where the ecdsa signature is checked, the nonce is verified, and the balance is checked to ensure that the eoa can pay. Then there's the actual execution of calldata.\n\nAccount abstraction moves validation to evm. So there's a validation stage where a function in the account is called to check if the op should be accepted, and then there's the execution.\n\nThe rules only apply during validation. In execution you can do anything",
        "created_at": "2023-05-25T05:47:37.528000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I know. But in the mempool, accounts are ephemeral. No reputation.",
        "created_at": "2023-05-25T05:48:04.587000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "4337 borrowed the notion of reputation for staked entities like paymasters or factories. These contracts are allowed to break the rules and access shared storage but they are throttled by reputation. \n\nFor accounts there is no stake so no Sybil resistance and therefore no reputation",
        "created_at": "2023-05-25T05:49:27.952000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://notes.ethereum.org/@yoav/unified-erc-4337-mempool",
        "created_at": "2023-05-25T05:50:16.075000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "This would be an easier read than the EIP, and explains the rationale",
        "created_at": "2023-05-25T05:50:36.419000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ok I think I understand validate-execution separation in ERC-4337 now.",
        "created_at": "2023-05-25T05:56:53.646000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think you may be misunderstanding my usage of exclusive; I don't want to exclude it for all but I want to prevent overlap similar to storage.",
        "created_at": "2023-05-25T06:00:08.740000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think it presents the same issue as storage though.",
        "created_at": "2023-05-25T06:01:29.886000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But accounts legitimately delegatecall the same contract. For example gnosis safe is a proxy. They all delegatecall the same implementation. And this implementation itself has delegatecall in its bytecode because it supports modules. If we banned delegatecall to shared contracts, we would have to ban Safe.",
        "created_at": "2023-05-25T06:02:26.784000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Accounts seldom need to access shared storage during validation (where they typically just check a signature or some internal configuration). But they often access a common implementation, a library, etc.",
        "created_at": "2023-05-25T06:03:39.793000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I need to get some sleep. It's already morning and I've been up for 24h. I'll be back later.",
        "created_at": "2023-05-25T06:12:12.684000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I see how the change causes static analysis for ERC-4337 to be more complicated, because storage is less-likely to overlap in the validation step than proxy code. The recursive nature of delegatecall can make it expensive to prove immutable execution. My proposed solution is not acceptable to you because validation would limit the ability to delegatecall within shared libraries. I expected this impact of this limitation to be minimal because those shared libraries would have to be themselves delegatecalling within validation for the overlap to count for exclusivity. But you cite Gnosis which has this behavior. I am surprised that Gnosis could be part of the validation step but if such recursive delegatecall were penalized in validation it would likely be replaced by another mechanism.\n\nThanks for your patience.",
        "created_at": "2023-05-25T06:30:06.634000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The behavior of Safe is actually quite a common pattern in smart accounts. A proxy pointing to an implementation, and the implementation supports modules or uses diamond storage.",
        "created_at": "2023-05-25T11:16:47.508000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "But thinking about the problem some more, I'd like to explore a solution that might satisfy the seemingly conflicting goals.",
        "created_at": "2023-05-25T11:17:28.734000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I do like the idea of cheap explicit upgradability and I agree it has good use cases. Account abstraction actually being one of them. What scares me is implicit upgradability.\n\nIf we modify setcode to revert when called in a delegatecall context? It would then only be able to operate on the contract that has this opcode.\n\n1. It seems to solve the use case you're concerned about. The trading contract could use this opcode.\n2. It solves the issue of breaking user expectations because static analysis can easily find out if a contract is upgradable. Etherscan, for example, could show a clear indication that it's a mutable contract.\n3. It doesn't conflict with account abstraction. The mempool nodes can check mutability for all the contracts involved in validation. Schemes like 4337 could add a rule: no calls to mutable contracts, but the account itself may be mutable since it can only invalidate its own ops this way.\n4. It can't affect existing contracts in unforeseen ways because they don't have this opcode.\n\nThe only thing it doesn't solve is the pricing difference between storage and code. On that issue I'd like to hear the opinion of client devs. Is sequential access that much cheaper than random access?",
        "created_at": "2023-05-25T11:29:03.514000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If the pricing issue is something clients can live with, would such compromise make sense?",
        "created_at": "2023-05-25T11:29:40.317000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Forbidding setcode within delegatecall would be okay with me. I was hoping current delegatecall proxies would be able to switch patterns but since it simplifies the static analysis so much I agree with the change.",
        "created_at": "2023-05-25T12:26:51.636000+00:00",
        "attachments": null
    },
    {
        "author": "yoavw",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So the remaining issue is storage, but I don't have enough information about the actual cost of sequential access vs. random access so let's defer this to core devs.",
        "created_at": "2023-05-25T13:41:58.296000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "sequential vs random access of storage slots? pricing scheme is the same for both",
        "created_at": "2023-05-25T14:02:37.069000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "No, we were comparing codecopy vs sload",
        "created_at": "2023-05-25T14:06:42.554000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(Codecopy of one word is 6 while sload is 100)",
        "created_at": "2023-05-25T14:08:01.302000+00:00",
        "attachments": null
    },
    {
        "author": "wjmelements",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Made this change https://github.com/ethereum/EIPs/pull/7071",
        "created_at": "2023-05-25T15:35:56.428000+00:00",
        "attachments": null
    }
]