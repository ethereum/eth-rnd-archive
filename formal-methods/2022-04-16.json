[
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "\u003c@711259089560272966\u003e sorry for the much delayed response!",
        "created_at": "2022-04-16T18:58:21.468000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "For the most part, we try do deal with any bitwise operations via algebraic reasoning (rewrites over expressions), rather than some bit-blasting approach or something.",
        "created_at": "2022-04-16T18:58:50.305000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "And I think it's the correct way to do it.",
        "created_at": "2022-04-16T18:58:54.947000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Bit-blasting I think makes very little sense for software verification honestly. Most software is not doing bit-level manipulations.",
        "created_at": "2022-04-16T18:59:10.077000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "And EVM bytecode that comes from the Solidity compiler (and likely other compilers) have very regular structure.",
        "created_at": "2022-04-16T18:59:39.038000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So bit-level operations on words are to project out chunks of bits for packed storage slots for the most part.",
        "created_at": "2022-04-16T18:59:53.659000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Which can be represented algebraically much cleaner.",
        "created_at": "2022-04-16T19:00:04.054000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "For example, something like `maxUInt48 \u0026Int (X \u003e\u003eInt 48)` means \"give me the second lowest 48 bits\"",
        "created_at": "2022-04-16T19:00:28.177000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "And if that's what you want, then you can just have a rule like `rule maxUInt48 \u0026Int (X \u003e\u003eInt 48) =\u003e projectSecondLowest48(X)`",
        "created_at": "2022-04-16T19:00:55.220000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Then axiomatize `projectSecondLowest48` directly.",
        "created_at": "2022-04-16T19:01:05.353000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Or you can have more generic `project...` functions which can be used.",
        "created_at": "2022-04-16T19:01:15.989000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "But the point is to take advantage of the structure that the compiler introduces. It's not like it will introduce _arbitrary_ bitwise operation, but highly structured ones. bit-blasting gives up completing on understanding that structure.",
        "created_at": "2022-04-16T19:01:56.562000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "Here, for example, is the algerbraic presentation of the needed packing/unpacking lemmas for multi-collateral dai: https://github.com/runtimeverification/evm-semantics/blob/master/tests/specs/mcd/word-pack.k",
        "created_at": "2022-04-16T19:02:51.049000+00:00",
        "attachments": null
    },
    {
        "author": "ehildenb",
        "category": "Consensus R\u0026D",
        "parent": "",
        "content": "So the short answer is \"we don't deal with things like shifts directly, we try to handle it at a higher-level, in a Solidity-specific or even contract-specific way\"",
        "created_at": "2022-04-16T19:03:34.073000+00:00",
        "attachments": null
    }
]