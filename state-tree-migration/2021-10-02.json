[
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Has anyone explored making an on-disk storage format and engine based on our merkle tree design?\n\nI think if you make a verkle tree implementation that stores nodes by their position in the tree, and edits them in place, then you can get an implementation where you just need ~4 DB reads (because verkle trees are 256-ary), and then if you assume a few hundred MB of cache, that goes down to ~1 DB read",
        "created_at": "2021-10-02T06:50:08.859000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So the problem becomes easier through a combination of (i) in-place editing instead of hash-storage and garbage collection, and (ii) the much greater width of the tree",
        "created_at": "2021-10-02T06:50:38.128000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The prover has:\n\n* The polynomial P\n* A coordinate X\n* A value Y, with the claim that P(X) = Y\n\nThe verifier already has:\n\n* A commitment to P (it's assumed that the verifier knows that the commitment is \"legit\" because they got it from some other source, eg. because it's hashed into some block that they verified); we'll call this commitment C\n* X and Y (eg. because the claimed values are provided in a witness, and the protocol here is just verifying that witness)\n\nThe prover provides a proof. The proof proves that P'(x) = y for *some* P' that matches C. There is only one possible P', which equals P",
        "created_at": "2021-10-02T06:55:10.474000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "The proof verification algorithm operates over the proof and over C, so the proof is tied to C",
        "created_at": "2021-10-02T06:55:30.607000+00:00",
        "attachments": null
    },
    {
        "author": "norswap",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Thanks! So my issue relates to\n\"The verifier already has a commitment to P\"\nI'm basing myself on https://notes.ethereum.org/@vbuterin/verkle_tree_eip#Verkle-tree-definition\nand according to there, we only have a commitment to vector values (not to polynomial coefficients such that evaluation of the polynomial returns the value)\n\nBut I think I found the answer at the bottom of the page here: https://dankradfeist.de/ethereum/cryptography/2021/07/27/inner-product-arguments.html#creating-an-ipa-for-a-polynomial-in-coefficient-form\n\nWhich to summarize says that:\n\nIf we have:\n* `a` a vector of values known by the prover\n* `P(X)` a polynomial returning the vector value at the position `X`\n* C, a commitment to `a` trusted by the verifier (e.g.) from a block\n\nThen we can prove `a . b = P(X)`, where `b` is a vector derived from `X` and the\ndomain ([0-255] in this case) via the barycentric formula, such that the\nverifier will indeed be convinced that `P(X)` is the value at index `X` in the vector `a`.\n\nSo the thing I was really missing was this barycentric formula to get `b` such\nthat the verifier would be able to trust that the proof is consistent with its\nexisting pedersen commitment to the vector.\n\n\u003c@!427491045308235776\u003e problem solved (at least for now)",
        "created_at": "2021-10-02T12:03:47.741000+00:00",
        "attachments": null
    }
]