[
    {
        "author": "philogy",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hey is EIP-6800 still the goto spec if I want to understand what a future Verkle-Ethereum is very like going to look like?\n\nDeveloping a smart contract and am looking to have it be optimized for Verkle trees already",
        "created_at": "2023-11-30T10:31:34.428000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think for the case you're mentioning, you'd be more interested in understanding https://eips.ethereum.org/EIPS/eip-4762\nSince the gas cost changes is probably what you'll try to optimize for.",
        "created_at": "2023-11-30T10:34:34.707000+00:00",
        "attachments": null
    },
    {
        "author": "philogy",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Where's the best place to ask questions and make comments on the upcominng Verkle changes? Mainly questions like:\n- couldn't the code size limit be lifted or largely increased now if accessing code is metered?\n- addresses are annotated as `bytes32`, however the EIPs (EIP-6800, EIP-4762) don't seem to specify whether `CREATE` \u0026 `CREATE2` will create contracts and return with addresses actually being 32-bytes long\n- why are things like contract nonce, version and code size packed into 1 leaf to minimize the common leaf accesses (maybe balance could be packed in too if restricted to 2^128)",
        "created_at": "2023-11-30T11:52:42.380000+00:00",
        "attachments": null
    },
    {
        "author": "philogy",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Furthermore the new metering for the `*CALL` and `SSTORE,SLOAD` opcodes is not entirely clear, is the base cost for these opcodes no always `100` with the only additional gas according to the state access/write event schedule? What about when the immutable pre-verkle state tree is accessed with one of the opcodes? Or is the entire tree transferred over upon first access free of charge?",
        "created_at": "2023-11-30T12:03:48.016000+00:00",
        "attachments": null
    },
    {
        "author": "philogy",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "EIP-4762 just says:\n\u003e Remove the following gas costs:\n\u003e - Increased gas cost of `CALL` if it is nonzero-value-sending\n\u003e - EIP-2200 `SSTORE` gas costs except for the `SLOAD_GAS`\n\u003e - 200 per byte contract code cost\n\u003e \n\u003e Reduce gas cost:\n\u003e \n\u003e - `CREATE` to 1000",
        "created_at": "2023-11-30T12:04:49.375000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e couldn't the code size limit be lifted or largely increased now if accessing code is metered?\nit could, but it's not the purpose of this EIP\n\n\u003e addresses are annotated as bytes32, however the EIPs (EIP-6800, EIP-4762) don't seem to specify whether CREATE \u0026 CREATE2 will create contracts and return with addresses actually being 32-bytes long\nyou are mixing up tree address with eoa/contract addresses, eoa/contract addresses are unchanged at 20 bytes and tree addresses are also unchanged at 32 bytes\n\n\u003e why are things like contract nonce, version and code size packed into 1 leaf to minimize the common leaf accesses (maybe balance could be packed in too if restricted to 2^128)\nbecause we want to make it stateless, on the one hand, so only pay for what is accessed, and zk friendly, on the other hand, so have every item use a fixed format instead of the highly zk-unfriendly rlp",
        "created_at": "2023-11-30T12:09:25.381000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e  is the base cost for these opcodes no always 100 \nnot always, it's only paid on first access, the cost dpeends on whether you already opened locations around it, and when it's been read/written once it's the same cost as reading a \"hot\" memory location\n\n\u003e ï»¿What about when the immutable pre-verkle state tree is accessed with one of the opcodes?\nthere is a client-side optimization that makes it possible to read both the pre and post state at the same time, and so reading the former state is somewhat \"free\".",
        "created_at": "2023-11-30T12:13:38.739000+00:00",
        "attachments": null
    },
    {
        "author": "philogy",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah I see that makes sense, yeah so the `*CALL` opcodes,  `SSTORE` and `SLOAD` all cost `100` **+ tree write/access costs**.\n\nWhen it comes to packing I don't mean doing RLP, I just mean putting the values at fixed byte offsets e.g. first 16-bytes is balance, next 8-bytes nonce, next 4-bytes the version and last 4-bytes the code size. This should be quite zk friendly, no? \n\nAlso to double check the base cost (not including tree write/access) of both `create` and `create2` is to be changed to 1000?",
        "created_at": "2023-11-30T12:20:57.581000+00:00",
        "attachments": null
    },
    {
        "author": "philogy",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Another question I had is for the storage slot tree key derivation why not have storage keys after the header start at the `MAIN_STORAGE_OFFSET` rather than `MAIN_STORAGE_OFFSET + HEADER_STORAGE_OFFSET` i.e. changing the `get_storage_slot_tree_keys` function to:\n\n```python\ndef get_storage_slot_tree_keys(storage_key: int) -\u003e [int, int]:\n    main_offset: int = HEADER_STORAGE_OFFSET + storage_key\n    if main_offset \u003c CODE_OFFSET:\n        pos = main_offset\n    else:\n        pos = MAIN_STORAGE_OFFSET + main_offset - CODE_OFFSET\n    return (\n        pos // 256,\n        pos % 256\n    )\n```\n\nThis would allow 256 keys (`[64; 320)`) to be stored together in the same sub-tree instead of only having the next 192 storage keys in the first main storage sub-tree",
        "created_at": "2023-11-30T12:23:26.663000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e When it comes to packing I don't mean doing RLP, I just mean putting the values at fixed byte offsets e.g. first 16-bytes is balance, next 8-bytes nonce, next 4-bytes the version and last 4-bytes the code size. This should be quite zk friendly, no? \nzkEVMs circuits deal with variables as scalar field elements of the underlying EC. any kind of arbitrary byte-offset/\"bit crafting\" format adds friction to the circuit design.\n\n\u003e Another question I had is for the storage slot tree key derivation why not...\nThat's a good point. I'm not sure about the original rationale in this decision, but it might be that it was preferred to have storage slots be more natural alignment of 256 at the cost of that second \"group\" not being (completely) filled.",
        "created_at": "2023-11-30T13:21:55.683000+00:00",
        "attachments": null
    },
    {
        "author": "philogy",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "On the packing topic, yes it would require extra constraints but I think the trade-off would be worth it considering no packing would lead:\n1. To some state bloat (3-4 extra leaves / account)\n2. 600-800 gas extra per call\n3. 20.1k-26.8k extra gas per create\n\nAs far as I understand, for zk circuits, doing such an unpacking (`(x // S) % M`) is not too expensive, assuming no custom gates (just `a * b + c`) it's 2-3 field multiplications and additions and 2 range-constraints?\n\nNot sure how verkle proofs work in zk but I assume that while cheap it's also not completely free to verify a witness with a few additional leaves?",
        "created_at": "2023-11-30T14:01:18.408000+00:00",
        "attachments": null
    }
]