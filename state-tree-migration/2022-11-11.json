[
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "ElementsToBytes follows the same pattern here too!\n\nI canâ€™t remember if we benchmarked that already",
        "created_at": "2022-11-11T00:00:22.011000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@427491045308235776\u003e , uhm, do we need this endianness conversion from `fp.Element` to `fr.Element`?",
        "created_at": "2022-11-11T00:00:58.137000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "You mean instead of doing BytesLE/SetBytesLE do Bytes/SetBytes?",
        "created_at": "2022-11-11T00:02:31.855000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I mean looking here:\n```\n    // Multiply x by yInv\n    for i := 0; i \u003c int(len(elements)); i++ {\n        var mappedElement fp.Element\n\n        mappedElement.Mul(\u0026elements[i].inner.X, \u0026yInvs[i])\n        byts := mappedElement.BytesLE()\n\n        var res fr.Element\n        res.SetBytesLE(byts[:])\n        scalars = append(scalars, res)\n    }\n```\nThere `mappedElement` is a `fp.Element`, and it gets `BytesLE()` and then `SetBytesLE(..)` to put that result into a `fr.Element` which underlying type is the same `[4]uint64`.\nI'm wondering if this `BytesLE() + SetBytesLE()` is really needed; but I can be probably missing something",
        "created_at": "2022-11-11T00:06:15.339000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In summary my question is if doing something like: `res = mappedElement` is incorrect",
        "created_at": "2022-11-11T00:07:17.188000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh I see what you mean",
        "created_at": "2022-11-11T00:07:23.953000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah thatâ€™s a good question",
        "created_at": "2022-11-11T00:07:41.315000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yep so they are both backed by 4 u64s which can be seen as a 256 bit number. fp.Element will ensure that the number that the 4 u64s represent are less than some prime â€˜pâ€™\n\nWhile fr.Element will ensure that the 4 u64s when interpreted as a number will be less than some prime â€˜râ€™",
        "created_at": "2022-11-11T00:11:34.428000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Oh I see in the code. `SetBytesLE` makes sure we do the `Mod(..)` of the field",
        "created_at": "2022-11-11T00:13:17.247000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "So I guess you can view fp as bigInt but all numbers are modulo p",
        "created_at": "2022-11-11T00:13:18.896000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yep exactly",
        "created_at": "2022-11-11T00:13:28.210000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "OK, and since `r` is smaller than `p` we have to do that. If we would be doing the inverse conversion, theoretically wouldn't be needed",
        "created_at": "2022-11-11T00:14:18.144000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yep exactly*\n\n*There can be complications depending on how you represent the number internally",
        "created_at": "2022-11-11T00:15:20.691000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Interesting. I'll marinate on this pattern to change from fields because maybe there's a way to avoid some things on how this works using the `sync.Pool`. I'll take some notes to take a look and see if there's something we can do about it.",
        "created_at": "2022-11-11T00:16:34.707000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sounds good! You may be able to upstream that change to the goff tool ðŸ™‚",
        "created_at": "2022-11-11T00:17:26.728000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@427491045308235776\u003e, this is ready for review: https://github.com/crate-crypto/go-ipa/pull/30\n\nNow I (optimistically) updated the benchs again targeting that PR branch. See here: https://github.com/gballet/go-verkle/pull/291#pullrequestreview-1176700034\nI summarized the results all over again since that PR is somewhat confusing.\n\nAfter all the changes (new master + assuming that go-ipa #30 gets merged), we have in `ns/value` (so, amortized cost per value):\n```\nname                          old ns/value   new ns/value   delta\nGroupToField/multiple/1-16       1.77k Â± 2%     1.68k Â± 1%   -5.32%  (p=0.008 n=5+5)\nGroupToField/multiple/2-16       1.10k Â± 1%     0.96k Â± 0%  -12.86%  (p=0.008 n=5+5)\nGroupToField/multiple/4-16         834 Â± 2%       692 Â± 3%  -17.00%  (p=0.008 n=5+5)\nGroupToField/multiple/8-16         703 Â± 3%       538 Â± 2%  -23.36%  (p=0.008 n=5+5)\nGroupToField/multiple/16-16        592 Â± 2%       446 Â± 4%  -24.55%  (p=0.008 n=5+5)\nGroupToField/multiple/32-16        545 Â± 2%       419 Â± 3%  -23.12%  (p=0.008 n=5+5)\nGroupToField/multiple/64-16        522 Â± 3%       411 Â± 2%  -21.31%  (p=0.008 n=5+5)\nGroupToField/multiple/128-16       514 Â± 3%       388 Â± 4%  -24.56%  (p=0.008 n=5+5)\nGroupToField/multiple/256-16       500 Â± 5%       378 Â± 2%  -24.47%  (p=0.008 n=5+5)\n```\nMakes sense that savings are more the bigger it is, because of how slices grow in Go. (They ~double (not exactly, but est.) whenever they hit the capacity. So if you start with a slice with capacity zero up to length 256, it will grow more times than to, e.g, than with length 4).\n\n\u003c@353136597522448385\u003e, apart from that referenced comment in the second link I shared in this message, I added some new _code_ comments in #291 that might be interesting to consider.",
        "created_at": "2022-11-11T02:24:46.916000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Unfortunately this last change doesn't seem to have any impact on the block replay benchmark, but if it improves the go benchmarks then it is still good to have. At this point,  `toFr` now represents under 2% of the execution time, so I'm happy to merge \u003c@774033563732541451\u003e's last PR into go-verkle and look at other areas.",
        "created_at": "2022-11-11T13:36:07.662000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "And one of these areas is point copy: it takes a lot of time, and imo it should be as cheap as copying bytes. Currently, to make a copy I have to call `Bytes` and then `SetBytesTrusted`. It could be even faster, I feel, if there was a `Copy` function that performs less checks that (it seems to me) aren't warranted in the case of a copy.",
        "created_at": "2022-11-11T13:38:28.823000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Also, `fp.Mul` is now the biggest time hog, so that's another area to look at.",
        "created_at": "2022-11-11T13:39:13.751000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "do you have an example in the code about that case? if it's copying a Fp, i'd guess a direct assignement should be fine. if it's a Fp to Fr then... yeah, that's related to this convo: https://discord.com/channels/595666850260713488/824798757618188339/1040417136423743520",
        "created_at": "2022-11-11T13:41:02.953000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "is possible that i could run that block-replay benchmark myself? (not sure if it's a benchmark in some separate branch, or needs some synced state?)",
        "created_at": "2022-11-11T13:41:46.590000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "https://github.com/gballet/go-verkle/blob/master/ipa.go#L40",
        "created_at": "2022-11-11T13:42:10.851000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes it needs some synced state but I deliberately won't share it right now because 1) it needs some cleanup that will be done in a couple weeks when I tackle the testing infra with devops 2) I don't want to derail you from what you're doing right now, what you're doing is quite useful",
        "created_at": "2022-11-11T13:47:01.454000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "cool, thanks for your support!",
        "created_at": "2022-11-11T13:48:50.436000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "One thing I don't understand from the PR, is the reason to use a slice of pointers to Frs, ie `[]*Fr` ... does the indirect help at all here? Since Fr is just an array of four elements.\n\n\u003c@353136597522448385\u003e this is probably a remnant from go-verkle",
        "created_at": "2022-11-11T13:49:09.342000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah, touched on that here https://github.com/gballet/go-verkle/pull/291#discussion_r1019764609",
        "created_at": "2022-11-11T13:50:43.819000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For Copying, I think you can use this: \u003chttps://github.com/crate-crypto/go-ipa/blob/master/banderwagon/element.go#L247\u003e",
        "created_at": "2022-11-11T13:52:55.392000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "oh",
        "created_at": "2022-11-11T13:55:21.533000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes",
        "created_at": "2022-11-11T13:55:24.397000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Ah I see, I always thought that those copys would be cheap enough since its just 4 u64's to avoid the indirection ðŸ˜…  I haven't actually benchmarked that though, so could be super wrong",
        "created_at": "2022-11-11T13:55:47.979000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but so I feel that if I can reuse points that were previously allocated, it would save a lot of time",
        "created_at": "2022-11-11T13:56:10.766000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "but I'll wait for Ignacio to chime on that",
        "created_at": "2022-11-11T13:56:26.990000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah I think thats fair, I'll tentatively merge with that API so you can remove the replace and merge the go-verkle one!",
        "created_at": "2022-11-11T13:57:01.376000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yeah, copying (multiple) 4 uint64 should be quite fast. Honestly, I don't entirely like the `[]*Fr` API since there's an implicit invariant that the slice can't be nil elements. \nTechnically speaking, it's less work since you don't have to do copies when getting back on the client side. But I'm not sure that's worth it or entirely relevat to pay it as a somewhat dangerous API really.",
        "created_at": "2022-11-11T13:58:13.574000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@353136597522448385\u003e For geth, is it the policy that the crypto can panic, \u003c@774033563732541451\u003e related to the go-ipa method where it panics if the slices are not equal",
        "created_at": "2022-11-11T13:59:15.052000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In the grand scheme of things, I'd doubt that extra copies (if we switch to `[]Fr` ) would be relevant. But hard to know with synthetic tests which can be red herrings compared to e2e benchmarks",
        "created_at": "2022-11-11T13:59:22.866000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Think we will scan the codebases to remove all panics that can be caused by user error, like passing in the wrong slice length, but I'm not entirely certain as to what the policy is for geth",
        "created_at": "2022-11-11T14:00:51.296000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Pasting the relevant code here as a reference:\n\n```go\nfunc MultiMapToScalarField(result []*fr.Element, elements []*Element) {\n    if len(result) != len(elements) {\n        panic(\"MultiMapToScalarField expects the result slice to be the same length of elements\")\n    }\n```",
        "created_at": "2022-11-11T14:01:24.561000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In general, an error should be returned, because having all geth clients panicking is not good. But the effect would be the same if an error was returned, so I guess it doesn't matter here.",
        "created_at": "2022-11-11T14:30:35.847000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Alright, will merge into go-ipa",
        "created_at": "2022-11-11T14:31:15.762000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Btw, I saw a conversation about it a couple days ago: the minimal go version that is supported by geth is now 1.18",
        "created_at": "2022-11-11T14:32:35.922000+00:00",
        "attachments": null
    }
]