[
    {
        "author": "ngweihan_eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Got it. What's the estimated average block size?",
        "created_at": "2023-07-04T00:53:23.919000+00:00",
        "attachments": null
    },
    {
        "author": "ngweihan_eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hi team, would like to ask, is it theoretically possible to verify a commitment of a node using the full compressed proof?\n\nFor example, in the picture below, I have generated a proof for 1 key-value pair, and would like to use the proof to verify against the commitment of the highlighted node.\n\nThe naive method I used to test in the go-verkle codebase is by slicing cis, zis and yis which corresponds to the targetted node. Something like:\n\n```\nproof, cis, zis, yis, _ := MakeVerkleMultiProof(root, [][]byte{zeroKeyTest})\n\npartialCis := cis[0]\npartialZis := zis[0]\npartialYis := yis[0]\n\nVerifyVerkleProof(proof, partialCis, partialZis, partialYis, cfg)\n```\nBut the verification returns false. \n\nIm still new to the cryptography behind VT, hope to get some pointers on this. Thank you! üòÑ",
        "created_at": "2023-07-04T03:03:21.266000+00:00",
        "attachments": [
            {
                "type": "image/png",
                "origin_name": "image.png",
                "content": "449c0cd9ddf23db15677c1bbf92250acc1cd537c640ca8ae695f30a2082e19ff"
            }
        ]
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, that check failing is expected.\n\nSo the reason for ‚Äúwhy‚Äù that‚Äôs the case can go as deep as you might want to dig. :)\n\nThe ELI5 answer is that the `MakeVerkleMultiProof(...)` call you did generate a proof of the tree keys `{zeroKeyTest}` (i.e: a single key in your example). That creates proof that involves proving openings of many nodes in the tree. Verifying this proof could be considered somewhat ‚Äúatomic‚Äù (I‚Äôm inventing this term). You can only verify that same original claim and not some part of it.\n\nThe underlying reason is that the proof aggregates inner product argument proofs, where all opening are ‚Äúcompressed‚Äù to a new (single) polynomial. The verifier needs the original openings (claims) to ‚Äúreconstruct‚Äù what it needs to know which that ‚Äúcompressed‚Äù polynomial is so that it can verify the proof.  (Deeper insight: the prover and verifier not agreeing on the inputs will make them differ on their view of the proof transcript, which will make the proof verification fail).\n\nNow, you are trying to do fine conceptually, but you can‚Äôt ‚Äúreslice‚Äù parts of the proof information in this library since it‚Äôs only focusing on the use case it needs (proofs for key values in blocks, so it starts from the root). You could theoretically create the proof ‚Äúsitting‚Äù from that node (and avoid reslicing), something like `root = root.(*InternalNode).children[0]`, and do the proof without reslicing using this new `root`. But that shouldn‚Äôt work either since, in this library, internal nodes internally have a `depth` attribute that is used to assist in generating proofs (so it‚Äôs expected the `root` to be at `depth`  0). [Also, doing `.(*InternalNode)` is cheating and nobody should be doing that; just mentioned as a hack]*",
        "created_at": "2023-07-04T12:02:34.252000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "In any case, you‚Äôre somewhat fighting with an API meant to work for a specific use case. There‚Äôs nothing stopping you from actually achieving what you want; but the verifier should know about this since if it tries to reconstruct a partial view of the tree from the proof, if you created the proof from a non-root node it will probably break many things. :)\n\nThe underlying multipoint-IPA proving system can be fed with whatever you want since it doesn‚Äôt care if this is coming from a VKT context or other thing, but the problem is mostly the prover and verifier of these higher-abstraction layers to agree on what is this proof and how to interpret it.",
        "created_at": "2023-07-04T12:02:35.742000+00:00",
        "attachments": null
    },
    {
        "author": "ngweihan_eth",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@774033563732541451\u003e thanks a lot for the super detailed explanation!!! will dig deeper and share if I have any new findings üôÇ",
        "created_at": "2023-07-04T12:24:12.652000+00:00",
        "attachments": null
    }
]