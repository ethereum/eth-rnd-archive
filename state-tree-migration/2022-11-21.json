[
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "sounds about right, I now remember that this endianness-conversion loop was a workaround. I must have forgotten about it when the function with he proper ordering was added. Would you mind creating a PR for it against `gballet/go-ethereum:beverly-hills-head`?",
        "created_at": "2022-11-21T07:55:30.522000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "sure!",
        "created_at": "2022-11-21T12:04:49.213000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003cdankrad\u003e \u003e \u003cdankrad\u003e  Q1, this seems to be a bit of a confusion. The tree key is not used to has data, only to get keys. So there is no such thing as a \"zeroed entry\". However the length encoding is important to distinguish hashes of say [0]*32 from [0]*64. Technically in our case all of them have the exact same input length so it's not required but wanted to make the spec a bit more future proof (re @verkle_bot: \u003cignacio (jsign)\u003e I've two questions reg this interesting `2 + 256 * len(inp)`  decision, maybe for @dankrad since it's EIP related. I just want to validate if they make sense (sorry if are obvious questions!)\n\nQ1: The idea there is to make the hash be different on \"empty\" entries vs \"zeroed entries\", right? e.g: if we have the hash of a vector with, say, 20 non-zero entries V be X. If we do `hash(V + [0])` we want the hash to be different.. so we need to pack the `len(..)` in the vector somehow, since the multiscalar multiplication can't really distinguish both cases. \n\nQ2: In the case of computing the hashes of leaf nodes in VKTs, I see we don't have this strategy of inserting the `len(..)` of the vector there. But I think that's because we're doing the \"leaf marker\"s? I think that is already solving the \"intentional zero\", so we don't need to include that length as we do for creating trie keys as in the other case?)",
        "created_at": "2022-11-21T18:33:34.486000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003cdankrad\u003e Q2: I don't understand what you mean by \"computing the hashes of leaf nodes\". Do you mean computing the Pedersen commitment to the leaves?\n\nSince all leaves are defined to be exactly 32 bytes, we do indeed not add the length anywhere",
        "created_at": "2022-11-21T18:36:28.281000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "(The bridge-bot formatting is a bit confusing, but I think I understood your message)\nI meant \"zeroed entries\" for other vector positions for the key generation. If in the future, for some reason the 6-th entry is intentionally 0x000000 the only way the hash can distinguish from a 5-th length vector is with that `len(...)` value.\nSo I think we're talking about the same!",
        "created_at": "2022-11-21T22:38:25.608000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, I meant Pedersen Commitment. \nI mean the length of the vector of non-zero entries (not the length of each entry which are 32 bytes, yes).\n\nI'll try to explain better to check if we're talking about the same.\nIn the leaf nodes, we have 256 entries for 128 values (low, high of each). Technically speaking, there might be entries in that 256 vector that have a value 0x00...000 not because a value was intentionally stored there, but because it's empty.\n\nIf we don't have that \"leaf marker\" the Pedersen Commitment in both cases (intentional 0x00000 and \"empty\" 0x0000) would lead to the same commitment value for the vector.\nI just tried to connect that usefulness of the \"leaf marker\", to the `len(...)` used for generating keys (yes, different use case) on how each of them try to exclude unintentional zero entries in the vectors so the underlying hash or commitment differs in both cases.\n\nI hope this wasn't a tongue twister and makes some sense!",
        "created_at": "2022-11-21T22:44:51.363000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@353136597522448385\u003e, I've this change ready. \nThe order for review would be:\n1) https://github.com/gballet/go-verkle/pull/300\n2) https://github.com/gballet/go-ethereum/pull/140",
        "created_at": "2022-11-21T22:46:34.522000+00:00",
        "attachments": null
    }
]