[
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Here are my comments:\n- In order to be 'fair' to pedersen, keccack should also be hashing 256x32 bytes, N of them being non-zero. Factors like caching would otherwise constitute an even bigger advantage to keccak (on a processor with a 4MB cache)\n- The case with 128 non-zero entries is missing from the benchmarks, which would be actually quite useful to know as it approximates a typical small contract\n- Going through the datasheet of your processor, it looks pretty high-end. It'd be nice to look at it on a more limited/common machine, e.g. a rpi4. I can help with that next week.\n- What you are computing in your benchmark is not a pedersen hash, it's the commitment to a leaf that has many children. While the results of this are still very interesting, what you should do is use `GetTreeKey` and not `NewLeafNode.Commit`\n\nThese numbers provide a good reference, thank you. What we would like to see as next steps:\n- Isolate fp.Mul/fp.Inv numbers and benchmark that against their bst version. We are trying to figure out if there is much left to optimize in the go code, and figuring this out is a priority\n- Add other benchmarks to use `GetTreeKey` and compare them against performing `keccak(addr)`, then `keccak(slot)` which represents the equivalent operation in the Ethereum MPT.\n- Rename `BenchmarkFullPedersen` to `BenchmarkFullCommit`",
        "created_at": "2022-10-28T09:08:11.534000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "hope this helps, let me know if something isn't clear",
        "created_at": "2022-10-28T09:08:26.315000+00:00",
        "attachments": null
    },
    {
        "author": "gballet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "looking at the translated layer, it's more like 4/5 these days (much closer to 4 though)",
        "created_at": "2022-10-28T09:09:05.250000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "- Is a 256x32 bytes keccak hash the average case for PMT? \n\n- Yeah it‚Äôs probably good to standardise the machine everyone runs on\n\n- Comitting to a leaf of children / vector of values is the same as a pedersen hash. GetTreeKey shouldn‚Äôt give numbers that are much different in isolation, though if we can figure out the average care access pattern for it, that would be great",
        "created_at": "2022-10-28T10:01:29.332000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Thanks a lot for your feedback!\nI'll reply in order:\n- Agree. Actually, I think makes sense to also do the same (2^N)x32bytes style as I did in the Pedersen case. I'll update that in my benchmarks.\n- I'll add it üëç \n- Yep, this CPU is pretty high end. I've also a Mac Book Pro. Maybe after we stabilize this set of benchmarks, we can commit to some `results` folder where record current results for our available setups (including your rpi4) to have an idea.\n- I'll rename that benchmark, and ad another to benchmark the \"logical key\" -\u003e \"trie key\" with `GetTreeKey` üëç .  Just to confirm: with `GetTreeKey` you're refering to this function https://github.com/ethereum/go-ethereum/pull/24906/files#diff-b4012b1250cf4664a9d898d0b1e2f5b45a93ab90c9626220ee5f633fd7c61264R62 ? (that commit is from this PR https://github.com/ethereum/go-ethereum/pull/24906). (Asking to verify if it's from there, or is in `main` somewhere already? I want to make sure to target the correct version/impl)\n\nReg next steps:\n- I'll work on it \n- üëç \n- üëç",
        "created_at": "2022-10-28T12:38:22.928000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e - Comitting to a leaf of children / vector of values is the same as a pedersen hash. GetTreeKey shouldn‚Äôt give numbers that are much different in isolation, though if we can figure out the average care access pattern for it, that would be great\nYes, that was my exact thinking when I created the benchmark. Under the hood they're somewhat the same, but it's true that it's worth separating just to be sure. I think mostly because the \"vector preparation\" stage is a bit different in both cases, but yes, the underlying EC arith ops are the same. I'll add that `GetTreeKey` bench and see if we discover something extra",
        "created_at": "2022-10-28T12:42:36.256000+00:00",
        "attachments": null
    },
    {
        "author": "jefferson8477",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hi \u003c@427491045308235776\u003e üëã I‚Äôd like to help contribute to and build out the Verkle Tree website. I‚Äôve made this PR fixing the KaTeX rendering issue - https://github.com/ethereum/verkle-dev-website/pull/14",
        "created_at": "2022-10-28T20:01:24.100000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hey Jefferson üëã Thanks for the PR! I‚Äôve merged it along with the Lagrange PR.\n\nFeel free to take on the other issues there! There is a docusaurus related issue when you use brackets in the title for example, that may be up your alley?",
        "created_at": "2022-10-28T20:11:49.409000+00:00",
        "attachments": null
    },
    {
        "author": "jefferson8477",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Sweet. Sure thing will take a look",
        "created_at": "2022-10-28T20:41:15.551000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003cdankrad\u003e \u003e \u003cdankrad\u003e  Can I clarify whether the keccak benchmark hashes one 32-byte input or 16 32-byte inputs? That's very unclear from the document (re @verkle_bot: \u003cignacio (jsign)\u003e [reply]: Thanks a lot for your feedback!\nI'll reply in order:\n- Agree. Actually, I think makes sense to also do the same (2^N)x32bytes style as I did in the Pedersen case. I'll update that in my benchmarks.\n- I'll add it üëç \n- Yep, this CPU is pretty high end. I've also a Mac Book Pro. Maybe after we stabilize this set of benchmarks, we can commit to some `results` folder where record current results for our available setups (including your rpi4) to have an idea.\n- I'll rename that benchmark, and ad another to benchmark the \"logical key\" -\u003e \"trie key\" with `GetTreeKey` üëç .  Just to confirm: with `GetTreeKey` you're refering to this function https://github.com/ethereum/go-ethereum/pull/24906/files#diff-b4012b1250cf4664a9d898d0b1e2f5b45a93ab90c9626220ee5f633fd7c61264R62 ? (that commit is from this PR https://github.com/ethereum/go-ethereum/pull/24906). (Asking to verify if it's from there, or is in `main` somewhere already? I want to make sure to target the correct version/impl)\n\nReg next steps:\n- I'll work on it \n- üëç \n- üëç)",
        "created_at": "2022-10-28T21:15:02.805000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003c@555483069038198827\u003e, that document is showing Keccak on a single 32 byte value.\nI'm working on a more general benchmark to test a single value with different sizes 2^N with N=[1, 10]\n\nHere's my current results (in this machine, we'll try to generate results in multiple setups soon):\n```\nBenchmarkKeccak/size=1-16                        1234263               980.1 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=2-16                        1339491               971.4 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=4-16                        1239312               983.7 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=8-16                        1224097               967.5 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=16-16                       1257001               956.1 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=32-16                       1254214               913.3 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=64-16                       1343644               898.6 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=128-16                      1382116               836.2 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=256-16                      1000000              1353 ns/op             480 B/op          2 allocs/op\nBenchmarkKeccak/size=512-16                       631677              2090 ns/op             480 B/op          2 allocs/op\nBenchmarkKeccak/size=1024-16                      397764              3340 ns/op             480 B/op          2 allocs/op\n```\n\nThere `size=N` means Keccak on a single value of N bytes.",
        "created_at": "2022-10-28T21:54:07.740000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "It's a bit unfortunate that the sha3 library used here (which is the same as Geth, so trying to be realistic here), has to do 2 memory allocations for this. That adds some noise to a potential theoretical expectation.",
        "created_at": "2022-10-28T21:55:36.594000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Here's another benchmark that hashes 32 independent values of different sizes N:\n```\nBenchmarkKeccak/32_values_of_size=1-16            176301             31737 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=2-16            185247             31777 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=4-16            188013             33793 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=8-16            156852             36945 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=16-16           177480             36507 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=32-16           155421             36179 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=64-16           169831             33000 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=128-16          186926             32087 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=256-16          124524             47274 ns/op           15840 B/op         66 allocs/op\nBenchmarkKeccak/32_values_of_size=512-16           84104             69537 ns/op           15840 B/op         66 allocs/op\n```",
        "created_at": "2022-10-28T22:01:58.830000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003cdankrad\u003e \u003e \u003cdankrad\u003e  but MPT always hashes 16*32 bytes so that's not a good metric, right? (re @verkle_bot: \u003cignacio (jsign)\u003e [reply]: @dankrad, that document is showing Keccak on a single 32 byte value.\nI'm working on a more general benchmark to test a single value with different sizes 2^N with N=[1, 10]\n\nHere's my current results (in this machine, we'll try to generate results in multiple setups soon):\n```\nBenchmarkKeccak/size=1-16                        1234263               980.1 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=2-16                        1339491               971.4 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=4-16                        1239312               983.7 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=8-16                        1224097               967.5 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=16-16                       1257001               956.1 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=32-16                       1254214               913.3 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=64-16                       1343644               898.6 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=128-16                      1382116               836.2 ns/op           480 B/op          2 allocs/op\nBenchmarkKeccak/size=256-16                      1000000              1353 ns/op             480 B/op          2 allocs/op\nBenchmarkKeccak/size=512-16                       631677              2090 ns/op             480 B/op          2 allocs/op\nBenchmarkKeccak/size=1024-16                      397764              3340 ns/op             480 B/op          2 allocs/op\n```\n\nThere `size=N` means Keccak on a single value of N bytes.)",
        "created_at": "2022-10-28T22:04:47.115000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003cdankrad\u003e \u003e BenchmarkKeccak/size=512-16                       631677              2090 ns/op             480 B/op          2 allocs/op\n\nSo this would be the relevant row?",
        "created_at": "2022-10-28T22:06:03.483000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yes, that should be the relevant in that case",
        "created_at": "2022-10-28T22:06:36.219000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003cdankrad\u003e \u003e BenchmarkKeccak/32_values_of_size=16-16           177480             36507 ns/op           15840 B/op         66 allocs/op\n\nDon't understand why this is different though?",
        "created_at": "2022-10-28T22:06:55.857000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003cdankrad\u003e shouldn't it be the same?",
        "created_at": "2022-10-28T22:07:07.241000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Nono, that benchmark is 32 independent 16-byte values. Sorry if that was confusing.",
        "created_at": "2022-10-28T22:09:41.694000+00:00",
        "attachments": null
    },
    {
        "author": "jsign",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "TL;DR (in this machine) is that 16*32byte (512byte total) single value in Keccak is around 2 microseconds",
        "created_at": "2022-10-28T22:11:09.985000+00:00",
        "attachments": null
    }
]