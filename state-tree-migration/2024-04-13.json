[
    {
        "author": "milos88",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I have a question regarding one function from EIP-6800:\n```\ndef pedersen_hash(inp: bytes) -\u003e bytes32:\n    assert len(inp) \u003c= 255 * 16\n    # Interpret input as list of 128 bit (16 byte) integers\n    ext_input = inp + b\"\\0\" * (255 * 16 - len(inp))\n    ints = [2 + 256 * len(inp)] + \\\n           [int.from_bytes(ext_input[16 * i:16 * (i + 1)], 'little') for i in range(255)]\n    return compute_commitment_root(ints).hash_point_to_bytes()\n```\nIs it ever used for an input that is not exactly 64 bytes long? More specifically: `address + tree_index.to_bytes(32, 'little')` .",
        "created_at": "2024-04-13T06:31:53.032000+00:00",
        "attachments": null
    },
    {
        "author": "milos88",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "If not, can we change it to something like this:\n```\ndef get_tree_stem(address: Address32, tree_index: int) -\u003e bytes31:\n    tree_index_bytes = tree_index.to_bytes(32, 'little')\n    \n    ints = [2 + 256 * 64, # maybe hardcode or change this to something else\n            int.from_bytes(address[:16], 'little'),\n            int.from_bytes(address[16:], 'little'),\n            int.from_bytes(tree_index_bytes[:16], 'little'),\n            int.from_bytes(tree_index_bytes[16:], 'little')] +\n           [0] * 251\n    return compute_commitment_root(ints).hash_point_to_bytes()[:31]\n```\nI think this would make it and it's purpose much clearer",
        "created_at": "2024-04-13T06:34:44.014000+00:00",
        "attachments": null
    }
]