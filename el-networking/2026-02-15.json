[
  {
    "author": "jochembrouwer",
    "category": "Execution Layer",
    "parent": "",
    "content": "<@194432762315407360> regarding eth/70 I was wondering, EIP states:\n\"Partial receipt lists cannot be verified against the block header, so in responses with lastBlockIncomplete = 1, the last receipts list must be validated in a different way:\"\n\nWhy can't we verify partial receipt lists? We can do so by reconstructing the trie and just attaching a range proof there. We don't need a left proof  because we assume that all values requested before or on \"firstBlockReceiptIndex\" are known.\nIf we want we can even extend this to omit the hashes already known by the receiver.\n\nThe downside of this is obviously that we have to reconstruct the trie, which might be somewhat expensive for the tries in question (> 10 mb data because we have to split them up).\n\nI'm thinking if there is a smarter way to do this, because we can derive the trie size (amount of transactions), and because we know the trie structure we could maybe use that to lower the data size required, or maybe even the trie calculation necessary (need specific nodes to prove it, so might not need to compute the entire trie)",
    "created_at": "2026-02-15T03:52:09.130000+00:00",
    "attachments": []
  },
  {
    "author": "jochembrouwer",
    "category": "Execution Layer",
    "parent": "",
    "content": "And actually this would be mitigated too then: \n> For a Receipts message, each block receipts list is validated by checking the full list against the tree root stored in the block header. When downloading a paginated list across multiple requests, the client must potentially buffer more than 10MB of unvalidated input. This cannot be avoided, since the protocol allows receipt lists of such size at a high block gas limit. However, we can at least bound the input size by applying sanity checks as recommended in the specification section.\n\nWith the proof we would directly validate it",
    "created_at": "2026-02-15T03:54:03.048000+00:00",
    "attachments": []
  },
  {
    "author": "jochembrouwer",
    "category": "Execution Layer",
    "parent": "",
    "content": "Instead of using lastBlockIncomplete, we'd change to a list. If the list is empty, then the returned receipts are complete. If not, then it includes the nodes necessary to prove the trie items. (This is nontrivial because for responses which include key 0 and a key <= 127 we need proof for 0 and for the highest key returned. Because of RLP encoding 0x80 = 0. For >= 128 we thus assume all proof nodes were retrieved from previous requests and we thus include only the proof of the final value (this thus includes the 0x80 node proof)). Since we initially return 0-N based on these rules we know which paths the given nodes belong to as we know how the final trie structure will look like. (or the order does not matter, we hash the proof nodes and then build the trie up from the trie root, we can then directly see if items belong or not)",
    "created_at": "2026-02-15T07:18:13.728000+00:00",
    "attachments": []
  },
  {
    "author": ".fjl",
    "category": "Execution Layer",
    "parent": "",
    "content": "We considered this, and the range proving primitive from snapsync could even be used. But the downside of attaching a proof is that it slows down the delivery. The receipt trie is not stored by any client, it always has to be reconstructed in memory for hashing.\n\nAnother issue is complexity. With the current approach, where we only validate complete lists, we can use the same verifier that we use for all the other block body constituents. If we add a proof to the receipts, we have to make a custom verifier.",
    "created_at": "2026-02-15T08:40:30.395000+00:00",
    "attachments": []
  }
]