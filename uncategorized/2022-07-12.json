[
    {
        "author": "dirtyminer",
        "category": "general",
        "parent": "",
        "content": "",
        "created_at": "2022-07-12T04:56:49.980000+00:00",
        "attachments": [
            {
                "type": "image/jpeg",
                "origin_name": "E72B8976-87D1-4D89-A0FC-0E4E34C724FF.jpg",
                "content": "879ec7c2e2f9ba15d6bf4e779381037e9bc53a269b5c126cf6b30155c84cb032"
            }
        ]
    },
    {
        "author": "dirtyminer",
        "category": "general",
        "parent": "",
        "content": "This is my approach. when you have a = b or c = 0, your answer is 1 which has no remainder.\nWhen you have q = 0, your function is undefined\nSo, as long as q =/= 0 you shouldn't have any problems. \n\nI agree with Kev, your program is doing a step wrong which throws everything else off",
        "created_at": "2022-07-12T04:59:05.567000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "general",
        "parent": "",
        "content": "I did not mean to imply that Marius was doing something wrong, just that itâ€™s a special case of something more general",
        "created_at": "2022-07-12T09:20:03.334000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Is this functionally equivalent?",
        "created_at": "2022-07-12T12:38:18.255000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "I tried that, problem is that b might be way bigger than q (q = 2) b \u003e 10000000000000000000000000000000000000000000000000",
        "created_at": "2022-07-12T12:39:52.213000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Well, you can always do (a-b)  mod q = (q - ((b-a) mod q)) mod q",
        "created_at": "2022-07-12T12:44:01.893000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "(Assuming q \u003e 0.)",
        "created_at": "2022-07-12T12:44:33.682000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "(Assuming that you want the result of the mod q operation to be in 0..q-1 for q\u003e0)",
        "created_at": "2022-07-12T12:45:56.606000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "If your library does not support negative numbers (which I find very, very weird, BTW), you are in for some case distinctions.",
        "created_at": "2022-07-12T12:49:12.842000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "If q==2, you have a-b mod 2== a+b mod 2 anyway.",
        "created_at": "2022-07-12T12:59:27.037000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "(not sure if q is hardwirded or a variable input in your problem; in general, (efficient algorithms for) computations involving modulo differ quite a lot depending on whether q is hardwired or not.)",
        "created_at": "2022-07-12T13:00:43.697000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "q is 2^x with x in [1, 64]",
        "created_at": "2022-07-12T13:01:32.804000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "What programming language?",
        "created_at": "2022-07-12T13:02:39.766000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Assuming u is represented binary (and positive; if negative, this is still true for 2's complement if the representation is \u003e=64 bits), you have u mod 2^x == u bitwise-and 2^x - 1.",
        "created_at": "2022-07-12T13:04:30.585000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "It might be better to actually bit-fiddle here.",
        "created_at": "2022-07-12T13:05:21.606000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "lest your math library does something stupid like use a general division algorithm.",
        "created_at": "2022-07-12T13:05:42.897000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Out of curiosity, what math library is making these trouble? Go's math.big library should work...",
        "created_at": "2022-07-12T13:14:26.546000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "(assuming you use Go)",
        "created_at": "2022-07-12T13:23:36.823000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Yeah but its within the go std library, so nat",
        "created_at": "2022-07-12T14:37:04.493000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "I used your suggestion now \u003c@761645159095599144\u003e, seemed to be the most sensible",
        "created_at": "2022-07-12T14:37:29.616000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Well, in practise, what you actually would want is just to obtain the least significant uint64",
        "created_at": "2022-07-12T14:38:04.561000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "There is no point in doing any modular computation until the very end.",
        "created_at": "2022-07-12T14:38:18.155000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Since x mod 2^i == 2 mod 2^64 mod 2^i for i\u003c=64.",
        "created_at": "2022-07-12T14:38:39.483000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "and Go's uint64 arithmetic works mod 2^64 anyway.",
        "created_at": "2022-07-12T14:38:52.197000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "I'm looking for a fast modular inverse algorithm now. The one I use only works for odd x. The b is guaranteed to be a power of two\nCurrent algo: https://link.springer.com/content/pdf/10.1007/3-540-46877-3_21.pdf p6",
        "created_at": "2022-07-12T14:39:08.617000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "of course.",
        "created_at": "2022-07-12T14:39:20.852000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Even numbers do not have a modular inverse modulo 2^i to start with.",
        "created_at": "2022-07-12T14:39:32.795000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "What are you trying to achieve? Improve Go's standard library?\n(which I find quite suboptimal in terms of allocations...)",
        "created_at": "2022-07-12T14:53:49.744000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Note that the algorithm you linked to might not be the fastest (if you really care about speed)",
        "created_at": "2022-07-12T14:58:03.187000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Yes",
        "created_at": "2022-07-12T14:58:08.776000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "ahh thats why^^",
        "created_at": "2022-07-12T14:58:17.645000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Something different is weird, the number should be odd",
        "created_at": "2022-07-12T15:00:42.318000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "I have a number with trailing zeros, I shift it right until it has no trailing zeros anymore, this number should be odd",
        "created_at": "2022-07-12T15:01:18.949000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Yes.",
        "created_at": "2022-07-12T15:01:27.288000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "Unless the number was all-zero, of course.",
        "created_at": "2022-07-12T15:01:35.128000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Is it possible for an odd number to not have an inverse in 2^n?",
        "created_at": "2022-07-12T15:05:03.255000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "No",
        "created_at": "2022-07-12T15:05:10.333000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "x is invertible modulo n iff gcd(x,n) == 1",
        "created_at": "2022-07-12T15:05:39.498000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "So for n a power of 2, that boils down to x being odd.",
        "created_at": "2022-07-12T15:05:53.680000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "I'm currently in a call for like; if you need help, it seems more efficient just just DM me for a quick call in 30mins.",
        "created_at": "2022-07-12T15:08:02.474000+00:00",
        "attachments": null
    },
    {
        "author": "mariusvanderwijden",
        "category": "general",
        "parent": "",
        "content": "Do you have a link to better one?",
        "created_at": "2022-07-12T15:08:32.506000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "No, just from looking at the algorithm; this is basically 2-adic Hensel lifting. You can do this 2^i - adic (meaning you can do several iterations of the main loop), provided you have a fixed 2^i-1 precomputation.",
        "created_at": "2022-07-12T15:10:16.138000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "This is basically trading iterations for lookup-tables.",
        "created_at": "2022-07-12T15:10:28.314000+00:00",
        "attachments": null
    },
    {
        "author": "gottfriedherold",
        "category": "general",
        "parent": "",
        "content": "With the lookup-table being a compile time constant, that can be done faster (at least in assembly)",
        "created_at": "2022-07-12T15:12:07.756000+00:00",
        "attachments": null
    }
]