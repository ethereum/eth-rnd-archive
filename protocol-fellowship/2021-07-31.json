[
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "I am _not_ an assembly wizard, but maybe the compiler at higher optimization levels is using a register you're clobbering in your assembly?",
        "created_at": "2021-07-31T05:25:01.086000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Been years since I've messed with any of that, and my memory is pretty spotty ^^;;",
        "created_at": "2021-07-31T05:26:01.477000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "This has been indeed my working thesis but I haven't been able to find it. Also cause the damned code works fine on every structure except the very large ones. It passes minimal tests and it segfaults only on the beaconstate for mainnet. I'll grab a coffee and give it my Saturday",
        "created_at": "2021-07-31T09:43:53.759000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "you were right on target! I was trying to be clever, but the compiler is smarter and was indeed breaking ABI in order to optimize. I needed to save one extra vector register and that's it. I'm not sure why this pops up on Intel and not AMD, but that's for another day.",
        "created_at": "2021-07-31T20:04:46.720000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Woo! That's awesome.",
        "created_at": "2021-07-31T20:05:34.674000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Optimizers are black magic. I'm sure there's a logical explanation for it... Somewhere.",
        "created_at": "2021-07-31T20:06:19.013000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Have you been compiling with `-march=native`?",
        "created_at": "2021-07-31T20:06:28.510000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "yes and no, in my AMD to run my benchmarks with SHA extensions of course I was, but to get a \"RELEASE\" version to run on my laptop I wasn't. Anyway the same segfault happens on the laptop compiling natively with `-march=native` on the laptop",
        "created_at": "2021-07-31T20:07:36.049000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Also the program is complicated enough that trying to trace the differences in the disassembly of the optimized vs unoptimized code will take me days, so decided not to do it ðŸ™‚",
        "created_at": "2021-07-31T20:08:25.657000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "There are some weirdness also that I don't understand, I'll post my new benchmarks in a minute when I'm done with Nimbus and Prysm, but my AVX2 implementation sucks on AMD and performs better on a small laptop, this is bizarre",
        "created_at": "2021-07-31T20:10:28.747000+00:00",
        "attachments": []
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "\u003c@!602753420033785856\u003e  probably better reporting here: I implemented assembly for x86_64 AVX2  8-blocks at a time, AVX 4-blocks and 1 block at a time, Testing on \n```\nIntel(R) Core(TM) i5-7200U CPU @ 2.50GHz\n```\nI get the following results for the hashing of the very same mainnet test that I mentioned before\n```\nLighthouse :   998ms\nPrysm      :  1085ms\nNimbus     :  1112ms\nMammon     :   654ms\n```\n~~I'm having  trouble building my patch to Nimbus to benchmark for some reason, but Nimbus uses the same library than Prysm I think~~. So the results here are clear as well. If you raise issues with the libraries you are using to hash, probably you want to point them to my repo for the respective implementations. Although presumably they'll be better at assembly than me. \n\nThe bizarre thing: if I run the AVX2 code on my Ryzen which is much more powerful than the laptop, it hashes in 760ms! This is the same as Lighthouse code without the SHA extensions. So that desktop running with AVX2 is slower  than the laptop. Remember that running natively with SHA-ni it hashes in 160ms",
        "created_at": "2021-07-31T20:47:40.273000+00:00",
        "attachments": []
    }
]