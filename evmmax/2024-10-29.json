[
    {
        "author": "jwasinger",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Hi \u003c@427491045308235776\u003e , Axic is not active on this project atm.  \u003c@450651770243252225\u003e \u003c@425274498732916736\u003e and myself have been contributing in recent times.\n\nI'm guessing you were looking at eip-6690?  there is a new draft EIP [here](https://hackmd.io/ouxz-L0ASGehx2z6EgHGTw).  In short, the changes are:\n* change the opcode format to perform the same operation on multiple values with a stride/skip factor (making it possible to implement and price arithmetic opcodes based on the use of SIMD).\n* support binary (power of two) moduli.",
        "created_at": "2024-10-29T03:32:48.816000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Is there somewhere I can read to see what gas pricing would roughly look like for something like the bls precompiles with evmmax?\n\nI put together implementation of g1/g2 ecmul (without conversion back to affine coords), and compared them to corresponding benchmarks of the 2bit windowed ecmul impl from gnark here:\n\nhttps://hackmd.io/QzHNML0YTYGy_djuAEl5Vg?view\n\nkeeping the implementation of the arithmetic constant, I think that the performance/gas ratio should somewhat hold if the implementation used glv (in fact, it should be better for EVM because less looping + ability to coallesce doublings means that non-arithmetic/control-flow EVM overhead is reduced).",
        "created_at": "2024-10-29T03:43:40.040000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e EIP says \"Gas models assume a rate of 1 gas per 25ns of execution time.\" -- I don't think 25ns makes sense since there is no standardized hardware for gas costs. Can this not be measured based off of the price of another instruction?\n\nIt was based off the performance of geth's ecrecover on a laptop with a weak mobile cpu that I was using at the time ðŸ˜†.  nonetheless I think the previous cost models from 6690/7747 would still hold, based on benchmarks I've done more recently.  But you're right that choosing a specific target rate is not correct here.",
        "created_at": "2024-10-29T03:45:09.490000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Since these are instructions for the modular arithmetic and not curve operations, what would be the plan to re-deploy the bls12/bn254 precompiles in client software?\n\nNot sure what you mean here.  I don't think that we (geth) would be reimplementing already-deployed precompiles using EVM bytecode if evmmax goes live.  at least not immediately.",
        "created_at": "2024-10-29T03:47:07.795000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Was there consideration to allow something like : `addN(modulus, [n1, n2, n3], [n4, n5, n6])` This would just return `[n1 + n4, n2+n5, n3+n6]` -- This could initially be priced the same as doing 3 separate additions with the same precompile.\n\nYup!  Basically this with a stride/skip factor is what we want to add.",
        "created_at": "2024-10-29T03:55:50.635000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Out of curiosity, what was the rationale for not including something like INVMODX?\n\nI think that so far, I'm not aware of a use-case that is really hamstrung by the lack of native inverse.  So far, we have just implemented inverse via fermat/exponentation.  for bls12381, the addchain uses about 450 multiplications+squarings with 25 allocated virtual registers (field elements).\n\nWe can also batch multiple inverses for little added overhead vs a single inverse.\n\nThat being said, we have to consider with Verkle that minimizing code-size will become very important.  so, the next cheapest alternative is using the modexp precompile (idk how much this would cost for bls12381, but I would imagine several thousand gas).",
        "created_at": "2024-10-29T04:09:21.309000+00:00",
        "attachments": null
    },
    {
        "author": "rodiazet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For the record. I shared our doc from first half of this year with some summary and our feedback. https://discord.com/channels/595666850260713488/800773302213279784/1295726333971791932",
        "created_at": "2024-10-29T08:11:22.581000+00:00",
        "attachments": null
    },
    {
        "author": "rodiazet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Right. We started implementing existing precompiles to verify what else is needed to add/change in the EVMMAX spec. We plan to focus on poseidon hash function too as a case which could potentially implemented in EVM (EVMMAX) but after devcon. We do not plan to convince clients to change their implementations of precompiles. But other idea was to use EMVMAX as a reference implementation of existing and future precompiles if it will be still a case. Even we can potentially consider  implementing a transpiler which translates EVMMAX to high level language (Go, C++ or rust i.e) and this can be used as precompile implementation in a client + probably some optimisation tweaks depending on how advanced the tool is.",
        "created_at": "2024-10-29T08:21:53.089000+00:00",
        "attachments": null
    },
    {
        "author": "rodiazet",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Personally I think the main reason for EVMMAX is to get rid of adding new precompiles process which is difficult to coordinate between different libraries. Good example is current bls discussion.",
        "created_at": "2024-10-29T08:26:47.323000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "I think SIMD part should not go in the first round because we will not know how much it helps if any.",
        "created_at": "2024-10-29T08:33:45.712000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Yep I was looking at the EIP and not the hackmd, will take a look",
        "created_at": "2024-10-29T11:16:59.164000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "\u003e Not sure what you mean here.  I don't think that we (geth) would be reimplementing already-deployed precompiles using EVM bytecode if evmmax goes live.  at least not immediately.\n\nSo for EVMMAX, it is not a goal to replace the existing precompiles?",
        "created_at": "2024-10-29T11:20:27.157000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yeah I'd say that's correct",
        "created_at": "2024-10-29T11:21:14.515000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "For inversion, I was thinking mostly in terms of curve operations; ie converting to affine form -- is the idea here that everyone who needs it, would reimplement it in their contract?",
        "created_at": "2024-10-29T11:22:07.046000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Okay this was my wrong assumption; what's the goal of EVMMAX?",
        "created_at": "2024-10-29T11:22:43.559000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "yes, or use the modexp precompile",
        "created_at": "2024-10-29T11:22:46.290000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "SIMD",
        "created_at": "2024-10-29T11:28:43.657000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Implement Poseidon using EVMMAX",
        "created_at": "2024-10-29T11:34:11.942000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Blockers for EVMMAX",
        "created_at": "2024-10-29T11:50:47.047000+00:00",
        "attachments": null
    },
    {
        "author": "kevaundray",
        "category": "Execution R\u0026D",
        "parent": "",
        "content": "Possible users of EVMMAX",
        "created_at": "2024-10-29T12:04:08.218000+00:00",
        "attachments": null
    }
]