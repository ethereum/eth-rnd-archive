[
    {
        "author": "mirgee",
        "category": "Execution Layer",
        "parent": "",
        "content": "Introducing SSZ into RLP stream is dirty, increases complexity and slows down implementation. But if there are important use-cases for proving against BALs, then IMO satisfying those should take precedence, and if there are not, then there is no debate. So, I think this question needs to be answered first.\n\nImplementing RLP encoding should be relatively trivial for any client, so we could implement that first and then try moving to SSZ as a separate effort. Then we either finish on time or run into issues and either way, we will learn empirically whether the implementation is too complex or not.",
        "created_at": "2025-06-26T07:56:39.126000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Execution Layer",
        "parent": "",
        "content": "My main concern with this approach is that clients may then not have the bandwidth to move over to ssz and we're again back at where we are today - practically not able to prove against the object. I've heard from multiple people that this would be a missed opportunity and the trade-off might be worth a bit more dirtiness.\nSince the BAL is a state diff, one could have quite lightweight merkle proofs proving things like balance changes (for eth and tokens), execution in general, etc.\nCurious what \u003c@402853454126776320\u003e thinks here.\n\nIn terms of size, the objects are very similar (25 KiB for state diff, 40 KiB for state diff + locations; snappy compressed), so it doesn't really matter. All clients have ssz libraries. If it end up adding significant complexity for devs, happy to remove it but we should take that decision soon.",
        "created_at": "2025-06-26T09:34:27.410000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Execution Layer",
        "parent": "",
        "content": "I've updated the SSZ structure and think this is the most efficient structure for minimizing the snappy compressed object size. Find the updated EIP here:\nhttps://github.com/nerolation/EIPs/blob/more-compact-structure/EIPS/eip-7928.md\nStill waiting for it being reviewed before merging.\n\nThere [bal builder reference](https://github.com/nerolation/eth-bal-analysis) can still do both build BALs with only state diffs or do state diffs + state+storage locations. To decide, we'd need numbers on \"how much would clients gain from having all storage+state locations available to do something like parallel IO of everything needed in the block?\" The size difference is 27 kib vs 40 kib (incl state+storage locations)",
        "created_at": "2025-06-26T09:54:11.898000+00:00",
        "attachments": null
    }
]