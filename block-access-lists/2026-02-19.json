[
  {
    "author": "nero_eth",
    "category": "Cross-layer",
    "parent": "",
    "content": "For the benchmarking, it'd be great to get status updates on how far clients are wrt the individual BAL optimizations.\nThe screenshot show the latest we have in <@577788234810130432> 's doc:\nhttps://notes.ethereum.org/@ethpandaops/bal-devnet-2\n\nWould be great if clients could let us know if something changed (new optimization implemented) + the flags to turn them on and off.\nSo far we have Besu (cc <@680337202521440470> ) ready (having all optimizations + provided the flags). Geth (cc <@427903869226582018> ) also has all the optimizations ready but would be great to add the flags to the doc.\n\ncc <@348512261955911691> <@429719902363058177> <@583892532644151312>",
    "created_at": "2026-02-19T09:14:47.427000+00:00",
    "attachments": [
      {
        "type": "image/webp",
        "origin_name": "Screenshot_from_2026-02-19_10-10-46.png",
        "content": "914f172712f64d45172ac94b285636fb141a28062c26a0b89601a06f4ac60b3d"
      }
    ]
  },
  {
    "author": "matkt0",
    "category": "Cross-layer",
    "parent": "",
    "content": "If we can update the Besu flags part\n\n## BAL Configuration Flags\n\n**`--Xbal-optimization-enabled`** (default: `true`)\nEnable/disable BAL-based optimizations.\n\n**`--Xbal-perfect-parallelization-enabled`** (default: `true`)\nEnable/disable BAL-based perfect parallelization when BALs are present.\n\n**`--Xbal-lenient-on-state-root-mismatch`** (default: `true`)\nLog an error instead of throwing when the BAL-computed state root doesn't match the sync-computed root.\n\n**`--Xbal-trust-state-root`** (default: `false`)\nTrust the BAL-computed state root without verification.\n\n**`--Xbal-log-bals-on-mismatch`** (default: `false`)\nLog the constructed and block's BAL when they differ.\n\n**`--Xbal-api-enabled`** (default: `false`)\nEnable `eth_getBlockAccessList` method and Block Access Lists in simulation results.\n\n**`--Xbal-state-root-timeout`** (default: `1000ms`)\nTimeout in milliseconds when waiting for the BAL-computed state root.\n\n**`--Xbal-processing-timeout`** (default: `1000ms`)\nTimeout in milliseconds when waiting for BAL transaction processing results.\n\n**`--Xbal-prefetch-reading-enabled`** (default: `false`)\nEnable prefetching of state data based on BAL read operations.\n\n**`--Xbal-prefetch-sorting-enabled`** (default: `true`)\nEnable sorting optimization during BAL prefetch operations.\n\n**`--Xbal-prefetch-batch-size`** (default: `100`)\nCustom batch size for BAL prefetch operations.",
    "created_at": "2026-02-19T10:59:55.349000+00:00",
    "attachments": []
  },
  {
    "author": "nero_eth",
    "category": "Cross-layer",
    "parent": "",
    "content": "As a heads-up, the [max-item check](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-7928.md#block-access-list-size-constraint) is now simplified to\n\n`bal_items <= block_gas_limit // ITEM_COST`\n\nWhere:\n```\nbal_items = storage_keys + addresses\nITEM_COST = 2000\n```",
    "created_at": "2026-02-19T11:14:51.686000+00:00",
    "attachments": []
  },
  {
    "author": "nero_eth",
    "category": "Cross-layer",
    "parent": "",
    "content": "Not sure if we have tests already for this but might be worth adding (cc <@762919002196410400> <@796570016966770688> )\n\nAs a reminder, this check is only used to ensure **invalid** blocks/BALs can be **invalidated** early on (based on the number of items in the BAL being unrealistic compared to the gas limit).\n\nNote that using 2000 gas might need to be updated depending on the final numbers of EIP-2780 (which makes accessing account significantly cheaper), which we get when the benchmarking for the repricing is done. The final number should be below the cheapest possible cost to get an item onto the BAL + leave some buffer for items in the BAL that get there for free (=system contract calls). Find the rational in [this](https://github.com/ethereum/EIPs/pull/11323) PR.",
    "created_at": "2026-02-19T11:18:20.043000+00:00",
    "attachments": []
  },
  {
    "author": "parithosh",
    "category": "Cross-layer",
    "parent": "",
    "content": "<@&1460290804898861117> for visibility ðŸ˜„",
    "created_at": "2026-02-19T13:55:01.499000+00:00",
    "attachments": []
  },
  {
    "author": "b.hartnett",
    "category": "Cross-layer",
    "parent": "",
    "content": "Does storage_keys here include the keys of storage reads and writes or just storage reads?",
    "created_at": "2026-02-19T15:10:00.953000+00:00",
    "attachments": []
  },
  {
    "author": "nero_eth",
    "category": "Cross-layer",
    "parent": "",
    "content": "Both, taking unique (address, key) combos across reads + changes",
    "created_at": "2026-02-19T15:15:04.863000+00:00",
    "attachments": []
  },
  {
    "author": "holgerd77",
    "category": "Cross-layer",
    "parent": "",
    "content": "<@792404665068158998> I couldn't resist and I will give a try and vibe-code a working version of the 2c proposal together, I am just too curious how this plays out on BAL size + (roughly judged) implementation complexity. As a starter I have created some mainnet block test scenario where we can locally replay mainnet blocks with EthereumJS VM and I created BALs for blocks 24476000 up to 24476009 to have some comparison data regarding BAL size (screenshot, we have some gas mismatches there, should not distort the outcome in a significant way though).\nhttps://github.com/ethereumjs/ethereumjs-monorepo/pull/4247\n\nNot sure how far I come here ðŸ™‚, I'll report back. In doubt it will be just me getting better in protocol vibe-coding! ðŸ˜†",
    "created_at": "2026-02-19T15:26:43.641000+00:00",
    "attachments": [
      {
        "type": "image/png",
        "origin_name": "552095192-750fec30-d429-45af-85b7-8fd0bf11db12.png",
        "content": "5262ee244a40c4180a867e8d47d3c0fc9479238d82a818b3e3c777bc12328685"
      }
    ]
  },
  {
    "author": "nero_eth",
    "category": "Cross-layer",
    "parent": "",
    "content": "Yeah let me know how it goes ðŸ«¡\nWe did test a bunch of different designs at the beginning and eventually settled at the current one because of a good size <> simplicity trade-off but curious what you get out of 2c.",
    "created_at": "2026-02-19T15:43:44.497000+00:00",
    "attachments": []
  },
  {
    "author": "jwasinger",
    "category": "Cross-layer",
    "parent": "",
    "content": "The flag to determine how BALs are executed in Geth is ` --bal.executionmode`.  It has several options:\n`sequential`: no performance acceleration\n `full` (default): parallel transaction execution, state root calculation, async warming of access list reads\n`nobatchio`: same as 'full', but without async warming of access list reads",
    "created_at": "2026-02-19T15:46:17.673000+00:00",
    "attachments": []
  },
  {
    "author": "holgerd77",
    "category": "Cross-layer",
    "parent": "",
    "content": "<@792404665068158998> Hmm. Hard and a bit over my head to interpret. Eventually the size gains might be achievable, but not to be safely claimed. Implementation here:\nhttps://github.com/ethereumjs/ethereumjs-monorepo/pull/4247\n\nBut interesting to see how far to (or not to) take this.",
    "created_at": "2026-02-19T16:30:13.118000+00:00",
    "attachments": [
      {
        "type": "image/png",
        "origin_name": "grafik.png",
        "content": "00d891c6ff886fd57e0676ed5f596a78bffbdc709f46c5a2d2e9c2fd0ad55bc0"
      }
    ]
  },
  {
    "author": "holgerd77",
    "category": "Cross-layer",
    "parent": "",
    "content": "<@792404665068158998> Ok, to complete on the analysis from today, used all the implementation/comparison context for some targeted BAL size reduction/optimization suggestions:\n\nhttps://gist.github.com/holgerd77/fb4a5487a41f115b61c0d50356b63f2f",
    "created_at": "2026-02-19T16:42:41.337000+00:00",
    "attachments": []
  }
]