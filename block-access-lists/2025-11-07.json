[
    {
        "author": "ethpandaops-devnet-pulse-v2",
        "category": "Cross-layer",
        "parent": "",
        "content": "",
        "created_at": "2025-11-07T01:00:00.591000+00:00",
        "attachments": null
    },
    {
        "author": "nero_eth",
        "category": "Cross-layer",
        "parent": "",
        "content": "Thanks for the feedback \u003c@429719902363058177\u003e !\nCurious what others think. We can discuss this during devconnect - please check out my post upfront.",
        "created_at": "2025-11-07T07:54:16.334000+00:00",
        "attachments": null
    },
    {
        "author": "draganrakita",
        "category": "Cross-layer",
        "parent": "",
        "content": "Testing case request. This got triggered as a consensus bug in latest revm release.\nCan we have a case with not enough gas for storage cold load on storage item that is part of access list?",
        "created_at": "2025-11-07T10:56:59.872000+00:00",
        "attachments": null
    },
    {
        "author": "raxhvl",
        "category": "Cross-layer",
        "parent": "",
        "content": "You got it, we'll have it our next release.",
        "created_at": "2025-11-07T10:58:20.641000+00:00",
        "attachments": null
    },
    {
        "author": "draganrakita",
        "category": "Cross-layer",
        "parent": "",
        "content": "Thanks!",
        "created_at": "2025-11-07T11:00:08.098000+00:00",
        "attachments": null
    },
    {
        "author": "qu0b",
        "category": "Cross-layer",
        "parent": "",
        "content": "I would generally recommend, if possible, that clients add their block level access list calculation to the `debug_getBadBlock` endpoint. That way we can easily compare block level access list from the bad block `block.accessList` to the access list that the client generated `generatedBlockAccessList` to quickly identify the diff and see what went wrong. This is especially useful for tooling and debugging on devnets.  \n\nPlease let me know what you think\n\n```go\ntype BadBlock struct {\n    // The hash of the block\n    Hash string `json:\"hash\"`\n    // Block is the actual bad block\n    Block json.RawMessage `json:\"block\"`\n    // RLP is the RLP encoded block\n    RLP string `json:\"rlp\"`\n    // GeneratedBlockAccessList is the access list generated by the client importing and executing the block. Diff: Block.accessList \u003c\u003e GeneratedBLockAccessList\n    GeneratedBlockAccessList json.RawMessage `json:\"generatedBlockAccessList,omitempty\"`\n}\n```\n\nI added step 4.\n\n```python\ndef validate_block(block):\n    # 1. Verify provided BAL matches header hash\n    import rlp\n    provided_bal_hash = keccak256(rlp.encode(block.block_access_list))\n    assert provided_bal_hash == block.header.block_access_list_hash\n    \n    # 2. Execute block and collect actual accesses\n    actual_bal = execute_and_collect_accesses(block)\n    \n    # 3. Verify actual execution matches provided BAL\n    actual_bal_hash = keccak256(rlp.encode(actual_bal))\n    assert actual_bal_hash == block.header.block_access_list_hash\n\n    # 4. Persist bad block\n    if debug and actual_bal_hash != block.header.block_access_list_hash\n      storeBadBlock(block, actual_bal)\n```",
        "created_at": "2025-11-07T11:45:13.931000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Cross-layer",
        "parent": "",
        "content": "Geth doesn't actually reproduce the entire BAL when verifying.  We just check that the state changes for each idx match between reported/computed and that the aggregate reads of the block match between reported/computed.  i.e. we don't reassemble all of the computed diff layers into the full BAL.",
        "created_at": "2025-11-07T11:48:42.154000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Cross-layer",
        "parent": "",
        "content": "also, if doing parallel execution it's not guaranteed that the trigger-point for a bad block is consistent:  it depends on the order which txs were executed and the state root calculation completed, and what the first \"bad block\" error that happened to surface was.",
        "created_at": "2025-11-07T11:51:45.409000+00:00",
        "attachments": null
    },
    {
        "author": "jwasinger",
        "category": "Cross-layer",
        "parent": "",
        "content": "actually, it should be possible to implement this endpoint for Geth in the case of the bad block (just re-execute the bad block with a flag to build the entire BAL from the parallel execution).",
        "created_at": "2025-11-07T11:58:55.021000+00:00",
        "attachments": null
    }
]