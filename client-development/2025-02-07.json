[
    {
        "author": "kolbyml",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "Didn't you just say the signature would be semi-random",
        "created_at": "2025-02-07T01:43:58.743000+00:00",
        "attachments": null
    },
    {
        "author": "kolbyml",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "so you can have multiple valid signatures for the same ENR",
        "created_at": "2025-02-07T01:44:17.396000+00:00",
        "attachments": null
    },
    {
        "author": "kolbyml",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "So you getting a different signature doesn't necessarily imply your implementation is wrong no?",
        "created_at": "2025-02-07T01:45:41.186000+00:00",
        "attachments": null
    },
    {
        "author": "dawid_sz",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "I guess so. I know Nethermind also uses random number generator in the code, so maybe thatâ€™s the way to go",
        "created_at": "2025-02-07T04:51:12.024000+00:00",
        "attachments": null
    },
    {
        "author": "b.hartnett",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "ECDSA requires a unique random value for each signature so each signature generated should look different even on the same data if you call sign a second time. The random value should never be reused and should be kept secret. Usually its best for the crypto library to handle that part though. You should just be able to pass in the CSPRNG to the object or function call. Also you should usually use the same instance of the CSPRNG across the application",
        "created_at": "2025-02-07T07:49:15.804000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "The most common signing strategy is to use a deterministic nonce, usually derived from the message itself.  That way you can sign the same message twice and get the same signature out each time.  Makes it *much* easier to test at the least, and is convenient in a few obscure cases in actual usage.",
        "created_at": "2025-02-07T08:14:19.554000+00:00",
        "attachments": null
    },
    {
        "author": "b.hartnett",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "Yes true, the signature would be the same if the message is unchanged in that case. That scheme is described here FYI: https://www.rfc-editor.org/rfc/rfc6979",
        "created_at": "2025-02-07T08:23:54.232000+00:00",
        "attachments": null
    },
    {
        "author": "dawid_sz",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "Thanks so much. I think you both refer to what the RFC calls `k` (section 3.2). Zig standard library already handles that for me if I don't set my own `noise` parameter. In such a case, I constantly get the same signature, but it differs from the one listed in the ENR spec. I tried to encode the same ENR using `go-ethereum` and sign it with the same private key. Again, I get different signature (even different from the one from Zig), but it's the same one every time I run the code. So is it correct and the different signatures between implementations are something normal (i.e. caused by differences in how crypto algorithms are implemented, etc.)?",
        "created_at": "2025-02-07T16:09:35.120000+00:00",
        "attachments": null
    },
    {
        "author": "dawid_sz",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "I can verify the record using the signature generated by Zig, so I guess it's OK...",
        "created_at": "2025-02-07T16:16:38.535000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "Possibly try signing one using your code and recovering it using one of the other known working libraries to confirm?",
        "created_at": "2025-02-07T18:50:15.502000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "Shouldn't be if I remember correctly from when I implemented `secp256k1`.  There are test cases you can download that have private keys and messages and the output should match exactly.",
        "created_at": "2025-02-07T19:50:10.817000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "Portal R\u0026D",
        "parent": "",
        "content": "This isn't foolproof as one can create an implementation that leaks data (like nonce re-use) that can compromise the key, but all of the signatures it produces will be valid.",
        "created_at": "2025-02-07T19:51:20.203000+00:00",
        "attachments": null
    }
]