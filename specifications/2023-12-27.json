[
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "this might help",
        "created_at": "2023-12-27T03:57:51.729000+00:00",
        "attachments": [
            {
                "type": "image/png",
                "origin_name": "worldstatetrie.png",
                "content": "4d170a8ff36682754b8113468c9cfde16ebe6285b1375b4f65c89b267947c503"
            }
        ]
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "The `ETH` and `WEI` and decimal value bits are wrong.  `value` in the state tree can be any 256-bit value.",
        "created_at": "2023-12-27T04:01:20.596000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "But overall a helpful image!",
        "created_at": "2023-12-27T04:01:37.677000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "\u003e  If all keys have the same length, how would this ever be the case? Is this tree structure used anywhere where the keys are not guaranteed to have the same length?\nafaik in ethereum mainnet this is never used, but it is defined for completeness\n\n\u003e I don’t understand how to structure an extension node.\nc(J,i) is the actual node value, which can be either a branch node, extension node, or a leaf node, whereas n(J, i) is the \"normalized\" or more correctly \"merkleized\" root of a subtree. In the definition of c(J,i), n(J,j) -- note *j* -- is root of the subtree with values starting with the prefix defined by j. You can see this is in the image where the \"next node\" value in the extension node will be the MPT of the tree of keys `37` and `97`.\n\n\u003e But how does the structural composition of the root node depend on the tree in such a way that any change below invalidates is?\nit's the same as any merkle tree, just with more hoops to jump through - you need to compute the root of each subtree before you can compute the final root. It's just that there are 3 different node types and 16 possible branching slots in the branch node",
        "created_at": "2023-12-27T04:08:28.002000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "\u003c@\u0026595685821026271242\u003e",
        "created_at": "2023-12-27T10:41:07.943000+00:00",
        "attachments": null
    },
    {
        "author": "dandan3385",
        "category": "general",
        "parent": "",
        "content": "Thanks a lot for the answers. I think the hashing might have clicked for me. So the “next node” value will be the hash of the node it references or the encoded node itself in case it is less than 32 bytes?\n\nAnd as this propagates all the way to the root, it will be fully deterministic. This makes sense to me, but is it correct? \n\nAs of my understanding, in the state tree, the value would be an RLP-serialized ethereum account, like this: `RLP([nonce, balance, storageRoot, codeHash])` (from https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/) (bonus question: Shouldn’t this be lexicographic with respect to the keys, so [balance, codeHash, nonce, storageRoot]?)\n\nSo an encoded leaf node would look like this: `node = [HP(path, 1), RLP([nonce, balance, storageRoot, codeHash])]` where HP is the hex-prefix encoding.\n\nAnd if this is more than 32 bytes I use `KEC(RLP(node))` as the reference. Is this correct?\n\nIn the case of less than 32 bytes, do I not use `RLP(node)`? What would `node` look like without serializing - do I just concatenate `HP(path, 1)` and `RLP([nonce, balance, storageRoot, codeHash])`?\n\nSorry for spamming this channel - is there a better place to ask these sort of questions?",
        "created_at": "2023-12-27T13:48:09.587000+00:00",
        "attachments": null
    }
]