[
    {
        "author": "voith",
        "category": "general",
        "parent": "",
        "content": "\u003c@!689161464829050960\u003e \u003c@!543900561460822016\u003e  \u003c@!497280885645639691\u003e for occurrences `⌊...⌋`(floor) we are currently using python's `//` operator. What do you think of using `math.floor` for better readability?",
        "created_at": "2021-07-08T15:21:24.787000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "`math.floor !== //`",
        "created_at": "2021-07-08T15:25:26.842000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "I don't think",
        "created_at": "2021-07-08T15:25:33.818000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Actually, lemme check.",
        "created_at": "2021-07-08T15:25:39.147000+00:00",
        "attachments": []
    },
    {
        "author": "voith",
        "category": "general",
        "parent": "",
        "content": "Yeah you're right. There's a slight difference",
        "created_at": "2021-07-08T15:25:58.434000+00:00",
        "attachments": []
    },
    {
        "author": "voith",
        "category": "general",
        "parent": "",
        "content": "I found this helpful: https://stackoverflow.com/a/37618712/3526700",
        "created_at": "2021-07-08T15:27:06.769000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "Personally, I'm fine with `//` since it's extremely explicit already (if it was only `/` like in C, I'd lean towards `math.floor`.)",
        "created_at": "2021-07-08T15:27:08.164000+00:00",
        "attachments": []
    },
    {
        "author": "samwilsn",
        "category": "general",
        "parent": "",
        "content": "If it's ever more readable to use floor, by all means, go for it!\n\nI don't remember if I implemented `__floor__` on the `Uint` types so you might need to do that too.",
        "created_at": "2021-07-08T15:29:36.502000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "we use `//` all over the place in the eth2 spec and are happy with it and never ran into it being too \"pythonic\" for readability",
        "created_at": "2021-07-08T17:16:12.416000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "e.g. here -- https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/beacon-chain.md#integer_squareroot",
        "created_at": "2021-07-08T17:17:38.146000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "it also clearly defines it as \"integer\" division in a single operation, imo, which is cleaner than float division that is then floored to an integer. It makes it clearer that an implementation does not need float division",
        "created_at": "2021-07-08T17:20:46.968000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "to me (naively):\n\n1. `floor(some_integer / some_other_integer)` looks like I should do float division an then do the floor\n2. `some_integer // some_other_integer` looks like I should do *integer division*\n\nVersion 1 implies somewhat that I need float division. obviously you can read between the lines and bypass float division with a replacement with pure integer division, but we avoided *all* float operations in eth2 spec so there was not any shred of doubt that all you need is ints",
        "created_at": "2021-07-08T17:24:23.271000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Wondering if I have found a problem with sync committee aggregators.  My maths goes like this:\n\n- there is a 3.125% chance of a validator being selected as an aggregator (1 in `SYNC_COMMITTEE_SIZE` // `SYNC_COMMITTEE_SUBNET_COUNT` // `TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE`)\n- there are 128 validators per sync committee subnet\n- 128 validators means that there is roughly a 1.7% `(1-0.03125)^128` chance that there are 0 aggregators for a given subnet for a slot\n- there are 4 subnets, so there is roughly a 93% `(1-(1-0.03125^128))^4` chance that there are aggregators for all subnets in a slot\n- over an epoch there is roughly a 10.8% `((1-(1-0.03125^128))^4)^32` chance that there are aggregators for all subnets in an epoch\n\nIf my maths checks out this is going to lead to a pretty poor set of results for sync committees and the rewards that should be gained, as there will be a significant number of sync committee messages that are dropped due to lack of an aggregator.\n\nThis should also be pretty obvious from running testnets.  I have seen this with my local altair testnet but would be interested to hear if others are seeing the same issue, because my codebase is still in the \"experimental\" phase.  Should be pretty easy to check: look at the number of bits set in each block of an epoch and see if they are all present and correct.",
        "created_at": "2021-07-08T21:03:59.801000+00:00",
        "attachments": []
    }
]