[
    {
        "author": "s1na",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I think the 4th option was simply setting a max witness size, but the conversation quickly moved on from that",
        "created_at": "2020-03-25T10:40:39.751000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "So two other ideas I had. Both involve doing (2), charging *at time of execution*, but then solving the backwards compatibility issue in a different way.\n\n1. Replace the 63/64 constant with 3/4. This way if you have a transaction that requires a computation and then some \"post-failure\" work in case the inner computation fails, you can still do it with the remaining 1/4.\n2. Allow the transaction sender themselves to select the above constant, or possibly even allow the transaction sender to supply a gas budget per contract as part of the transaction\n\nThe principle behind the second idea is that ultimately the party that would lose money if an internal call \"betrays\" them is the sender themselves, so the sender should choose which addresses to trust",
        "created_at": "2020-03-25T15:16:50.564000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But to validate these ideas it would be nice to have a list of applications in mind to mentally test against",
        "created_at": "2020-03-25T15:17:49.535000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The main one I remember is meta-transactions (A calls B, and afterwards within the same transaction A collects a reward from B for doing so; A can still collect the reward even if B goes OOG)",
        "created_at": "2020-03-25T15:19:10.811000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And either of the solutions above would solve that",
        "created_at": "2020-03-25T15:19:31.272000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "My main goal here is to find ways to try to get mostly-backwards-compatibility (even if apps have to rewrite themselves), and avoid the complexity nightmare of having two gas tables that every tx has to be processed against or any other solution like that",
        "created_at": "2020-03-25T15:20:15.987000+00:00",
        "attachments": null
    },
    {
        "author": "afdudley",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e The principle behind the second idea is that ultimately the party that would lose money if an internal call \"betrays\" them is the sender themselves, so the sender should choose which addresses to trust\nI like this a lot, I'm generally in favor of pushing more work to the edges of the network.",
        "created_at": "2020-03-25T15:22:07.579000+00:00",
        "attachments": null
    }
]