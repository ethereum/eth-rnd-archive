[
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e @dankrad @kevaundray @jtraglia I wonder what's the best way to do the decoupled challenge computation. In #3236, we are currently (https://github.com/ethereum/consensus-specs/pull/3236/files) doing explicit challenge computation both in compute_challenge() and ad-hoc in verify_kzg_proof_multi().\n\nthat's actually a non-trivial amount of code that needs to be duped in c-kzg: https://github.com/ethereum/c-kzg-4844/blob/7cb53389509f8c4616d7875fec22734896b83646/src/c_kzg_4844.c#L699\n\ni think at the very least we can avoid the double hashing at the end. we should be able to use hash_to_bls_field() without a previous hash() since they are two separate protocols with their own domain string.\n\nI suspect that it will be hard to unify those two computations because they take different arguments and are used in different places. maybe we can simplify further?",
        "created_at": "2023-02-13T14:28:37.154000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e alternatively, can't we access an rng from within the spec and just generate a random private-randomness `r`. since this doesn't need to be a fiat-shamir value.",
        "created_at": "2023-02-13T15:24:56.226000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e \u003e \u003ckevaundray\u003e  It's batching which is \"public aggregation\" so you can sample random numbers (not sure how to do this in the spec) (re @asn_d6: @dankrad @kevaundray @jtraglia I wonder what's the best way to do the decoupled challenge computation. In #3236, we are currently doing explicit challenge computation both in compute_challenge() and ad-hoc in verify_kzg_proof_multi().\n\nthat's actually a non-trivial amount of code that needs to be duped in c-kzg: https://github.com/ethereum/c-kzg-4844/blob/7cb53389509f8c4616d7875fec22734896b83646/src/c_kzg_4844.c#L699\n\ni think at the very least we can avoid the double hashing at the end. we should be able to use hash_to_bls_field() without a previous hash() since they are two separate protocols with their own domain string.\n\nI suspect that it will be hard to unify those two computations because they take different arguments and are used in different places. maybe we can simplify further?)",
        "created_at": "2023-02-13T15:26:19.754000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e right",
        "created_at": "2023-02-13T15:26:41.422000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e import rand ðŸ¤¡",
        "created_at": "2023-02-13T15:27:30.499000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e Yeah ``randrange(`modulus`)`` probably would be the way forward here",
        "created_at": "2023-02-13T15:27:50.761000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e yeah i've never seen this done anywhere on the spec... new frontier.",
        "created_at": "2023-02-13T15:28:21.950000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e @hwwang @dannyryan @dankrad maybe you guys know?",
        "created_at": "2023-02-13T15:28:36.823000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cralexstokes\u003e i feel like a \"nondeterministic spec\" would break our spec test generation",
        "created_at": "2023-02-13T16:11:49.939000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cralexstokes\u003e i guess for this use case all of the data would be provided and the only \"random\" part would be during the test gen itself?",
        "created_at": "2023-02-13T16:12:34.637000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e \u003e \u003casn_d6\u003e  yes that wouldn't surprise me. that said, the simplification is non-trivial so we might want to think of how to achieve this. (re @ralexstokes: i feel like a \"nondeterministic spec\" would break our spec test generation)",
        "created_at": "2023-02-13T16:18:28.348000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e \u003e \u003casn_d6\u003e  hmm not sure what you mean. the spec function `verify_blob_kzg_proof_multi()` would need to sample a random value and use that internally. the inputs to the function would indeed be provided. (re @ralexstokes: i guess for this use case all of the data would be provided and the only \"random\" part would be during the test gen itself?)",
        "created_at": "2023-02-13T16:19:13.205000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdankrad\u003e I'm not sure what cryptographers say about this? When I coded it up I thought the best practice is to turn it into a deterministic protocol by computing the challenge in a Fiat-Shamir like way. Using real randomness assumes you have a good source of randomness... which should almost always be the case...",
        "created_at": "2023-02-13T16:27:11.717000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cralexstokes\u003e \u003e \u003cralexstokes\u003e  i don't grok all the details but i think in practice the change would be: instead of the test generation being deterministic for a given spec version, the test generation would now change per run for a given spec version -- this isn't the end of the world but does make some of the operations around it a bit more cumbersome (e.g. we would want to also provide the seed to the python tooling and be able to load it to remove the non-determinstic aspect) (re @asn_d6: hmm not sure what you mean. the spec function verify_blob_kzg_proof_multi() would need to sample a random value and use that internally. the inputs to the function would indeed be provided.)",
        "created_at": "2023-02-13T16:33:21.334000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdannyryan\u003e is this an optimization? If so, I wouldn't spec `rand` into the spec but leave it as an implementation note",
        "created_at": "2023-02-13T16:37:15.598000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdankrad\u003e basically one of the protocols needs a random value to verify something. It's not something that the prover has to respond to, all the computation is local to the verifier. So there are two options:\n1. Compute the challenge deterministically by hashing all the input values. This is safe but means hashing some data that we don't really need to\n2. Get a random challenge",
        "created_at": "2023-02-13T16:41:16.741000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e right. so we mainly want this not because of performance but because it allows us to remove a bunch of code",
        "created_at": "2023-02-13T16:55:25.150000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e however, now that i think more about it, introducing a multi-platform RNG into c-kzg is gonna be a PITA on its own...",
        "created_at": "2023-02-13T16:56:22.304000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e we could alternatively have the caller of `verify_blob_kzg_proof_multi()` provide the random value themselves but that's a potential foot gun for client devs...",
        "created_at": "2023-02-13T16:57:20.491000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e \u003e \u003ckevaundray\u003e  Yeah, I think the cloest thing in the spec that we could mimic is \"seed\". I saw it in a function called `shuffle` (re @ralexstokes: i guess for this use case all of the data would be provided and the only \"random\" part would be during the test gen itself?)",
        "created_at": "2023-02-13T17:45:44.377000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdannyryan\u003e seed is determistic as a function of blocks",
        "created_at": "2023-02-13T17:47:43.171000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e \u003e \u003ckevaundray\u003e  The last implementation I saw in the wild just pulled in randomness from the OS, I think there was also a proof/folklore where the random integer can be 128 bits instead of 256 bits (re @dankrad: I'm not sure what cryptographers say about this? When I coded it up I thought the best practice is to turn it into a deterministic protocol by computing the challenge in a Fiat-Shamir like way. Using real randomness assumes you have a good source of randomness... which should almost always be the case...)",
        "created_at": "2023-02-13T17:47:44.883000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdannyryan\u003e so a bit different",
        "created_at": "2023-02-13T17:47:46.028000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e \u003e \u003ckevaundray\u003e  Ahh, I thought the testing framework passed in a random seed (re @dannyryan: so a bit different)",
        "created_at": "2023-02-13T17:48:09.965000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e \u003e \u003ckevaundray\u003e  I thought it is an optimisation because you can verify all of the proofs individually, but instead you are batching them together (re @asn_d6: right. so we mainly want this not because of performance but because it allows us to remove a bunch of code)",
        "created_at": "2023-02-13T17:49:42.453000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdannyryan\u003e \u003e \u003cdannyryan\u003e  ah, to test that function in isolation in a unit test, it might do that. but that function is not directly tested for cross-client vectors. only as a dependency in more full, determeinistic block tests (re @kevaundray: Ahh, I thought the testing framework passed in a random seed)",
        "created_at": "2023-02-13T17:50:24.081000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e \u003e \u003ckevaundray\u003e  My understanding is that its something like:\n\nProver says:\n\n- a + b = 0\n- c + d = 0\n\nThe verifier can then choose to check both of these equations individually, but instead they say, iff those two equations are correct, then the following is also correct:\n\n- (a+b) + random * (c+d) = 0\n\nAnd I'll do one check (re @asn_d6: right. so we mainly want this not because of performance but because it allows us to remove a bunch of code)",
        "created_at": "2023-02-13T17:51:50.267000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdankrad\u003e \u003e \u003cdankrad\u003e  ah yes this is probably true (re @kevaundray: The last implementation I saw in the wild just pulled in randomness from the OS, I think there was also a proof/folklore where the random integer can be 128 bits instead of 256 bits)",
        "created_at": "2023-02-13T17:55:57.294000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdankrad\u003e doesn't help much in this case though",
        "created_at": "2023-02-13T17:56:05.042000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdankrad\u003e \u003e \u003cdankrad\u003e  yup (re @kevaundray: My understanding is that its something like:\n\nProver says:\n\n- a + b = 0\n- c + d = 0\n\nThe verifier can then choose to check both of these equations individually, but instead they say, iff those two equations are correct, then the following is also correct:\n\n- (a+b) + random * (c+d) = 0\n\nAnd I'll do one check)",
        "created_at": "2023-02-13T17:56:34.039000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e \u003e \u003ckevaundray\u003e  could we then just iterate over all kzg proofs in the spec calling verify and then say \"you can optimise this by batching+randomness\" or is that leaving too much to the implementer? (re @dankrad: yup)",
        "created_at": "2023-02-13T17:59:29.958000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdankrad\u003e right, so in the spec we will not actually call this function. But I did specify it in `polynomial_commitments.md` because then we can write tests for it and test it against all implementations",
        "created_at": "2023-02-13T18:15:24.722000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e @dankrad here is a thread about how `verify_blog_kzg_proof()` will be used by the FC layer. might be worth monitoring it in case we need to introduce a master function that does:\n\n```\nif len(blobs) \u003e 1:\n   return verify_blob_kzg_proof_multi(...)\nelse:\n  return verify_blob_kzg_proof(...)```",
        "created_at": "2023-02-13T19:05:00.647000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e \u003e \u003casn_d6\u003e  i think that would be nice to do in our case as well; instead of that extra fiat-shamir which adds code complexity and a bunch of kbs of hashing.\n\nhowever, to do that in c-kzg we would need to fold in libsodium or openssl or some other portable crypto library that knows how to fetch randomness in different OSes â€” doing this without a library is quite gnarly (https://github.com/torproject/tor/blob/main/src/lib/crypt_ops/crypto_rand.c#L130) and the failure case is disastrous.\n\nand then there is the consensus-specs scaffolding as well.\n\nso yeah not sure. i mean including a library in c-kzg is not the end of the world but it increases code/build  system complexity as well... fiat-shamir is starting to look more reasonable. (yes c sucks ðŸ˜–) (re @kevaundray: The last implementation I saw in the wild just pulled in randomness from the OS, I think there was also a proof/folklore where the random integer can be 128 bits instead of 256 bits)",
        "created_at": "2023-02-13T19:11:30.853000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e \u003e \u003casn_d6\u003e  yes that's indeed why we need batch verify. in my comment, i was referring to using an rng instead of fiat-shamir. (re @kevaundray: I thought it is an optimisation because you can verify all of the proofs individually, but instead you are batching them together)",
        "created_at": "2023-02-13T19:17:50.597000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e \u003e \u003ckevaundray\u003e  Yeah for C, the general advice is to use libsodium so you avoid a lot of footguns: https://paragonie.com/blog/2016/05/how-generate-secure-random-numbers-in-various-programming-languages#c-csprng\n\nSo fiat-shamir might be best in this case, as its familiar to the specs, does not rely on a source of randomness and is the easiest way to do it in C without another dependency ðŸ˜¢ (re @asn_d6: i think that would be nice to do in our case as well; instead of that extra fiat-shamir which adds code complexity and a bunch of kbs of hashing.\n\nhowever, to do that in c-kzg we would need to fold in libsodium or openssl or some other portable crypto library that knows how to fetch randomness in different OSes â€” doing this without a library is quite gnarly and the failure case is disastrous.\n\nand then there is the consensus-specs scaffolding as well.\n\nso yeah not sure. i mean including a library in c-kzg is not the end of the world but it increases code/build  system complexity as well... fiat-shamir is starting to look more reasonable. (yes c sucks ðŸ˜–))",
        "created_at": "2023-02-13T19:25:16.854000+00:00",
        "attachments": []
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cdannyryan\u003e \u003e \u003cdannyryan\u003e  in terms of spec, I'd rather avoid `import random` from python and instead use some sort of stub `SAFE_RANDOMNESS_FUNCTION()` that has an english definition and in testing we instantiate with the python `random` library (re @asn_d6: i think that would be nice to do in our case as well; instead of that extra fiat-shamir which adds code complexity and a bunch of kbs of hashing.\n\nhowever, to do that in c-kzg we would need to fold in libsodium or openssl or some other portable crypto library that knows how to fetch randomness in different OSes â€” doing this without a library is quite gnarly and the failure case is disastrous.\n\nand then there is the consensus-specs scaffolding as well.\n\nso yeah not sure. i mean including a library in c-kzg is not the end of the world but it increases code/build  system complexity as well... fiat-shamir is starting to look more reasonable. (yes c sucks ðŸ˜–))",
        "created_at": "2023-02-13T20:31:02.971000+00:00",
        "attachments": []
    }
]