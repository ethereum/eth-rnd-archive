[
    {
        "author": "m.kalinin",
        "category": "Cross-layer",
        "parent": "",
        "content": "I see, thanks! it seems to be an off-by-one kind of error that I have faced with, related to genesis slot. As my code starts Phase 1 since genesis and there the slot of the shard state is equal to the slot of the beacon state which is equal to `0`. In all other cases beacon chain slot will be further than shard state slot at least by `1`",
        "created_at": "2020-07-08T10:20:54.691000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Cross-layer",
        "parent": "",
        "content": "Genesis is not clean\n\nIf you assume genesis is non zero (whihc phase 1 in mainnet will be) and shard states start at genesis-1, it works fine. Otherwise you have to step genesis forward  1 without making shard blocks at genesis 0",
        "created_at": "2020-07-08T13:06:08.386000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Cross-layer",
        "parent": "",
        "content": "In my particular case genesis slot is `0` and attestations in that slot are produced with Phase1 spec which is going to be common setup for networks starting with Phase 1, e.g. testnets. In the mainnet we may initiate shard states with `beacon_state.slot - 1` to avoid this off-by-one issue.",
        "created_at": "2020-07-08T14:46:25.464000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Cross-layer",
        "parent": "",
        "content": "Yeah, agreed its not clean\nI think we have an arbitrary  `next_slot` at the start of phase 1 tests\n\nWill see if we can come up with a cleaner way that handles genesis fine",
        "created_at": "2020-07-08T14:53:14.291000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Cross-layer",
        "parent": "",
        "content": "I will spend a little time on discovering this way by my own, probably it will succeed ðŸ™‚",
        "created_at": "2020-07-08T14:54:03.336000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Cross-layer",
        "parent": "",
        "content": "I've managed to do this with only three crutches ðŸ˜†",
        "created_at": "2020-07-08T15:55:04.425000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Cross-layer",
        "parent": "",
        "content": "just having vals skip attestation if beacon_state.shard_transitions[shard].slot \u003c current_slot?",
        "created_at": "2020-07-08T15:58:04.331000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Cross-layer",
        "parent": "",
        "content": "or what?",
        "created_at": "2020-07-08T15:58:05.537000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Cross-layer",
        "parent": "",
        "content": "1) `get_shard_transition` returns empty shard transition if `GENESIS_SLOT`\n2) `validate_attestation` allows for empty shard transition root if `GENESIS_SLOT`\n3) `process_shard_transitions` skips crosslink processing if `compute_previous_slot(state.slot) == GENESIS_SLOT`",
        "created_at": "2020-07-08T16:03:42.356000+00:00",
        "attachments": []
    },
    {
        "author": "m.kalinin",
        "category": "Cross-layer",
        "parent": "",
        "content": "actually 2nd is only needed when `GENESIS_SLOT == 0`, otherwise `validate_attestation` would be OK with `ShardTransition(start_slot = GENESIS_SLOT)`",
        "created_at": "2020-07-08T16:07:09.154000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Cross-layer",
        "parent": "",
        "content": "yeah, something along those lines makes sense to me",
        "created_at": "2020-07-08T16:51:33.215000+00:00",
        "attachments": []
    }
]