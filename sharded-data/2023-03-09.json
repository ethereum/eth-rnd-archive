[
    {
        "author": "termina1",
        "category": "Cross-layer",
        "parent": "",
        "content": "Hi, I apologize if this is incorrect place to ask those questions. But I'm trying to understand sharding now, and I don't understand the connection between data blob transactions and data shards.\nGathering info from EIP-4844 and other sources it looks like:\nbasically we allow N data blob transaction per block, each data blob tx is basically data shard. So the amount of shards == max allowed data blob tx per block?",
        "created_at": "2023-03-09T09:43:49.887000+00:00",
        "attachments": []
    },
    {
        "author": "termina1",
        "category": "Cross-layer",
        "parent": "",
        "content": "And whats the most up to date info on DAS and full sharding? I see that specifications are marked as outdated.",
        "created_at": "2023-03-09T09:45:32.902000+00:00",
        "attachments": []
    },
    {
        "author": "termina1",
        "category": "Cross-layer",
        "parent": "",
        "content": "Also, I see some mentions of 2d KZG scheme here and on the internet. But I don' understand the current situation:\nthe most fresh piece of writing I could find is https://hackmd.io/@vbuterin/sharding_proposal\n\nIt looks like here each validator only samples for (shard, slot) they were assigned to. 2D sampling looks like were designed to allow validators to sample all shards simultaneously.",
        "created_at": "2023-03-09T10:58:46.263000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "If we removed AccessLists and ContractCreation from blob transactions, the Size of the Union would go down from 315/186 to 306/180 (uncompressed/compressed) which is quite an improvement over the normalized approach (340/234). It's (34/54) bytes respectively. Just to give a small reference point, saving 20 bytes per transaction of all historic transactions would save 37GB of history on full nodes. (half of all transactions have been send in the last 2 years)",
        "created_at": "2023-03-09T12:21:27.911000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "cc \u003c@881905303011086387\u003e",
        "created_at": "2023-03-09T12:22:30.571000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "There are 0-4 blob transactions per payload, the rest doesn't benefit from removing access lists and contract creation.\nIs 2 years the EIP-4444 threshold?",
        "created_at": "2023-03-09T12:25:12.438000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "The 2 years are just an interesting fact",
        "created_at": "2023-03-09T12:27:03.358000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "Also, are archive nodes using either of these representations? Or something specialized with yet another representation?",
        "created_at": "2023-03-09T12:27:29.695000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "No, but all other transactions also benefit from the union type (not as much)",
        "created_at": "2023-03-09T12:27:39.088000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "All nodes try to do as little unmarshaling and marshaling as possible, so they will use whatever the wire protocol uses",
        "created_at": "2023-03-09T12:28:12.665000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "SSZ transactions benefit, non-SSZ transactions don't really. Have to store `tx_hash`, `tx_from`, create `contract_address` _somewhere_ (either in tx / receipts / somewhere else) to allow proving them. For SSZ transaction, the size benefit comes because `tx_hash` and `sig_hash` are computable. For non-SSZ (either RLP, or Poseidon / something else) that's not the case.",
        "created_at": "2023-03-09T12:29:56.575000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "As little unmarshalling / marshalling as possible to serve JSON-RPC requests, or to serve sync requests from other nodes?",
        "created_at": "2023-03-09T12:32:18.283000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "If you have a DB index by `tx_hash`, the `tx_hash` being computable also doesn't really help anymore",
        "created_at": "2023-03-09T12:33:04.968000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "I don't really understand this, could you elaborate?",
        "created_at": "2023-03-09T12:34:57.824000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "yes",
        "created_at": "2023-03-09T12:35:03.682000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "The goal is to have a verifiable JSON-RPC response, and to reduce need for light client to implement a multitude of signature schemes and hashing methods. \n\nRequesting a transaction via JSON-RPC exposes `transaction_hash`, `from`, and `contract_address` (for tx deploying new contract).\nSo, those three fields should be provable as well. There are two ways to make them provable:\n– (1) Have `transaction_hash` and `sig_hash` as part of the SSZ tree\n– (2) Have `transaction_hash`, `from`, and `contract_address` as part of the SSZ tree.\n\nFor EIP-6493 SSZ transaction, `transaction_hash` and `sig_hash` are computable from the original wire SSZ object via just `hash_tree_root`, so that's where the size benefit is coming from. However, for non-SSZ transactions (RLP, or Poseidon / future ones), that is not the case, and those two hashes must be included somewhere else to keep those fields provable (without requiring client to download entire tx). Furthermore, committing to just `sig_hash` also means that the client needs secp256k1 pubkey recovery, and keccak, and a tiny bit of RLP to recover `from` and `contract_address`, and also all potential future signature schemes / hashing methods if the computation of `from` and `contract_address` changes (e.g., create2 transaction requiring a different method for deriving `contract_address`; or, ed25519 / postquantum tx signatures). Also, as you want to be able to look up a transaction by hash, in your DB, you need to keep a copy of the `transaction_hash` as well _somewhere_. So, even for SSZ transactions, you don't actually save those 32 bytes, you still need to store them.",
        "created_at": "2023-03-09T12:43:06.984000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "Those are two different things.\n\nFor JSON-RPC request, the normalized tx gives you all the fields directly. Just need to convert them to JSON, add the merkle proof, and done.\nFor the union, need to compute (or store) `transaction_hash`, `from`, `contract_address` to answer JSON-RPC request.\n\nFor the sync requests via devp2p, the wire protocol can just be updated to match whatever is being used by `ExecutionPayload`. \nI agree that without a networking update, it's a bit annoying to convert back and forth, but that's a temporary thing.\n\nAs for `engine_newPayload` / `engine_getPayload`, those are APIs that use JSON and are accessed remotely through builder-APIs by the majority, the conversion from the original representation to SSZ Union / normalized TX (and back to original to validate transactions on newPayload) is an insignificant portion of this process.\n\n(Also, even for the SSZ BlobTransaction, a conversion is needed to discard the network wrapper on `getPayload`)",
        "created_at": "2023-03-09T12:47:11.031000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "Okay so iiuc you are trying to optimize for lightclients and json rpc while I'm trying to optimize for the smallest disk layout for full nodes and the wire. The `from` and `creation_address` can be computed on demand (and cached) the same way we do it right now imo. Full nodes will store, sync and exchange the ssz encoded blob, so I'm trying to make that as small as possible",
        "created_at": "2023-03-09T12:53:48.164000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "There is one more request, namely `eth_getBlockByNumber(includeTransactions = false)` that requests all the transaction hashes within a block. If the `transaction_hash` is not at the same location for all transactions, that means that even a basic tx inclusion proof becomes quite messy.",
        "created_at": "2023-03-09T12:53:53.404000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "How easy would it be to extend the existing normalized transaction with one more field?",
        "created_at": "2023-03-09T12:55:00.057000+00:00",
        "attachments": []
    },
    {
        "author": "mariusvanderwijden",
        "category": "Cross-layer",
        "parent": "",
        "content": "And would old transactions suddenly become invalid because of that?",
        "created_at": "2023-03-09T12:55:25.589000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "No, they don't become invalid. The raw transaction representation is totally unaffected. \nEIP-6404 is solely about how transactions are represented _after_ being included in an `ExecutionPayload`, i.e., after removing the network wrapper for blob transaction, and after converting tx to SSZ (whether union / normalized doesn't matter).",
        "created_at": "2023-03-09T12:57:09.823000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "Extending normalized tx is trivial, just add the new field. If it is something that the majority of transactions is expected to use, like the EIP-1559 priority fee, just add it and provide reasonable default value. If it is something very spsecific like max_fee_per_data_gas, add it as an optional",
        "created_at": "2023-03-09T12:58:19.356000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "That's actually a really accurate description! Yes, there are different interests that we should find a compromise on. Network data size vs compute is a tradeoff as well.",
        "created_at": "2023-03-09T13:01:35.324000+00:00",
        "attachments": []
    },
    {
        "author": "etan_status",
        "category": "Cross-layer",
        "parent": "",
        "content": "btw, that also doesn't suddenly allow all sort of nasty field combinations. Those SSZ converted transactions (whether union or normalized) are not the representation actually being signed, they just exist in the payload (after making it through the mempool and getting bundled into a payload) — see `validate_transaction` function in EIP-6404",
        "created_at": "2023-03-09T13:03:03.703000+00:00",
        "attachments": []
    }
]