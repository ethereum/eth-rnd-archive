[
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cinphi\u003e I was hoping blst would have generic functions to check pairings. But the API is specific to verifying BLS signatures.\n\nIn general, the client should piece together whatever basic functionality blst offers with exceptions made for performance sensitive functions.  blst already contains functions to operate on field elements. So we can implement alot of non performance critical functions in the spec using blst right now. For example, blst should only provide a `bls.pairing` function rather than `verify_kzg_proof` as it can then be reused later for other purposes such as vector commitments.\n\n`evaluate_polynomial_in_evaluation_form` seems outside the scope of blst, but if they are willing to implement that for us that'll be great, but this isn't a hard requirement imo. I'd also like a blst implementation of `lincomb`.\n\nIn summary, I'd like to see the following supported by blst:\n-  A function to compute a pairing\n-  `LinCombG1` in go-kzg\n-  `evaluate_polynomial_in_evaluation_form` in the spec",
        "created_at": "2022-08-21T02:15:18.651000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e @inphi Thanks for the feedback!\n\nSupranational agreed that the current interface for pairings is very troublesome and they would improve documentation etc.\nI'm wondering if improving the interface is also possible, or the troublesome externl interface is needed for internal optimizations (I haven't checked).",
        "created_at": "2022-08-21T10:50:22.220000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e FWIW, if we decide to let client devs implement functions like `compute_kzg_proof()` on their own (instead of having blst expose it), then blst would need to expose functions like `bls_modular_inverse()` etc.",
        "created_at": "2022-08-21T10:54:48.145000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cinphi\u003e I think that's ok to expose those functions. OTOH, the cgo overhead of calling into exposed functions may be non-negligible. Would they be willing to provide functions for primitive operations and a `compute_kzg_proof()` implementation?",
        "created_at": "2022-08-21T16:28:34.386000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "I'm outside of this, but since there's a small chance that I'll be implementing some of this on Prysm I want to leave a vote towards having BLST exposing a minimal but complete lower level interface and clients implementing the higher level functions leaving the option to expand these later on",
        "created_at": "2022-08-21T16:28:39.025000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e ack thanks for the feedback",
        "created_at": "2022-08-21T16:49:27.474000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003casn_d6\u003e makes sense",
        "created_at": "2022-08-21T16:49:29.196000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Cross-layer",
        "parent": "",
        "content": "\u003cprotolambda\u003e From experience with previous go-KZG BLS library integrations: the CGO overhead can be quite bad, exposing only the lowest level operations like multiplying will mean thousands of CGO calls for some operations. Even if computationally thereâ€™s no optimization possible with a vector operation, practically reduced CGO overhead still counts. This is part of the reason why Kilic BLS performs better than Herumi BLS: kilic BLS is Go asm, while Herumi uses CGO. Or maybe we end up wrapping the C BLST library, like C-KZG, and creating CGO bindings for that somehow. Would much prefer they support the functionality directly. To avoid conflicts of linking the same BLST shared object twice, possibly even different versions.",
        "created_at": "2022-08-21T17:08:01.947000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "Cross-layer",
        "parent": "",
        "content": "We've had pretty bad overhead with cgo on SHA libraries to the point of having to port them entirely to Go assembly. I think BLST itself may be such a case. In general any function that needs to be called on a loop should be implemented internally by BLST",
        "created_at": "2022-08-21T17:30:24.495000+00:00",
        "attachments": null
    }
]