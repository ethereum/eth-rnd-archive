[
    {
        "author": "yushao13141651",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "When will the nodes of the beacon chain officially start running? Who knows the answer? Thank you",
        "created_at": "2020-06-14T01:54:16.220000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Are we seeing all three clients in proposer graffiti?",
        "created_at": "2020-06-14T02:08:58.516000+00:00",
        "attachments": []
    },
    {
        "author": "nishant0",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "https://witti.beaconcha.in/charts/participation_rate\nseems like a 10% drop-off in participation",
        "created_at": "2020-06-14T02:10:30.072000+00:00",
        "attachments": []
    },
    {
        "author": "nishant0",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I am seeing lighthouse and prysm in the graffiti, havent been able to find for teku though",
        "created_at": "2020-06-14T02:15:11.880000+00:00",
        "attachments": []
    },
    {
        "author": "nishant0",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "ok nvm , just saw teku",
        "created_at": "2020-06-14T02:15:41.075000+00:00",
        "attachments": []
    },
    {
        "author": "nishant0",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "seems like someone with a large amount of validators went offline",
        "created_at": "2020-06-14T02:15:57.150000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Im okay with just watching  and seeing what happens",
        "created_at": "2020-06-14T02:54:50.616000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Kind of want to see the network heal through leaked deposits but also kind of expecting sme clients to have menory growth isues",
        "created_at": "2020-06-14T03:19:12.668000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Teku will last a bit longer as it can drop states now but itâ€™s still going to increase memory requirements so will eventually be doomed.",
        "created_at": "2020-06-14T03:19:17.732000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Think lighthouse mem remains constant during  a leak. Not sure about prysm\n\nThis is probably worth an information exchange",
        "created_at": "2020-06-14T03:23:54.224000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Our memory will grow slightly as we hold the unfinalized DAG in memory. However, we only store a few hundred bytes per block (nothing for skip slot). It should take more than a year to get to a GB.",
        "created_at": "2020-06-14T03:27:15.663000+00:00",
        "attachments": []
    },
    {
        "author": "djrtwo",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ah, right forgot about forkchoice",
        "created_at": "2020-06-14T03:27:55.521000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Prysm should be ok for a long period of no finality, the biggest side effect is excessive state storage on disk",
        "created_at": "2020-06-14T03:41:03.350000+00:00",
        "attachments": []
    },
    {
        "author": "terence0083",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Prysm is the same as lh. With proto array fork choice, we'll gain a few KB on per block level. Other than that, everything is capped",
        "created_at": "2020-06-14T03:45:29.144000+00:00",
        "attachments": []
    },
    {
        "author": "donschoe",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "would be nice to see inactive validators to be kicked out. we had some right after genesis, when would we start seeing this? after 28 days?",
        "created_at": "2020-06-14T09:43:11.921000+00:00",
        "attachments": []
    },
    {
        "author": "nishant0",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "it would take a while, the threshold to kick them out would be 16 ETH, which will take much longer without \ninactivity leak penalties",
        "created_at": "2020-06-14T09:44:25.764000+00:00",
        "attachments": []
    },
    {
        "author": "donschoe",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "uh",
        "created_at": "2020-06-14T09:44:38.179000+00:00",
        "attachments": []
    },
    {
        "author": "nishant0",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "yeah those guys will be around for a few months lol",
        "created_at": "2020-06-14T09:45:17.978000+00:00",
        "attachments": []
    },
    {
        "author": "butta",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "are we going to test hardfork coordinations on phase0 testnets?",
        "created_at": "2020-06-14T09:53:25.344000+00:00",
        "attachments": []
    },
    {
        "author": "handelaar2",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "It seems to be the teku node of this eth1-address: https://witti.beaconcha.in/validators/eth1deposits?q=0xeef4aB970751CA4F315FB1D9c61729949aBD29E7 (or at least a major \"contributor\")",
        "created_at": "2020-06-14T10:58:00.448000+00:00",
        "attachments": []
    },
    {
        "author": "handelaar2",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!557201004060213248\u003e You sent over 12000 eth to the above address: https://goerli.etherscan.io/tx/0xaf8b965aa5cadf19e5182ffa4da711dd90a1e2ba6b2bead703147553cb93f49e",
        "created_at": "2020-06-14T11:09:51.837000+00:00",
        "attachments": []
    },
    {
        "author": "handelaar2",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "(maybe you remember who it was)",
        "created_at": "2020-06-14T11:10:28.990000+00:00",
        "attachments": []
    },
    {
        "author": "benjaminion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hey, anyone having trouble with stack overflow on Teku during this period of non-finalisation, the quickest workaround is to increase the Java stack size (something like `JAVA_OPTS=-Xss8m` should be plenty). I've got a proper fix in the pipeline (https://github.com/PegaSysEng/teku/pull/2145) but want to test it out for a while before committing.",
        "created_at": "2020-06-14T15:59:53.483000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@!573787335796326400\u003e you can/should likely keep get-ancestor optimized for getting the ancestor of a recent block, but for a worst-case of looking tens of thousands of blocks back, you can optimize it using proto-array forkchoice: it's an array with insertion order, so you can binary search it by slot attribute, with the exception that pivot points may not be canonical, in which case you've to look for another pivot. Checking if it's canonical is O(1), since each node references the head, which you already have. So you can find the ancestor for a given slot (or most recent if the slot is empty) in `O(log(n))` (ignoring pivot misses, but oh well, if that becomes a problem you can add a \"lowest seen slot\" attribute to each proto-array node to speed things up).",
        "created_at": "2020-06-14T16:16:13.104000+00:00",
        "attachments": []
    },
    {
        "author": "benjaminion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Thanks, \u003c@!203220829473996800\u003e - I was sure there'd be a better method. I'll pass this on to those responsible for this bit of code: I'm just hacking enough to keep us running for now ðŸ˜‚",
        "created_at": "2020-06-14T16:19:31.995000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yes, makes sense, and in the regular case of looking up a recent block it's the better approach. It's only with crazy long non-finality when the nice things start to break",
        "created_at": "2020-06-14T16:20:37.927000+00:00",
        "attachments": []
    },
    {
        "author": "ajsutton",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The good news though - last time we ran out of memory before we got to this issue. ðŸ™‚",
        "created_at": "2020-06-14T21:04:31.521000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e Regarding that optimisation, Iâ€™m not sure the O(1) lookup to determine the link between ancestor/descendant works since get_ancestor deals with descendants that are not necessarily the canonical head.",
        "created_at": "2020-06-14T21:12:32.624000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Oh good point, forgot about that ðŸ˜¦",
        "created_at": "2020-06-14T21:13:18.444000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "But adding the \"lowest seen slot\" attribute to each node would work around that",
        "created_at": "2020-06-14T21:13:52.045000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "basically put the `max(last_node.lowest_seen_slot, new_block.slot)` in each node you append",
        "created_at": "2020-06-14T21:14:38.243000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "For get_ancestor we use the proto_array to do a simple parent-by-parent search backwards. Since youâ€™re just skipping around an array by index itâ€™s quite fast.",
        "created_at": "2020-06-14T21:14:44.053000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "then binary search with lowest-seen",
        "created_at": "2020-06-14T21:14:53.421000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "\u003e basically put the `max(last_node.lowest_seen_slot, new_block.slot)` in each node you append\n\u003c@203220829473996800\u003e  hmm still not convinced. What if you have three heads that all come from the same finalised checkpoint.",
        "created_at": "2020-06-14T21:15:09.351000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "And one that doesnâ€™t \u003câ€” ignore that",
        "created_at": "2020-06-14T21:15:25.563000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "at worst the fragmentation could cause the lowest-seen to not be distributed nicely, making search slower",
        "created_at": "2020-06-14T21:16:16.272000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "I canâ€™t think of the exact scenario to break that, but it just doesnâ€™t feel right that you can link block to arbitrary ancestor using only two slot values.",
        "created_at": "2020-06-14T21:16:36.950000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Ok, alternative optimization idea: every N slots, reference the node at the start of the interval. And have every interval reference the previous interval. That way you can speed up traversal from head by approx. N times.",
        "created_at": "2020-06-14T21:19:34.502000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Idk, it's not too difficult to trade memory for cpu here. Just not doing it recursively to avoid stack frames is a good start.",
        "created_at": "2020-06-14T21:20:55.771000+00:00",
        "attachments": []
    },
    {
        "author": "benjaminion",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Skiplists are cool ðŸ™‚",
        "created_at": "2020-06-14T21:21:26.738000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "The idea is a lot like a skip list yes, except just one direction, and forking the other direction.",
        "created_at": "2020-06-14T21:22:26.312000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Yeah we built a stateful iterator that doesnâ€™t use recursion.",
        "created_at": "2020-06-14T21:22:58.334000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Great. And compared to the beacon state transition, it probably takes several 10s of thousands of slots in forkchoice for iteration to start become noticeable (in Rust at least)",
        "created_at": "2020-06-14T21:24:19.609000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Hmm, paul is right about the binary search, lowest-seen breaks when forks are inserted with delays. Order of insertion is preserved, but not over all forks. So skip-lists it is if it ever becomes a real problem. Or just iterate in-place instead of recursion, should be fine",
        "created_at": "2020-06-14T21:32:32.100000+00:00",
        "attachments": []
    },
    {
        "author": "protolambda",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "Also, if you've the state of the block you are getting the ancestor for ready anyway, you get to just read it from the block-roots, good for 8,192 slots (=~27 hours)",
        "created_at": "2020-06-14T21:44:10.074000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Channel Graveyard",
        "parent": "",
        "content": "IIRC thereâ€™s only one case where you donâ€™t already feasibly have the state on hand",
        "created_at": "2020-06-14T21:45:57.951000+00:00",
        "attachments": []
    }
]