[
    {
        "author": "mratsim",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Isn't the graffiti field made for that?",
        "created_at": "2019-12-11T18:23:40.313000+00:00",
        "attachments": []
    },
    {
        "author": "mratsim",
        "category": "Consensus Layer",
        "parent": "",
        "content": "ah maybe there is no equivalent in the networking spec",
        "created_at": "2019-12-11T18:24:13.411000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yeah this isn't for blocks, this is for the nodes themselves.",
        "created_at": "2019-12-11T18:35:12.745000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Is that an existing field in the hello?",
        "created_at": "2019-12-11T18:42:28.114000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Iâ€™m happy to support that if it can be done with existing message, hello is a spec object so weâ€™d have to propose it upstream first if we wanted to add another field",
        "created_at": "2019-12-11T18:43:04.751000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@399309815517544451\u003e what's the process to do that?  Create a PR?",
        "created_at": "2019-12-11T19:01:14.978000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I would start a convo in the ETH2 discord in networking channel. If there is no clear objection, then I think itâ€™s a good approach to start with a PR or GitHub issue",
        "created_at": "2019-12-11T19:13:44.790000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Umm... isn't that here?",
        "created_at": "2019-12-11T19:14:12.001000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Oh... we are in ETH2 discord lol",
        "created_at": "2019-12-11T19:14:12.252000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "My bad, discord confusion, too many servers ðŸ˜‚",
        "created_at": "2019-12-11T19:14:25.189000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I support this idea, but looking forward to hearing any critical feedback. Iâ€™d expect this is an optional field, which may or may not be accurate depending on the intention of the user",
        "created_at": "2019-12-11T19:15:25.248000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "These messages are also infrequent, so they are low impact on performance, in my opinion",
        "created_at": "2019-12-11T19:15:52.024000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Wouldn't that hurt privacy and enable people to block certain clients? ðŸ™‚",
        "created_at": "2019-12-11T19:25:16.477000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "why would someone block certain clients? isn't it beneficial to be connected to anyone that will give you data?",
        "created_at": "2019-12-11T19:26:34.544000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "regarding privacy, is this a concern? I thought eth1 clients advertise their client name and version",
        "created_at": "2019-12-11T19:27:07.960000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "For syncing it doesn't make sense to block, but if you deny syncing to other clients your client will apear to sync faster. \nI don't think this theory is viable because someone would figure out and it won't benefit client doing it in the long run.\n\nOther thing is it would make quite easy to find nodes with vulnerable software that forgot to update and expose it (increase in attack vector).\nJust went and checked, aparently eth1 clients don't advertise it: https://github.com/ethereum/devp2p/blob/master/caps/eth.md#status-0x00",
        "created_at": "2019-12-11T19:36:37.075000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@545555441518772225\u003e yes you could use it to block certain node software, but the only useful reason to do this would be if there was a problem with such software (sending incorrect data, not throttling, etc.)  So there are legitimate reasons for doing so that improve overall network health.",
        "created_at": "2019-12-11T19:46:52.609000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "As for denying connections to other clients, you can do that regardless of the type and version of node software they are using",
        "created_at": "2019-12-11T19:47:21.819000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "you have peerReputation for that though",
        "created_at": "2019-12-11T19:47:22.068000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "That first thing was just first thing that came to mind, second is probably more important",
        "created_at": "2019-12-11T19:48:33.717000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Peer reputation is based on the instance though, not the software",
        "created_at": "2019-12-11T19:49:35.056000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "(Is there anything out there that describes peer reputation in detail?)",
        "created_at": "2019-12-11T19:50:15.231000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "not really AFAIK but not sure if I understand why is blocking on misbehaviour detection problematic?",
        "created_at": "2019-12-11T19:51:54.636000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It's not just blocking on problematic behaviour, it can be custom handling of requests/responses based on the quirks of any given software/version combination.",
        "created_at": "2019-12-11T19:53:24.962000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It might be better to include protocolVersion field like in eth1 then?",
        "created_at": "2019-12-11T19:54:38.618000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Also, peeer reputation is reactive (the client has to misbehave for its reputation to be decreased) rather than proactive",
        "created_at": "2019-12-11T19:55:00.328000+00:00",
        "attachments": []
    },
    {
        "author": "dryajov",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!144468805697929216\u003e imo, adding a clientid field makes a lot of sense...",
        "created_at": "2019-12-11T19:55:04.089000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Protocol ID says what it is meant to do, doesn't give us any information about if it does it properly or not",
        "created_at": "2019-12-11T19:55:17.148000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "That seems like bad practice to allow software to behave incorrectly by handling invalid protocol messages, also you are not suppose to crash if you encounter invalid data.\nThat said, I don't believe blocking peers based on software name and version is the way to go. #EveryNewPeerIsEqual ðŸ˜„",
        "created_at": "2019-12-11T19:59:32.713000+00:00",
        "attachments": []
    },
    {
        "author": "dryajov",
        "category": "Consensus Layer",
        "parent": "",
        "content": "There might be known buggy clients that one might want to disconnect from (or avoid connecting to)  as soon as possible, this would allow for it. IMO, it's pretty standard practice to provide some client versioning in application level protocols. I see clear benefits from adding this and not a lot of drawbacks. My .2c.",
        "created_at": "2019-12-11T20:03:30.138000+00:00",
        "attachments": []
    },
    {
        "author": "mpetrunic",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I would argue that somebody would run buggy client if it doesn't work. If he is doing it intentionally, I don't think client name will make his job harder ðŸ™‚",
        "created_at": "2019-12-11T20:08:37.541000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Let's take a hypothetical example.  There is a version of software out there that, for some reason, sends transfer messages with sender and recipient reversed.  This version of the software has been out there for a while and no-one realised the issue (because transfers weren't enabled until just now).  This version of the software is also very popular, so lots of nodes out there are running it.\n\nSo, there are messages going around the network that fail the signature check.  These could all be thrown out due to this, or other node software *could* know the fields are reversed (because it knows the client software version) and swap the fields internally before they carry out validation.\n\nThis is very much a contrived example, but the general point is that working around popular node issues is going to be a better solution that writing them off as \"bad\", or having on-going struggles across the network with problem nodes we can't recognise because we have to work on the assumption that all nodes are both equal and \"good\".\n\nAnd most \"bad\" nodes are going to be there because users won't upgrade if they don't see problems, rather than because they are being malicious.",
        "created_at": "2019-12-11T20:13:07.332000+00:00",
        "attachments": []
    },
    {
        "author": "dryajov",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Agree, plus being an open network, I can fork any client and run my own version, just as it happens with Eth1 right now - there are tons of nodes from all sorts of experiments, testnets, forks floating around. The standard practice is to talk to only a few well know clients and discard the rest.",
        "created_at": "2019-12-11T20:16:09.127000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yep could have inclusion lists, exclusion lists, down to the node.  But being able to handle different client software versions differently is usually one of those things that goes in after the fact when you find out you *really* need it.  Would be nice to get ahead of the game",
        "created_at": "2019-12-11T20:20:15.969000+00:00",
        "attachments": []
    }
]