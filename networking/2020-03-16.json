[
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "regarding testing, I remember the libp2p folks presented a \"generic\" distributed systems test framework - anyone looked into that? just like we have a state transition conformance test, we'd love to see one for libp2p and one for the eth2 messages",
        "created_at": "2020-03-16T07:19:17.787000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "seeding is fine to a certain extent, though we might have to keep some data external (ie validator key etc) - for example, can test that gossip doesn't spread junk but other things are a bit more fishy: if a block was gossiped, is the client obliged to respond to a block request? kind of not really, but \"good\" clients will.. it would be interesting to have some stress tests in there as well - for example \"servers\" that misbehave when answering to requests: send unexpected blocks as responses etc",
        "created_at": "2020-03-16T07:24:40.844000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "Consensus Layer",
        "parent": "",
        "content": "specially the latter part is interesting because the clients we develop are unlikely to have these \"features\" of spreading misinformation, so having a dedicated bad actor would be good",
        "created_at": "2020-03-16T07:25:26.641000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Consensus Layer",
        "parent": "",
        "content": "You mean a chaos monkey",
        "created_at": "2020-03-16T10:47:12.024000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Consensus Layer",
        "parent": "",
        "content": "metaphorically maybe -- my understanding is that the original namesake mostly turned on/off systems/networks/etc (I could be totally wrong on this), but that it would help to have a way of testing empirically the extent to which eth2 is defensible from something closer to byzantine threats",
        "created_at": "2020-03-16T13:13:57.550000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The thing is having a \"skynet\": Multiple agents deployed around the testnet, that mostly behave normal, but would send RPC calls to a central to get scripted actions (their \"battle orders\")",
        "created_at": "2020-03-16T13:14:56.198000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I'm thinking those BT clients which provide false hashes for blocks to try to sabotage torrents",
        "created_at": "2020-03-16T13:14:57.219000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The scripted actions being orchestrated attacks. Once it is learned how to do the attacks, the next phase is randomizing them.",
        "created_at": "2020-03-16T13:16:30.753000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Consensus Layer",
        "parent": "",
        "content": "_Rumor_ to be seen as a T-800 ðŸ˜Ž",
        "created_at": "2020-03-16T13:17:00.759000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Consensus Layer",
        "parent": "",
        "content": "That seems reasonable",
        "created_at": "2020-03-16T13:20:07.920000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Rumor is perfect, so the only enhancement to add it is the ability to HTTP query a central (so we don't need to open for them an extra listening port) to receive its \"battle orders\" (I don't know what's the term in english ðŸ‡¬ðŸ‡§ )",
        "created_at": "2020-03-16T13:24:58.149000+00:00",
        "attachments": null
    },
    {
        "author": "Deleted User",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I should do that instead of posting \"it would be nice\" messages ðŸ˜“",
        "created_at": "2020-03-16T13:25:24.820000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\"order of battle\"",
        "created_at": "2020-03-16T13:25:54.694000+00:00",
        "attachments": null
    },
    {
        "author": "tersec",
        "category": "Consensus Layer",
        "parent": "",
        "content": "(it must be a relatively literal translation from some other language -- it doesn't come across as idiomatic in English IMO)",
        "created_at": "2020-03-16T13:26:34.738000+00:00",
        "attachments": null
    },
    {
        "author": "pipermerriam",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e for the python bindings I highly recommend porting to use trio over asyncio",
        "created_at": "2020-03-16T13:31:01.463000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It worked fine so far, does trio have any particular feature that asyncio doesn't provide? I know Trinity switched, but unclear why. I just need simple awaits to work mostly. And pyrum reads/writes from rumor using asyncio subprocess. \u003c@364458974906548225\u003e",
        "created_at": "2020-03-16T17:48:01.168000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The idea is to keep the python layer thin. Just provide elegant async scripting. And do concurrent networking in rumor (Go, with all the upstream libp2p and dv5 libraries)",
        "created_at": "2020-03-16T17:49:13.631000+00:00",
        "attachments": null
    }
]