[
    {
        "author": "mratsim",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It might need updating: https://github.com/eth2-clients/multinet",
        "created_at": "2021-01-28T12:13:46.971000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Thanks! Def need updating tho",
        "created_at": "2021-01-28T14:34:44.709000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "For sync there's a key metric = min distance between a peer and a node to consider triggering a finalized sync. Seems like Lighthouse has it set to 2 epochs while Prysm 1 epoch (not versed in all languages so I might be wrong). Could each team share if there is a reasoning for this values?",
        "created_at": "2021-01-28T14:36:47.846000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Also, most clients seem to wait to have some min peers before starting a finalized sync from them. Do team have any experience or advice on what is good min peers value and why?",
        "created_at": "2021-01-28T14:38:25.213000+00:00",
        "attachments": []
    },
    {
        "author": "mratsim",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Only votes for the last 2 epochs count. So a client can considered itself synced at least when it makes sense for it to vote.",
        "created_at": "2021-01-28T14:46:40.252000+00:00",
        "attachments": []
    },
    {
        "author": "mratsim",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Nimbus considers itself synced when it's within the last 2 epochs as well.",
        "created_at": "2021-01-28T14:47:05.584000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Thanks! Does Nimbus has a notion of min peers for syncing?",
        "created_at": "2021-01-28T14:49:24.460000+00:00",
        "attachments": []
    },
    {
        "author": "mratsim",
        "category": "Consensus Layer",
        "parent": "",
        "content": "There is a warning if you have low peer count but no low peer count doesn't prevent syncing.",
        "created_at": "2021-01-28T14:50:04.262000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "For us, there is a race-condition of sorts. If we start syncing with a peer, we fix a specific slot to sync to. In the time it takes to sync, the chain is likely to have advanced. We repeat the process. If the sync process is slow then the difference between our head and the peer we are syncing from grows a bit. We consider 2 epochs synced, because there's not too much overhead to ask for individual blocks in the same process that occurs if a synced peer forks or deviates from our current head slightly",
        "created_at": "2021-01-28T14:52:21.597000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "We dont have a min peer count to start syncing. We can sync with a single peer. We are careful about eclipses via our discovery mechanism",
        "created_at": "2021-01-28T14:52:40.340000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Would it be possible if you were connected to a single peer (attacker) to get fed a wrong finalized fork? If then, the node connects to good peers who continue on the main fork (now conflicting), could the node recover on its own?",
        "created_at": "2021-01-28T14:53:25.344000+00:00",
        "attachments": []
    },
    {
        "author": "mratsim",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It will replay from the fork and will recover though it will be busy because replaying is costly.",
        "created_at": "2021-01-28T14:54:26.837000+00:00",
        "attachments": []
    },
    {
        "author": "mratsim",
        "category": "Consensus Layer",
        "parent": "",
        "content": "also we randomly accept peers to avoid eclipse attacks.",
        "created_at": "2021-01-28T14:54:45.167000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Thanks! Would you mind linking to the relevant code that handles eclipses?",
        "created_at": "2021-01-28T14:55:32.936000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "A single peer (who is a valid validator) could feed a chain with lots of empty and a few valid slots (this wouldn't be finalized however) after a good peer sent the correct chain, fork-choice would select the honest chain (with the most validator votes)",
        "created_at": "2021-01-28T14:56:00.458000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The code is somewhat complicated, I can link you. But essentially its based on kademlia queries. We pick a random distance and find nodes close to that distance. We dont return the query early until all nodes close to a random distance have been contacted.",
        "created_at": "2021-01-28T14:58:00.434000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It makes it hard for an attacker to generate and posses sall nodes closer to random distances than we can find on the DHT",
        "created_at": "2021-01-28T14:58:31.848000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Basic query logic is here if you are interested: https://github.com/sigp/discv5/blob/master/src/query_pool/peers/closest.rs#L127",
        "created_at": "2021-01-28T15:01:15.271000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Thanks! Related, do you have practical testing or historical reasoning on this value, and why not 1? (from Lighthouse's ChainCollection)\n```rs\n/// The number of head syncing chains to sync at a time.\nconst PARALLEL_HEAD_CHAINS: usize = 2;\n```",
        "created_at": "2021-01-28T15:03:36.535000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Do you keep track of peers that have banned you and avoid connecting to them for some time?",
        "created_at": "2021-01-28T15:27:02.986000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yes. It used to be unlimited. There are issues with networks with a high degree of forking. If the forks are very long, think 1000 blocks, syncing many in parallel is highly imeffecient as you download many duplicates. \nIf you only do 1 at a time, you could get stuck on a non canonical fork for a long time when another could make it obsolete.",
        "created_at": "2021-01-28T15:44:21.376000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Peers that ban us disconnect from us. We just find other peers to fill reach our target peer count",
        "created_at": "2021-01-28T15:45:00.650000+00:00",
        "attachments": []
    },
    {
        "author": "dapplion",
        "category": "Consensus Layer",
        "parent": "",
        "content": "What prevents you from finding the same peer again?",
        "created_at": "2021-01-28T15:45:47.298000+00:00",
        "attachments": []
    },
    {
        "author": "agemanning",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Nothing, but if it has banned us it won't accept a reconnection.",
        "created_at": "2021-01-28T15:46:25.092000+00:00",
        "attachments": []
    }
]