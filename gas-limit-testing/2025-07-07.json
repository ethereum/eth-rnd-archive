[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cCPerezz\u003e @marcin_d_s @KamilChNethermind we will start sync tests as well as attack-vector tests agains Bloatnet at 1.5x state size.  I was mainly wondering if there are any worst-cases from Perfnet (aside from XEN) which would be interesting to test with higher state-size. \n\nAll the ones I could think of are either developed or almost-developed (will try to make EELS tests for them so that we can integrate with your platform easier(?).  LMK if there's anything you think makes sense to test there too!",
        "created_at": "2025-07-07T14:02:29.733000+00:00",
        "attachments": null
    },
    {
        "author": "parithosh",
        "category": "Execution Layer",
        "parent": "",
        "content": "Please push this change to your performance branches, we'd like to benchmark the change and observe modexp performance: https://github.com/ethereum/EIPs/pull/9969",
        "created_at": "2025-07-07T14:51:31.482000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcin_d_s\u003e to performance-modexp please üôÇ",
        "created_at": "2025-07-07T14:57:40.259000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cvdWijden\u003e Done",
        "created_at": "2025-07-07T14:58:59.893000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcin_d_s\u003e Also done for nethermind",
        "created_at": "2025-07-07T15:01:50.821000+00:00",
        "attachments": null
    },
    {
        "author": "taratorio",
        "category": "Execution Layer",
        "parent": "",
        "content": "pushed to performance-modexp for Erigon too",
        "created_at": "2025-07-07T15:09:12.633000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003camezianehamlat\u003e Also done on Besu",
        "created_at": "2025-07-07T15:35:25.501000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cvdWijden\u003e When do you think can we move the performance-modexp branch to fusaka spec? Iirc there's something in the framework that needs to change @marcin_d_s @KamilChNethermind ?",
        "created_at": "2025-07-07T17:39:16.287000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e re: **@vdWijden**\n\u003e When do you think can we move the performance-modexp branch to fusaka spec? Iirc there's something in the framework that needs to change @marcin_d_s @KamilChNethermind ?\nDiscussed that with Marcin today and we will do our best to make it quickly but no ETA for now.\nAfaik Marcin had some branch on which majority of things already worked but there are some small tweaks needed but were surprising enough that is hard to guess.",
        "created_at": "2025-07-07T17:40:30.922000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcin_d_s\u003e Yeah in current generator we have hardcoded dencun genesis and all is based on nethermind code from about a year ago. After merging all the updates from master, there were massive amount of conflicts. I solved everything (and made forced refactors) and generally made it working (which makes generating tests on top of any other genesis possible), but last payload is always empty and I didn't found the reason yet. Might be an hour of debugging or a few days üòÇ",
        "created_at": "2025-07-07T18:51:27.252000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcin_d_s\u003e Last results of modexp (with 3x pricing):",
        "created_at": "2025-07-07T18:52:00.640000+00:00",
        "attachments": [
            {
                "type": "image/jpeg",
                "origin_name": "file_68.jpg",
                "content": "1e47e54986ebe30cce4cafdde449300d5eda9fd61d29e3ad1657278a81d87c27"
            }
        ]
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcin_d_s\u003e we have a worst case at 31.4 MGas/s which isn't optimal for sure, but should be okayish with going to 100M",
        "created_at": "2025-07-07T18:52:40.420000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e Sorry I missed this: Why aren‚Äôt Erigon/Geth using GMP or other libs that go faster?",
        "created_at": "2025-07-07T18:53:45.082000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcin_d_s\u003e And potential for future optimizations is huge",
        "created_at": "2025-07-07T18:54:07.730000+00:00",
        "attachments": [
            {
                "type": "image/jpeg",
                "origin_name": "file_69.jpg",
                "content": "c36f9d9677fdc7e24a78257eb2b660f575ace7c40b46bba50774df42a364ca79"
            }
        ]
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cmarcin_d_s\u003e \u003c@486477492434239488\u003e to keep diversification",
        "created_at": "2025-07-07T18:57:14.252000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e re: **@marcin_d_s**\n\u003e \u003c@486477492434239488\u003e to keep diversification\nWhat‚Äôs the thing you guys worry about? Bug in GMP math?",
        "created_at": "2025-07-07T19:01:13.365000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@gakonst**\n\u003e Sorry I missed this: Why aren‚Äôt Erigon/Geth using GMP or other libs that go faster?\nGMP doesn't play well with golang (- yet, i haven't looked too much into it)",
        "created_at": "2025-07-07T19:01:18.868000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e re: **@somnergy**\n\u003e GMP doesn't play well with golang (- yet, i haven't looked too much into it)\nRespect but diversification @marcin_d_s is very unconvincing\n\n@somnergy do you want any help on it? what doesn‚Äôt work well in go?",
        "created_at": "2025-07-07T19:02:19.069000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e I understand it‚Äôs a C lib that you need to call from Go, https://github.com/ncw/gmp is this package not workable?\n\nHave we checked w/ any of the Gnark-related lib maintainers and they don‚Äôt have a good modexp impl?",
        "created_at": "2025-07-07T19:04:47.568000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@gakonst**\n\u003e Respect but diversification @marcin_d_s is very unconvincing\n\n@somnergy do you want any help on it? what doesn‚Äôt work well in go?\nI think some work is already being done by both teams, we didn't see it as a priority. What help tho? Do you have an efficient wrapper?\n- It's hard to build using golang's builder, unless you include the binaries already included in the platform (read linux)\n- The cgo overhead makes it so that there aren't any significant gains over the native bigInt package",
        "created_at": "2025-07-07T19:05:27.952000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e Well now that i look at the graph from Nethermind tho, we may have to prioritize modexp too",
        "created_at": "2025-07-07T19:07:28.263000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e Yep",
        "created_at": "2025-07-07T19:09:59.093000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@somnergy**\n\u003e I think some work is already being done by both teams, we didn't see it as a priority. What help tho? Do you have an efficient wrapper?\n- It's hard to build using golang's builder, unless you include the binaries already included in the platform (read linux)\n- The cgo overhead makes it so that there aren't any significant gains over the native bigInt package\nThis is a bit suprising, what was the overhead of calling cgo vs computing the modexp operation for various different modexp bitsizes?\n\nFor very small bitsizes, I could see this being plausible",
        "created_at": "2025-07-07T19:14:22.327000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e re: **@kevaundray**\n\u003e This is a bit suprising, what was the overhead of calling cgo vs computing the modexp operation for various different modexp bitsizes?\n\nFor very small bitsizes, I could see this being plausible\nIdk, i just seen it be slower, when imported by others (not tagging)",
        "created_at": "2025-07-07T19:15:37.123000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@kevaundray**\n\u003e This is a bit suprising, what was the overhead of calling cgo vs computing the modexp operation for various different modexp bitsizes?\n\nFor very small bitsizes, I could see this being plausible\nhas to pause execution, move execution to fixed thread to call C, then after resume back on go thread; as go doesn't use threads the way C expects. It means there is additional overhead in calling C libs compared to other runtimes (and why most stuff is re-written in golang instead)\n\nAlso most of the data types have to have their data copied to the other environment (can't be directly passed)",
        "created_at": "2025-07-07T19:20:43.662000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e re: **@ben_a_adams**\n\u003e has to pause execution, move execution to fixed thread to call C, then after resume back on go thread; as go doesn't use threads the way C expects. It means there is additional overhead in calling C libs compared to other runtimes (and why most stuff is re-written in golang instead)\n\nAlso most of the data types have to have their data copied to the other environment (can't be directly passed)\nYep this makes sense -- though it would be suprising if the overhead meant that there aren't any significant gains to be had over native big.Int",
        "created_at": "2025-07-07T19:27:51.397000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ckevaundray\u003e I'd expect this is somewhere on the order of high nanoseconds to a few microseconds (?)",
        "created_at": "2025-07-07T19:28:02.060000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cgakonst\u003e Ya my rec would be to benchmark it, compare and decide then if it‚Äôs worth it or not",
        "created_at": "2025-07-07T19:29:20.181000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@kevaundray**\n\u003e I'd expect this is somewhere on the order of high nanoseconds to a few microseconds (?)\nidk ü§∑‚Äç‚ôÇÔ∏è think it messes up the golang GC and scheduler also; as the runtime can't make the C threads yield to it",
        "created_at": "2025-07-07T19:30:01.272000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Is a reason why most things are rewritten in golang; and you can output assembly directly from go compiler (to avoid calling C) üòÖ",
        "created_at": "2025-07-07T19:32:38.559000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003csomnergy\u003e It can be worth it if it's included with go binary, and callable truly natively. That'll also eliminate any other platform dependent friction. Ball is with go makers (and perhaps Google) on that. Presumably, otherwise, it will never reach performance more than half of like a rust wrapper's. But we may be able to optimize it a lot, a big 'maybe'",
        "created_at": "2025-07-07T20:39:39.387000+00:00",
        "attachments": null
    }
]