[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@lrozmej**\n\u003e I really think the future of Ethereum VM is transpilation to multiple native-like backends. We can achieve that in few ways. We can keep domain specific language - EVM, but we need to make that transpilation easier - and EOF comes here big. Or we can also move to something simpler like Risc-V, but that has other set of problems where you are ignoring domain specific problems and thus making optimizing them hard.\nRISC-V is JIT-attackable for the same reasons EVM is: no verification and dynamic jumps.",
        "created_at": "2025-05-29T07:25:34.648000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@MarekM25**\n\u003e Now, very important goal will be to standardize the format for benchmarks\nEEST works great for this. I encourage everyone to try it first, e.g. try to run these worst-case workloads: https://github.com/ethereum/execution-spec-tests/releases/tag/zkevm%40v0.1.0\n\nThe testing team (STEEL) is also very responsive to feedback.",
        "created_at": "2025-05-29T07:31:57.510000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e We are improving our infrastructure and tests preparation (for example we want to add proper warmup as languages like c# and Java need to have few runs over methods to show real performance and this warmup is on place on any running node) and will work on including these",
        "created_at": "2025-05-29T07:40:53.380000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e re: **@chfast**\n\u003e RISC-V is JIT-attackable for the same reasons EVM is: no verification and dynamic jumps.\nThat is why I would go EOF and try to phase out legacy\n\nBut can you link to explanation of the attack?",
        "created_at": "2025-05-29T07:44:12.944000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cchfast\u003e re: **@lrozmej**\n\u003e That is why I would go EOF and try to phase out legacy\n\nBut can you link to explanation of the attack?\nI don't know any good writeup about it. For JIT you have to reconstruct some form of control-flow graph. It should be higher level than EVM and RISC-V is. So you can make a input program for which this CFG analysis explodes and/or the final jitted code perform worse than the interpreter.",
        "created_at": "2025-05-29T07:52:39.942000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e Seeking for opinions from people out there especially from EL devs.\n\nWorst-case (opcodes) stress testing seems like super valuable thing but we are having some doubts about results especially comparing various languages used (rust and go vs java and c#). Java and C# seems like require some prewarming of methods to show \"Real\" data.\n\nWorst-case scenario of course is - no warmup and sudden attack with some very specific opcodes but this affects only new nodes - and actually I'm not even sure if it affects them because user needs still to sync and process quite a big chunk of data so EVM methods should be \"warm\" before actually node starts following the chain.\n\nWorking now on prewarming and have first version of that which proves for sure that neth and besu are doing better - question is if we should run both types so \"warm\" and \"cold\" or maybe even spending resources on testing \"cold\" path doesn't make sense.",
        "created_at": "2025-05-29T17:56:26.187000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e Pre warming is often a proxy for running your node for 2-5 minutes. While cold start should be a consideration most of the network is not in a cold start state.",
        "created_at": "2025-05-29T17:58:12.745000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e By the time a node is back in sync from a restart the jit compilation has done 95% of the needed work.",
        "created_at": "2025-05-29T17:58:50.066000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e Sustained tps and gps are the gold standard here, as there are many moving pieces outside of the EVM that impact the node more,.such as data caching.",
        "created_at": "2025-05-29T17:59:42.204000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e So to be really affected by that and consider it even \"wors-case\" sopmething ecven worse should happen before :D",
        "created_at": "2025-05-29T17:59:50.092000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e To have for example 66% of nodes down and started at the same time",
        "created_at": "2025-05-29T18:00:00.706000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e Something that could kill multiple clients, yes.",
        "created_at": "2025-05-29T18:00:36.685000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e Yeah but I mean - other issues needs to be on place (maybe not even related to EVM itself) which will make those nodes down - only then we can consider we have most of the network in cold state and the window is pretty short",
        "created_at": "2025-05-29T18:01:20.625000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003crjected\u003e or crash loop bug, for ex an OOM which would cause frequent restarts",
        "created_at": "2025-05-29T18:01:39.288000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e And seems like (but not yet fully confirmed) it affects only besu and nethermind with jit compilation",
        "created_at": "2025-05-29T18:01:40.381000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e reth for sure with prewarming keeps similar performance",
        "created_at": "2025-05-29T18:01:57.692000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e While for nethermind for example I can see even 100% better results",
        "created_at": "2025-05-29T18:02:07.885000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e Disc cache loading impacts everyone.  With that every client will see a performance curve from cold start.  Just a question of how much.",
        "created_at": "2025-05-29T18:03:46.941000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e Above tests are on empty state as it should not affect that much those specific scenarios - so probably not by a lot and also is a matter of minutes to be on full throttle, right? And real node after few minutes downtime will reproces already quite a big chunk of data so once will be on a tip will already be quite warm",
        "created_at": "2025-05-29T18:05:24.923000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@shemnon**\n\u003e Pre warming is often a proxy for running your node for 2-5 minutes. While cold start should be a consideration most of the network is not in a cold start state.\nhow much warming (method iterations) does Java need these days? Is quite high?",
        "created_at": "2025-05-29T18:07:36.525000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e Is there any way to actually verify what is cold and what is warm? :D It is above my knowledge of that, trying to set proper warmuping but executing tests 10times for one measured one seems like overkill (at least in terms of time of execution which is now 30 minutes and will be 6hours per run)",
        "created_at": "2025-05-29T18:08:56.153000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e It's adaptive complication.  Their first tier is fairly good.  It will adapt to long observed patterns (such as a field always being null) with a kick out to interpreted if the invariant fails.",
        "created_at": "2025-05-29T18:09:26.898000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e @kamil for a 30 minute test just discard the first minute to ten.  For a six hour test the same.  The average over six hours will be close enough.",
        "created_at": "2025-05-29T18:10:21.257000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e Probably closer to one minute than ten.",
        "created_at": "2025-05-29T18:10:37.184000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e Especially with empty state.",
        "created_at": "2025-05-29T18:10:50.396000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003crjected\u003e In reth we're experimenting with using PGO on some workload before building the binaries that we distribute, are there similar things in other langs?",
        "created_at": "2025-05-29T18:11:39.747000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@rjected**\n\u003e In reth we're experimenting with using PGO on some workload before building the binaries that we distribute, are there similar things in other langs?\n.NET and Java do live PGO on the running code; which is why the need for warm up",
        "created_at": "2025-05-29T18:12:30.613000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e For Java there is CRaC (just for cold starts), haven't used it but other Twitter Java people rave about it https://openjdk.org/projects/crac/",
        "created_at": "2025-05-29T18:12:52.625000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003crjected\u003e Right, wondering more if you could do this ahead of time",
        "created_at": "2025-05-29T18:12:59.561000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003crjected\u003e to speed up this warm up or remove the \"penalty\" of being cold",
        "created_at": "2025-05-29T18:13:26.498000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshemnon\u003e A little of both.  Mostly cold start.",
        "created_at": "2025-05-29T18:13:46.599000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Can do ready to run for another 10mins of compilation time to improve cold starts; but it still does runtime PGO to adapt to the specific CPU its running on and turn variables into constants and branch elimination based on things that become constants",
        "created_at": "2025-05-29T18:14:19.955000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Would make sense for rust (and golang?) though since you don't get to recompile at runtime",
        "created_at": "2025-05-29T18:18:43.187000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@shemnon**\n\u003e It's adaptive complication.  Their first tier is fairly good.  It will adapt to long observed patterns (such as a field always being null) with a kick out to interpreted if the invariant fails.\nCan we pass jvm flags to besu? Like\n\n`-Xcomp -XX:-TieredCompilation`",
        "created_at": "2025-05-29T18:33:26.931000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Maybe JAVA_OPTS",
        "created_at": "2025-05-29T18:40:38.073000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Or send a ton of blocks; which would get to the more real world state :)",
        "created_at": "2025-05-29T18:52:00.024000+00:00",
        "attachments": null
    }
]