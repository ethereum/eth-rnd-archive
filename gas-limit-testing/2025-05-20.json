[
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e I mean - if we can agree that one block txs are bad then we should discourage them",
        "created_at": "2025-05-20T00:00:26.074000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e It may cost more but it reflects the cost in lack of parallelism in some sense",
        "created_at": "2025-05-20T00:01:33.272000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e Meh actually that is kind of messed up",
        "created_at": "2025-05-20T00:02:48.411000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Execution Layer",
        "parent": "",
        "content": "I guess I'm saying we probably shouldn't agree on that.  If we often saw blocks with just a single tx that indicates a problem, but it seems quite reasonable to think that updating systems might use a lot of gas and benefit from being able to do that atomically in a single tx.\n\nIf it was just that the gas got more expensive (either in protocol or just needing a larger tip) that would be totally fine. These big upgrades are very rare so they don't need to be cheap.  But if they become impossible to do atomically that creates a ton of complexity and risk and we should understand how widespread that is (ie if it's just OP Stack probably fine, we'll sort something out, if it hits a bunch of apps then it would be a UX problem that would drive people away).",
        "created_at": "2025-05-20T00:03:14.703000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@FunnyGiulio**\n\u003e I mean - if we can agree that one block txs are bad then we should discourage them\nCan see some atomicity issues in doing an L2 contracts upgrade \n\nUnless it was deploy, deploy, deploy, proxy swap. But equally some of the initialization probably can't be done until the contracts are in place, so not sure how much can be subdivided",
        "created_at": "2025-05-20T00:04:39.026000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e then it seems we cannot go low",
        "created_at": "2025-05-20T00:04:58.153000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e At least, we answered the question. 30M limit it is ig",
        "created_at": "2025-05-20T00:05:12.378000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@FunnyGiulio**\n\u003e then it seems we cannot go low\ncan't go too low :)",
        "created_at": "2025-05-20T00:05:13.970000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e Well that tx is 27M",
        "created_at": "2025-05-20T00:05:30.250000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Is different than less than 30M",
        "created_at": "2025-05-20T00:05:31.135000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e You are there more or less",
        "created_at": "2025-05-20T00:05:41.985000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e I wonder if this will be affected by jacek's opcode repricing. maybe these compute heavy txs will require a lot less gas?",
        "created_at": "2025-05-20T00:05:46.076000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@FunnyGiulio**\n\u003e Well that tx is 27M\nWas also 3 upgrades that can be subdivided",
        "created_at": "2025-05-20T00:05:46.166000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@notnotstorm_p**\n\u003e I wonder if this will be affected by jacek's opcode repricing. maybe these compute heavy txs will require a lot less gas?\nAlso 8 contract deploys; which has its own pricing",
        "created_at": "2025-05-20T00:07:06.750000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e presumably the deploys could be a separate tx?",
        "created_at": "2025-05-20T00:08:27.612000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e without breaking atomicity of the upgrade",
        "created_at": "2025-05-20T00:08:39.678000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e My honest gut feeling is not to mess around with the limit too much",
        "created_at": "2025-05-20T00:09:24.020000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e I think it is not really worth it if it only is 10M for example",
        "created_at": "2025-05-20T00:09:50.789000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Could do 15M so larger safety margin; then revisit post opcode repricing",
        "created_at": "2025-05-20T00:10:27.495000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e Idt it is worth it",
        "created_at": "2025-05-20T00:10:52.629000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e I think we need to be pragmatic here. If we cannot get it low enough to be worth it, we should set it to smtgh safe",
        "created_at": "2025-05-20T00:11:47.920000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Depends if you want any guarantees from parallelism; or to have parallelism but still set block gaslimit and block time as if it was a single tx using all the gas?",
        "created_at": "2025-05-20T00:12:43.265000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Execution Layer",
        "parent": "",
        "content": "Most contract impls are predeployed in OP Stack (FaultDisputeGame and PermissionedDisputeGame are the couple of contracts I mentioned that don't yet follow best practice).  But there are often new proxies that do get deployed per chain - these are much lower cost but still not nothing. It's possible to predeploy those proxies but does introduce a fair bit more complexity (and we'd probably spend a bunch of gas validating the proxy is setup correctly for safety).\nAnd more importantly, this is just OP Stack, if we're using large tx for upgrades, there's a very good chance other people are too and we need to do the leg work to find them and understand how they would be impacted. Graphs of percentage of tx using different amounts of gas won't show these as they're very rare but very important.",
        "created_at": "2025-05-20T00:13:11.491000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e 15M would still be double throughput of 30M (in parallel)",
        "created_at": "2025-05-20T00:13:22.198000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@ben_a_adams**\n\u003e Depends if you want any guarantees from parallelism; or to have parallelism but still set block gaslimit and block time as if it was a single tx using all the gas?\nyou wouldnt get worst case guarantees in any case because all of the txs could be modifying the same state?",
        "created_at": "2025-05-20T00:13:37.423000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e Yeah but like",
        "created_at": "2025-05-20T00:13:43.648000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e 30M is like also 1/10 of 300M",
        "created_at": "2025-05-20T00:13:55.771000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e rn GL is too low for us to even take this into account imo",
        "created_at": "2025-05-20T00:14:15.535000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@notnotstorm_p**\n\u003e you wouldnt get worst case guarantees in any case because all of the txs could be modifying the same state?\nEither same state is in CPU cache (vs unshared from disk/ram); or you have enough data from BLAs to not worry about it",
        "created_at": "2025-05-20T00:15:04.631000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Still would have a verify step to check what the BLA is telling you about the values is correct; but that could be done in parallel",
        "created_at": "2025-05-20T00:16:31.533000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@ben_a_adams**\n\u003e Either same state is in CPU cache (vs unshared from disk/ram); or you have enough data from BLAs to not worry about it\nif there is serial dependency in computation though that kills a lot of the parallelism. maybe the IO doesn't suffer but the cpu would",
        "created_at": "2025-05-20T00:17:24.752000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Optimistically run all txs in parallel using BAL data; and start on stateroot, while confirming the BAL in background",
        "created_at": "2025-05-20T00:17:34.686000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@ben_a_adams**\n\u003e Optimistically run all txs in parallel using BAL data; and start on stateroot, while confirming the BAL in background\nyea that wouldnt help speedup serial cpu dependencies tho?",
        "created_at": "2025-05-20T00:18:03.257000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@notnotstorm_p**\n\u003e if there is serial dependency in computation though that kills a lot of the parallelism. maybe the IO doesn't suffer but the cpu would\nOnly to the builder; one of the BAL options has all the values you need for all txs to run in parallel without worrying about dependencies (e.g. post tx writes)",
        "created_at": "2025-05-20T00:18:50.971000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e CPU is cheap",
        "created_at": "2025-05-20T00:20:20.845000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e re: **@lrozmej**\n\u003e CPU is cheap\nAlways has been",
        "created_at": "2025-05-20T00:20:36.969000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e not for geth",
        "created_at": "2025-05-20T00:21:00.571000+00:00",
        "attachments": [
            {
                "type": "image/jpeg",
                "origin_name": "file_32.jpg",
                "content": "bcc54adf30d15c0b8f7b1a4e72556e6c3d39f467ab64b67a0e455450722084ee"
            }
        ]
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@lrozmej**\n\u003e CPU is cheap\nWith BAL we go GPU? üòâ",
        "created_at": "2025-05-20T00:21:12.277000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e re: **@notnotstorm_p**\n\u003e not for geth\nwell they are not using the power of parallelism",
        "created_at": "2025-05-20T00:21:36.601000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e CPU is cheap because it gets exponentially better in the years",
        "created_at": "2025-05-20T00:21:59.463000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e btw with BAL can we make protocol incentives to build parallelizable blocks?",
        "created_at": "2025-05-20T00:22:16.132000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@FunnyGiulio**\n\u003e CPU is cheap because it gets exponentially better in the years\nif you can take advantage of parallelism",
        "created_at": "2025-05-20T00:22:16.626000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@ben_a_adams**\n\u003e Only to the builder; one of the BAL options has all the values you need for all txs to run in parallel without worrying about dependencies (e.g. post tx writes)\nI see. so BAL's will forsure contain each tx's pre and post image of state?",
        "created_at": "2025-05-20T00:22:50.893000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@FunnyGiulio**\n\u003e CPU is cheap because it gets exponentially better in the years\nOnly if you can go parallel because Dennard scaling is dead üò¢ https://en.wikipedia.org/wiki/Dennard_scaling",
        "created_at": "2025-05-20T00:23:13.539000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@notnotstorm_p**\n\u003e I see. so BAL's will forsure contain each tx's pre and post image of state?\npre location; post state (if written)",
        "created_at": "2025-05-20T00:24:09.189000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e So any dependencies will have their changed data as part of the BAL (so no dependencies in effect)",
        "created_at": "2025-05-20T00:24:48.353000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@ben_a_adams**\n\u003e So any dependencies will have their changed data as part of the BAL (so no dependencies in effect)\nmakes sense!",
        "created_at": "2025-05-20T00:25:25.422000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Builder still has issues though as they don't get these advantages; but we assume they have better hardware than average validator",
        "created_at": "2025-05-20T00:25:39.343000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e my reservations for BAL is that it optimizes validating a lot, but I think it may expose bottleneck in building",
        "created_at": "2025-05-20T00:26:01.157000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e and actually it slightly complicates building",
        "created_at": "2025-05-20T00:26:22.325000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@lrozmej**\n\u003e my reservations for BAL is that it optimizes validating a lot, but I think it may expose bottleneck in building\nmy main concern is bandwidth. if overall system is bottlenecked by bandwidth then adding BAL+parallelism could make things slower, not faster",
        "created_at": "2025-05-20T00:27:10.786000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@lrozmej**\n\u003e and actually it slightly complicates building\nwhat gets more complicated beyond just bookkeeping of state changes?",
        "created_at": "2025-05-20T00:27:42.092000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@notnotstorm_p**\n\u003e my main concern is bandwidth. if overall system is bottlenecked by bandwidth then adding BAL+parallelism could make things slower, not faster\nWill have look back",
        "created_at": "2025-05-20T00:33:26.337000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e nice!\n\nit would be helpful to see the mean+worstcast SSZ encoded block size alongside, to show the % increase",
        "created_at": "2025-05-20T00:33:27.492000+00:00",
        "attachments": [
            {
                "type": "image/jpeg",
                "origin_name": "file_33.jpg",
                "content": "aa46f5eb17ce5e5467a9bfeb3de56bacd9bc017e72f875531c73dbc80b9ab849"
            }
        ]
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Worst case 1MiB for post-tx execution BAL; avg 48KiB (guessing per 36MGas)?",
        "created_at": "2025-05-20T00:35:43.983000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Is something that would need to take into account though",
        "created_at": "2025-05-20T00:36:44.790000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Worst of all cases though is to have the bandwidth increase from BAL; but then not be able to do much with the data because its all 1 tx using full block (still get parallel IO to a degree, but not parallel execution)",
        "created_at": "2025-05-20T00:37:44.248000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e need numbers for total execution time vs total network transport time\n\nthen we can say \"transport time expected to increase by X%, execution time expected to decrease by Y%\" and see which one is bigger",
        "created_at": "2025-05-20T00:37:44.471000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@ben_a_adams**\n\u003e Worst of all cases though is to have the bandwidth increase from BAL; but then not be able to do much with the data because its all 1 tx using full block (still get parallel IO to a degree, but not parallel execution)\nThen that erases any guarantees of gains, so can't say latency is 3 times lower because at least 3 txs will be being processed at once (as example); so then can't use that to lower block times or increase block gaslimit. Due to being bounded by the worst case",
        "created_at": "2025-05-20T00:41:12.252000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Lower tx cap is one way to reduce that worst case",
        "created_at": "2025-05-20T00:42:19.423000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Obvs don't want to break anything either (like OP upgrades) by going too low ;)",
        "created_at": "2025-05-20T00:42:54.504000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e And maybe L2s go even lower; for additional parallelism gains vs L1 ü§∑‚Äç‚ôÇÔ∏è\n\nStill needs to be worth it at L1 though for it to be implemented in the main ELs",
        "created_at": "2025-05-20T00:45:03.256000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@notnotstorm_p**\n\u003e what gets more complicated beyond just bookkeeping of state changes?\nI assume because the builder gets none of the benefits from BALs",
        "created_at": "2025-05-20T01:06:19.072000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnero_eth\u003e Builders don't get benefits, but they are also incentiviced to not build non-parallelizable blocks, just bc this increases the chances of gettimg reorged out.\nBALs would slightly increase the block size by ~20%, this is still way lower than the blocksizes we saw post dencun/pre pectra when some rollups were still using calldata. Also today, tx with starks are about  5x of the BAL size and compared to calldata, the worst-case size for BALs is still below the worst-case size for calldata (and they can't be used together, as in, you can either maximize the BAL size or the calldata, but buildimg a big calldata block would come with an (almost) empty BAL.",
        "created_at": "2025-05-20T04:00:53.774000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnero_eth\u003e re: **@notnotstorm_p**\n\u003e what gets more complicated beyond just bookkeeping of state changes?\nThe bookkeeping itself is easy since block builders can just keep track of what they touch and the values written to disk during execution. So, no sophistication needed.",
        "created_at": "2025-05-20T04:05:29.925000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@nero_eth**\n\u003e Builders don't get benefits, but they are also incentiviced to not build non-parallelizable blocks, just bc this increases the chances of gettimg reorged out.\nBALs would slightly increase the block size by ~20%, this is still way lower than the blocksizes we saw post dencun/pre pectra when some rollups were still using calldata. Also today, tx with starks are about  5x of the BAL size and compared to calldata, the worst-case size for BALs is still below the worst-case size for calldata (and they can't be used together, as in, you can either maximize the BAL size or the calldata, but buildimg a big calldata block would come with an (almost) empty BAL.\nyea this makes sense. but if the main thrust of BAL's is to increase throughput via parallelization, should make sure that in most average cases the parallelization benefits outweight the bandwidth costs\n\nbandwidth costs are also the main hesitation I have about starks and statelessness",
        "created_at": "2025-05-20T05:15:45.033000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e this would actually be a great usecase for perfnet infra...\n\nrun a testnet that uses BAL's, see how much more (or less!) gas/s each client can process under different workloads",
        "created_at": "2025-05-20T05:16:34.151000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnero_eth\u003e re: **@notnotstorm_p**\n\u003e yea this makes sense. but if the main thrust of BAL's is to increase throughput via parallelization, should make sure that in most average cases the parallelization benefits outweight the bandwidth costs\n\nbandwidth costs are also the main hesitation I have about starks and statelessness\nyeah agree. If BALs turn out to only trade-off bandwidth for parallelization, then it's questionable if we really want it.\nI expect that the parallelization will be worth it, especially since the data footprint is very small compared to. \n\nFurthermore, BALs come with 3 other nice effects: \n1) Can be used for syncing. It's like healing but without the merkle proofs.\n2) Without executing any transaction, you can already compute the post state. This is particularly useful for something like FOCIL that comes with post-execution validity checks (\"could a omitted tx still be appended?\"). Those check can then be done pre-execution. This makes FOCIL compatible with delayed exec (see here (https://hackmd.io/@Nerolation/rkht8vVZxx)¬†for more info on that)\n3) For block-level warming, BALs can be used to distribute the warming costs evenly/fairly over all accesses, pre-execution. Today, we'd have to execute the block to see which tx accesses what and all tx must be able to pay for warming themselves. With BALs, this can be figured out upfront and the charged during execution.",
        "created_at": "2025-05-20T05:28:21.953000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e re: **@nero_eth**\n\u003e yeah agree. If BALs turn out to only trade-off bandwidth for parallelization, then it's questionable if we really want it.\nI expect that the parallelization will be worth it, especially since the data footprint is very small compared to. \n\nFurthermore, BALs come with 3 other nice effects: \n1) Can be used for syncing. It's like healing but without the merkle proofs.\n2) Without executing any transaction, you can already compute the post state. This is particularly useful for something like FOCIL that comes with post-execution validity checks (\"could a omitted tx still be appended?\"). Those check can then be done pre-execution. This makes FOCIL compatible with delayed exec (see here¬†for more info on that)\n3) For block-level warming, BALs can be used to distribute the warming costs evenly/fairly over all accesses, pre-execution. Today, we'd have to execute the block to see which tx accesses what and all tx must be able to pay for warming themselves. With BALs, this can be figured out upfront and the charged during execution.\nseems like there's lots of synergy between FOCIL+warming+delayedexecution+BAL's ü§î",
        "created_at": "2025-05-20T07:41:46.102000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnotnotstorm_p\u003e another possible benefit is it might make it easier to run a partial state node as vitalik recently wrote about because it would give you better ability to select the portion of statediffs/txs that you care about",
        "created_at": "2025-05-20T07:43:12.681000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "What you wrote is true, but I feel it is a slippery slope we are on here. A lot of the properties you describe are just the general benefits of all stateless designs. BALs are good for some things, but since they do not contain a proof of the prestate, they are not safe to use as a block witness. So I'd much rather ship Verkle, which also has the same benefits you mentioned, but it comes with proofs of the values.",
        "created_at": "2025-05-20T09:45:45.090000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@gas_limit_testing_bot**\n\u003e \u003c.fjl\u003e What you wrote is true, but I feel it is a slippery slope we are on here. A lot of the properties you describe are just the general benefits of all stateless designs. BALs are good for some things, but since they do not contain a proof of the prestate, they are not safe to use as a block witness. So I'd much rather ship Verkle, which also has the same benefits you mentioned, but it comes with proofs of the values.\nWell would run on a full node, so have the values and can confirm the data so don't need the proofs\n\nWould allow for optimistic parallel running (including all IO, all tx, state root etc)\n\nVerkle proofs would add even more to bandwidth is a much larger long task; so far later deliverable and BLAs don't prevent us from doing Verkle but allow some of the benefits earlier",
        "created_at": "2025-05-20T10:22:03.339000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cfradamt\u003e re: **@notnotstorm_p**\n\u003e seems like there's lots of synergy between FOCIL+warming+delayedexecution+BAL's ü§î\nOne thing to note here, at least for the FOCIL + delayed execution part of the synergy (I haven't given much thought to warming) is that it actually doesn't depend on BALs (in the sense of specifying state accesses), but on state diffs, because all you need is to be able to statically compute the post-state. We have been saying BALs to mean \"the particular version of BALs which includes post-tx values\", but actually here we only care about the latter. Or even less, we only care about having a block level diff, not tx by tx",
        "created_at": "2025-05-20T10:25:56.963000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cfradamt\u003e Same for parallel execution. We can have parallel execution only with post-tx values (tx level diffs), without actually having a BAL, we just wouldn't also get parallel IO",
        "created_at": "2025-05-20T10:26:55.798000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cfradamt\u003e So in terms of bandwidth costs, it would be good to differentiate between what is incurred by including all state accesses versus just tx level or block level diffs. It might be that parallel IO is not worth the bandwidth cost of specifying all reads, but that parallel execution + better sync + ability to run a partially stateful node (eventually, with zkEVM) + easy compatibility of FOCIL and delayed execution is worth having the diffs/specifying writes",
        "created_at": "2025-05-20T10:29:48.308000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e BALs would also give us data to imperially inform us about statelessness, delayed stateroot needs, what we can do with slot times etc; how good parallization is, so then we can make better choices on future features",
        "created_at": "2025-05-20T10:34:43.283000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cCPerezz\u003e re: **@ben_a_adams**\n\u003e Well would run on a full node, so have the values and can confirm the data so don't need the proofs\n\nWould allow for optimistic parallel running (including all IO, all tx, state root etc)\n\nVerkle proofs would add even more to bandwidth is a much larger long task; so far later deliverable and BLAs don't prevent us from doing Verkle but allow some of the benefits earlier\nVerkle proofs would have considerably smaller sizes than ZKEVM ones. Or Binary trees.\n\nOfc, at the cost of non-PQ sec. And no proof of exec wrt. ZKEVM case.",
        "created_at": "2025-05-20T10:34:44.583000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cCPerezz\u003e re: **@ben_a_adams**\n\u003e BALs would also give us data to imperially inform us about statelessness, delayed stateroot needs, what we can do with slot times etc; how good parallization is, so then we can make better choices on future features\nBALS don't really give you much statelessness data don't they?\n\nI mean, you need proofs and re-execution when running a stateless node.\n\nBALs help on re-execution (maybe?) But certainly not on data authenticity and verifiability.\n\nStateless nodes (specially partial ones) will need to keep re-executing and will always need proofs.",
        "created_at": "2025-05-20T10:37:07.565000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Verkle might be great for statelessness; so you can run on phone or watch; but will need even higher bandwidth which might not be practical for smaller devices\n\nThen would we want some design where you would want to pull a per tx verkle changes so you could just follow your own tx in wallet, watch, phone etc rather than having a full block of verkle",
        "created_at": "2025-05-20T10:37:34.577000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e The behaviour changes we could do with BALs would provide insights that we could then feed into that decisioning, design, research etc",
        "created_at": "2025-05-20T10:38:41.235000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@CPerezz**\n\u003e BALS don't really give you much statelessness data don't they?\n\nI mean, you need proofs and re-execution when running a stateless node.\n\nBALs help on re-execution (maybe?) But certainly not on data authenticity and verifiability.\n\nStateless nodes (specially partial ones) will need to keep re-executing and will always need proofs.\nThey inform about the bandwidth increase as full statelessness will need even more data",
        "created_at": "2025-05-20T10:39:41.047000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e So if we can't get a benefit from the additional bandwidth use on BALs; then full statelessness will be questionable (becomes a value judgement on storage space rather than any other benefit)",
        "created_at": "2025-05-20T10:40:50.434000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e BALs would be a powerful checkpoint to give us data on path toward statelessnes; with much lower effort and faster delivery than full statelessness",
        "created_at": "2025-05-20T10:43:53.699000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e e.g. not much has to change for BALs; a huge amount has to change for Verkle",
        "created_at": "2025-05-20T10:44:33.161000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "I was referring to what \u003cnotnotstorm_p\u003e wrote about using BALs for sync, partial nodes, etc.",
        "created_at": "2025-05-20T10:45:55.242000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "The original idea with BALs is using them as a method of acceleration for block processing when you have the full state",
        "created_at": "2025-05-20T10:46:25.454000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "But it's very tempting to then go and use them for other stuff, which is kind of unsafe",
        "created_at": "2025-05-20T10:47:00.839000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "BALs are only safe if you have the state",
        "created_at": "2025-05-20T10:47:14.885000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e I can see sync; as can verify the trie at end of sync; would be very annoying if it was wrong though :)",
        "created_at": "2025-05-20T10:47:33.460000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e Since you have the state and the roots at end of sync",
        "created_at": "2025-05-20T10:48:10.154000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e So can confirm if it was correct",
        "created_at": "2025-05-20T10:48:28.953000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cfradamt\u003e re: **@gas_limit_testing_bot**\n\u003e \u003c.fjl\u003e But it's very tempting to then go and use them for other stuff, which is kind of unsafe\nYou're definitely right for partially stateful nodes, that's only useful with zkEVM or some other way of ensuring validity. I don't think it's unsafe to use state diffs for sync though. Sync relies on state roots being correct. If you have a valid chain, state diffs are also correct",
        "created_at": "2025-05-20T10:49:04.692000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cfradamt\u003e There was a discussion on this point in a BAL channel a while ago, starting here: https://t.me/c/2288707855/210",
        "created_at": "2025-05-20T10:51:11.930000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e re: **@nero_eth**\n\u003e yeah agree. If BALs turn out to only trade-off bandwidth for parallelization, then it's questionable if we really want it.\nI expect that the parallelization will be worth it, especially since the data footprint is very small compared to. \n\nFurthermore, BALs come with 3 other nice effects: \n1) Can be used for syncing. It's like healing but without the merkle proofs.\n2) Without executing any transaction, you can already compute the post state. This is particularly useful for something like FOCIL that comes with post-execution validity checks (\"could a omitted tx still be appended?\"). Those check can then be done pre-execution. This makes FOCIL compatible with delayed exec (see here¬†for more info on that)\n3) For block-level warming, BALs can be used to distribute the warming costs evenly/fairly over all accesses, pre-execution. Today, we'd have to execute the block to see which tx accesses what and all tx must be able to pay for warming themselves. With BALs, this can be figured out upfront and the charged during execution.\nIt is not like optimistic parallelization isn't already doable, it is complicated to implement but works and gives decent improvements",
        "created_at": "2025-05-20T10:57:25.161000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@lrozmej**\n\u003e It is not like optimistic parallelization isn't already doable, it is complicated to implement but works and gives decent improvements\nStill good for builder ;)",
        "created_at": "2025-05-20T10:58:56.249000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cfradamt\u003e But it's optimistic. Would anyone feel comfortable significantly raising the gas limit because of that?",
        "created_at": "2025-05-20T10:58:57.715000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnero_eth\u003e re: **@lrozmej**\n\u003e It is not like optimistic parallelization isn't already doable, it is complicated to implement but works and gives decent improvements\nagreed, what I heard from @rjl493456442 was that optimistic parallelization is great and performs well on average blocks. It's more the worst-case blocks (every tx dependent on the prev one) where optimistic parallelization struggles.",
        "created_at": "2025-05-20T10:59:13.036000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@fradamt**\n\u003e But it's optimistic. Would anyone feel comfortable significantly raising the gas limit because of that?\nFull parallelization would raise the performance for weaker validators (i.e. worst case improvements)",
        "created_at": "2025-05-20T11:00:49.858000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e So then easier to justify faster blocks and/or higher gaslimit",
        "created_at": "2025-05-20T11:02:16.746000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e re: **@ben_a_adams**\n\u003e Still good for builder ;)\nyes builders will need to rely on optimistic parallelization. And as we want to keep local building a thing, kind of most if not all clients would need to implement it?",
        "created_at": "2025-05-20T11:02:30.248000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@lrozmej**\n\u003e yes builders will need to rely on optimistic parallelization. And as we want to keep local building a thing, kind of most if not all clients would need to implement it?\nIf they want to build good blocks; could still build blocks without, and also how good blocks they could build depends on orderflow",
        "created_at": "2025-05-20T11:03:30.244000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "I understand that, theoretically, you can verify the full state at the end",
        "created_at": "2025-05-20T11:23:02.520000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "that's not how we sync though",
        "created_at": "2025-05-20T11:23:10.926000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "we want to have the guarantee that, at the end of sync, the state we have is fully consistent with the state root, without necessarily verifying it another time",
        "created_at": "2025-05-20T11:23:45.718000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "this is not really possible with BALs",
        "created_at": "2025-05-20T11:23:55.474000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "so I would say it's better to go for full statelessness",
        "created_at": "2025-05-20T11:24:25.124000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "it isn't that much more complex",
        "created_at": "2025-05-20T11:24:31.046000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@gas_limit_testing_bot**\n\u003e \u003c.fjl\u003e this is not really possible with BALs\nyou have all the writes with BALs and that block hash matches header?",
        "created_at": "2025-05-20T11:30:36.889000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e So BAL data is correct for the block in chain (or would be invalid block and not in chain)",
        "created_at": "2025-05-20T11:31:15.851000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@gas_limit_testing_bot**\n\u003e \u003c.fjl\u003e so I would say it's better to go for full statelessness\nfull statlessness is huge with merkle; and a very big change to move to verkle? (as well as verkle not being ready as crypto tree is changing to binary tree?)",
        "created_at": "2025-05-20T11:34:14.837000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cnero_eth\u003e re: **@gas_limit_testing_bot**\n\u003e \u003c.fjl\u003e so I would say it's better to go for full statelessness\nThe required proofs are large. Even with BALs, we're already hesitant due to the extra data (around 20 to 50 KiB) that would need to be included in each block.",
        "created_at": "2025-05-20T11:36:20.811000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e If BAL prevented full statelessness; would be a different conversation; but is more of an earlier deliverable?",
        "created_at": "2025-05-20T11:38:30.667000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cdankrad\u003e re: **@gas_limit_testing_bot**\n\u003e \u003c.fjl\u003e we want to have the guarantee that, at the end of sync, the state we have is fully consistent with the state root, without necessarily verifying it another time\nyou get that by syncing via state diffs too! you can keep updating all the Merkle paths and you do know that the state you synced is correct with reference to the final state root!",
        "created_at": "2025-05-20T13:11:48.511000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e re: **@gas_limit_testing_bot**\n\u003e \u003c.fjl\u003e it isn't that much more complex\nfull statelessness is more complex than BAL and it is not even close",
        "created_at": "2025-05-20T13:17:19.356000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e If there block is finalized or safe then probably enough validators already verified BAL to trust it",
        "created_at": "2025-05-20T13:20:50.746000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003clrozmej\u003e Those near head are less trustworthy",
        "created_at": "2025-05-20T13:21:24.817000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e re: **@lrozmej**\n\u003e If there block is finalized or safe then probably enough validators already verified BAL to trust it\nBAL is part of block; if you accept block BAL is good",
        "created_at": "2025-05-20T13:22:03.384000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e re: **@lrozmej**\n\u003e Those near head are less trustworthy\nBut this is also difficult. You need to still verify CL proposer signature so if this is not a validator client, it is fine",
        "created_at": "2025-05-20T13:22:10.833000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cdankrad\u003e re: **@lrozmej**\n\u003e If there block is finalized or safe then probably enough validators already verified BAL to trust it\nit does not matter if you trust the BAL if you verify that the Merkle root after the update is correct.",
        "created_at": "2025-05-20T13:22:27.061000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e even if you go to a wrong fork for 12 secs nobody is gonna have issues on an RPC client that does not stake",
        "created_at": "2025-05-20T13:22:48.136000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cben_a_adams\u003e have the header chain you are trying to follow from CL though?",
        "created_at": "2025-05-20T13:29:16.727000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cshekhirin\u003e re: **@shekhirin**\n\u003e @KamilChNethermind gm! Can we bump Reth from the latest image and re-run modexp spamoor run that we had before? We significantly improved its perf so would like to see if it'd be reflected in the perfnet.\ngm, bump on this üòÑ cc @cbermudez97",
        "created_at": "2025-05-20T16:59:51.856000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cKamilChNethermind\u003e Ahh sure, pinging",
        "created_at": "2025-05-20T17:36:45.697000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e I was wondering if you could actually implement partial statelessness today. clients tracing already support diffMode, which just returns the plain diffs in json. what if you just query them then take them and propagate them to the network by having the proposer/syncCommittee signing it? with enough validators supporting this, you could have partial statelessness without an hardfork today",
        "created_at": "2025-05-20T20:49:07.843000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "could even reactivate the \"wit\" protocol to distribute them: https://github.com/ethereum/devp2p/blob/master/caps/wit.md",
        "created_at": "2025-05-20T21:54:46.038000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "üôÇ",
        "created_at": "2025-05-20T21:54:58.066000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "(not entirely serious suggestion)",
        "created_at": "2025-05-20T21:55:07.171000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e re: **@gas_limit_testing_bot**\n\u003e \u003c.fjl\u003e (not entirely serious suggestion)\nI was thinking to actually propagate them on the CL's libp2p. gossip network has been mostly de-activated on EL",
        "created_at": "2025-05-20T21:56:20.533000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e also you need to have these witnesses signed *somehow*",
        "created_at": "2025-05-20T21:56:33.901000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "yeah I understand",
        "created_at": "2025-05-20T22:04:02.565000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "I just thought it's funny because we made this protocol 5 years ago",
        "created_at": "2025-05-20T22:04:25.787000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "it was created by the \"Trinity\" python client team because the client wanted to implement \"beam sync\", which was a kind of stateless sync protocol.",
        "created_at": "2025-05-20T22:05:48.384000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e but how can this protocol work if you cannot authenticate the witnesses?",
        "created_at": "2025-05-20T22:06:45.564000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e anyway this is offtopic but just my curiosity",
        "created_at": "2025-05-20T22:06:53.188000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "so at the time, this would've been used by the client to run the block optimistically, until it had fully backfilled the history",
        "created_at": "2025-05-20T22:08:34.190000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "you can read more here: https://snakecharmers.ethereum.org/beam-sync-in-80-seconds-using-meta-witnesses/",
        "created_at": "2025-05-20T22:08:43.559000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003ccskiraly\u003e re: **@FunnyGiulio**\n\u003e I was thinking to actually propagate them on the CL's libp2p. gossip network has been mostly de-activated on EL\nWhat you mean by \"gossip network has been mostly de-activated on EL\"? Transactions are \"gossiped\", just not with GossipSub.",
        "created_at": "2025-05-20T22:09:57.992000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e ah right - forgot about that",
        "created_at": "2025-05-20T22:10:13.880000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e but anyway you cannot do it through the EL, because you need some auth. i think if you want to do it you need to use either the sync committees or the proposer signature *unless you want to propagate 300MB** proofs",
        "created_at": "2025-05-20T22:10:50.026000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "yeah the requirement to sign means the CL has to participate",
        "created_at": "2025-05-20T22:11:28.799000+00:00",
        "attachments": null
    },
    {
        "author": ".fjl",
        "category": "Execution Layer",
        "parent": "",
        "content": "it's OK though",
        "created_at": "2025-05-20T22:11:32.048000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e this is just an idea that might work today in implementing \"partial statelessness\" that is also not very complex (there is some degree of complexity on the CL though). i am not sure if it is good/useful enough to be seriously considered tho as an immediate solution to statelessness",
        "created_at": "2025-05-20T22:12:34.882000+00:00",
        "attachments": null
    },
    {
        "author": "bridge-bot",
        "category": "Execution Layer",
        "parent": "",
        "content": "\u003cFunnyGiulio\u003e mh, actually, idt it is complex on the CL either. you do not even need aggregation actually, just a forwarding",
        "created_at": "2025-05-20T22:15:46.052000+00:00",
        "attachments": null
    }
]