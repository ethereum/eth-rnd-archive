[
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Here's my thoughts on loading validator keys into a validator client (from filesystem). It's not quite how lighthouse does it, writing this doc lead me to make some changes. Looking to encourage collab, not necessarily define standards.\n\nThere's three docs (all accessible via the linked doc):\n\n- Overview (linked)\n- Simple structure: only concerned with voting keys.\n- Extended structure: extension to simple that's also concerned with withdrawal keys and eth1 deposits.\n\nhttps://notes.ethereum.org/r6UL8XeuSfaewZwS8wzGig?view",
        "created_at": "2020-06-16T01:39:46.692000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!361447803194441738\u003e you beat me to a doc.  I'll see if I can put extended comments in yours.",
        "created_at": "2020-06-16T06:24:53.480000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "hackmd isn't desparately comment-friendly: any comment on a list point goes to the entire list; sorry.  I'll put numbers against the comments in future to try to avoid confusion.",
        "created_at": "2020-06-16T06:42:56.084000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "In general, I think we're pretty close in terms of a usable system.  It feels like the biggest differences stem from you seeming to have much more faith in users' ability to manage their system than I do.",
        "created_at": "2020-06-16T06:44:28.998000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e It feels like the biggest differences stem from you seeming to have much more faith in users' ability to manage their system than I do.\nI'm not sure about that.. Which part are you referring to specifically?",
        "created_at": "2020-06-16T06:47:19.134000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It's also worth noting that I'm not actually defining a concrete key management system here, I'm just trying to establish some basics that can allow for multiple different systems.",
        "created_at": "2020-06-16T06:48:45.408000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Lighthouse is going to have to apply it's own opinions to the keys it generates and I imagine other clients will too. For example, we're going to be doing key generation through a GUI front-end and that's going to need to have a rather particular layout in order for it to be user friendly.",
        "created_at": "2020-06-16T06:50:07.223000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Talk of moving keys around, for example, suggest a user with the ability to do so.",
        "created_at": "2020-06-16T07:12:24.140000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Is this channel for discussion on how validators will manage their keys on a validating server without putting all of their funds at risk?",
        "created_at": "2020-06-16T07:14:51.478000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Tying voting keystores down with their filename, too, feels like a case of overloading metadata.  If a user wants to stop validating with a given key it will need to rename the file.  That seems more risky than having a separate list.",
        "created_at": "2020-06-16T07:15:39.353000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!301186049323958275\u003e I don't thik that was it's purpose, but if we don't have a slashing-protection channel this is closer than anything else (and it's a good topic!)",
        "created_at": "2020-06-16T07:16:24.313000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e \n\u003e Tying voting keystores down with their filename, too, feels like a case of overloading metadata.  If a user wants to stop validating with a given key it will need to rename the file.  That seems more risky than having a separate list.\n\u003e \u003c@!144468805697929216\u003e They don't necessarily have to rename/remove the file. We'll have a start/stop API and you can always add an `--exclude` flag on top of this system.",
        "created_at": "2020-06-16T07:18:02.831000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It just doesn't mandate an `--include` flag",
        "created_at": "2020-06-16T07:18:14.997000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Surely `--include` is safe rthan `--exclude`, when we're talking about validating",
        "created_at": "2020-06-16T07:18:57.920000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Depends, forgetting to `--include` means you get penalized.",
        "created_at": "2020-06-16T07:19:25.226000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "There's already some protection against duplicate signing via lockfiles",
        "created_at": "2020-06-16T07:19:35.348000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Anyway, with this system you can have `--include` too",
        "created_at": "2020-06-16T07:20:31.648000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "And forgetting `--exclude` means you may get slashed.  I know which I'd prefer.\n\nAlthough I agree that the lockfiles provide some protection they aren't foolproof.  And if we're going for safety first (and why not?) `--include` is the safer of the two options.",
        "created_at": "2020-06-16T07:20:33.069000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I don't see any reason why you can't have an `--include`",
        "created_at": "2020-06-16T07:21:15.818000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Sure, but it isn't in the doc (nor is `--exclude`, as far as I can see).  I think we're back to trying to work out which bits should form a standard, and which bits are implementation-specific.",
        "created_at": "2020-06-16T07:22:42.058000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Correct, `--include` and `--exclude` aren't in the docs.",
        "created_at": "2020-06-16T07:24:00.645000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The standard and implementation do, of course, inform each other which is where it's all a bit mixed up.",
        "created_at": "2020-06-16T07:24:34.718000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I was trying to convey at the start of the doc and when I shared it that I'm not trying to define a complete standard here",
        "created_at": "2020-06-16T07:26:16.537000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "If you want to try and define a rigid system for all validators to ahere to, then go ahead. Now you have a bunch of input from me.",
        "created_at": "2020-06-16T07:29:05.036000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Personally, I'm not convinced that going to the effort of defining a rigid standard complete with CLI flags and all is likely enough to get traction that it's worth the time. But I could indeed be wrong.",
        "created_at": "2020-06-16T07:30:05.044000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "No, I agree that we don't need everything to be the same.",
        "created_at": "2020-06-16T07:30:31.901000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It's more of a case of considering the bits at the bottom that, if they are the same, make all our lives easier.",
        "created_at": "2020-06-16T07:30:59.525000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Indeed, glad we agree on something lol",
        "created_at": "2020-06-16T07:32:00.302000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I think we agree on most things, to be fair!",
        "created_at": "2020-06-16T07:32:30.297000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "So I would guess you're saying that you think `--include` and `--exclude` are \"bottom bits\"?",
        "created_at": "2020-06-16T07:33:15.896000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Which is fair, I'm thinking about this now",
        "created_at": "2020-06-16T07:33:29.432000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It's more that having implicit inclusion/exclusion based on filenames (as well as filters) feels more dangerous",
        "created_at": "2020-06-16T07:34:47.892000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "(On a separate level, I wonder about tying keys to purposes.  It's hard to know at the point where each key _does_ have a single purpose, but feels proscriptive overall.  But let's not go there now, we already have enough to think about ðŸ˜†)",
        "created_at": "2020-06-16T07:36:35.559000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e It's more that having implicit inclusion/exclusion based on filenames (as well as filters) feels more dangerous\n\u003c@!144468805697929216\u003e What's the way around this? Just have a `validators.config` file that has a list of validator keypairs in it?",
        "created_at": "2020-06-16T07:37:37.374000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "*validator keypair paths",
        "created_at": "2020-06-16T07:39:26.290000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yeah; it could be implementation-dependent but some sort of \"use these keys\" directive seems like a good idea, and leads to more abstraction options.",
        "created_at": "2020-06-16T07:40:27.878000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "hmm.. that is pretty appealing",
        "created_at": "2020-06-16T07:40:59.720000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "So the \"fetching keys\" process becomes more of an \"open everything, see if it matches something in the list, if so use it\".",
        "created_at": "2020-06-16T07:41:21.371000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "(that was an awesomely generic process, I note)",
        "created_at": "2020-06-16T07:41:56.978000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I'm coming around to `validators.config`.. let me have a think about it",
        "created_at": "2020-06-16T07:43:54.909000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It does have a downside from a wide-scale distribution sense that it requires moving files *and* modifying a file.",
        "created_at": "2020-06-16T07:45:05.555000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "but that can be helped with tooling",
        "created_at": "2020-06-16T07:45:26.821000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "(Probably also out of scope for this discussion, but may be worth considering a \"where\" as well as a \"what\".  For example, my servers are currently running with \"remote\" as the \"where\" and use the \"what\" piece to know which (public) keys to fetch from the remote server.)",
        "created_at": "2020-06-16T07:50:37.674000+00:00",
        "attachments": []
    },
    {
        "author": "zahary.",
        "category": "Consensus Layer",
        "parent": "",
        "content": "FWIW, our keystore management is currently quite close to \u003c@!361447803194441738\u003e's proposal. One key operation that needs additional metadata in my opinion is deriving a new keystore (and respectively creating a new deposit) from your existing master key (mnemonic).  Surely, this is what the walletstore standard is about, but I feel it's pretty important part of the user experience and a more integrated standard is beneficial",
        "created_at": "2020-06-16T08:19:40.838000+00:00",
        "attachments": []
    },
    {
        "author": "zahary.",
        "category": "Consensus Layer",
        "parent": "",
        "content": "But I also think that the wallet metadata around keystores can be quite thin and perhaps this is what motivates Paul's proposal - the `nextaccount` property is the only crucial piece you need in order to derive new keys.\n\nI'm also not sure that managing all these entities as files is something that will prove to be popular in the long term. Even in the initial implementation, I've wanted to have a bit more transactional semantics for most command-line operations and storing everything in our Sqlite database seemed quite attractive. When you run multiple validator clients on multiple machines, you would quite likely want to have some kind of coordination service that ensures your configuration is not wrong (again, suggesting an approach based on a database)",
        "created_at": "2020-06-16T08:47:20.539000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "walletstore is adding metadata, primarily the seed and secondarily a name.  Paul mentioned (and I agree with him) that a minimal system should provide details about how to access keys rather than defining a general-purpose key management system.  I'm all for people following EIP-2386 and use the data in it to create keys, but we're going to need to create individual focused EIPs to do this rather than try to create a single overarching standard.",
        "created_at": "2020-06-16T08:48:15.911000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Storage of keys is really interesting.  Ultimately we have lots of different ways of doing so (local, remote, database, hardware, software) and they all kind-of overlap.  This goes back to my \"where\" comment a little way back: being able to say to a validator client \"I'm storing my keys in a directory/in a database/on a remote server/in hardware\" and giving some indication of how to access the data is really important, but each of those \"where\"s is probably a separate EIP rather than a single standard (as each \"where\" has its own pros and cons, and there is no obvious single best approach)",
        "created_at": "2020-06-16T08:51:23.171000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yeah, I'm coming around to the config file. I might write it out and see how it pans out.",
        "created_at": "2020-06-16T08:53:43.876000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Maybe if all we agree on is that you can import/export keys as EIP-2335 then we've got somewhere ðŸ˜…",
        "created_at": "2020-06-16T08:54:19.022000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "EIP-2335 is, ultimately, the only thing that *matters*.  All the rest is useful, makes life easier and the like but clients can scrape by with doing their own naming, finding, filtering _etc._  Decoding it when we find it though, that does need to be standard for us to stand a chance.",
        "created_at": "2020-06-16T09:01:09.506000+00:00",
        "attachments": []
    },
    {
        "author": "zahary.",
        "category": "Consensus Layer",
        "parent": "",
        "content": "So, \u003c@!361447803194441738\u003e, how is Lighthouse roughly going to handle restoring a number of keystores on a new machine and creating a new deposit from an existing mnemonic?",
        "created_at": "2020-06-16T09:03:11.894000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e So, \u003c@!361447803194441738\u003e, how is Lighthouse roughly going to handle restoring a number of keystores on a new machine and creating a new deposit from an existing mnemonic?\n\u003c@!553610810652622860\u003e If we have a mnemonic we can generate an EIP-2386 wallet, from which we can generate EIP-2335 keystores. Once we're at that point it's pretty much the same as when generating new keys (except we have to give lots of warnings that you might be re-creating a validator that already exists).",
        "created_at": "2020-06-16T23:51:54.198000+00:00",
        "attachments": []
    }
]