[
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Our security review claims scrypt to be \"a much stronger choice than PBKDF2\", for what it's worth.",
        "created_at": "2020-06-19T00:29:46.929000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "(Also, apologies for the scattered thoughts last night; I'm a morning person and I'm generally running on empty by the time it comes to midnight)",
        "created_at": "2020-06-19T00:30:22.584000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus Layer",
        "parent": "",
        "content": "you seemed perfectly coherent to me",
        "created_at": "2020-06-19T00:36:45.652000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I also wouldn't mind replacing scrypt with argon, as \u003c@!144468805697929216\u003e mentioned. Seems that PBKDF2 is the \"crowd favourite\" that's not necessarily technically superior whilst scrypt is the opposite. Having two hashers gives *a choice*, which is nice I guess. Perhaps having more would start to feel messy. Two's company, three's a crowd? Also fairly ambivalent here. And #notacrytpographer.\n\nIt seems like there's a decent argon2 Rust library, but I don't see security reviews and can't vouch for it. The current favourite Rust crypto implementations (`RustCrypto`) wants to merge it into their org, so that's a plus.",
        "created_at": "2020-06-19T00:45:09.989000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Giving multiple crypto options means that anyone who wants to process a thing now needs to *correctly* implement multiple crypto functions.  The more crypto one has to implement and use correctly, the more opportunity for one of them having a bug.",
        "created_at": "2020-06-19T02:03:55.918000+00:00",
        "attachments": []
    },
    {
        "author": "sky.cactus",
        "category": "Consensus Layer",
        "parent": "",
        "content": "This isn't to say \"never do it\", just that the advantage has to be worth it.",
        "created_at": "2020-06-19T02:04:14.253000+00:00",
        "attachments": []
    },
    {
        "author": "carlbeek",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e Our security review claims scrypt to be \"a much stronger choice than PBKDF2\", for what it's worth.\n\u003c@!361447803194441738\u003e \n\nPBKDF2 is not memory hardened so ASICs make it very speedup-able. Because EIP2335 uses SHA256 as the internal hash for PBKDF2, there are lost of ASICS fit for purpose too.\n\nscrypt is memory hardened so ASICs (and GPUs) are much less useful. Thanks to Litecoin, there are scrypt ASICs, but their speed up is not several orders of magintude over GPU or even CPUs",
        "created_at": "2020-06-19T07:11:13.411000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e scrypt ASICs\nI used to own one of these!",
        "created_at": "2020-06-19T07:12:53.405000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Send me your keystores for Paul's Free Backup Service ðŸ˜›",
        "created_at": "2020-06-19T07:13:13.080000+00:00",
        "attachments": []
    },
    {
        "author": "carlbeek",
        "category": "Consensus Layer",
        "parent": "",
        "content": "We can team up. I'll place an auto-upload function in the Launchpad so users will seamlessly have their keys hosted on Paul's Free Backup Service (tm) ðŸ˜›",
        "created_at": "2020-06-19T07:14:36.951000+00:00",
        "attachments": []
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e We can team up. I'll place an auto-upload function in the Launchpad so users will seamlessly have their keys hosted on Paul's Free Backup Service (tm) ðŸ˜›\n\u003c@!550420431744794624\u003e Sounds like we have a standard in the works!",
        "created_at": "2020-06-19T07:16:12.951000+00:00",
        "attachments": []
    },
    {
        "author": "carlbeek",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Regarding Argon2, there seem to be reasonable implementations/bindings in Rust, Go, JS, and Python. Java looks to be the one language where I'd be a little concerned about the quality of the bindings. That said, I am not familiar enough with the Java ecosystem to make a good judgement.",
        "created_at": "2020-06-19T07:26:22.179000+00:00",
        "attachments": []
    },
    {
        "author": "carlbeek",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The one downside of dropping PBKDF2 support is scrypt \u0026 Argon2 probably won't run on hardware wallets for key exporting (if that ever becomes a supported feature) due to the memory requirements. That said, PBKDF2 would probably take forever too due to the number of rounds required to make it secure anyway",
        "created_at": "2020-06-19T07:31:05.198000+00:00",
        "attachments": []
    },
    {
        "author": "carlbeek",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I made some fairly major breaking changes to EIP 2333. Most notably, HKDF_mod_r is BLS v2 KeyGen compliant. Additionally, a few areas were clarified and the tests were updated. The full diff can be seen here: https://github.com/ethereum/EIPs/compare/50c86e1..bf62883",
        "created_at": "2020-06-19T15:07:47.634000+00:00",
        "attachments": []
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!550420431744794624\u003e or anyone. Have we already talked about eip-2334 and the potential desire for withdrawal keys and signing keys to remain entirely separate? 2334 requires that signing keys be a child of the withdrawal key which would mean that users most engage with their withdrawal key any time they want to derive a new signing key.\n\n```\nValidator keys\nEach Eth2 validator has two keys, one for withdrawals and transfers (called the withdrawal key), and the other for performing their duties as a validator (henceforth referred to as the signing key).\n\nThe path for withdrawal keys is m/12381/3600/i/0 where i indicates the ith set of validator keys.\n\nThe path for the signing key is m/12381/3600/i/0/0 where again, i indicates the ith set of validator keys. Another way of phrasing this is that the signing key is the 0th child of the associated withdrawal key for that validator.\n```",
        "created_at": "2020-06-19T19:30:54.933000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus Layer",
        "parent": "",
        "content": "we discussed it some on the key mgmt call yesterday",
        "created_at": "2020-06-19T20:38:12.080000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus Layer",
        "parent": "",
        "content": "just so i follow, the concern is that you'll need to instantiate your withdrawal key to get any key in the sub-tree and we would rather do this as little as possible to minimize risk of leakage?",
        "created_at": "2020-06-19T20:38:53.680000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus Layer",
        "parent": "",
        "content": "a counter question: why would you want a \"subkey\" of a given withdrawal key (beyond one signing key)",
        "created_at": "2020-06-19T20:39:14.930000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus Layer",
        "parent": "",
        "content": "given that users of this scheme will have secured the root secret, it doesn't seem to add a lot of overhead to manage N withdrawal keys (producing N signing keys as needed) rather than mapping 1 withdrawal : N signing keys",
        "created_at": "2020-06-19T20:40:34.390000+00:00",
        "attachments": []
    },
    {
        "author": "ralexstokes",
        "category": "Consensus Layer",
        "parent": "",
        "content": "if i'm right about the concern then it seems like we just want to separate which subtrees we are using in the root tree as much as possible which should be straightforward to do given the constraints on `m/12381/3600`",
        "created_at": "2020-06-19T20:49:03.004000+00:00",
        "attachments": []
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e given that users of this scheme will have secured the root secret, it doesn't seem to add a lot of overhead to manage N withdrawal keys (producing N signing keys as needed) rather than mapping 1 withdrawal : N signing keys\n\u003c@!539495253418180618\u003e My point was that the assumption that the withdrawal key and signing key come from the same root is not necessarily a valid one.  But I believe we ended up with the idea of making this a suggested practice if the user wanted it, which would allow programmatic linking of withdrawal and signing key if the user so desired but not make it mandatory",
        "created_at": "2020-06-19T21:21:33.616000+00:00",
        "attachments": []
    }
]