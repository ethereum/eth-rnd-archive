[
    {
        "author": "carlbeek",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e mean that users most engage with their withdrawal key any time they want to derive a new signing key.\nThis is not the case. Validators generate a new withdrawal key for every validator so they don't have to engage with their old withdrawal keys when making a new deposit.\n\n\u003e It might be worth agreeing if we're going to use this update in Altona.\nThis seems very wise. Given the timeframe, I'd prefer not to push these updates for use in Altona to ensure client teams focus on other deployment problems.\n\nI made some further changes to the EIPs last night:\n* EIP2334 Paths: clarifies that if it is not possible to derive the signing \u0026 withdrawal keys using the path specified, then that is ok.\n* EIP2335 Keystores: Support for unicode passwords \u0026 description field (both backwards compatible changes)",
        "created_at": "2020-06-25T09:55:11.311000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Hey guys, here is the validator accounts management proposal from Prysmatic Labs: https://hackmd.io/@Yl0VNGYRR6aeDrHHQNhuaA/Hyxr5YM08",
        "created_at": "2020-06-25T22:55:36.950000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Curious to hear your thoughts",
        "created_at": "2020-06-25T22:55:46.002000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Cool, having a look",
        "created_at": "2020-06-25T22:58:49.604000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e having the passwords adjacent to them makes encryption useless\nUseless is too strong IMO, directory permissions can be used to allow access to read keystores without access to passwords.\n\u003e decryption passwords can be provided at runtime.\nThis won't be much fun if your server goes down and `systemd` (or w/e) tries to restart it.",
        "created_at": "2020-06-25T23:00:15.313000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Ah I see, thats an interesting perspective. Is it necessary though to have passwords on disk?",
        "created_at": "2020-06-25T23:01:01.041000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "So the other place you can get them there is via an env variable. Assuming you don't have some fancy service injecting env variables (i.e, in a cloud) you got those variables from:\n- Using `export MY_SECRET=1234`: generally discouraged because it inevitably ends up with passwords in bash history.\n- Using `source secrets.env`: the passwords are in a file again.",
        "created_at": "2020-06-25T23:02:42.636000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "env vars seem to be the most recommended method from the feedback we've received",
        "created_at": "2020-06-25T23:03:11.208000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "then why cant we go with a .env file instead?",
        "created_at": "2020-06-25T23:03:23.238000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e then why cant we go with a .env file instead?\n\u003c@!311971895828283393\u003e Secrets are in a file again..",
        "created_at": "2020-06-25T23:03:34.780000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Also a difficult thing with env vars is when you have lots of validators; you probably want to have the env vars something like `PASSWORD_\u003cPUBKEY\u003e` and this is a little odd for env vars in my experience.",
        "created_at": "2020-06-25T23:04:23.929000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I think the threat here is that the files are located adjactent to each other whereas something like secrets.env could be on a different disk, perhaps temporarily.",
        "created_at": "2020-06-25T23:04:29.234000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "You can put the secrets directory wherever you want",
        "created_at": "2020-06-25T23:04:46.176000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "i.e. if you make a disk backup, you're in trouble",
        "created_at": "2020-06-25T23:04:49.666000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "right, the general question we have is mostly about why the proposed file structure requires those .pass files in that exact hierarchy",
        "created_at": "2020-06-25T23:05:00.377000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yeah the point of keeping the keystores and passwords directories separate is to allow for backups.",
        "created_at": "2020-06-25T23:05:25.326000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "They're required in *some* heirarchy. At least if you (the account manager tool) create those password files you can create them with strict file permissions.",
        "created_at": "2020-06-25T23:06:04.936000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "If you rely on users to source thier own env vars I think you're less likely to see them use strict file permissions on them.",
        "created_at": "2020-06-25T23:06:28.732000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I see, so then to adapt the proposal we could have something like:\n```\ndatadir/\n  wallet/\n    account1/\n       keymanageropts.json (type of keymanager: remote, direct, derived, etc.)\n       deposit_data.rlp\n       keystore.json (may not exist depending on the keymanageropts)\n       ...\n    account2/\n       keymanageropts.json (type of keymanager: remote, direct, derived, etc.)\n       deposit_data.rlp\n       keystore.json (may not exist depending on the keymanageropts)\n       ...\n  passwords/\n    account1.pass\n    account2.pass\n  validator.db\n```",
        "created_at": "2020-06-25T23:07:33.031000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Yep, that would work. It's basically the proposal I had made but with some more structure around the `wallet` dir.",
        "created_at": "2020-06-25T23:08:21.730000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "That being said, are you expecting to import EIP-2386 wallets into the VC and decrypt them?",
        "created_at": "2020-06-25T23:08:35.232000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Or wil the VC only open EIP-2335 keystores?",
        "created_at": "2020-06-25T23:08:46.623000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I still think this is a signficant risk to have the password co-located to the encrypted data. Imagine if someone set their datadir to `~/Documents` and they have icloud backup or dropbox backup. File permissions wouldn't save them",
        "created_at": "2020-06-25T23:08:53.650000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Or if they take regular snapshots of their disk on AWS/GCP/Azure",
        "created_at": "2020-06-25T23:09:32.952000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e I still think this is a signficant risk to have the password co-located to the encrypted data. Imagine if someone set their datadir to `~/Documents` and they have icloud backup or dropbox backup. File permissions wouldn't save them\n\u003c@!399309815517544451\u003e You can put the `passwords/` dir whever you like. My proposal made no specifications about the location of it.",
        "created_at": "2020-06-25T23:09:34.445000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The main functionality we want to focus on is the ability to allow for multiple keymanager implementations. Either direct, derived, or remote. If account1 says it the keymanager is \"direct\", then it will utilize the keystore.json defined by the EIP. If \"remote\", it will utilize credentials in keymanageropts.json to connect to a server and perform responsibilities",
        "created_at": "2020-06-25T23:10:01.106000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I would *love* to not store the passwords locally, but I think it's just super valuable to have the VC boot without requiring shell input.",
        "created_at": "2020-06-25T23:10:31.217000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e Yep, that would work. It's basically the proposal I had made but with some more structure around the wallet dir.\nYep! Similar to your extended accounts proposal but making some decisions around having different keymanagers",
        "created_at": "2020-06-25T23:10:57.978000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e \u003c@!399309815517544451\u003e You can put the passwords/ dir whever you like. My proposal made no specifications about the location of it. \nThanks. I thought I had seem something like what Raul posted above as the suggested directory hierarchy",
        "created_at": "2020-06-25T23:12:13.937000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e The main functionality we want to focus on is the ability to allow for multiple keymanager implementations. Either direct, derived, or remote. If account1 says it the keymanager is \"direct\", then it will utilize the keystore.json defined by the EIP. If \"remote\", it will utilize credentials in keymanageropts.json to connect to a server and perform responsibilities\n\u003c@!311971895828283393\u003e Cool! I'm very hesitant about decrypting EIP-2386 wallets in the VC, but it seems you're not doing that üôÇ",
        "created_at": "2020-06-25T23:12:14.394000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It looks like you're going down the \"config file\" path, if I understand correctly. This is the path I think we might follow too, I just really need to do some more thinking about it in the context of our upcoming VC API which is going to support some key management operations. I'll get to that in the coming weeks so hopefully I can figure out our plans then.",
        "created_at": "2020-06-25T23:13:36.321000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "yep - that will depend on the exact implementation of the \"keymanager\". Awesome, I think we can find a good middle-ground in which we're compatible with Lighthouse accounts-management at a high level despite implementations being a tad different",
        "created_at": "2020-06-25T23:14:16.230000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "What do you think about the proposed terminology?",
        "created_at": "2020-06-25T23:14:30.435000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "```\n- A wallet is the tangible, on disk metadata about the various accounts that an user owns and there may be multiple accounts within a given wallet. The ./prysm.sh validator accounts command, for example, interacts with an on disk wallet at a specified directory path to perform its responsibilities\n- An account is a unique namespace that identifies a keystore and its associated metadata. We propose that one account should correspond to a single public key identifier (this is the same as popular eth1 wallets such as Metamask, in which one account is uniquely identified by its public key)\n- A keymanager defines a software interface which provides keystore access and management: can either be ‚Äúremote‚Äù, ‚Äúderived‚Äù, ‚Äúdirect‚Äù, ‚Äúunencrypted‚Äù (for interop / local dev). Proposed by Jim Mcdee\n- A keystore, based on EIP-2335 is ‚Äúa mechanism for storing private keys. It is a JSON file that encrypts a private key and is the standard for interchanging keys between devices as until a user provides their password, their key is safe‚Äù\n```",
        "created_at": "2020-06-25T23:15:05.267000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "In terms of shell commands, we're thinking of a simple `validator accounts new | list | import | export` structure",
        "created_at": "2020-06-25T23:15:32.758000+00:00",
        "attachments": null
    },
    {
        "author": "raulj",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Thanks so much for the feedback, we'll revise the doc",
        "created_at": "2020-06-25T23:17:33.877000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Definitions look good to me!",
        "created_at": "2020-06-25T23:46:43.437000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I think there's still potential for some confusion between \"wallet\" and EIP-2386 \"walletstore\" but I'm not sure what we can do about that..",
        "created_at": "2020-06-25T23:47:10.165000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I think the most unforunate thing is that a \"keystore\" contains \"keys\", whilst it's the opposite for walletstore/wallet.",
        "created_at": "2020-06-25T23:48:06.618000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Oh also, regarding passwords on disk; just because they *can* be stored on disk doesn't stop an implementation from requesting interactive password input if the files are not present.",
        "created_at": "2020-06-25T23:49:55.365000+00:00",
        "attachments": null
    },
    {
        "author": "zahary.",
        "category": "Consensus Layer",
        "parent": "",
        "content": "in our own CLI, I'm leaning towards the terms **wallets** (which asks the user to remember a mnemonic upon creation, is always protected with an interactive password and can be used for making deposits and withdrawals), and **deposits** (used a bit interchangeably with **validator**; backed by a keystore decrypted with a password on disk, has a `status` operation)\n\nIn other words, the user may execute commands along these lines:\n\n```\nnimbus wallets create --name=mywallet\nnimbus deposits create --count=10 --wallet=mywallet\nnimbus deposits status\n```",
        "created_at": "2020-06-25T23:56:06.126000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Our flow is more like this:\n```\n# Create a EIP-2386 wallet.\nlighthouse accounts wallet create ...\n\n# Create validator keypairs, deposit data, etc.\nlighthouse accounts validator create ...\n\n# Submit the validator deposit data to the smart contract.\nlighthouse accounts validator deposit ...\n```",
        "created_at": "2020-06-25T23:57:33.853000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It's documented here, if anyone is interested: https://lighthouse-book.sigmaprime.io/key-managment.html",
        "created_at": "2020-06-25T23:58:16.276000+00:00",
        "attachments": null
    },
    {
        "author": "paulhauner",
        "category": "Consensus Layer",
        "parent": "",
        "content": "My take is that a \"deposit\" is something that a validator does, among other things.",
        "created_at": "2020-06-25T23:59:58.461000+00:00",
        "attachments": null
    }
]