[
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!499114472594604044\u003e for sure! feel free to send me a DM",
        "created_at": "2020-09-01T00:12:55.765000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!602753420033785856\u003e \u003c@!499114472594604044\u003e would be interesting to make sure a remote signer setup can get that data easily",
        "created_at": "2020-09-01T05:44:23.168000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!636950487089938462\u003e I'm not super familiar with the requirements for a remote signer, but I would have thought it would be a once-off dump when you switch from using a local validator to using a remote signer?",
        "created_at": "2020-09-01T05:48:14.016000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!602753420033785856\u003e it can happen in different scenarios:\n1) switching to different machine\n2) restore\n3) moving between providers\n\nWhatever the reason you will need to import the slashing data. \nbtw we only need a few thousands of epoch right? not the whole data",
        "created_at": "2020-09-01T05:50:11.380000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@!636950487089938462\u003e I think the minimal format (which is very succinct) will get a lot of use initially, I've been thinking about combining the minimal + complete formats into a hybrid with the best of both, but trying to ship a MVP first",
        "created_at": "2020-09-01T05:52:56.589000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Lighthouse will initially have a CLI command for import/export, but eventually we should maybe standardise an HTTP API",
        "created_at": "2020-09-01T05:53:22.707000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e Lighthouse will initially have a CLI command for import/export, but eventually we should maybe standardise an HTTP API\n\u003c@!602753420033785856\u003e definitely.",
        "created_at": "2020-09-01T05:53:37.547000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e \u003c@!636950487089938462\u003e I think the minimal format (which is very succinct) will get a lot of use initially, I've been thinking about combining the minimal + complete formats into a hybrid with the best of both, but trying to ship a MVP first\n\u003c@!602753420033785856\u003e So for the actual slashing protection a wallet really needs:\n- for attestations just the signed root and slot number\n- for proposals just the slot number",
        "created_at": "2020-09-01T05:54:33.338000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "mmm wait, that's wrong",
        "created_at": "2020-09-01T05:55:08.403000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "yeah, my mistake, you need the target and source points as well",
        "created_at": "2020-09-01T05:55:46.329000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I think for a remote wallet you can import that data as a file or via api calls to your fav node.. should be enough",
        "created_at": "2020-09-01T05:56:24.135000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "cool",
        "created_at": "2020-09-01T05:59:10.420000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "I would be wary of an API endpoint to export slashing protection information.  If a validator client is live then the data could be out-of-date immediately after it is obtained.  The only safe way to pull the data would be whilst it is not validating, so probably a separate offline command.",
        "created_at": "2020-09-01T06:05:13.569000+00:00",
        "attachments": null
    },
    {
        "author": "hatter_hats_finance",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003c@144468805697929216\u003e that's a good point",
        "created_at": "2020-09-01T06:14:23.354000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "that's an implementation level detail",
        "created_at": "2020-09-01T06:36:34.354000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "a remote wallet can simply not sign unless it fetched the necessary data",
        "created_at": "2020-09-01T06:36:49.360000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "API is crucial unless we expect every user to run shell commands when they restore their wallet or move it",
        "created_at": "2020-09-01T06:37:24.630000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "It's not an implementation detail.  Simple example:\n\n  - Validator client 1 fetches data from validator client 2, obtains proposal data up to slot x-1\n  - Validator client 2 signs proposal for slot x\n  - Validator client 1 signs proposal for slot x",
        "created_at": "2020-09-01T06:45:32.077000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "you can't control a user running multiple validators for the same key, exporting it to a file won't help in that scenario either.",
        "created_at": "2020-09-01T06:48:53.930000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "The more likely scenario is restoring a validator somewhere, in that case validator 1 should be killed before restoring validator 2",
        "created_at": "2020-09-01T06:49:39.117000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "(kill the signing operation/ wallet)",
        "created_at": "2020-09-01T06:50:03.386000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "That's the point of what I'm saying!  If you have an online API then you can always be in the situation where the data you fetch from the API is out of date by the time you shut the validator client down.",
        "created_at": "2020-09-01T07:00:53.720000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "and that's true for any kind of export..",
        "created_at": "2020-09-01T07:02:06.572000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "the issue is not the export method but rather running multiple validators for the same key",
        "created_at": "2020-09-01T07:02:28.822000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "which can get you slashed regardless of exporting slashing data",
        "created_at": "2020-09-01T07:02:50.325000+00:00",
        "attachments": null
    },
    {
        "author": "hatter_hats_finance",
        "category": "Consensus Layer",
        "parent": "",
        "content": "maybe we can mark the db as exported and not let the validator sign things when its protection db is marked as exported",
        "created_at": "2020-09-01T07:04:44.024000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Could be a DOS vector, if not careful",
        "created_at": "2020-09-01T07:05:43.492000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e It very tricky trying to protect against running 2 validators in parallel..",
        "created_at": "2020-09-01T07:06:34.005000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "But i think that is true regardless of the export discussion.",
        "created_at": "2020-09-01T07:07:03.019000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "What about the following idea (not optimal and not sure it even helps): A validator asks for the head slot E and will not sign an attestation which it's source is \u003cE and target is not E+1 (for that initial attestation)",
        "created_at": "2020-09-01T07:09:08.658000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "NM it won't work under a fork assumption..",
        "created_at": "2020-09-01T07:12:25.623000+00:00",
        "attachments": null
    },
    {
        "author": "hatter_hats_finance",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e maybe we can mark the db as exported and not let the validator sign things when its protection db is marked as exported\n\u003c@!499114472594604044\u003e \nwe can use it in the cli method \u003c@!144468805697929216\u003e suggested",
        "created_at": "2020-09-01T07:14:35.022000+00:00",
        "attachments": null
    },
    {
        "author": "hatter_hats_finance",
        "category": "Consensus Layer",
        "parent": "",
        "content": "btw \ni think \n```\n\"last_signed_block_slot\": \"89765\",\n\"last_signed_attestation_source_epoch\": \"2990\",\n\"last_signed_attestation_target_epoch\": \"3007\",\n``` \nshould be replaced with \n```\n\"highest_signed_block_slot\": \"89765\",\n\"highest_signed_attestation_source_epoch\": \"2990\",\n\"highest_signed_attestation_target_epoch\": \"3007\",\n```\nwhen clocks go backwards last can be different then highest",
        "created_at": "2020-09-01T07:16:19.958000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e btw \n\u003e i think \n\u003e ```\n\u003e \"last_signed_block_slot\": \"89765\",\n\u003e \"last_signed_attestation_source_epoch\": \"2990\",\n\u003e \"last_signed_attestation_target_epoch\": \"3007\",\n\u003e ``` \n\u003e should be replaced with \n\u003e ```\n\u003e \"highest_signed_block_slot\": \"89765\",\n\u003e \"highest_signed_attestation_source_epoch\": \"2990\",\n\u003e \"highest_signed_attestation_target_epoch\": \"3007\",\n\u003e ```\n\u003e when clocks go backwards last can be different then highest\n\u003c@!499114472594604044\u003e if you got highest signed block than you can use what i wrote above.\nThis all assumes access to the validator, what if i don't have it? for example lost the SSH keys? We should hopefully keep the ability to restore a validator with only the seed",
        "created_at": "2020-09-01T07:19:04.473000+00:00",
        "attachments": null
    },
    {
        "author": "hatter_hats_finance",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e \u003c@!499114472594604044\u003e if you got highest signed block than you can use what i wrote above.\n\u003e This all assumes access to the validator, what if i don't have it? for example lost the SSH keys? We should hopefully keep the ability to restore a validator with only the seed\n\u003c@!636950487089938462\u003e \nif you loose access to your validator you can wait couple of hours with finality look on the explorer for your highst signed block and attestation and relaunch with manual input of minimal protection",
        "created_at": "2020-09-01T07:23:00.958000+00:00",
        "attachments": null
    },
    {
        "author": "hatter_hats_finance",
        "category": "Consensus Layer",
        "parent": "",
        "content": "\u003e What about the following idea (not optimal and not sure it even helps): A validator asks for the head slot E and will not sign an attestation which it's source is \u003cE and target is not E+1 (for that initial attestation)\n\u003c@!636950487089938462\u003e \ni am going to implement minimal protection in prysm in that way. using the highest... parameters",
        "created_at": "2020-09-01T07:24:29.383000+00:00",
        "attachments": null
    },
    {
        "author": "alon.ssv.network",
        "category": "Consensus Layer",
        "parent": "",
        "content": "do explorers keep forked chain attestations? how good of an assumption is it?",
        "created_at": "2020-09-01T07:38:22.275000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Regarding `highest_signed_block_slot` vs `last_signed_block_slot`, the spec (correctly) defines it to be:\n\n\u003e  the greatest slot of a block signed by pubkey\n\nI agree we could change the name for clarity, I just used the name that Teku used",
        "created_at": "2020-09-01T08:32:03.677000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "Consensus Layer",
        "parent": "",
        "content": "PSA: I've just published v3 of the interchange format spec, now with (basic) test cases! Might be useful for you \u003c@!499114472594604044\u003e",
        "created_at": "2020-09-01T08:35:00.701000+00:00",
        "attachments": null
    },
    {
        "author": "hatter_hats_finance",
        "category": "Consensus Layer",
        "parent": "",
        "content": "thanks",
        "created_at": "2020-09-01T08:35:38.143000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "Consensus Layer",
        "parent": "",
        "content": "Happy with either name really - both are correct for Teku, the last signed block must be the highest because we'd never sign one less than or equal to that.",
        "created_at": "2020-09-01T08:59:51.196000+00:00",
        "attachments": null
    },
    {
        "author": "hatter_hats_finance",
        "category": "Consensus Layer",
        "parent": "",
        "content": "i think it will be clearer with highest",
        "created_at": "2020-09-01T11:52:01.266000+00:00",
        "attachments": null
    }
]