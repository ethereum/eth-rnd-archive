[
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "Is there any spec'd way of signing non-consensus messages with validator keys? It seems like currently the domain is always reliant on beacon state, which I don't think is ideal if you only want to sign a message that can be authenticated",
        "created_at": "2022-04-27T07:50:13.126000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "general",
        "parent": "",
        "content": "The domain is mixed into the message before signing (to avoid replays) - nothing prevents signing any (32 byte) message without the domain, there's just no use case for it in the consensus spec",
        "created_at": "2022-04-27T07:59:07.630000+00:00",
        "attachments": null
    },
    {
        "author": "arnetheduck",
        "category": "general",
        "parent": "",
        "content": "Maybe a silly question, but in danksharding, who actually stores the blocks and responds to sampling requests? \"Full nodes\" validate samples, validators might store parts thereof, but... How many nodes are involved in maintaining the 75% availability and how do they coordinate?",
        "created_at": "2022-04-27T08:03:36.896000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "Right, but since the consensus-spec is the canonical source of info related to validator keys, it seems like the correct place to carve out a domain for non-consensus messages? Iâ€™m running into a need for them in the builder API where a validator needs to authenticate their chosen fee recipient",
        "created_at": "2022-04-27T09:01:26.106000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Domain isn't always reliant on beacon state. Validator deposits are an example of this.\n\nNote that you should always have a fork version, to avoid cross-chain replay issues, but it can be the genesis fork version rather than the current fork version.",
        "created_at": "2022-04-27T10:08:42.245000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I don't think this is a silly question. It gets asked from time to time and I haven't seen any reasonable answer yet. It seems we're moving into a system in which we will be able to request proof that you have (or more precisely had) something, but not be able to enforce that you share it. It seems we will be relying on altruism to maintain data in the network. Not that this is bad per se, perhaps it's unavoidable, but it's itchy nonetheless",
        "created_at": "2022-04-27T10:22:59.793000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "This is not a departure from the model of the network today. No one must serve blocks but they do within reason\n\ndata withholding attacks are sidestepped because everyone downloads everything",
        "created_at": "2022-04-27T19:47:34.497000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "In a world in which everyone doesn't (can't) download everything, you have to ensure data withholding attacks do not occur. Thus sampling",
        "created_at": "2022-04-27T19:48:09.834000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "As for serving said data, avoiding witholding attacks ensures those than want it can get it. And some spec'd altruism for serving and time-frames gets us to about where we are today",
        "created_at": "2022-04-27T19:48:58.237000+00:00",
        "attachments": null
    }
]