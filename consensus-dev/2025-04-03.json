[
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Bringing the discussion here cc \u003c@554799849288105986\u003e \u003c@539495253418180618\u003e I started implementing 7917 in Prysm, it may be a simple change BUT, and this is a big BUT",
        "created_at": "2025-04-03T17:40:08.948000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "peer DAS as speced today does not have any beacon state changes, using the electra state vs introducing a whole new state and all the boilerplate for it is an actual change",
        "created_at": "2025-04-03T17:44:38.453000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "If we only scope peerDAS, this does not need to change, if we add this feature, the single addition of this field to the state makes us pull the whole boilerplate of new protobuf definitions for the new state etc",
        "created_at": "2025-04-03T17:45:28.037000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "it may sound trivial and small (and it may be not much coding) but it is definitely not something to ignore and say that it's just a couple of hours nor 100 LOC",
        "created_at": "2025-04-03T17:45:57.572000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "cc \u003c@911437720994324570\u003e",
        "created_at": "2025-04-03T17:46:27.855000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "so just to be very clear, in a fork that otherwise wouldn't change the beaconstate structure, this EIP will make it so that it now changes, with all the downstream effects that this has",
        "created_at": "2025-04-03T17:47:41.667000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I am discussing a way forward in Prysm and it seems that it is a non-trivial path to implementing this in parallel to peer DAS and switching from not-including it to including it and back since this would involve merging a branch with state changes with another one without. This is not \"simple\" by any definition of simple. It may be not complicated, but definitely not a simple change",
        "created_at": "2025-04-03T17:53:34.861000+00:00",
        "attachments": null
    },
    {
        "author": "linoscope",
        "category": "general",
        "parent": "",
        "content": "Is this mainly about managing branches within git, or are there more downstream impacts of adding beacon state changes to a fork?",
        "created_at": "2025-04-03T17:59:07.129000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "There are lots of downstream effects like how we cache hashing tries,   mark leaves dirty etc. There's a lot of boilerplate that is mostly cooked by now cause we have gone through this a few times already but it's a lot of work that does not need to be done in a pure peer DAS fork",
        "created_at": "2025-04-03T18:11:01.508000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I'm surprised lighthouse could do this with 100 loc",
        "created_at": "2025-04-03T18:12:27.066000+00:00",
        "attachments": null
    },
    {
        "author": "pawandhananjay",
        "category": "general",
        "parent": "",
        "content": "there's a lot of code generation happening with macros. In the lighthouse code, its adding another variant to a struct. basically\n```rust\nstruct BeaconState {\n...\n    #[superstruct(only(Fulu))]\n    pub proposer_lookahead: List\u003cu64, E::ProposerLookaheadSize\u003e,\n}\n```",
        "created_at": "2025-04-03T18:27:22.300000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Yeah we would get all the protobufs generated automatically. But the trie handling, all the case switches, getters setters, etc aren't automated at all. And a few of our most subtle bugs (which honestly I think this feature will not cause any) came from the trie cache and dirty leaves rehashing",
        "created_at": "2025-04-03T18:31:12.933000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "one thing we should ensure is that for every EIP we formally include in a hard fork, we have done this type of technical vetting\n\neven a few lines of spec code can have massive impact in clients (see EIP-7549 in Pectra)\n\nthis type of investigation from potuz is a good signal to help assess how to schedule EIP-7917\n\nthere is a (n implicit) question from today's call around which stage of the EIP process (CFI vs SFI) is the appropriate gate for this kind of check, which i will also bring up on next week's ACDE",
        "created_at": "2025-04-03T20:30:24.804000+00:00",
        "attachments": null
    }
]