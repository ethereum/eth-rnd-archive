[
    {
        "author": "nc1234",
        "category": "general",
        "parent": "",
        "content": "This is what Lodestar is doing. We have a simple struct `RewardCache` that is attached to the beacon state cache. Throughout the `processBlock`, we update the values in `RewardCache`. Good thing about this is that it can be reused in the block rewards api endpoint. https://github.com/ChainSafe/lodestar/pull/6136",
        "created_at": "2024-02-01T07:24:26.077000+00:00",
        "attachments": null
    },
    {
        "author": "tbenr",
        "category": "general",
        "parent": "",
        "content": "cool thanks. We have similar caches attached to the state only for epochTransition purpose. Attaching a blockProcessing cache too is actually what I was experimenting yesterday.",
        "created_at": "2024-02-01T08:12:47.567000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "general",
        "parent": "",
        "content": "In Lighthouse we use the same state that the rest of block production uses, so we don't have any issues related to state loads/state advances. Our reward calculating function does re-run parts of the block transition for attestations, but I think this is pretty quick (will benchmark and confirm). We don't mutate the state while calculating rewards, so this calculation doesn't interfere with any other parts of block production",
        "created_at": "2024-02-01T22:16:12.003000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "general",
        "parent": "",
        "content": "Lighthouse doesn't quite use the _actual_ reward when packing, although we use something proportional to it. But we also cut corners when it comes to slashable attestations while packing, so we have a separate accurate rewards calculator that bypasses the pool (and the heuristics)",
        "created_at": "2024-02-01T22:17:07.970000+00:00",
        "attachments": null
    }
]