[
    {
        "author": "massaccept",
        "category": "general",
        "parent": "",
        "content": "Hello there, I'm not a node runner, but I knew about the required upgrade before most of the ETH runners out there... this, unfortunately, shows a LACK of ATTENTION thus I submitted a proposal for **Consensus of Attention** please consider it I believe this will provide additional measures to assert that GOOD actors will (at least know about) future upgrades before sensitive information and SW updates are released to the wild... \n\nPlease review its a very simple concept that would ASSERT your hard work is not overlooked due to a LACK of ATTENTION.\n\nThanks üòâ\n\nhttps://ethereum-magicians.org/t/consensus-of-attention-due-to-the-recent-geth-fork-vulnerability/6965",
        "created_at": "2021-08-30T03:34:40.552000+00:00",
        "attachments": null
    },
    {
        "author": "massaccept",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425615769280315392\u003e \u003c@!296630428754771968\u003e \u003c@!364458974906548225\u003e if I posted this in the wrong section please excuse me. Have a wonderful night.",
        "created_at": "2021-08-30T03:46:29.528000+00:00",
        "attachments": null
    },
    {
        "author": "treyzania",
        "category": "general",
        "parent": "",
        "content": "what does this actually solve?  geth was out of spec and it was fixed to being it back into spec with all of the other clients, every major party (exchanges, service operators, etc.) was upgraded enough before it even became an issue",
        "created_at": "2021-08-30T04:38:44.259000+00:00",
        "attachments": null
    },
    {
        "author": "treyzania",
        "category": "general",
        "parent": "",
        "content": "if users want to run out-of-spec clients and not update them, that's on them, in-spec nodes will *never* accept any blocks they relay",
        "created_at": "2021-08-30T04:38:53.083000+00:00",
        "attachments": null
    },
    {
        "author": "treyzania",
        "category": "general",
        "parent": "",
        "content": "that coindesk article even says\n\u003e Ethereum is currently operating normally.",
        "created_at": "2021-08-30T04:42:25.419000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Getting back to the execution validation discussion.\n\nPenalising peer for gossiping a block with invalid execution payload would require payload verification as a part of the gossip flow, i.e. executing payload *before* propagating a block. Which we can't afford as a payload verification takes a plenty of time and we would likely end up a block hadn't been gossiped in 4s throughout a slot. Thus, only proposer's signature should be verified before block propagation which is aligned with the approach we have in the PoW network. \u003c@!340345049063882753\u003e Am I missing anything?\n\nBefore proof-of-custody for execution is introduced an incentive to verify a payload is the contribution to the health of the network that each individual validator is connected to and gets the profit from. cc \u003c@!755590043632140352\u003e \n\nThe new proof-of-custody game will include a new slashable offence. Which should literally be *not executing a payload of a block* rather than *gossiping or producing a bad block*. I agree with \u003c@!476250636548308992\u003e that adding the would result in a much bigger risk of mass slashing (due to bug in a software) than the slashing conditions that we already have and planning to have in the future (proof-of-custody games).\n\nThe question to me is whether it is possible to create a proof-of-custody algorithm that would maintain the possibility for a *valid* client to correctly verify the proof generated by a *buggy* client. My guess that the answer would be *yes* if an execution would be *stateless*. And it seems that we will have to find a way of mitigating a risk of mass slashing due to software bugs. One of the potential ways is to run multiple clients as it was mentioned by \u003c@!301186049323958275\u003e  which is resource costly for individual stakers. Curious what does \u003c@!555483069038198827\u003e think about it.",
        "created_at": "2021-08-30T08:24:44.449000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Do you all think you have a viable solution to PoS, or just that you hope to find one?",
        "created_at": "2021-08-30T08:31:03.776000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "There has been a *huge* amount of research into proof of custody in the past for storage platforms, and I think I have only seen one solution that was viable (FileCoin), and it is unclear if it can be retrofitted into Ethereum.",
        "created_at": "2021-08-30T08:31:36.969000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "AFAIK, Dankrad is working on it. Let's wait for him to chime in",
        "created_at": "2021-08-30T08:32:39.822000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "FileCoin at least showed (IMO) that it is *possible* to have an incentive aligned proof of custody system, so that is positive.  I do worry about banking too much on unfinished research though.",
        "created_at": "2021-08-30T08:33:31.538000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "In terms of detecting bad blocks yes you would gossip after the signature is verified but clients would also have to maintain a list of known bad blocks. So once the block is processed and found invalid it goes into the bad block list so it can be immediately rejected in future. Then any block you receive via gossip that has a parent root in your bad block list must be from a faulty peer and you would disconnect them immediately. \nSo you get away with gossiping the first block but it‚Äôs the second block that gets you disconnected.",
        "created_at": "2021-08-30T08:34:48.335000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "This is about PoC solution for data availability, right? We're looking for another one, which would have the same properties but able to verify whether the particular transaction or a set of transactions has been executed or not. The data availability one has already been designed and is here, in the specs https://github.com/ethereum/consensus-specs/tree/dev/specs/custody_game",
        "created_at": "2021-08-30T08:35:56.623000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "What happens if a block takes longer than 12 seconds to process?",
        "created_at": "2021-08-30T08:36:48.293000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Oh, I get what you mean! And we already have this in the spec üëç",
        "created_at": "2021-08-30T08:37:17.290000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "I believe we *know* of ways to construct execution blocks that are \u003e 12 seconds.  Could someone create such a block that was invalid at the end (state root doesn't match) and then broadcast it to the network to get people kicked?",
        "created_at": "2021-08-30T08:37:20+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Then we‚Äôre all in a lot of trouble. üôÇ but it would be reasonable and probably preferable if you didn‚Äôt gossip a block until you had imported its parent.",
        "created_at": "2021-08-30T08:37:33.977000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Do clients do the right thing and protect themselves from getting kicked right now?",
        "created_at": "2021-08-30T08:38:00.257000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Because this is something someone can do *today*.",
        "created_at": "2021-08-30T08:38:05.559000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Btw, we have an item for this in the Merge readiness checklist. It is Resource exhaustion post-merge in the R\u0026D section (https://github.com/ethereum/pm/blob/master/Merge/mainnet-readiness.md#rd)",
        "created_at": "2021-08-30T08:38:27.998000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "It isn't a big problem because worst case scenario is that you have some reorgs during the time maybe, but I would be very concerned if it resulted in mass peer discconnects.",
        "created_at": "2021-08-30T08:38:40.989000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I think currently all clients just downscore on receiving a bad block rather that directly disconnect because there isn‚Äôt the same risk of clients not validating blocks properly.",
        "created_at": "2021-08-30T08:39:29.601000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "So the attacker would need to submit `n` bad blocks in a row to mass disconnect?",
        "created_at": "2021-08-30T08:39:54.610000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "How hard would it be to have clients stop attesting if they ever haven't validated the parent block?",
        "created_at": "2021-08-30T08:40:36.734000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "e.g., refuse to attest to block `n` if block `n.parent`'s execution payload isn't locally validated yet.",
        "created_at": "2021-08-30T08:40:56.724000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "And would that cause *worse* problems, or would that result in a generally healthy service degredation?",
        "created_at": "2021-08-30T08:41:38.892000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "So the disconnect behaviour im explaining is more from the eth1 chain than the beacon node. But as they merge beacon node clients will need to move towards this behaviour (and the spec adopt it).",
        "created_at": "2021-08-30T08:41:41.825000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I‚Äôm not sure why attesting is relevant here. \nBut clients attest to the block that is their current chain head (ie the best block they have finished importing)",
        "created_at": "2021-08-30T08:42:22.765000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Ah, sorry.  I may have misunderstood the behavior.  Reread what you said above and you are correct that attestations have nothing to do with it.",
        "created_at": "2021-08-30T08:43:33.704000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Will clients gossip execution payloads for blocks where they haven't fully validated the parent block?",
        "created_at": "2021-08-30T08:44:07.123000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "Slow client A: Receives block 5, which is invalid.  It validates the header (ok) and sends it to B.\nFast client B: Receives block 5 and validates the header, then the body (quickly).\nA: Receives block 6 (parent is 5 from above) and hasn't finished validating block 5.  Does it send block 6 to B?",
        "created_at": "2021-08-30T08:45:30.472000+00:00",
        "attachments": null
    },
    {
        "author": "sky.cactus",
        "category": "general",
        "parent": "",
        "content": "If it does, B will kick A IIUC, even though A is not malicious, just slow.",
        "created_at": "2021-08-30T08:45:48.388000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I don‚Äôt think they should.  It would open up quite a few potential issues and there‚Äôs no point gossiping faster if we can‚Äôt keep up with importing the blocks anyway.",
        "created_at": "2021-08-30T08:45:54.598000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "So, we want to significantly descore a peer that has propagated a block when its parent contains an invalid payload. Such that his peer will be immediately disconnected. right?",
        "created_at": "2021-08-30T08:45:56.688000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Yea I‚Äôd say so. And I believe that‚Äôs essentially what happens on eth1 today though there are likely some slight variations between clients or other details I‚Äôve got slightly wrong.",
        "created_at": "2021-08-30T08:46:44.463000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "But it makes it really easy to identify peers that aren‚Äôt validating blocks if you require the parent to already be imported before gossiping and keep a record of bad blocks. Otherwise it becomes pretty much impossible to identify non validating peers.",
        "created_at": "2021-08-30T08:47:51.619000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Of course the downside is you only see this when there‚Äôs a chain split which is hopefully quite rare.",
        "created_at": "2021-08-30T08:48:11.162000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "yeah I think it was never suggested to penalize for gossip. But perhaps penalize for an attestation on a block that has invalid execution starting from the parent consensus block of the attested block. That is, if I am attesting for a consensus block `B`  that has payload `P`  and consensus parent `B'`, which introduced a payload `P'` that happens to be the parent of `P`. Now if `P`  is invalid, and I attest for this block, I believe I should be penalized. It is a simple on-chain extra verification so it's not the engineering that is preventing this.",
        "created_at": "2021-08-30T09:21:29.322000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Notice that the block `B`  in this setup will never be accepted anyway so to penalize this behavior is has to be done through the same mechanism as slashing",
        "created_at": "2021-08-30T09:22:57.804000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "You mean adding a penalty on top of a penalty for missing a head which I believe will be applied in this case?",
        "created_at": "2021-08-30T09:27:09.698000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "yes, I think this has to be a harsh penalty because otherwise it is beneficial for validators to never check execution... there's disagreement on this last sentence, but I am currently convinced is the case and I didn't find the arguments against this statement to be correct",
        "created_at": "2021-08-30T09:28:56.938000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Also notice that you miss the whole attestation, not only head, this attestation cannot be included",
        "created_at": "2021-08-30T09:30:32.464000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Yes, you're right",
        "created_at": "2021-08-30T09:31:51.711000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "*Not executing* rather than *attesting* implies no penalty/slashing in case of software bug but might be infeasible w/o statelessness (still an open question to me) as the proof generated by buggy software will likely be considered invalid by valid clients. So, there might be no difference between proof of custody and penalty from attesting an invalid block. But proof of custody prevents outsourcing payload verification which is the outcome we're pursuing and which penalising for attesting to invalid payload may not provide.",
        "created_at": "2021-08-30T09:35:36.234000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I don't think that preventing outsourcing of payload verification is the problem I want to solve, but depending on how this proof of custody works it may indeed be a solution to the problem that I am pointing as not verifying execution payload may become dangerous. So if the plan is to have something like this that solves my issue in this regard",
        "created_at": "2021-08-30T09:41:15.881000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Penalty for attesting to a block with invalid payload would only work in case if bad block appears in the system which is a rare case unless somebody altruistically make them. Proof of custody could work in the case of normal operation and hence is more efficient.",
        "created_at": "2021-08-30T09:44:34.568000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "That is what I meant above that the way to penalize this behavior is only via the slashing mechanism, where someone that has seen this attestation has to send proof of it to get included in a valid block",
        "created_at": "2021-08-30T09:46:30.740000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "You can't verify whether a validator *does* or *does not* execute a payload unless there is an invalid block in the system, right?",
        "created_at": "2021-08-30T09:48:40.248000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "it doesn't need to be included though: the situation is like Friday: the chain splits, validator `A`  gets a bad block and attests for it, that bad block will not be on the good chain, but a validator `B` in the good chain can see the attestation and includes proof of it in a block he's proposing. This way you do not need to have the bad block included, just a proof that it was bad",
        "created_at": "2021-08-30T09:51:32.710000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Right, but my point is that bad blocks appearance is pretty rare in the case of mainnet. It gives a *seldom* opportunity to proof that validator does not verify an execution payload.",
        "created_at": "2021-08-30T09:57:46.538000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Ah sure I agree with this, proof of custody is much better",
        "created_at": "2021-08-30T10:00:49.143000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I wasn't aware of plans for this",
        "created_at": "2021-08-30T10:01:06.184000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Being a work in progress it wasn't presented/discussed widely yet but we have a related item in the Merge readiness checklist",
        "created_at": "2021-08-30T10:02:37.715000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "\u003c@!425572898787426305\u003e was there a discussion previously that consensus at slot n would be for the payload of block n - 1? So this should give enough of time to verify the payload. It brings an extra one-slot delay for transactions, but it's probably not that big issue.",
        "created_at": "2021-08-30T15:31:33.729000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Here is the corresponding proposal by Dankrad, https://ethresear.ch/t/commit-to-pre-state-instead-of-post-state-on-the-executable-beacon-chain/8802",
        "created_at": "2021-08-30T15:34:55.108000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "Thanks, will need to check the links in the proposal, but this approach is currently not considered?",
        "created_at": "2021-08-30T15:45:45.895000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "yes, it is not considered for inclusion into initial Merge scope",
        "created_at": "2021-08-30T15:46:46.777000+00:00",
        "attachments": null
    }
]