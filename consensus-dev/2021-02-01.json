[
    {
        "author": "furriebunnie0730",
        "category": "general",
        "parent": "",
        "content": "hi guys, id like to set up my own eth2 network on aws to work on security issues - any primer available on how to do that",
        "created_at": "2021-02-01T08:09:20.634000+00:00",
        "attachments": null
    },
    {
        "author": "furriebunnie0730",
        "category": "general",
        "parent": "",
        "content": "?",
        "created_at": "2021-02-01T08:09:23.162000+00:00",
        "attachments": null
    },
    {
        "author": "thiago_crowdtainer",
        "category": "general",
        "parent": "",
        "content": "This channel is for eth 2 protocol development and discussions. Please kindly head to ethstaker discord community for node setup and related topics.",
        "created_at": "2021-02-01T12:07:24.691000+00:00",
        "attachments": null
    },
    {
        "author": "butta",
        "category": "general",
        "parent": "",
        "content": "You can spin up your own local testnet with nimbus \u003chttps://nimbus.team/#Build-and-run-the-Ethereum-2-0-local-beacon-chain-simulation\u003e ... \u003c-- but this link seems to be outdated ðŸ˜¦\nmaybe \u003c@!203220829473996800\u003e  can help",
        "created_at": "2021-02-01T12:21:29.244000+00:00",
        "attachments": null
    },
    {
        "author": "butta",
        "category": "general",
        "parent": "",
        "content": "And yeah join us @ https://discord.gg/NvCxbCu ðŸ™‚",
        "created_at": "2021-02-01T12:22:07.610000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Up-to-date link: https://nimbus.guide/developers.html#build-and-run-the-local-beacon-chain-simulation",
        "created_at": "2021-02-01T13:32:59.817000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Starting with creating a single client testnet, and joining the ethstaker discord, would be a good start if you're new to this",
        "created_at": "2021-02-01T13:33:46.919000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Then, for multi-client custom testnets you want to tune the eth2 chain configuration to lower the amount of validators (i.e. running 16000+ validators on a aws machines is probably out of budget), and tune genesis (different deposit contract, use goerli testnet for eth1, reduce genesis delay, etc.). This is automated in https://github.com/eth2-clients/multinet, although that doesn't run on multiple machines.",
        "created_at": "2021-02-01T13:37:31.836000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "And for something advanced, running many machines, multiple clients, and the time to do the devops, you can set up something as big as Pyrmont with tooling such as:\n- https://github.com/protolambda/eth2-val-tools\n- https://github.com/protolambda/eth2-bootnode\n- https://github.com/protolambda/ansible_eth2\n- https://github.com/consensys/eth2stats-server\n- And more...",
        "created_at": "2021-02-01T13:40:17.715000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "You can find the pyrmont chain configuration here, if you want to compare it to mainnet (see specs repo): https://github.com/protolambda/pyrmont",
        "created_at": "2021-02-01T13:41:35.238000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "But again, start simple. Try running a single client. Then a single-client testnet. Then a small multi-client testnet on your local machine. Understand the critical setup components (discv5, keystores, genesis). And only then start a big one (if you get this far I'd be more than happy to help you with the last steps)",
        "created_at": "2021-02-01T13:43:36.373000+00:00",
        "attachments": null
    },
    {
        "author": "donschoe",
        "category": "general",
        "parent": "",
        "content": "did anyone notice that sync speed of clients decreases with increasing slot number? what could be the reason for that?",
        "created_at": "2021-02-01T15:31:27.811000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "In principle processing blocks costs more if there's more validators, not sure if this is the main reason though",
        "created_at": "2021-02-01T15:33:45.020000+00:00",
        "attachments": null
    },
    {
        "author": "donschoe",
        "category": "general",
        "parent": "",
        "content": "that would be my first guess too... because on mainnet we see a steady increase of validators",
        "created_at": "2021-02-01T15:34:21.098000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "So the cost of processing attestations and rewards/penalties should grow linearly at least. But perhaps there are other bigger costs",
        "created_at": "2021-02-01T15:35:16.480000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "\u003c@!755590043632140352\u003e The fork choice issue (along with a deeper attack vector) and suggested fix for the epoch boundaries is here https://notes.ethereum.org/@vbuterin/HF1_proposal#Fork-choice-by-block-slot-pair\n\nnote that the fault shifts from attesters to proposer so epoch boundaries should still be optimized (and I know are actively being optimized in some clients right now)",
        "created_at": "2021-02-01T15:53:19.568000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Thanks I read that document after the call and was waiting for the implementation in the specs to see. The issue is that it's not clear from what it's written there what \"blank\" means. Currently there's a window of about 8 seconds where if a block arrives it screws all attesters and still is canonical since the next proposer bases on it. If blank is defined as the majority of attesters head, namely if the block doesn't come at 4 seconds then it's considered blank, then I think this solves that issue indeed. I still think that rewarding proposers by votes is complementary to this and I see some advantages to do it",
        "created_at": "2021-02-01T16:07:56.346000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "so the fork choice respects the block/slot graph rather than just the block graph, so if attesters vote on blank, that blank node in the graph has weight now and would compete with a late block or that late blocks ancestors and if the block were actually late (like we see on mainnet today, blank would win out and subsequent proposers would build in that chain",
        "created_at": "2021-02-01T18:25:36.071000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "I need to review your proposal. will comment after",
        "created_at": "2021-02-01T18:25:43.785000+00:00",
        "attachments": null
    },
    {
        "author": "jgm",
        "category": "general",
        "parent": "",
        "content": "Does this change the \"best\" activity of a validator on slot 0 of an epoch from attesting as soon as it has seen a block to waiting until it sees a significant proportion of votes to know which way the wind is blowing?  And wouldn't that ultimately mean that no-one would ever vote for a block in slot 0, as everyone will hold off on voting for a while and then go for the \"no bock seen\" option as they assume they would have seen votes for the block if others had seen it?",
        "created_at": "2021-02-01T18:50:10.395000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Ah perfect thanks, so all the current problematic blocks will become orphaned.",
        "created_at": "2021-02-01T20:17:08.722000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Why slot 0, it seems the same reasoning should be applied to all blocks, I wouldn't worry much about attesters holding off since it's a risky business processing all votes and hope that the subnets you weren't subscribed behaved the same way",
        "created_at": "2021-02-01T20:19:04.146000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "But what this does though is put a strain on the next block proposer cause needs to process all attestations fast on the previous block. I wonder how fast can clients run fork choice like this before proposing right after a block that came close to the 4 seconds mark",
        "created_at": "2021-02-01T20:20:32.573000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I think the key here is that attestations are published 4 seconds into the slot, so when you're attesting you really have to decide for yourself whether the block is going to be included or not as you won't have information from other nodes yet.  You might have some attestations for the block, but you won't have any aggregates and won't have any attestations for an empty slot.\n\nCurrently with the way fork choice works, any time you get a block that is the child of your current canonical head, you immediately make it your new canonical head without having to run fork choice (because there's no other fork to choose).  With this change there is a choice between the new block or an empty slot, but as mentioned above, prior to 4 seconds into the slot the only information you'll have is voting for the block. \n\nSo based on all that, if you get a block that's the child of your canonical head within the first 4 seconds of the slot (or really, before you've attested) then you should make it the new canonical head and attest to it. If it comes after the first 4 seconds, then you should stick with the empty slot you attested to. Then at 8 seconds into the slot you'll start getting aggregates which provide information about what everyone else saw and towards the end of the slot you can run full fork choice to reorg to either remove or add the block if required.",
        "created_at": "2021-02-01T20:40:26.026000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "The fix for the fork choice balance attack (https://notes.ethereum.org/@vbuterin/HF1_proposal#Fork-choice-balance-attack-fix) also scheduled for the HF is more challenging in terms of performance for block producers. I think it requires running fork choice at the very start of the slot and delaying block production until it completes.",
        "created_at": "2021-02-01T20:42:17.949000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Speaking of that one, I forgot to actually share the thoughts on how to implement that.  https://hackmd.io/nyKbwIluQlWBH6sli4tJlA?view is how I think it will pan out for Teku. It actually feels a little too simple so would be good to get feedback one whether I've interpreted the change correctly. (cc \u003c@!291925846556540928\u003e \u003c@!273808422753796097\u003e )",
        "created_at": "2021-02-01T20:46:10.419000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "But my point above was that even the other fix also forces you to delay block production since you need to wait for all aggregates and decide if the previous block was empty or not, even if you saw the block say at 3.9 seconds. You will be forced to wait until aggregates not only for inclusion but also to run fork choice",
        "created_at": "2021-02-01T20:52:40.395000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "and decide only then on which block you will base your next one",
        "created_at": "2021-02-01T20:53:14.584000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "So for example current techniques that are based in sync block, immediately cache state by advancing slot, will start missing that cache more often",
        "created_at": "2021-02-01T20:54:06.674000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "I think generally there should be plenty of time between aggregates and the start of the next slot to run fork choice. If you ran fork choice even 1 second prior to the end of slot you should have all the aggregates by then and still complete fork choice easily within that 1 second before you need to produce a block.\nIt's not entirely a new problem either - there could be multiple forks to choose from because of the blocks produced and you'd need to run full fork choice to switch between them. The later you run that fork choice the more information you have so the more likely you are to get it right.",
        "created_at": "2021-02-01T21:15:47.571000+00:00",
        "attachments": null
    }
]