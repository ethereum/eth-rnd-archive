[
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "Could you tell more about the plans on sharding - is it planned to build on the current Phase 1 spec in the `dev` branch (which we have almost implemented) or Kate commitments are decided already (seems \u003c@!273808422753796097\u003e is working on a serious rework https://github.com/ethereum/eth2.0-specs/tree/vbuterin-patch-6 )? Or is it still an open question and will be decided next year?",
        "created_at": "2020-12-15T10:37:38.082000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "The phase 1 in the dev branch is absolutely deprecated",
        "created_at": "2020-12-15T10:38:08.533000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "We're gonna push some new things to the dev branch soon",
        "created_at": "2020-12-15T10:38:17.956000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "(light client related stuff, accounting reforms, data availability sampling, sharding)",
        "created_at": "2020-12-15T10:38:33.743000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "Great, these new are ideas I saw in patches look really promising.\n \nWere there any discussions how clients are going organize the Phase 1 implementation in the existing Phase 0 clients? We found that it's a bit of hassle to deal with that in static languages. We are considering some crazy ideas such as using a separate runtime for each Phase with communication between them (maybe even via standard API). The main reason is that after the fork the Phase 0 should be put in stone anyway, which is tricky to achieve if the code is DRY-ed nicely.",
        "created_at": "2020-12-15T11:06:44.284000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "wait why would you do that?",
        "created_at": "2020-12-15T11:07:03.390000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "These should be treated just like hard forks in eth1",
        "created_at": "2020-12-15T11:07:10.993000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "the beacon chain *will* change in phase 1 and in the hard fork before that",
        "created_at": "2020-12-15T11:07:24.490000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "hm... my thinking was that the phase 0 historical chain (until the fork) stays as it is. Let's say beacon block structures keeps the same, otherwise if the block structures are changed backwards it's not the same chain any more (different hashes etc.)",
        "created_at": "2020-12-15T11:10:01.583000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "right, the pre-fork phase 0 chain will stay the same",
        "created_at": "2020-12-15T11:10:56.120000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "the structures will be changed (basically a few fields added to the beacon block body and the beacon state) but that would only apply to blocks after the fork slot",
        "created_at": "2020-12-15T11:11:25.016000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "sure, my comment was actually from the static languages perspective. If you are mostly doing Python you can just hack things here and there and have the same struct serving both phases. Not so easy in static languages.",
        "created_at": "2020-12-15T11:12:34.330000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "Yeah, for static langs there is more of a challenge",
        "created_at": "2020-12-15T11:12:58.073000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "you'd basically need to have a \"BeaconBlock\" and \"BeaconBlock2\" class and same for states, or something like that",
        "created_at": "2020-12-15T11:13:18.291000+00:00",
        "attachments": null
    },
    {
        "author": ".vbuterin",
        "category": "general",
        "parent": "",
        "content": "I would highly recommend talking to eth1 client devs about this btw, there's a lot of wisdom on this that I am sure they could share",
        "created_at": "2020-12-15T11:14:22.324000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "yes, we saw some nasty code on this in static languages ðŸ™‚ But anyway, I don't see much dissadvanteges of a bigger isolation between the phases code. The changes between phases will probably be massive anyway, which is always an extra hassle in order to keep old phases untouched if everything is in a common nicely DRY-ed codebase. But let's see.",
        "created_at": "2020-12-15T11:19:28.955000+00:00",
        "attachments": null
    }
]