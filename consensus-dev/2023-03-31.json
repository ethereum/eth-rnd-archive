[
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "\u003c@539495253418180618\u003e re: https://notes.ethereum.org/@ralexstokes/notes-on-cl-access\n\nOption 1) and 2) are burdensome for CL devs as every fork that changes beacon state structure CL devs will have additional duty to reflect the changes in a precompile. Also, a protocol will set in stone a way consensus objects are described with it difficult to be changed if some optimisations are found in the future. From this perspective option 3) is the best one.",
        "created_at": "2023-03-31T04:40:59.238000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "the are burdensome but the idea is to take on this burden so that apps can be trust-minimized, i.e. providing that benefit to all users of the protocol",
        "created_at": "2023-03-31T05:33:50.932000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "and i can't help but point out the harder it is to maintain, the slower devs will be to include the next marginal feature",
        "created_at": "2023-03-31T05:34:35.040000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "Re: EIP-4788, shouldn't we pass `(beacon_state_root, slot)` tuples and keep a map of a slot onto a root? Referencing beacon state data by a slot looks more natural than by EL's block number. There will be gaps due to missed slots but we don't have a lot of missed slots on mainnet thus it should be fine.",
        "created_at": "2023-03-31T05:35:19.549000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "yeah if anything i think having a smart contract maintained by a reputable entity is a good starting point and if a particular thing becomes obvious we can enshrine in a precompile",
        "created_at": "2023-03-31T05:35:42.284000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "\u003c@425572898787426305\u003e yeah im changing most of the \"leaves\" of the decision tree on 4788, expect an update soon",
        "created_at": "2023-03-31T05:36:14.743000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "current thinking is: include in each execution payload header `(start_slot, end_slot, beacon_block_root)`",
        "created_at": "2023-03-31T05:36:54.062000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "if we can lean on EL to compute slots from timestamp (see discussion in \u003c#688075293562503241\u003e ) then we can remove the slot data and just append the block root to the header",
        "created_at": "2023-03-31T05:37:20.219000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "If at any point in time we change a slot duration which is not unlikely, then EL will have to update too. Providing a range is less complicated, IMO",
        "created_at": "2023-03-31T05:45:11.320000+00:00",
        "attachments": null
    },
    {
        "author": "ralexstokes",
        "category": "general",
        "parent": "",
        "content": "agree, as long as we are ok with the extra 16 bytes in the header\n\ncould also keep the last slot updated as a key in the state and then only need to send over the end slot value",
        "created_at": "2023-03-31T06:40:55.730000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "This is one of the options, also we can reuse `nonce`, and if we use ring buffer of `2**n` length then we can use `n` highest bits of nonce to encode a number of empty slots and the rest for the end slot. E.g. `n=13` as it is currently used by `SLOTS_PER_HISTORICAL_ROOT`, then `2**51`. We can for instance reserve `16` highest bits as 48 bits for a slot number is more than enough",
        "created_at": "2023-03-31T07:28:17.434000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "A quick question on https://github.com/ethereum/consensus-specs/blob/6181035d5ddef4b668d0fcfee460da9888009dd9/specs/bellatrix/beacon-chain.md#is_execution_enabled . Can it be reduced to just `body.execution_payload != ExecutionPayload()` ?",
        "created_at": "2023-03-31T07:52:12.453000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "One may send a block with `ExecutionPayload()` after the transition, but in this case `is_execution_enabled()` must return true.",
        "created_at": "2023-03-31T08:05:31.683000+00:00",
        "attachments": null
    },
    {
        "author": "sauliusgrigaitis",
        "category": "general",
        "parent": "",
        "content": "but after the merge transition `ExecutionPayload()` is invalid with probability 1.",
        "created_at": "2023-03-31T08:10:52.389000+00:00",
        "attachments": null
    },
    {
        "author": "m.kalinin",
        "category": "general",
        "parent": "",
        "content": "it won't be invalidated if we reduce `is_execution_enabled()` to `body.execution_payload != ExecutionPayload()`",
        "created_at": "2023-03-31T08:24:35.421000+00:00",
        "attachments": null
    }
]