[
    {
        "author": "mratsim",
        "category": "general",
        "parent": "",
        "content": "\u003c@!203220829473996800\u003e did you come across this when looking into remerkleable? https://github.com/dusk-network/kelvin",
        "created_at": "2020-05-05T20:01:44.498000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Nope, thanks for that link, will look into it now. I've looked into other trees (mostly sparse ones, see SMT issue), but it's just all a little too niche for what we are doing with ssz.",
        "created_at": "2020-05-05T20:10:14.204000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Ok, the cardinality thing is cool, but we already have length mix-ins, and have no sparse trees currently, so it's not as useful to us. And then the sizes and representation of sparse trees has already been discussed, there's just no ideal solution until we have our first serious use case for it in the spec.",
        "created_at": "2020-05-05T20:18:39.989000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "And regarding storage: remerkleable already allows you to implement arbitrary backing node types to back the types with. I even put lazy-loading nodes in there, just so you can theoretically have some kind of storage, from which the deeper tree is retrieved once you need the backing contents.",
        "created_at": "2020-05-05T20:20:03.165000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "The real problem however, is that binary trees just don't fit well on the disk. To many pointers, too deep. You need to store/retrieve them in batches. Which is also possible in remerkleable (just lazy-load a few depths at a time), but still not ideal, as you lack a good storage representation. And for SSZ it's more complicated, as it's not a sparse tree, but more like something with optimized but changing in-place. I.e. things are addressed by position, not by content.",
        "created_at": "2020-05-05T20:22:51.077000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Cool toolkit nevertheless \u003c@!570268431522201601\u003e, but works better for pure content-addressed sparse merkle trees",
        "created_at": "2020-05-05T20:23:39.822000+00:00",
        "attachments": null
    },
    {
        "author": "bitmexresearch",
        "category": "general",
        "parent": "",
        "content": "Is this logic correct?",
        "created_at": "2020-05-05T22:33:18.667000+00:00",
        "attachments": [
            {
                "type": "",
                "origin_name": "unknown.png",
                "content": "bfe7a391e85c3f130f4dced358c38ca30bf4df7c7e9e31192c14c9d2160a4496"
            }
        ]
    }
]