[
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nif you decide to enforce a type bound in your DB, then that is a simple implementation detail, and could just be a bitfield attached to your index of leaf nodes, or some other minimal form. And then have the application put bottom nodes explicitly as bottom nodes. No magic there.",
        "created_at": "2019-07-25T00:03:17.744000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nDon't take this all personally btw, love discussion about things like this üòÇ",
        "created_at": "2019-07-25T00:05:00.668000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "If you're talking about compression -- that does not work. There's one bound for each merkle root, and you'd have no way to know whether other types treats any internal nodes as another merkle root.",
        "created_at": "2019-07-25T00:05:18.377000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "To be honest I really feel like the \"recursive index\" is just a fancy trick. In real life when you do something like that, you'd always have the type information in hand. And if you have the type information, you can always do the recursive access via multiple generalized index. The database access overhead is the same.",
        "created_at": "2019-07-25T00:08:24.131000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nok, what I imagine is a big raw list of hashes, and then some (optimized or not) pointer structure to dig through the tree. Difference between two ends in discusssion here really is: does the hash value stop the traversal, or does the pointer (or some other flag embedded somewhere) make a node a bottom node. (I would not add a bit to the node itself, as that makes sharing the node between different types not work. Adding it to the relation of its parent nodes works however).",
        "created_at": "2019-07-25T00:08:26.773000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nIf it is the hash itself that makes the difference, you do conceptually put that bit on it to say \"this is bottom, please stop traversal\". Whereas you could maintain the bound, and e.g. put it during insertion with the pointer data that binds the parent to a bottom node.",
        "created_at": "2019-07-25T00:10:40.089000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003e binds the parent to a bottom node\n\nNo you can't. You can simultaneously have `BeaconBlock` and `BeaconBlockHeader` stored in the database. They have the same pointer, but with different bound. So if you'd want reliability you'd either have type information, or you'd need to set the merkle root to a tuple `(H256, u64)`.",
        "created_at": "2019-07-25T00:12:23.577000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nre fancy index trick: totally agree. But it's so simple, that it's kinda extra useful. Combining indices is super simple (concat the non root parts), merging indices is simple (mask), etc. etc. Just a good standard to have regardless",
        "created_at": "2019-07-25T00:12:30.357000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nYou can. Storing `\u003cparent bytes32\u003e\u003cchild 0 bytes32\u003e\u003cchild 1 bytes32\u003e` seems silly. When you can just do `\u003cparent bytes32\u003e\u003ctable index of child 0\u003e\u003ctable index of child 1\u003e`, and those two child pointers can store whatever bounds relation you need, and are constructed during insertion from an application (which has the type data available). And then both childs will still be plain 32 bytes. Heck, you can even optimize by storing some table indices in a special range that is defined to be a bottom node, or other specifics.",
        "created_at": "2019-07-25T00:15:52.239000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nAh wait, I see what you mean",
        "created_at": "2019-07-25T00:16:45.529000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nSo if there is a root A, then some contents of A, and then those contents have bounds themselves, which needs to be defined. Yes, but the change of hash for bottom nodes also don't provide different bounds based on upper types.",
        "created_at": "2019-07-25T00:18:08.562000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "Eth2 call in ~12 hours\nagenda: https://github.com/ethereum/eth2.0-pm/issues/64\nyoutube stream: https://www.youtube.com/watch?v=ReSiB2940AE\nyoutube chatbox: https://www.youtube.com/live_chat?v=ReSiB2940AE\u0026is_popout=1",
        "created_at": "2019-07-25T01:52:17.784000+00:00",
        "attachments": null
    },
    {
        "author": "sproul",
        "category": "general",
        "parent": "",
        "content": "I think I found an issue with the calculation of the compact committees root, in that it happens after we've updated the start shard: https://github.com/ethereum/eth2.0-specs/issues/1315",
        "created_at": "2019-07-25T05:37:27.704000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "@everyone Test format/distribution survey results, and proposed solution: https://github.com/ethereum/eth2.0-specs/issues/1311#issuecomment-515015182",
        "created_at": "2019-07-25T11:59:07.655000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "general",
        "parent": "",
        "content": "Great work Proto üôå",
        "created_at": "2019-07-25T12:08:05.906000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cdjrtwo\u003e call in ~10 minutes\nagenda: https://github.com/ethereum/eth2.0-pm/issues/64\nyoutube stream: https://www.youtube.com/watch?v=ReSiB2940AE\nyoutube chatbox: https://www.youtube.com/live_chat?v=ReSiB2940AE\u0026is_popout=1\nzoom: https://zoom.us/j/933098943",
        "created_at": "2019-07-25T13:47:49.782000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "so short!",
        "created_at": "2019-07-25T14:43:36.142000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003cmratsim\u003e My notes: https://gist.github.com/mratsim/3c3c07da603bfedf417292d22b3eae33",
        "created_at": "2019-07-25T14:44:02.982000+00:00",
        "attachments": null
    },
    {
        "author": "mratsim",
        "category": "general",
        "parent": "",
        "content": "btw can we create a channel for the logistics of the interop meet in September?",
        "created_at": "2019-07-25T14:44:58.999000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "re merkle partials, basically we define a structure like this: https://github.com/sorpaas/bm/blob/e2dd41b62b960bdba96458b4c4ad86ca661df8c4/src/proving.rs#L172\n\n```\nenum CompactValue\u003cV\u003e {\n  Single(V),\n  Combined(Box\u003c(CompatValue\u003cV\u003e, CompactValue\u003cV\u003e)\u003e),\n}\n```\n\nWe can easily see that this is compact representation that can have the same tree hash root as the complete tree. In ssz, we'd just require 1 bit information per 32 bytes to encode whether it's `Single` or `Combined`.",
        "created_at": "2019-07-25T14:46:13.281000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nAnd then categorize every single leaf node in every type to be transparent or not. Like the benefits, but it's at a cost in freedom. Something that can already be solved if you have the type available.",
        "created_at": "2019-07-25T14:49:16.564000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "TBH I'm really worried about eth2's attitude on this -- I really don't see many merkle tree designed without distinguish intermediate and end, and I can easily see someone creating unsafe types defined on bm where it's vulnerable to preimage. All our current types are not vulnerable, of course.",
        "created_at": "2019-07-25T14:55:45.257000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "\u003c@242032644232183808\u003e does `bm` support loading partial proofs?",
        "created_at": "2019-07-25T14:58:04.715000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "Yes.",
        "created_at": "2019-07-25T14:58:18.554000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "this is awesome!",
        "created_at": "2019-07-25T15:01:51.083000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "How do you interact with an object that you load from a partial proof? Do you have an example I can look at?",
        "created_at": "2019-07-25T15:20:47.842000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "You call `from_compact` https://github.com/sorpaas/bm/blob/e2dd41b62b960bdba96458b4c4ad86ca661df8c4/src/proving.rs#L150\nAnd then feed that value directly into a database https://github.com/sorpaas/bm/blob/e2dd41b62b960bdba96458b4c4ad86ca661df8c4/src/memory.rs#L201\nAfter that just do normal merkle operations.",
        "created_at": "2019-07-25T15:25:27.473000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "Thank you! Do you plan to support \"paths\" or is that orthogonal to the goal of `bm`?",
        "created_at": "2019-07-25T15:26:34.322000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "If you mean generalized merkle index just use `Raw`.",
        "created_at": "2019-07-25T15:27:14.184000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "So if I have a function that takes a path (as defined here: https://github.com/ethereum/eth2.0-specs/blob/dev/specs/light_client/merkle_proofs.md#ssz-object-to-index) and outputs a general index and I can use the `Raw` implementation?",
        "created_at": "2019-07-25T15:36:46.943000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "Yeah it should. Though I think `bm` correctly lack some helper functions to work with it conveniently. If you just need the value, just take the end of the path and access that as an index using `Raw`. If you need the complete proof for the path -- it mostly corresponds to the compact proof in `bm`, but currently you'll need to write the helper function to convert it to the type.",
        "created_at": "2019-07-25T15:45:34.936000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "are those things you're planning to add, or is that out of scope?",
        "created_at": "2019-07-25T15:46:01.303000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "Yeah I'm definitely planning to support all those.",
        "created_at": "2019-07-25T15:46:27.362000+00:00",
        "attachments": null
    },
    {
        "author": "lightclient",
        "category": "general",
        "parent": "",
        "content": "awesome üòÅ",
        "created_at": "2019-07-25T15:51:50.874000+00:00",
        "attachments": null
    }
]