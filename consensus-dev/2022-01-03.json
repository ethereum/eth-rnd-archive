[
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "\u003c@!602753420033785856\u003e \u003c@!449019668296892420\u003e \u003c@!688748669268132001\u003e we've opened a new repo https://github.com/prysmaticlabs/hashtree which is a library that most probably we'll be using at prysm. It's a single header exposing custom assembly functions optimized for sha256 of Merkle trees. I've included support for a large variety of CPUs tested on Linux and Windows. I am tagging you for two reasons. 1) I would greatly appreciate if you could benchmark your own implementation of hashing of a large lists of uints64 (say the balance list) vs hashing with this library.  The biggest gain would come if you also change the hashing loop, instead of calling multiple times to hash 64bytes, to call a single time to hash an array of 64 bytes. This is described in \u003chttps://hackmd.io/80mJ75A5QeeRcrNmqcuU-g\u003e.  2) If you think there may be an interest in using this library in your client, I'd be happy to add bindings or help in any way I can. I am not tagging Adrian cause I am not sure if Java will benefit from calling an external library or not and I gathered last time that it was hard to benchmark this.",
        "created_at": "2022-01-03T18:56:09.101000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "The library is a single header without any dependency at all",
        "created_at": "2022-01-03T18:56:36.653000+00:00",
        "attachments": null
    },
    {
        "author": "ajsutton",
        "category": "general",
        "parent": "",
        "content": "Mostly just FYI: Java usually does benefit from native libraries for crypto operations but from the benchmarks I've done sha-256 seems to be a bit of an exception. There are a couple of likely reasons for that 1) I believe the default implementation actually uses intrinsics so while the standard library is written in Java at runtime it can actually be hot-swapped for optimised assembly that does the same thing 2) the java implementations of sha-256 appear to be very close in performance to native ones (and sha-256 is quite a small part of our overall CPU usage currently), and jumping from java to native code does have a slight cost.\n\nThat said, given your work isn't just a straight native implementation but is aiming to add the \"batching\" benefits I suspect it's something we would want to consider.\n\nAnd yes benchmarking java can be tricky because so much optimisation happens at runtime (including dead code elimination so it's very common for people to write benchmarks where the entire thing to be measured is eliminated).  The `jmh` library is an excellent tool for avoiding those kind of problems.",
        "created_at": "2022-01-03T20:31:52.201000+00:00",
        "attachments": null
    }
]