[
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Hello, I'm reviewing Capella and besides some minor typos I was confused by this line in the computation of the withdrawal tree root:\n```\nreturn hash(node + uint256(state.withdrawal_count).encode_bytes())\n```\nIs this using `encode_bytes` from remerkleable? I ask cause there may be an issue with big endian systems unless the encoding is set explicitly. The `phase0` core specs define a function `uint_to_bytes` that can then be padded, but I didn't find the `encode_bytes` as in remerkleable",
        "created_at": "2022-04-17T10:18:21.691000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "cc \u003c@203220829473996800\u003e",
        "created_at": "2022-04-17T10:18:56.088000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Itâ€™s supposed to encode the uint256 as ssz type, thus little endian. If you like you can submit a PR to make it more explicit with a comment or helper func like in phase0",
        "created_at": "2022-04-17T10:40:40.317000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Right, the only issue I see is where to find the function `encode_bytes`. If it's like remerkleable then it's fine cause phase0 defines ENDIANNESS as \"little\"",
        "created_at": "2022-04-17T10:44:18.498000+00:00",
        "attachments": null
    }
]