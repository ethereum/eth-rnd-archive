[
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "For everyone interested in SSZ changes: I proposed a small addition (backwards compatible) to the SSZ spec, for compatibility with other commitment types, to improve the sharding spec: https://github.com/ethereum/consensus-specs/pull/2585",
        "created_at": "2021-09-08T15:41:04.523000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I looked at the PR when it appeared and it gave me a bad feeling to have something in the spec that is *not specified*. Nothing concrete against it though, just that for library writers it may be a bit awkward to have to expose an object that takes a custom hasher to produce its htr. I thought about the option of just leaving KZG commitments just as containers and let implementers just override htr in their own, but this doesn't really look good either",
        "created_at": "2021-09-08T16:53:37.404000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "\u003c@!755590043632140352\u003e to intention is to create standard interfaces, for compatibility \u0026 extensibility, so we do not have to hardcode every special case. And where applicable to the spec, like this case in the sharding spec, this interface can be implemented",
        "created_at": "2021-09-08T16:56:52.782000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I understand, just that it looks cleaner at least in my mind if SSZ and Merkleization are separate standards. You have SSZ objects that serialize/deserialize in a given manner. And then there's a different standard that tells you how to hash a given SSZ object. This way KZG committment containers would be just containers for an SSZ library, and for a merkleization library, it would be a KZG SSZ object.",
        "created_at": "2021-09-08T16:59:32.678000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I had that feeling before this PR, like serialization and",
        "created_at": "2021-09-08T17:00:09.554000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "Merkleization were different standards, and this PR just solidified this feeling for me",
        "created_at": "2021-09-08T17:00:26.792000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "If we support them as separate standards, then we also enable any combination of the two (i.e. potential merkleization + verification override on every serializable type), and things get a lot more complex. It's sufficient to only have this for containers, so I like to keep it simple.",
        "created_at": "2021-09-08T17:05:55.700000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "That's a fair point",
        "created_at": "2021-09-08T17:07:32.796000+00:00",
        "attachments": null
    },
    {
        "author": "potuz",
        "category": "general",
        "parent": "",
        "content": "I guess I have in mind a `C++` approach on how I'd see an object in the form\n```\nclass BeaconState : public SSZContainer, public HTRContainer {\n... // do stuff\n}\n\nclass KZGCommitment : public SSZContainer, public HTRCommitment {\n... // do stuff\n}\n```",
        "created_at": "2021-09-08T17:10:22.342000+00:00",
        "attachments": null
    }
]