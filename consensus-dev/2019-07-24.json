[
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "https://github.com/ethereum/eth2.0-specs/issues/1311\nPlease help by taking a look at the survey, and sending me answers, or just suggestions at least. The replies really helped so far, but want to hear every team ðŸ˜ƒ",
        "created_at": "2019-07-24T11:16:47.853000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "So far I have a full response from 2 teams, and a brief response from 2 teams. If you have not responded yet, please take a look at the issue, and see if you like to answer the survey. Will put out a change proposal tomorrow. (the new format being boiled up is looking good so far, but I want forwardness in needs/concerns from remaining teams)",
        "created_at": "2019-07-24T14:51:06.471000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "general",
        "parent": "",
        "content": "Wait where the survey",
        "created_at": "2019-07-24T15:06:08.229000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e For Parity Shasper we just hope the test format does not change. It's working well for us at this moment.",
        "created_at": "2019-07-24T15:10:58.313000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "\u003c@322222239850168331\u003e in  the bottom of the issue. Send response in discord or telegram DM. Will go through answers, and keep them anonymous (be forward in needs, need to make progress here)",
        "created_at": "2019-07-24T15:12:52.008000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "\u003c@242032644232183808\u003e If it were to change in a structural way (organization of files), but not in test format, would that work? One of the main things I am thinking about is lowering the memory requirements, and enabling better filtering of tests, by splitting up the suite files.",
        "created_at": "2019-07-24T15:14:28.734000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "Yeah that works for us.",
        "created_at": "2019-07-24T15:15:07.980000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "general",
        "parent": "",
        "content": "Oh cool ok \u003c@203220829473996800\u003e",
        "created_at": "2019-07-24T15:16:32.497000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "However having too much files will indeed be an annoyance for us (we need to write one entry per file, because traverse the directory is not reliable). So I just hope we don't do this too much.",
        "created_at": "2019-07-24T15:25:48.062000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "How is traverse directory unreliable?",
        "created_at": "2019-07-24T15:26:12.911000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "\u003c@242032644232183808\u003e",
        "created_at": "2019-07-24T15:27:19.903000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "I know geth does a tree walk in the eth1 tests. Should be fine, no?",
        "created_at": "2019-07-24T15:28:02.837000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "general",
        "parent": "",
        "content": "\u003c@242032644232183808\u003e are you able to load all the tests into memory on a ci?",
        "created_at": "2019-07-24T15:33:17.059000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "general",
        "parent": "",
        "content": "we also hard code define the list of files. It would be a false positive if a file were to disappear and the tests pass",
        "created_at": "2019-07-24T15:33:46.029000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e We have type-level config so directory traversal is just not an option.",
        "created_at": "2019-07-24T15:36:09.294000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "general",
        "parent": "",
        "content": "\u003c@399309815517544451\u003e we could just implememnt a cache script - dumps a hash of the tree of files and you do a quick compare before each test, if it changes set an alarm off",
        "created_at": "2019-07-24T15:36:29.471000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "general",
        "parent": "",
        "content": "our build tooling already has a caching mechanism like that (using merkle trees, yay). In any case, we are also constrained by test types and prefer to list out the yaml files",
        "created_at": "2019-07-24T15:37:33.575000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "If indexing/missing files is a problem, I can just add a yaml file at the root containing all test paths. If that helps",
        "created_at": "2019-07-24T15:37:43.249000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "general",
        "parent": "",
        "content": "we only have to update the list on every update to spec tests, which is seemingly infrequent. a test yaml manifest might help to ensure we aren't missing any files in our hard coded lists",
        "created_at": "2019-07-24T15:40:16.333000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "In that case, what's better: a tree-structure in yaml, or a list of paths, 1 per line?",
        "created_at": "2019-07-24T15:41:04.722000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e In the current setup a yaml index file does not help for us. We need the type information before parsing a test file. It's possible to work around this by delaying instantiate the type information, but again it's just slight annoyance.",
        "created_at": "2019-07-24T15:41:59.626000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "if the type information is in the file name, and we have separate files for each content (pre/post/transfer/attestation/etc). Can you then select your type to parse based on that?",
        "created_at": "2019-07-24T15:43:06.795000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Also, handlers  (dirs right under runner dirs) are set up for exactly that currently: all suites in the same directory, have the same typing. Should be really easy to deal with, even with compile time constants",
        "created_at": "2019-07-24T15:44:05.362000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "general",
        "parent": "",
        "content": "one test type per directory would be helpful i think",
        "created_at": "2019-07-24T15:49:14.941000+00:00",
        "attachments": null
    },
    {
        "author": "prestonvanloon",
        "category": "general",
        "parent": "",
        "content": "ah one other thing, we have different runners for the minimal and mainnet configs, so if those are both in the same directory then we would have to filter them out when listing those files",
        "created_at": "2019-07-24T15:50:18.673000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e Anyway I do understand other team's concern on memory usage and other issues (so far we don't have any), so if we change the test organzation I won't complain (as long as we don't hugely change the test format).",
        "created_at": "2019-07-24T15:53:31.753000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Yes, looking into file structure instead of clunky header data in mega files",
        "created_at": "2019-07-24T15:53:32.441000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003czilm13\u003e \u003c@322222239850168331\u003e we were forced to add 1 more Gb of memory on CI, because we cannot use Yaml reader in streaming mode. I'd suggest to cap one yaml file to 200Mb. I don't care of total size etc, but I couldn't read only one testcase in the middle with standard reader.",
        "created_at": "2019-07-24T16:18:13.181000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "general",
        "parent": "",
        "content": "\u003c@425907307621122049\u003e Hmm hmm what ci do you use for the life of me idk how to add more",
        "created_at": "2019-07-24T17:07:58.319000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_gitter_bot",
        "category": "general",
        "parent": "",
        "content": "\u003czilm13\u003e \u003c@322222239850168331\u003e CircleCI, it had enough but java (our code runs on java) were started with lower limit by default.",
        "created_at": "2019-07-24T17:16:58.380000+00:00",
        "attachments": null
    },
    {
        "author": "gregthegreek",
        "category": "general",
        "parent": "",
        "content": "ahh hmm -- re tests we got them to pass on our CI with a weird flag change",
        "created_at": "2019-07-24T17:31:20.956000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "For binary merkle tree, do we have any preventions for preimage attack?",
        "created_at": "2019-07-24T20:23:21.298000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "please elaborate? Like collision resistance? Or concerned about other things?",
        "created_at": "2019-07-24T20:25:10.835000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "The usage of a preimage resistant hash function should hold the preimage resistant property through the tree of hashes",
        "created_at": "2019-07-24T20:59:25.712000+00:00",
        "attachments": null
    },
    {
        "author": "djrtwo",
        "category": "general",
        "parent": "",
        "content": "What exactly is the concern here?",
        "created_at": "2019-07-24T20:59:32.715000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e \u003c@291925846556540928\u003e I'm talking about `Intermediate` and `End` value having the same encoding. This is of course not exploitable on any of our data structures, but it's a potential issue for fast sync and when we transmit unknown merkle trees. This feels to me like a minor design flaw -- we need to consider preimage attack every time when we create something new on the current merkle tree, while we could have prevented it by define the tree items as follows:\n\n```\nenum {\n  Intermediate(H256),\n  MaybeIntermediate(H256),\n  End(H256),\n}\n```\n\nWhere `Intermediate` and `MaybeIntermediate` have the same encoding, but `End` uses a different one (for example, put a prefix byte).\n\nThis is just a small issue but I just wonder how people think about it.",
        "created_at": "2019-07-24T21:00:55.438000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Ssz transparency, or downwards extensions as Vitalik calls them, is a thing. And it sounds like that may not work if you change hash based on outer/inner",
        "created_at": "2019-07-24T21:03:28.606000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Correct me if I'm wrong",
        "created_at": "2019-07-24T21:03:49.169000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Trying to get a better sense of the syncing case you mentioned",
        "created_at": "2019-07-24T21:04:11.022000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "It continues to work. The above `enum` explicitly preserves that property by having `Intermediate` and `MaybeIntermediate`.",
        "created_at": "2019-07-24T21:04:17.515000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "The issue is rather with `End`. Yes, sometimes you want an `Intermediate` to be interpreted as `End`, but you'd never want an `End` to be interpreted as `Intermediate`.",
        "created_at": "2019-07-24T21:05:07.761000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Can you describe the attack vector in more detail?",
        "created_at": "2019-07-24T21:05:09.773000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Not sure about the end as intermediate. We've transparent block headers with bodies for example. Need the body root to embed easily",
        "created_at": "2019-07-24T21:06:38.588000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e There's only attack vectors on specific implementations if they don't handle those cases correctly. But to me it really feels like `secp256k1` vs `x25519` -- one with many corner cases where we could have just avoided considering them in the first place.",
        "created_at": "2019-07-24T21:06:40.620000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "I think it may not be much of an issue (and less complex) if people just start using generalized indices to describe what they are communicating when it is not already set, then there are no surprises with collisions either.",
        "created_at": "2019-07-24T21:22:36.611000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e Consider an arbitrary merkle tree which we currently do not know its structure. Some untrusted peers ask to access value at merkle index N. We have no way to know whether index N exists or not in the merkle tree, because we do not distinguish Intermediate and End, if we store multiple merkle trees in one database (which is a common practice).",
        "created_at": "2019-07-24T22:34:17.697000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Well, if a gen index is queried, along with a root hash to start from, I assume a client can look it up efficiently from a table index. If not, it's always possible to walk down the tree using the generalized index, which is cheap too: there is a maximum depth, along with length mixins, to cut off the (direct) walk to the queried gen index.",
        "created_at": "2019-07-24T22:38:55.376000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "and if the data in between the queried root and the gen index doesn't exist, it doesn't make much sense at all to serve it I think, as there is no proof. Maybe you can give an example?",
        "created_at": "2019-07-24T22:40:48.358000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e Given structure `A -\u003e (B, C)` where A is intermediate, and B, C are ends. We may have another local structure in the local database `B -\u003e (D, E)`. Given an arbitrary tree with root A, and index 4, there's no way to know whether it exists in tree A because the current complete decoded tree looks like this: `A -\u003e (B -\u003e (D, E), C)`.",
        "created_at": "2019-07-24T22:43:54.661000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "index 4, general index here? `100`, That would be D?",
        "created_at": "2019-07-24T22:45:22.650000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "Or you want to check quickly if you have data under C available?",
        "created_at": "2019-07-24T22:46:12.088000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**vbuterin**\nYou should know whether or not index 4 exists in A if you know the type from A",
        "created_at": "2019-07-24T22:46:57.095000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**vbuterin**\nFrom an SSZ type you can compute all valid generalized indices of leaves",
        "created_at": "2019-07-24T22:47:08.828000+00:00",
        "attachments": null
    },
    {
        "author": "protolambda",
        "category": "general",
        "parent": "",
        "content": "In that case, the difference would be really error prone. Since some roots stored in the full beacon state, actually are transparent too, for light clients to proof things.",
        "created_at": "2019-07-24T22:47:13.938000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**vbuterin**\nThe craziest transparency that we have is the recursive state -\u003e historical accumulator -\u003e state root",
        "created_at": "2019-07-24T22:47:51.199000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**vbuterin**\nYou can theoretically go arbitrarily deep through that path",
        "created_at": "2019-07-24T22:47:58.391000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\n@vbuterin exactly, but I think the type is not known, \"Given an arbitrary tree with root A\"",
        "created_at": "2019-07-24T22:47:59.980000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**vbuterin**\nSSZ is philosophically very static-type-oriented ðŸ˜œ",
        "created_at": "2019-07-24T22:48:16.402000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**vbuterin**\nIt's not like RLP and hex patricia trees",
        "created_at": "2019-07-24T22:48:25.349000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nI do think you should always know the type for a root you are storing. Not that hard",
        "created_at": "2019-07-24T22:48:37.207000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nBut in a mixed-type merkle DB, it may be more complicated with application layer logic (the types) and the merkle logic mixed together",
        "created_at": "2019-07-24T22:49:17.128000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nAnother complexity is: you may know the type, and its leafs. But during sync, you need to keep track of the data in your DB too, child nodes of some roots may still be missing",
        "created_at": "2019-07-24T22:51:48.457000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\n\u003c@242032644232183808\u003e You've some fair points, but in the end the application layer accesses the data, and can check if an index is valid, by just the type. And then optionally you track what is present or not, if you do not already have the guarantee that everything under a root (and valid subset of type) can be found in the merkle store.",
        "created_at": "2019-07-24T22:54:23.459000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e I'm just arguing that if we were to redesign the merkle tree today, I would properly distinguish intermediate and end nodes. I see no drawbacks at all and by doing that it just avoids the above hazard.",
        "created_at": "2019-07-24T22:58:56.677000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nYou lose a lot of flexibility in allowing deeper merkle lookups. A generalized index could point really far back in history, and application layer could just adjust the limit based on use case (i.e. type definition), and then the merkle DB could dive through the general index path on request. If you mark a node as forced tree bottom, or mark a node as forced tree top, you can't do that.",
        "created_at": "2019-07-24T23:02:23.316000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003e You lose a lot of flexibility in allowing deeper merkle lookups.\n\n\u003c@203220829473996800\u003e It doesn't. It still has the flexibility in allowing deeper merkle lookups.",
        "created_at": "2019-07-24T23:03:42.654000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "You'd just allow \"ghost intermediate\", which is the same of what we're doing now.",
        "created_at": "2019-07-24T23:04:39.635000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nSo what is the benefit then? Not need type information to verify an index? I think that type information should be present anyway",
        "created_at": "2019-07-24T23:05:49.342000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "It's a big benefit in some cases not requiring type information, because you can now generalize operations and handle arbitrary data without knowing what's happening inside. It's actually quite useful if you want arbitrary execution engine defining arbitrary state types. Still, I think my question is -- what's the drawback?",
        "created_at": "2019-07-24T23:09:05.528000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nSo, essentially we use a different hash function (one that adds a bit of extra data to the normal hash input to differentiate), but only for leaves that we know to always be end-points?",
        "created_at": "2019-07-24T23:12:08.279000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\n*Wouldn't that require more type information during hashing?",
        "created_at": "2019-07-24T23:12:28.846000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "Why would it require more type information? With old scheme you hash 64 bytes, with new scheme you just hash 66 bytes. It's the same.",
        "created_at": "2019-07-24T23:14:10.687000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nBut you need to know when to hash 66 bytes",
        "created_at": "2019-07-24T23:14:28.354000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "No. You just always hash 66 bytes. Period.",
        "created_at": "2019-07-24T23:14:42.926000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nSame thing, if normal case is 64, or some special prefix. Case is, what happens to a leaf, of bytes32 type, that connects to some existing merkle data, that needs to connect? The ghost-intermediate vs end thing needs to be determined there",
        "created_at": "2019-07-24T23:15:53.704000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "For ghost intermediate you always treat it the same as a normal intermediate. It's just in the database we don't have its children information.",
        "created_at": "2019-07-24T23:16:48.222000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nyes, but how about an end node, when and where in the stack is the decision made to use a different prefix?",
        "created_at": "2019-07-24T23:17:36.699000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "The benefit is that -- you always explicitly mark something as \"merkle root\" in your data structure. There's no chance that we'd mistreat things like `graffiti` as intermediate.",
        "created_at": "2019-07-24T23:17:56.075000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003e yes, but how about an end node, when and where in the stack is the decision made to use a different prefix?\n\n\u003c@203220829473996800\u003e It's in when you hash the merkle tree? That's when type information is always available, and with type information you would know perfectly whether something is a sub-merkle-tree-root or just arbitrary data.",
        "created_at": "2019-07-24T23:19:00.429000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nhonestly I like the idea of pushing that complexity to types in application layer. Merkle db should be simply agnostic to the needs of the application",
        "created_at": "2019-07-24T23:19:05.955000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003e Merkle db should be simply agnostic to the needs of the application\n\nThat's exactly the point. The current scheme just means we cannot deal with arbitrary tree, which is the opposite of \"agnostic to the needs of the application\".",
        "created_at": "2019-07-24T23:20:20.147000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nthe current scheme does work, just pushes logic from hashing to types",
        "created_at": "2019-07-24T23:20:49.984000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e It does work for typed data. It does not work for untyped data. I think we've discussed this clearly above.",
        "created_at": "2019-07-24T23:21:41.802000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nBut re your idea: so during hashing in application layer, you hash absolute bottom nodes differently. And what if something changes to be a non-bottom node later? Re-hash all existing data?",
        "created_at": "2019-07-24T23:21:50.124000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "If something is potentially non-bottom node, you know it from the beginning, because you generated the hash. There's no way something can change from End to Intermediate.\nIn the worst case, `set(index, value)` is just a normal merkle operation that you can always invoke to change End to Intermediate.",
        "created_at": "2019-07-24T23:23:38.537000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nbut then the root is affected if you change the type (a subjective meaning) of some root to something deeper. Deciding on every use case of some 32 bytes (e.g. graffiti) in advance is not a benefit imho :(",
        "created_at": "2019-07-24T23:25:48.426000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nyou'd need to fork to change the meaning of graffiti then, while it could be just application. And so many other easy backward-compatible upgrade cases with EEs later on.",
        "created_at": "2019-07-24T23:26:59.311000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nit only really makes sense for non-32 bottom types, that are not meant to be e roots, ever. And even then, I prefer the application to deal with it instead",
        "created_at": "2019-07-24T23:28:10.295000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e Do you mean that clients can interpret graffiti as some other merkle root if it wants? I cannot think of any security risks at this moment but I'm really skeptical about it -- it just doesn't feel safe.",
        "created_at": "2019-07-24T23:28:12.705000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nwhy not? If the root is random and cannot be found, it doesn't matter? If it can, it's perfectly fine",
        "created_at": "2019-07-24T23:28:53.015000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nImaginary example: some new incentives pop up, and graffiti is moved by social consensus one down: now it's old_graffiti -\u003e (new_root, new_graffiti). Bascily user-activated fork to include more data in the state. But optional, as the contents themselves are not included or enforced in transition. So much flexibility still.",
        "created_at": "2019-07-24T23:30:28.349000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "Hmm this feels dangerous to me, because you just described the exact scenario of merkle preimage attack...",
        "created_at": "2019-07-24T23:30:28.813000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nit's no attack if everyone that doesn't participate has the type anyway, and doesn't need to store or serve anything extra",
        "created_at": "2019-07-24T23:31:24.773000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "Okay that's interesting. But I'm still not convinced that this is safe.",
        "created_at": "2019-07-24T23:31:25.759000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nSo your concern is: generalized index goes beyond normal bound, and application doesn't care to check the type, so it will try to look up the data, and find nothing is there just one query later?",
        "created_at": "2019-07-24T23:32:25.828000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nand if there is, it's part of the state somewhere else already, no?",
        "created_at": "2019-07-24T23:33:04.376000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nThat's another user activated-case, we could shorten proofs by putting a deeper node in the graffiti field of a recent block. But still within state bounds, perfectly fine imo.",
        "created_at": "2019-07-24T23:33:47.676000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nAnd everything is still 100% safe if you just stick to type information on application layer, then deny a generalized index beyond that. Type information may be deferred too: simply store the bounds of the type somewhere, and forget the type itself. If that's all you need.",
        "created_at": "2019-07-24T23:37:07.269000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e Can you explain more the scenario if we don't have type information? I believe this is also quite possible for eth2 -- in the future you'd define execution engines, which has state which beacon client may or may not know about.",
        "created_at": "2019-07-24T23:41:02.775000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nSo if there is no type information, but the roots of non-beacon data are in the same DB and some leaf X that was already available in the state equals them, we could choose to allow the generalized index to pass through that X, and lookup the other data. Or if we do not want that, we say: \"no, index is invalid based on this predefined index bound, or this bound derived from the type we use for the upper root\".",
        "created_at": "2019-07-24T23:44:47.671000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nand this concept transfers to any other mixed type merkle store (essentially just a k-v, nothing special)",
        "created_at": "2019-07-24T23:45:25.618000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nAnd complexity is flexible, always backwards compatible, and pushed to application layer.",
        "created_at": "2019-07-24T23:46:00.883000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e Also during sync if without type information, a can supply/accept merkle trees which it was not intended before.\n\nI think the biggst flaw that troubled me for the current scheme is this:  in raw merkle tree implementation, I can put in `A -\u003e (B, C)`, but later when I want to retrieve the complete merkle tree (and put it elsewhere, possibly), I may get `A -\u003e (B -\u003e (D, E), C)` or other values depending on other insertions to the database. In other words -- it's not deterministic.",
        "created_at": "2019-07-24T23:46:28.853000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nbut it is if you have bounds, a list of generalized indices for the leaves, or just a type",
        "created_at": "2019-07-24T23:47:23.786000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nwhich is good enough imho",
        "created_at": "2019-07-24T23:47:43.118000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "I think that essentially means that the type we use to define merkle root is not `H256`, but `(H256, u64)`, where the second item in the tuple is the bound.",
        "created_at": "2019-07-24T23:48:45.795000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nanother benefit is that leaves of 32 bytes can just be that, 32 bytes. No need for hash(leaf).",
        "created_at": "2019-07-24T23:49:16.175000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003e another benefit is that leaves of 32 bytes can just be that, 32 bytes. No need for hash(leaf).\n\nThat's always the case no matter you put prefix or not.",
        "created_at": "2019-07-24T23:49:40.951000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nI think that essentially means that the type we use to define merkle root is not `H256`, but `(H256, u64)`\n\nMerkle root there is an old concept. (H256, u64) would be your local interpretation of the data. And H256 would be just the identity (but not the form) of the data",
        "created_at": "2019-07-24T23:50:36.201000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nI do belief that prefixes are prone to result in extra data, somewhere, at some cost. (although maybe not in your specific case, but likely in others) Just like storing bounds. No free lunch in computer science",
        "created_at": "2019-07-24T23:52:56.241000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "Also I think this totally changed the normal definition of merkle tree. We'd usually have leaf nodes and non-leaf nodes. But under eth2's defintion everything is non-leaf node. This will prevents certain optimizations we can do to compress the database size -- for example, the one turbo geth is working on.",
        "created_at": "2019-07-24T23:54:15.127000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "In the normal definition we can treat the merkle tree as a way to \"organize\" data blocks. In this way it's possible to compress some non-leaf nodes and generate its hash on the fly. But I'm not sure how this can be done in eth2's definition.",
        "created_at": "2019-07-24T23:55:13.156000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nIt can be a leaf node just fine if you decide not to store extra information, and enforce it by checking bounds of inserted data)",
        "created_at": "2019-07-24T23:55:15.676000+00:00",
        "attachments": null
    },
    {
        "author": "eth2_bridge_bot",
        "category": "general",
        "parent": "",
        "content": "**protolambda**\nThe difference here is that the implementer has the ability to choose to set hard bounds, or not. Instead of the merkleization itself forcing something",
        "created_at": "2019-07-24T23:56:34.425000+00:00",
        "attachments": null
    },
    {
        "author": "sorpaas",
        "category": "general",
        "parent": "",
        "content": "\u003c@203220829473996800\u003e I don't think we can distinguish leaf nodes and non-leaf nodes in the implementation, while the hash function does not distinguish it. There either need to be extra hashing (represent nodes hashed with prefix internally, and \"attach\" non-prefixed nodes to it), or allow ambiguity.",
        "created_at": "2019-07-24T23:57:27.879000+00:00",
        "attachments": null
    }
]