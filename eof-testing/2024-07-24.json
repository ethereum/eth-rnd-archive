[
    {
        "author": "marioevz",
        "category": "Testing",
        "parent": "",
        "content": "First attempt at introducing fuzzing to EEST: https://github.com/ethereum/execution-spec-tests/pull/709\n\nI think the next steps are:\n1) writing a valid/invalid EOF code generator,\n2) figure out a way to connect this to goevmlab.\n\n\u003c@403707149043105803\u003e \u003c@907931206081990666\u003e",
        "created_at": "2024-07-24T22:03:49.296000+00:00",
        "attachments": null
    },
    {
        "author": "chfast",
        "category": "Testing",
        "parent": "",
        "content": "Good that more and more people understands fuzz testing. I want to comment and answer some questions related to my work: libfuzzer based EOF validation.\n\nlibfuzzer provides coverage-guided (not only) fuzzing. It test an input on given code and collects a coverage \"path\" of execution. if the \"path\" is unique the new test is added to \"corpus\".\n\nI initialized the corpus with evmone's unit tests.\n\nThere are 2 additional features in libfuzzer:\n1. it can reduce tests: shorter test with the same coverage path replaces the longer one.\n2. it can merge multiple dirs of tests: only tests which increase coverage are added.\n\nConsidering we have tests in ethereum/tests, EEST and evmone, we can use the fuzzer as the quality tool. Exporting EOF bytecodes from EEST will be handy. The fuzzer expects a file with raw bytecode (no hex) and you can name it as you want, e.g. \"eest-test-name\".\n\nThis way we can check if there are any unique test cases in any of EEST, ethereum/tests, evmone and the fuzzer itself.",
        "created_at": "2024-07-24T23:27:12.384000+00:00",
        "attachments": null
    }
]